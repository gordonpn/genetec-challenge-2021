// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { AmqpAnnotatedMessage, Constants } from "@azure/core-amqp";
import { Buffer } from "buffer";
import Long from "long";
import { uuid_to_string } from "rhea-promise";
import { defaultDataTransformer } from "./dataTransformer";
import { messageLogger as logger } from "./log";
import { reorderLockToken } from "./util/utils";
/**
 * @internal
 * @hidden
 */
export var DispositionType;
(function (DispositionType) {
    DispositionType["complete"] = "complete";
    DispositionType["deadletter"] = "deadletter";
    DispositionType["abandon"] = "abandon";
    DispositionType["defer"] = "defer";
})(DispositionType || (DispositionType = {}));
/**
 * @internal
 * @hidden
 * Gets the error message for when a property on given message is not of expected type
 */
export function getMessagePropertyTypeMismatchError(msg) {
    if (msg.contentType != null && typeof msg.contentType !== "string") {
        return new TypeError("The property 'contentType' on the message must be of type 'string'");
    }
    if (msg.subject != null && typeof msg.subject !== "string") {
        return new TypeError("The property 'label' on the message must be of type 'string'");
    }
    if (msg.to != null && typeof msg.to !== "string") {
        return new TypeError("The property 'to' on the message must be of type 'string'");
    }
    if (msg.replyTo != null && typeof msg.replyTo !== "string") {
        return new TypeError("The property 'replyTo' on the message must be of type 'string'");
    }
    if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== "string") {
        return new TypeError("The property 'replyToSessionId' on the message must be of type 'string'");
    }
    if (msg.timeToLive != null && typeof msg.timeToLive !== "number") {
        return new TypeError("The property 'timeToLive' on the message must be of type 'number'");
    }
    if (msg.sessionId != null && typeof msg.sessionId !== "string") {
        return new TypeError("The property 'sessionId' on the message must be of type 'string'");
    }
    if (msg.messageId != null &&
        typeof msg.messageId !== "string" &&
        typeof msg.messageId !== "number" &&
        !Buffer.isBuffer(msg.messageId)) {
        return new TypeError("The property 'messageId' on the message must be of type string, number or Buffer");
    }
    if (msg.correlationId != null &&
        typeof msg.correlationId !== "string" &&
        typeof msg.correlationId !== "number" &&
        !Buffer.isBuffer(msg.correlationId)) {
        return new TypeError("The property 'correlationId' on the message must be of type string, number or Buffer");
    }
    return;
}
/**
 * @internal
 * @hidden
 * Converts given ServiceBusMessage to RheaMessage
 */
export function toRheaMessage(msg) {
    const amqpMsg = {
        body: msg.body,
        message_annotations: {}
    };
    if (msg.applicationProperties != null) {
        amqpMsg.application_properties = msg.applicationProperties;
    }
    if (msg.contentType != null) {
        amqpMsg.content_type = msg.contentType;
    }
    if (msg.sessionId != null) {
        if (msg.sessionId.length > Constants.maxSessionIdLength) {
            throw new Error("Length of 'sessionId' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.group_id = msg.sessionId;
    }
    if (msg.replyTo != null) {
        amqpMsg.reply_to = msg.replyTo;
    }
    if (msg.to != null) {
        amqpMsg.to = msg.to;
    }
    if (msg.subject != null) {
        amqpMsg.subject = msg.subject;
    }
    if (msg.messageId != null) {
        if (typeof msg.messageId === "string" && msg.messageId.length > Constants.maxMessageIdLength) {
            throw new Error("Length of 'messageId' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.message_id = msg.messageId;
    }
    if (msg.correlationId != null) {
        amqpMsg.correlation_id = msg.correlationId;
    }
    if (msg.replyToSessionId != null) {
        amqpMsg.reply_to_group_id = msg.replyToSessionId;
    }
    if (msg.timeToLive != null && msg.timeToLive !== Constants.maxDurationValue) {
        amqpMsg.ttl = msg.timeToLive;
        amqpMsg.creation_time = Date.now();
        if (Constants.maxAbsoluteExpiryTime - amqpMsg.creation_time > amqpMsg.ttl) {
            amqpMsg.absolute_expiry_time = amqpMsg.creation_time + amqpMsg.ttl;
        }
        else {
            amqpMsg.absolute_expiry_time = Constants.maxAbsoluteExpiryTime;
        }
    }
    if (msg.partitionKey != null) {
        if (msg.partitionKey.length > Constants.maxPartitionKeyLength) {
            throw new Error("Length of 'partitionKey' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.message_annotations[Constants.partitionKey] = msg.partitionKey;
    }
    // Will be required later for implementing Transactions
    // if (msg.viaPartitionKey != null) {
    //   if (msg.viaPartitionKey.length > Constants.maxPartitionKeyLength) {
    //     throw new Error(
    //       "Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters."
    //     );
    //   }
    //   amqpMsg.message_annotations![Constants.viaPartitionKey] = msg.viaPartitionKey;
    // }
    if (msg.scheduledEnqueueTimeUtc != null) {
        amqpMsg.message_annotations[Constants.scheduledEnqueueTime] = msg.scheduledEnqueueTimeUtc;
    }
    logger.verbose("SBMessage to RheaMessage: %O", amqpMsg);
    return amqpMsg;
}
/**
 * @internal
 * @hidden
 * Converts given RheaMessage to ServiceBusReceivedMessage
 */
export function fromRheaMessage(msg, delivery, shouldReorderLockToken) {
    var _a, _b;
    if (!msg) {
        msg = {
            body: undefined
        };
    }
    const sbmsg = {
        body: msg.body
    };
    if (msg.application_properties != null) {
        sbmsg.applicationProperties = msg.application_properties;
    }
    if (msg.content_type != null) {
        sbmsg.contentType = msg.content_type;
    }
    if (msg.group_id != null) {
        sbmsg.sessionId = msg.group_id;
    }
    if (msg.reply_to != null) {
        sbmsg.replyTo = msg.reply_to;
    }
    if (msg.to != null) {
        sbmsg.to = msg.to;
    }
    if (msg.ttl != null) {
        sbmsg.timeToLive = msg.ttl;
    }
    if (msg.subject != null) {
        sbmsg.subject = msg.subject;
    }
    if (msg.message_id != null) {
        sbmsg.messageId = msg.message_id;
    }
    if (msg.correlation_id != null) {
        sbmsg.correlationId = msg.correlation_id;
    }
    if (msg.reply_to_group_id != null) {
        sbmsg.replyToSessionId = msg.reply_to_group_id;
    }
    if (msg.message_annotations != null) {
        if (msg.message_annotations[Constants.partitionKey] != null) {
            sbmsg.partitionKey = msg.message_annotations[Constants.partitionKey];
        }
        // Will be required later for implementing Transactions
        // if (msg.message_annotations[Constants.viaPartitionKey] != null) {
        //   sbmsg.viaPartitionKey = msg.message_annotations[Constants.viaPartitionKey];
        // }
        if (msg.message_annotations[Constants.scheduledEnqueueTime] != null) {
            sbmsg.scheduledEnqueueTimeUtc = msg.message_annotations[Constants.scheduledEnqueueTime];
        }
    }
    const props = {};
    if (msg.message_annotations != null) {
        if (msg.message_annotations[Constants.deadLetterSource] != null) {
            props.deadLetterSource = msg.message_annotations[Constants.deadLetterSource];
        }
        if (msg.message_annotations[Constants.enqueueSequenceNumber] != null) {
            props.enqueuedSequenceNumber = msg.message_annotations[Constants.enqueueSequenceNumber];
        }
        if (msg.message_annotations[Constants.sequenceNumber] != null) {
            if (Buffer.isBuffer(msg.message_annotations[Constants.sequenceNumber])) {
                props.sequenceNumber = Long.fromBytesBE(msg.message_annotations[Constants.sequenceNumber]);
            }
            else {
                props.sequenceNumber = Long.fromNumber(msg.message_annotations[Constants.sequenceNumber]);
            }
        }
        if (msg.message_annotations[Constants.enqueuedTime] != null) {
            props.enqueuedTimeUtc = new Date(msg.message_annotations[Constants.enqueuedTime]);
        }
        if (msg.message_annotations[Constants.lockedUntil] != null) {
            props.lockedUntilUtc = new Date(msg.message_annotations[Constants.lockedUntil]);
        }
    }
    if (msg.ttl != null && msg.ttl >= Constants.maxDurationValue - props.enqueuedTimeUtc.getTime()) {
        props.expiresAtUtc = new Date(Constants.maxDurationValue);
    }
    else {
        props.expiresAtUtc = new Date(props.enqueuedTimeUtc.getTime() + msg.ttl);
    }
    const rcvdsbmsg = Object.assign(Object.assign(Object.assign({ _rawAmqpMessage: AmqpAnnotatedMessage.fromRheaMessage(msg), _delivery: delivery, deliveryCount: msg.delivery_count, lockToken: delivery && delivery.tag && delivery.tag.length !== 0
            ? uuid_to_string(shouldReorderLockToken === true
                ? reorderLockToken(typeof delivery.tag === "string" ? Buffer.from(delivery.tag) : delivery.tag)
                : typeof delivery.tag === "string"
                    ? Buffer.from(delivery.tag)
                    : delivery.tag)
            : undefined }, sbmsg), props), { deadLetterReason: (_a = sbmsg.applicationProperties) === null || _a === void 0 ? void 0 : _a.DeadLetterReason, deadLetterErrorDescription: (_b = sbmsg.applicationProperties) === null || _b === void 0 ? void 0 : _b.DeadLetterErrorDescription });
    logger.verbose("AmqpMessage to ServiceBusReceivedMessage: %O", rcvdsbmsg);
    return rcvdsbmsg;
}
/**
 * @internal
 * @hidden
 */
export function isServiceBusMessage(possible) {
    return possible != null && typeof possible === "object" && "body" in possible;
}
/**
 * Describes the message received from Service Bus.
 *
 * @internal
 * @hidden
 * @class ServiceBusMessageImpl
 * @implements {ServiceBusReceivedMessage}
 */
export class ServiceBusMessageImpl {
    /**
     * @internal
     */
    constructor(msg, delivery, shouldReorderLockToken, receiveMode) {
        Object.assign(this, fromRheaMessage(msg, delivery, shouldReorderLockToken));
        // Lock on a message is applicable only in peekLock mode, but the service sets
        // the lock token even in receiveAndDelete mode if the entity in question is partitioned.
        if (receiveMode === "receiveAndDelete") {
            this.lockToken = undefined;
        }
        if (msg.body) {
            this.body = defaultDataTransformer.decode(msg.body);
        }
        // TODO: _rawAmqpMessage is already being populated in fromRheaMessage(), no need to do it twice
        this._rawAmqpMessage = AmqpAnnotatedMessage.fromRheaMessage(msg);
        this.delivery = delivery;
    }
    /**
     * Creates a clone of the current message to allow it to be re-sent to the queue
     * @returns ServiceBusMessage
     */
    clone() {
        // We are returning a ServiceBusMessage object because that object can then be sent to Service Bus
        const clone = {
            body: this.body,
            contentType: this.contentType,
            correlationId: this.correlationId,
            subject: this.subject,
            messageId: this.messageId,
            partitionKey: this.partitionKey,
            replyTo: this.replyTo,
            replyToSessionId: this.replyToSessionId,
            scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,
            sessionId: this.sessionId,
            timeToLive: this.timeToLive,
            to: this.to,
            applicationProperties: this.applicationProperties
            // Will be required later for implementing Transactions
            // viaPartitionKey: this.viaPartitionKey
        };
        return clone;
    }
}
//# sourceMappingURL=serviceBusMessage.js.map