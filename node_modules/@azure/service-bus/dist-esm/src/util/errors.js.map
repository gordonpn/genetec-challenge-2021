{"version":3,"file":"errors.js","sourceRoot":"","sources":["../../../src/util/errors.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logger, receiverLogger } from \"../log\";\nimport Long from \"long\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { isServiceBusMessage, ServiceBusReceivedMessage } from \"../serviceBusMessage\";\nimport { ReceiveMode } from \"../models\";\n\n/**\n * Error message to use when EntityPath in connection string does not match the\n * queue or topic name passed to the methods in the ServiceBusClient that create\n * senders and receivers.\n *\n * @internal\n * @hidden\n */\nexport const entityPathMisMatchError =\n  \"The queue or topic name provided does not match the EntityPath in the connection string passed to the ServiceBusClient constructor.\";\n\n/**\n * Error message for when maxMessageCount provided is invalid.\n *\n * @internal\n * @hidden\n */\nexport const InvalidMaxMessageCountError = \"'maxMessageCount' must be a number greater than 0.\";\n\n/**\n * @internal\n * @hidden\n * Logs and throws Error if the current AMQP connection is closed.\n * @param context The ConnectionContext associated with the current AMQP connection.\n */\nexport function throwErrorIfConnectionClosed(context: ConnectionContext): void {\n  if (context && context.wasConnectionCloseCalled) {\n    const errorMessage = \"The underlying AMQP connection is closed.\";\n    const error = new Error(errorMessage);\n    logger.warning(`[${context.connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * @hidden\n * Gets the error message when a sender is used when its already closed\n * @param entityPath Value of the `entityPath` property on the client which denotes its name\n */\nexport function getSenderClosedErrorMsg(entityPath: string): string {\n  return (\n    `The sender for \"${entityPath}\" has been closed and can no longer be used. ` +\n    `Please create a new sender using the \"createSender\" method on the ServiceBusClient.`\n  );\n}\n\n/**\n * @internal\n * @hidden\n * Gets the error message when a receiver is used when its already closed\n * @param entityPath Value of the `entityPath` property on the client which denotes its name\n * @param sessionId If using session receiver, then the id of the session\n */\nexport function getReceiverClosedErrorMsg(entityPath: string, sessionId?: string): string {\n  if (sessionId == undefined) {\n    return (\n      `The receiver for \"${entityPath}\" has been closed and can no longer be used. ` +\n      `Please create a new receiver using the \"createReceiver\" method on the ServiceBusClient.`\n    );\n  }\n  return (\n    `The receiver for session \"${sessionId}\" in \"${entityPath}\" has been closed and can no ` +\n    `longer be used. Please create a new receiver using the \"acceptSession\" or \"acceptNextSession\" method on the ServiceBusClient.`\n  );\n}\n\n/**\n * @internal\n * @hidden\n * @param entityPath Value of the `entityPath` property on the client which denotes its name\n * @param sessionId If using session receiver, then the id of the session\n */\nexport function getAlreadyReceivingErrorMsg(entityPath: string, sessionId?: string): string {\n  if (sessionId == undefined) {\n    return `The receiver for \"${entityPath}\" is already receiving messages.`;\n  }\n  return `The receiver for session \"${sessionId}\" for \"${entityPath}\" is already receiving messages.`;\n}\n\n/**\n * @internal\n * @hidden\n * Logs and Throws TypeError if given parameter is undefined or null\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to check\n * @param parameterValue Value of the parameter to check\n */\nexport function throwTypeErrorIfParameterMissing(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any\n): void {\n  if (parameterValue === undefined || parameterValue === null) {\n    const error = new TypeError(`Missing parameter \"${parameterName}\"`);\n    logger.warning(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * @hidden\n * Logs and Throws TypeError if given parameter is not of expected type\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n * @param expectedType Expected type of the parameter\n */\n\nexport function throwTypeErrorIfParameterTypeMismatch(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any,\n  expectedType: string\n): void {\n  if (typeof parameterValue !== expectedType) {\n    const error = new TypeError(\n      `The parameter \"${parameterName}\" should be of type \"${expectedType}\"`\n    );\n    logger.warning(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * @hidden\n * Logs and Throws TypeError if given parameter is not of type `Long` or an array of type `Long`\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterNotLong(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any\n): TypeError | undefined {\n  if (Array.isArray(parameterValue)) {\n    return throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue);\n  }\n  if (Long.isLong(parameterValue)) {\n    return;\n  }\n  const error = new TypeError(`The parameter \"${parameterName}\" should be of type \"Long\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * @hidden\n * Logs and Throws TypeError if given parameter is not an array of type `Long`\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterNotLongArray(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any[]\n): TypeError | undefined {\n  if (parameterValue.every((item) => Long.isLong(item))) {\n    return;\n  }\n  const error = new TypeError(`The parameter \"${parameterName}\" should be an array of type \"Long\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * @hidden\n * Logs and Throws TypeError if given parameter is an empty string\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterIsEmptyString(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: string\n): TypeError | undefined {\n  if (parameterValue !== \"\") {\n    return;\n  }\n  const error = new TypeError(`Empty string not allowed in parameter \"${parameterName}\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * @hidden\n * The error message for operations on the receiver that are invalid for a message received in receiveAndDelete mode.\n */\nexport const InvalidOperationInReceiveAndDeleteMode =\n  \"The operation is not supported in 'receiveAndDelete' receive mode.\";\n\n/**\n * @internal\n * @hidden\n * The error message for operations on the receiver that are invalid for a peeked message.\n */\nexport const InvalidOperationForPeekedMessage =\n  \"This operation is not supported for peeked messages. Only messages received using 'receiveMessages()', 'subscribe()' and 'getMessageIterator()' methods on the receiver in 'peekLock' receive mode can be settled.\";\n\n/**\n * @internal\n * @hidden\n * The error message for when one attempts to settle an already settled message.\n */\nexport const MessageAlreadySettled = \"The message has either been deleted or already settled\";\n\n/**\n * Throws error if the ServiceBusReceivedMessage cannot be settled.\n * @internal\n * @hidden\n */\nexport function throwErrorIfInvalidOperationOnMessage(\n  message: ServiceBusReceivedMessage,\n  receiveMode: ReceiveMode,\n  connectionId: string\n) {\n  let error: Error | undefined;\n\n  if (receiveMode === \"receiveAndDelete\") {\n    error = new Error(InvalidOperationInReceiveAndDeleteMode);\n  } else if (!message.lockToken) {\n    error = new Error(InvalidOperationForPeekedMessage);\n  }\n\n  if (error) {\n    receiverLogger.logError(\n      error,\n      \"[%s] An error occurred for message with id '%s'\",\n      connectionId,\n      message.messageId\n    );\n    throw error;\n  }\n}\n\n/**\n * Error message for when the ServiceBusMessage provided by the user has different values\n * for partitionKey and sessionId.\n * @internal\n * @hidden\n * @throw\n */\nexport const PartitionKeySessionIdMismatchError =\n  \"The fields 'partitionKey' and 'sessionId' cannot have different values.\";\n/**\n * Throws error if the given object is not a valid ServiceBusMessage\n * @internal\n * @hidden\n * @param msg The object that needs to be validated as a ServiceBusMessage\n * @param errorMessageForWrongType The error message to use when given object is not a ServiceBusMessage\n */\nexport function throwIfNotValidServiceBusMessage(msg: any, errorMessageForWrongType: string): void {\n  if (!isServiceBusMessage(msg)) {\n    throw new TypeError(errorMessageForWrongType);\n  }\n  if (msg.partitionKey && msg.sessionId && msg.partitionKey !== msg.sessionId) {\n    throw new TypeError(PartitionKeySessionIdMismatchError);\n  }\n}\n"]}