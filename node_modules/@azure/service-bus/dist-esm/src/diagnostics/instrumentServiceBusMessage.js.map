{"version":3,"file":"instrumentServiceBusMessage.js","sourceRoot":"","sources":["../../../src/diagnostics/instrumentServiceBusMessage.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  extractSpanContextFromTraceParentHeader,\n  getTraceParentHeader,\n  getTracer\n} from \"@azure/core-tracing\";\nimport { CanonicalCode, Link, Span, SpanContext, SpanKind } from \"@opentelemetry/api\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { getParentSpan, OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { ServiceBusReceiver } from \"../receivers/receiver\";\nimport { ServiceBusMessage, ServiceBusReceivedMessage } from \"../serviceBusMessage\";\n\n/**\n * @hidden\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * Populates the `ServiceBusMessage` with `SpanContext` info to support trace propagation.\n * Creates and returns a copy of the passed in `ServiceBusMessage` unless the `ServiceBusMessage`\n * has already been instrumented.\n * @param message The `ServiceBusMessage` to instrument.\n * @param span The `Span` containing the context to propagate tracing information.\n * @hidden\n * @internal\n */\nexport function instrumentServiceBusMessage(\n  message: ServiceBusMessage,\n  span: Span\n): ServiceBusMessage {\n  if (message.applicationProperties && message.applicationProperties[TRACEPARENT_PROPERTY]) {\n    return message;\n  }\n\n  // create a copy so the original isn't modified\n  message = { ...message, applicationProperties: { ...message.applicationProperties } };\n\n  const traceParent = getTraceParentHeader(span.context());\n  if (traceParent) {\n    message.applicationProperties![TRACEPARENT_PROPERTY] = traceParent;\n  }\n\n  return message;\n}\n\n/**\n * Extracts the `SpanContext` from an `ServiceBusMessage` if the context exists.\n * @param message An individual `ServiceBusMessage` object.\n * @internal\n * @hidden\n */\nexport function extractSpanContextFromServiceBusMessage(\n  message: ServiceBusMessage\n): SpanContext | undefined {\n  if (!message.applicationProperties || !message.applicationProperties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = message.applicationProperties[TRACEPARENT_PROPERTY] as string;\n  return extractSpanContextFromTraceParentHeader(diagnosticId);\n}\n\n/**\n * Provides an iterable over messages, whether it is a single message or multiple\n * messages.\n *\n * @param receivedMessages A single message or a set of messages\n * @internal\n * @hidden\n */\nfunction* getReceivedMessages(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[]\n): Iterable<ServiceBusReceivedMessage> {\n  if (!Array.isArray(receivedMessages)) {\n    yield receivedMessages;\n  } else {\n    for (const message of receivedMessages) {\n      yield message;\n    }\n  }\n}\n\n/**\n * A span that encompasses the period when the message has been received and\n * is being processed.\n *\n * NOTE: The amount of time the user would be considered processing the message is\n * not always clear - in that case the span will have a very short lifetime\n * since we'll start the span when we receive the message and end it when we\n * give the message to the user.\n *\n * @internal\n * @hidden\n */\nexport function createProcessingSpan(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[],\n  // NOTE: the connectionConfig also has an entityPath property but that only\n  // represents the optional entityPath in their connection string which is NOT\n  // what we want for tracing.\n  receiver: Pick<ServiceBusReceiver, \"entityPath\">,\n  connectionConfig: Pick<ConnectionContext[\"config\"], \"host\">,\n  options?: OperationOptionsBase\n): Span {\n  const links: Link[] = [];\n\n  for (const receivedMessage of getReceivedMessages(receivedMessages)) {\n    const spanContext = extractSpanContextFromServiceBusMessage(receivedMessage);\n\n    if (spanContext == null) {\n      continue;\n    }\n\n    links.push({\n      context: spanContext,\n      attributes: {\n        enqueuedTime: receivedMessage.enqueuedTimeUtc?.getTime()\n      }\n    });\n  }\n\n  const span = getTracer().startSpan(\"Azure.ServiceBus.process\", {\n    kind: SpanKind.CONSUMER,\n    links,\n    parent: getParentSpan(options?.tracingOptions)\n  });\n\n  span.setAttributes({\n    \"az.namespace\": \"Microsoft.ServiceBus\",\n    \"message_bus.destination\": receiver.entityPath,\n    \"peer.address\": connectionConfig.host\n  });\n\n  return span;\n}\n\n/**\n * Creates and immediately ends a processing span. Used when\n * the 'processing' occurs outside of our control so we don't\n * know the scope.\n *\n * @internal\n * @hidden\n */\nexport function createAndEndProcessingSpan(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[],\n  receiver: Pick<ServiceBusReceiver, \"entityPath\">,\n  connectionConfig: Pick<ConnectionContext[\"config\"], \"host\">,\n  options?: OperationOptionsBase\n): void {\n  const span = createProcessingSpan(receivedMessages, receiver, connectionConfig, options);\n  span.setStatus({ code: CanonicalCode.OK });\n  span.end();\n}\n"]}