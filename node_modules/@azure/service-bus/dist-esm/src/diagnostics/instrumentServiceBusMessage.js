// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { extractSpanContextFromTraceParentHeader, getTraceParentHeader, getTracer } from "@azure/core-tracing";
import { CanonicalCode, SpanKind } from "@opentelemetry/api";
import { getParentSpan } from "../modelsToBeSharedWithEventHubs";
/**
 * @hidden
 */
export const TRACEPARENT_PROPERTY = "Diagnostic-Id";
/**
 * Populates the `ServiceBusMessage` with `SpanContext` info to support trace propagation.
 * Creates and returns a copy of the passed in `ServiceBusMessage` unless the `ServiceBusMessage`
 * has already been instrumented.
 * @param message The `ServiceBusMessage` to instrument.
 * @param span The `Span` containing the context to propagate tracing information.
 * @hidden
 * @internal
 */
export function instrumentServiceBusMessage(message, span) {
    if (message.applicationProperties && message.applicationProperties[TRACEPARENT_PROPERTY]) {
        return message;
    }
    // create a copy so the original isn't modified
    message = Object.assign(Object.assign({}, message), { applicationProperties: Object.assign({}, message.applicationProperties) });
    const traceParent = getTraceParentHeader(span.context());
    if (traceParent) {
        message.applicationProperties[TRACEPARENT_PROPERTY] = traceParent;
    }
    return message;
}
/**
 * Extracts the `SpanContext` from an `ServiceBusMessage` if the context exists.
 * @param message An individual `ServiceBusMessage` object.
 * @internal
 * @hidden
 */
export function extractSpanContextFromServiceBusMessage(message) {
    if (!message.applicationProperties || !message.applicationProperties[TRACEPARENT_PROPERTY]) {
        return;
    }
    const diagnosticId = message.applicationProperties[TRACEPARENT_PROPERTY];
    return extractSpanContextFromTraceParentHeader(diagnosticId);
}
/**
 * Provides an iterable over messages, whether it is a single message or multiple
 * messages.
 *
 * @param receivedMessages A single message or a set of messages
 * @internal
 * @hidden
 */
function* getReceivedMessages(receivedMessages) {
    if (!Array.isArray(receivedMessages)) {
        yield receivedMessages;
    }
    else {
        for (const message of receivedMessages) {
            yield message;
        }
    }
}
/**
 * A span that encompasses the period when the message has been received and
 * is being processed.
 *
 * NOTE: The amount of time the user would be considered processing the message is
 * not always clear - in that case the span will have a very short lifetime
 * since we'll start the span when we receive the message and end it when we
 * give the message to the user.
 *
 * @internal
 * @hidden
 */
export function createProcessingSpan(receivedMessages, 
// NOTE: the connectionConfig also has an entityPath property but that only
// represents the optional entityPath in their connection string which is NOT
// what we want for tracing.
receiver, connectionConfig, options) {
    var _a;
    const links = [];
    for (const receivedMessage of getReceivedMessages(receivedMessages)) {
        const spanContext = extractSpanContextFromServiceBusMessage(receivedMessage);
        if (spanContext == null) {
            continue;
        }
        links.push({
            context: spanContext,
            attributes: {
                enqueuedTime: (_a = receivedMessage.enqueuedTimeUtc) === null || _a === void 0 ? void 0 : _a.getTime()
            }
        });
    }
    const span = getTracer().startSpan("Azure.ServiceBus.process", {
        kind: SpanKind.CONSUMER,
        links,
        parent: getParentSpan(options === null || options === void 0 ? void 0 : options.tracingOptions)
    });
    span.setAttributes({
        "az.namespace": "Microsoft.ServiceBus",
        "message_bus.destination": receiver.entityPath,
        "peer.address": connectionConfig.host
    });
    return span;
}
/**
 * Creates and immediately ends a processing span. Used when
 * the 'processing' occurs outside of our control so we don't
 * know the scope.
 *
 * @internal
 * @hidden
 */
export function createAndEndProcessingSpan(receivedMessages, receiver, connectionConfig, options) {
    const span = createProcessingSpan(receivedMessages, receiver, connectionConfig, options);
    span.setStatus({ code: CanonicalCode.OK });
    span.end();
}
//# sourceMappingURL=instrumentServiceBusMessage.js.map