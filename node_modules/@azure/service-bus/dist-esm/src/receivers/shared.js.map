{"version":3,"file":"shared.js","sourceRoot":"","sources":["../../../src/receivers/shared.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { MessageHandlers, ProcessErrorArgs } from \"../models\";\nimport { ServiceBusReceiver } from \"./receiver\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { receiverLogger, ServiceBusLogger } from \"../log\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport {\n  DeadLetterOptions,\n  DispositionType,\n  ServiceBusMessageImpl,\n  ServiceBusReceivedMessage\n} from \"../serviceBusMessage\";\nimport { DispositionStatusOptions } from \"../core/managementClient\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { ErrorNameConditionMapper } from \"@azure/core-amqp\";\nimport { MessageAlreadySettled } from \"../util/errors\";\n\n/**\n * @internal\n * @hidden\n */\nexport function assertValidMessageHandlers(handlers: any) {\n  if (\n    handlers &&\n    handlers.processMessage instanceof Function &&\n    handlers.processError instanceof Function\n  ) {\n    return;\n  }\n\n  throw new TypeError('Invalid \"MessageHandlers\" provided.');\n}\n\n/**\n * @internal\n * @hidden\n */\nexport async function* getMessageIterator(\n  receiver: Pick<ServiceBusReceiver, \"receiveMessages\">,\n  options?: OperationOptionsBase\n): AsyncIterableIterator<ServiceBusReceivedMessage> {\n  while (true) {\n    const messages = await receiver.receiveMessages(1, options);\n\n    if (messages.length === 0) {\n      continue;\n    }\n\n    yield messages[0];\n  }\n}\n\n/**\n * @internal\n * @hidden\n */\nexport function wrapProcessErrorHandler(\n  handlers: Pick<MessageHandlers, \"processError\">,\n  logger: ServiceBusLogger = receiverLogger\n): MessageHandlers[\"processError\"] {\n  return async (args: ProcessErrorArgs) => {\n    try {\n      args.error = translateServiceBusError(args.error);\n      await handlers.processError(args);\n    } catch (err) {\n      logger.logError(err, `An error was thrown from the user's processError handler`);\n    }\n  };\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {ServiceBusMessageImpl} message\n * @param {ConnectionContext} context\n * @param {string} entityPath\n */\nexport function completeMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Completing the message with id '%s'.\",\n    context.connectionId,\n    message.messageId\n  );\n  return settleMessage(message, DispositionType.complete, context, entityPath);\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {ServiceBusMessageImpl} message\n * @param {ConnectionContext} context\n * @param {string} entityPath\n * @param {{ [key: string]: any }} [propertiesToModify]\n */\nexport function abandonMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string,\n  propertiesToModify?: { [key: string]: any }\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Abandoning the message with id '%s'.\",\n    context.connectionId,\n    message.messageId\n  );\n  return settleMessage(message, DispositionType.abandon, context, entityPath, {\n    propertiesToModify\n  });\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {ServiceBusMessageImpl} message\n * @param {ConnectionContext} context\n * @param {string} entityPath\n * @param {{ [key: string]: any }} [propertiesToModify]\n */\nexport function deferMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string,\n  propertiesToModify?: { [key: string]: any }\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Deferring the message with id '%s'.\",\n    context.connectionId,\n    message.messageId\n  );\n  return settleMessage(message, DispositionType.defer, context, entityPath, {\n    propertiesToModify\n  });\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {ServiceBusMessageImpl} message\n * @param {ConnectionContext} context\n * @param {string} entityPath\n * @param {(DeadLetterOptions & { [key: string]: any })} [propertiesToModify]\n */\nexport function deadLetterMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string,\n  propertiesToModify?: DeadLetterOptions & { [key: string]: any }\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Deadlettering the message with id '%s'.\",\n    context.connectionId,\n    message.messageId\n  );\n\n  const actualPropertiesToModify: Partial<DeadLetterOptions> = {\n    ...propertiesToModify\n  };\n\n  // these two fields are handled specially and don't need to be in here.\n  delete actualPropertiesToModify.deadLetterErrorDescription;\n  delete actualPropertiesToModify.deadLetterReason;\n\n  const dispositionStatusOptions: DispositionStatusOptions = {\n    propertiesToModify: actualPropertiesToModify,\n    deadLetterReason: propertiesToModify?.deadLetterReason,\n    deadLetterDescription: propertiesToModify?.deadLetterErrorDescription\n  };\n\n  return settleMessage(\n    message,\n    DispositionType.deadletter,\n    context,\n    entityPath,\n    dispositionStatusOptions\n  );\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {ServiceBusMessageImpl} message\n * @param {DispositionType} operation\n * @param {ConnectionContext} context\n * @param {string} entityPath\n * @param {DispositionStatusOptions} [options]\n */\nfunction settleMessage(\n  message: ServiceBusMessageImpl,\n  operation: DispositionType,\n  context: ConnectionContext,\n  entityPath: string,\n  options?: DispositionStatusOptions\n): Promise<void> {\n  const isDeferredMessage = !message.delivery.link;\n  const receiver = isDeferredMessage\n    ? undefined\n    : context.getReceiverFromCache(message.delivery.link.name, message.sessionId);\n  const associatedLinkName = receiver?.name;\n\n  let error: Error | undefined;\n  if (message.delivery.remote_settled) {\n    error = new Error(MessageAlreadySettled);\n  } else if (\n    !isDeferredMessage &&\n    (!receiver || !receiver.isOpen()) &&\n    message.sessionId != undefined\n  ) {\n    error = translateServiceBusError({\n      description:\n        `Failed to ${operation} the message as the AMQP link with which the message was ` +\n        `received is no longer alive.`,\n      condition: ErrorNameConditionMapper.SessionLockLostError\n    });\n  }\n\n  if (error) {\n    receiverLogger.logError(\n      error,\n      \"[%s] An error occurred when settling a message with id '%s'\",\n      context.connectionId,\n      message.messageId\n    );\n    throw error;\n  }\n\n  // Message Settlement with managementLink\n  // 1. If the received message is deferred as such messages can only be settled using managementLink\n  // 2. If the associated receiver link is not available. This does not apply to messages from sessions as we need a lock on the session to do so.\n  if (isDeferredMessage || ((!receiver || !receiver.isOpen()) && message.sessionId == undefined)) {\n    return context\n      .getManagementClient(entityPath)\n      .updateDispositionStatus(message.lockToken!, operation, {\n        ...options,\n        associatedLinkName,\n        sessionId: message.sessionId\n      })\n      .catch((err) => {\n        throw translateServiceBusError(err);\n      });\n  }\n\n  return receiver!.settleMessage(message, operation, options).catch((err) => {\n    throw translateServiceBusError(err);\n  });\n}\n"]}