// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import { trace } from "../modelsToBeSharedWithEventHubs";
import { getAlreadyReceivingErrorMsg, getReceiverClosedErrorMsg, InvalidMaxMessageCountError, throwErrorIfConnectionClosed, throwTypeErrorIfParameterMissing, throwTypeErrorIfParameterNotLong, throwErrorIfInvalidOperationOnMessage, throwTypeErrorIfParameterTypeMismatch } from "../util/errors";
import { StreamingReceiver } from "../core/streamingReceiver";
import { BatchingReceiver } from "../core/batchingReceiver";
import { abandonMessage, assertValidMessageHandlers, completeMessage, deadLetterMessage, deferMessage, getMessageIterator, wrapProcessErrorHandler } from "./shared";
import { Constants, RetryOperationType, retry } from "@azure/core-amqp";
import "@azure/core-asynciterator-polyfill";
import { LockRenewer } from "../core/autoLockRenewer";
import { createProcessingSpan } from "../diagnostics/instrumentServiceBusMessage";
import { receiverLogger as logger } from "../log";
import { translateServiceBusError } from "../serviceBusError";
/**
 * @internal
 * @hidden
 */
export class ServiceBusReceiverImpl {
    /**
     * @throws Error if the underlying connection is closed.
     */
    constructor(_context, entityPath, receiveMode, maxAutoRenewLockDurationInMs, retryOptions = {}) {
        this._context = _context;
        this.entityPath = entityPath;
        this.receiveMode = receiveMode;
        /**
         * @property {boolean} [_isClosed] Denotes if close() was called on this receiver
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(_context);
        this._retryOptions = retryOptions;
        this._lockRenewer = LockRenewer.create(this._context, maxAutoRenewLockDurationInMs, receiveMode);
        this._createProcessingSpan = createProcessingSpan;
    }
    get logPrefix() {
        return `[${this._context.connectionId}|receiver:${this.entityPath}]`;
    }
    _throwIfAlreadyReceiving() {
        if (this._isReceivingMessages()) {
            const errorMessage = getAlreadyReceivingErrorMsg(this.entityPath);
            const error = new Error(errorMessage);
            logger.logError(error, `${this.logPrefix} is already receiving`);
            throw error;
        }
    }
    _throwIfReceiverOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (this.isClosed) {
            const errorMessage = getReceiverClosedErrorMsg(this.entityPath);
            const error = new Error(errorMessage);
            logger.logError(error, `${this.logPrefix} is closed`);
            throw error;
        }
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the Receiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control if messages should be automatically completed, and/or have
     * their locks automatically renewed. You can control the maximum number of messages that should
     * be concurrently processed. You can also provide a timeout in milliseconds to denote the
     * amount of time to wait for a new message before closing the receiver.
     *
     * @returns void
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if current receiver is already in state of receiving messages.
     * @throws ServiceBusError if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
     */
    _registerMessageHandler(onInitialize, onMessage, onError, options) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        const connId = this._context.connectionId;
        throwTypeErrorIfParameterMissing(connId, "onMessage", onMessage);
        throwTypeErrorIfParameterMissing(connId, "onError", onError);
        if (typeof onMessage !== "function") {
            throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
        }
        if (typeof onError !== "function") {
            throw new TypeError("The parameter 'onError' must be of type 'function'.");
        }
        this._createStreamingReceiver(Object.assign(Object.assign({}, options), { receiveMode: this.receiveMode, retryOptions: this._retryOptions, lockRenewer: this._lockRenewer, onError }))
            .then((sReceiver) => __awaiter(this, void 0, void 0, function* () {
            if (!sReceiver) {
                return;
            }
            this._streamingReceiver = sReceiver;
            try {
                yield onInitialize();
            }
            catch (err) {
                onError({
                    error: err,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host
                });
            }
            if (!this.isClosed) {
                sReceiver.subscribe(onMessage, onError);
            }
            else {
                yield sReceiver.close();
            }
            return;
        }))
            .catch((err) => {
            // TODO: being a bit broad here but the only errors that should filter out this
            // far are going to be bootstrapping the subscription.
            onError({
                error: err,
                errorSource: "receive",
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host
            });
        });
    }
    _createStreamingReceiver(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (options.autoCompleteMessages == null)
                options.autoCompleteMessages = true;
            // When the user "stops" a streaming receiver (via the returned instance from 'subscribe' we just suspend
            // it, leaving the link open). This allows users to stop the flow of messages but still be able to settle messages
            // since the link itself hasn't been shut down.
            //
            // Users can, if they want, restart their subscription (since we've got a link already established).
            // So you'll have an instance here if the user has done:
            // 1. const subscription = receiver.subscribe()
            // 2. subscription.stop()
            // 3. receiver.subscribe()
            this._streamingReceiver = (_a = this._streamingReceiver) !== null && _a !== void 0 ? _a : new StreamingReceiver(this._context, this.entityPath, options);
            // this ensures that if the outer service bus client is closed that  this receiver is cleaned up.
            // this mostly affects us if we're in the middle of init() - the connection (and receiver) are not yet
            // open but we do need to close the receiver to exit the init() loop.
            this._context.messageReceivers[this._streamingReceiver.name] = this._streamingReceiver;
            yield this._streamingReceiver.init(Object.assign({ connectionId: this._context.connectionId, useNewName: false }, options));
            return this._streamingReceiver;
        });
    }
    receiveMessages(maxMessageCount, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            this._throwIfAlreadyReceiving();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "maxMessageCount", maxMessageCount);
            throwTypeErrorIfParameterTypeMismatch(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");
            if (isNaN(maxMessageCount) || maxMessageCount < 1) {
                throw new TypeError(InvalidMaxMessageCountError);
            }
            const receiveMessages = () => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (!this._batchingReceiver || !this._context.messageReceivers[this._batchingReceiver.name]) {
                    const options = {
                        maxConcurrentCalls: 0,
                        receiveMode: this.receiveMode,
                        lockRenewer: this._lockRenewer
                    };
                    this._batchingReceiver = this._createBatchingReceiver(this._context, this.entityPath, options);
                }
                const receivedMessages = yield this._batchingReceiver.receive(maxMessageCount, (_a = options === null || options === void 0 ? void 0 : options.maxWaitTimeInMs) !== null && _a !== void 0 ? _a : Constants.defaultOperationTimeoutInMs, defaultMaxTimeAfterFirstMessageForBatchingMs, options !== null && options !== void 0 ? options : {});
                return receivedMessages;
            });
            const config = {
                connectionHost: this._context.config.host,
                connectionId: this._context.connectionId,
                operation: receiveMessages,
                operationType: RetryOperationType.receiveMessage,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
                retryOptions: this._retryOptions
            };
            return retry(config).catch((err) => {
                throw translateServiceBusError(err);
            });
        });
    }
    getMessageIterator(options) {
        return getMessageIterator(this, options);
    }
    receiveDeferredMessages(sequenceNumbers, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
            throwTypeErrorIfParameterNotLong(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
            const deferredSequenceNumbers = Array.isArray(sequenceNumbers)
                ? sequenceNumbers
                : [sequenceNumbers];
            const receiveDeferredMessagesOperationPromise = () => __awaiter(this, void 0, void 0, function* () {
                const deferredMessages = yield this._context
                    .getManagementClient(this.entityPath)
                    .receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, undefined, Object.assign(Object.assign({}, options), { associatedLinkName: this._getAssociatedReceiverName(), requestName: "receiveDeferredMessages", timeoutInMs: this._retryOptions.timeoutInMs }));
                return deferredMessages;
            });
            const config = {
                operation: receiveDeferredMessagesOperationPromise,
                connectionId: this._context.connectionId,
                operationType: RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return retry(config);
        });
    }
    // ManagementClient methods # Begin
    peekMessages(maxMessageCount, options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            const managementRequestOptions = Object.assign(Object.assign({}, options), { associatedLinkName: this._getAssociatedReceiverName(), requestName: "peekMessages", timeoutInMs: (_a = this._retryOptions) === null || _a === void 0 ? void 0 : _a.timeoutInMs });
            const peekOperationPromise = () => __awaiter(this, void 0, void 0, function* () {
                if (options.fromSequenceNumber) {
                    return yield this._context
                        .getManagementClient(this.entityPath)
                        .peekBySequenceNumber(options.fromSequenceNumber, maxMessageCount, undefined, managementRequestOptions);
                }
                else {
                    return yield this._context
                        .getManagementClient(this.entityPath)
                        .peek(maxMessageCount, managementRequestOptions);
                }
            });
            const config = {
                operation: peekOperationPromise,
                connectionId: this._context.connectionId,
                operationType: RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return retry(config);
        });
    }
    subscribe(handlers, options) {
        assertValidMessageHandlers(handlers);
        options = options !== null && options !== void 0 ? options : {};
        const processError = wrapProcessErrorHandler(handlers);
        const internalMessageHandlers = handlers;
        this._registerMessageHandler(() => __awaiter(this, void 0, void 0, function* () {
            if (internalMessageHandlers === null || internalMessageHandlers === void 0 ? void 0 : internalMessageHandlers.processInitialize) {
                yield internalMessageHandlers.processInitialize();
            }
        }), (message) => __awaiter(this, void 0, void 0, function* () {
            const span = this._createProcessingSpan(message, this, this._context.config, options);
            return trace(() => handlers.processMessage(message), span);
        }), processError, options);
        return {
            close: () => __awaiter(this, void 0, void 0, function* () {
                var _a;
                return (_a = this._streamingReceiver) === null || _a === void 0 ? void 0 : _a.stopReceivingMessages();
            })
        };
    }
    completeMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return completeMessage(msgImpl, this._context, this.entityPath);
        });
    }
    abandonMessage(message, propertiesToModify) {
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return abandonMessage(msgImpl, this._context, this.entityPath, propertiesToModify);
        });
    }
    deferMessage(message, propertiesToModify) {
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return deferMessage(msgImpl, this._context, this.entityPath, propertiesToModify);
        });
    }
    deadLetterMessage(message, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return deadLetterMessage(msgImpl, this._context, this.entityPath, options);
        });
    }
    renewMessageLock(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            let associatedLinkName;
            if (msgImpl.delivery.link) {
                const associatedReceiver = this._context.getReceiverFromCache(msgImpl.delivery.link.name);
                associatedLinkName = associatedReceiver === null || associatedReceiver === void 0 ? void 0 : associatedReceiver.name;
            }
            return this._context
                .getManagementClient(this.entityPath)
                .renewLock(message.lockToken, { associatedLinkName })
                .then((lockedUntil) => {
                message.lockedUntilUtc = lockedUntil;
                return lockedUntil;
            });
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this._isClosed = true;
                if (this._context.connection && this._context.connection.isOpen()) {
                    // Close the streaming receiver.
                    if (this._streamingReceiver) {
                        yield this._streamingReceiver.close();
                    }
                    // Close the batching receiver.
                    if (this._batchingReceiver) {
                        yield this._batchingReceiver.close();
                    }
                }
            }
            catch (err) {
                logger.logError(err, `${this.logPrefix} An error occurred while closing the Receiver`);
                throw err;
            }
        });
    }
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
     */
    _isReceivingMessages() {
        if (this._streamingReceiver &&
            this._streamingReceiver.isOpen() &&
            this._streamingReceiver.isReceivingMessages) {
            return true;
        }
        if (this._batchingReceiver &&
            this._batchingReceiver.isOpen() &&
            this._batchingReceiver.isReceivingMessages) {
            return true;
        }
        return false;
    }
    _createBatchingReceiver(context, entityPath, options) {
        return BatchingReceiver.create(context, entityPath, options);
    }
    /**
     * Helper function to retrieve any active receiver name, regardless of streaming or
     * batching if it exists. This is used for optimization on the service side
     */
    _getAssociatedReceiverName() {
        if (this._streamingReceiver && this._streamingReceiver.isOpen()) {
            return this._streamingReceiver.name;
        }
        if (this._batchingReceiver &&
            this._batchingReceiver.isOpen() &&
            this._batchingReceiver.isReceivingMessages) {
            return this._batchingReceiver.name;
        }
        return;
    }
}
/**
 * The default time to wait for messages _after_ the first message
 * has been received.
 *
 * This timeout only applies to receiveMessages()
 *
 * @internal
 * @hidden
 */
export const defaultMaxTimeAfterFirstMessageForBatchingMs = 1000;
//# sourceMappingURL=receiver.js.map