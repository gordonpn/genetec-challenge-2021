// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { ConnectionConfig } from "@azure/core-amqp";
import { ConnectionContext } from "./connectionContext";
import { SharedKeyCredential } from "./servicebusSharedKeyCredential";
/**
 * @internal
 * @hidden
 *
 * @param {string} connectionString
 * @param {(SharedKeyCredential | TokenCredential)} credential
 * @param {ServiceBusClientOptions} options
 */
export function createConnectionContext(connectionString, credential, options) {
    var _a, _b;
    const config = ConnectionConfig.create(connectionString);
    config.webSocket = (_a = options === null || options === void 0 ? void 0 : options.webSocketOptions) === null || _a === void 0 ? void 0 : _a.webSocket;
    config.webSocketEndpointPath = "$servicebus/websocket";
    config.webSocketConstructorOptions = (_b = options === null || options === void 0 ? void 0 : options.webSocketOptions) === null || _b === void 0 ? void 0 : _b.webSocketConstructorOptions;
    return ConnectionContext.create(config, credential, options);
}
/**
 * @param connectionString
 * @param options
 * @internal
 * @hidden
 */
export function createConnectionContextForConnectionString(connectionString, options = {}) {
    const credential = SharedKeyCredential.fromConnectionString(connectionString);
    return createConnectionContext(connectionString, credential, options);
}
/**
 *
 * @param credential
 * @param host
 * @param options
 * @internal
 * @hidden
 */
export function createConnectionContextForTokenCredential(credential, host, options = {}) {
    if (typeof host !== "string") {
        throw new TypeError("`host` parameter is not a string");
    }
    // host, credential and options based constructor was invoked
    if (!host.endsWith("/")) {
        host += "/";
    }
    const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;`;
    return createConnectionContext(connectionString, credential, options);
}
/**
 * Parses a connection string and extracts the EntityPath named entity out.
 * @param connectionString An entity specific Service Bus connection string.
 * @internal
 * @hidden
 */
export function getEntityNameFromConnectionString(connectionString) {
    const entityPathMatch = connectionString.match(/^.+EntityPath=(.+?);{0,1}$/);
    if (entityPathMatch != null && entityPathMatch.length === 2) {
        return entityPathMatch[1];
    }
    else {
        throw new Error("No entity name present in the connection string");
    }
}
//# sourceMappingURL=constructorHelpers.js.map