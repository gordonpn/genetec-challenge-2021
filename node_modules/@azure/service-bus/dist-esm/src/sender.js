// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import { MessageSender } from "./core/messageSender";
import { getSenderClosedErrorMsg, throwErrorIfConnectionClosed, throwIfNotValidServiceBusMessage, throwTypeErrorIfParameterMissing, throwTypeErrorIfParameterNotLong } from "./util/errors";
import { RetryOperationType, retry } from "@azure/core-amqp";
import { createSendSpan, getParentSpan } from "./modelsToBeSharedWithEventHubs";
import { CanonicalCode } from "@opentelemetry/api";
import { senderLogger as logger } from "./log";
import { ServiceBusError } from "./serviceBusError";
/**
 * @internal
 * @hidden
 * @class ServiceBusSenderImpl
 * @implements {ServiceBusSender}
 */
export class ServiceBusSenderImpl {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     */
    constructor(_context, _entityPath, retryOptions = {}) {
        this._context = _context;
        this._entityPath = _entityPath;
        /**
         * @property Denotes if close() was called on this sender
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(_context);
        this.entityPath = _entityPath;
        this._sender = MessageSender.create(this._context, _entityPath, retryOptions);
        this._retryOptions = retryOptions;
    }
    get logPrefix() {
        return `[${this._context.connectionId}|sender:${this.entityPath}]`;
    }
    _throwIfSenderOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (this.isClosed) {
            const errorMessage = getSenderClosedErrorMsg(this._entityPath);
            const error = new Error(errorMessage);
            logger.logError(error, `[${this._context.connectionId}] is closed`);
            throw error;
        }
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    sendMessages(messages, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "messages", messages);
            const invalidTypeErrMsg = "Provided value for 'messages' must be of type ServiceBusMessage, ServiceBusMessageBatch or an array of type ServiceBusMessage.";
            let batch;
            if (isServiceBusMessageBatch(messages)) {
                batch = messages;
            }
            else {
                if (!Array.isArray(messages)) {
                    messages = [messages];
                }
                batch = yield this.createMessageBatch(options);
                for (const message of messages) {
                    throwIfNotValidServiceBusMessage(message, invalidTypeErrMsg);
                    if (!batch.tryAddMessage(message, { parentSpan: getParentSpan(options === null || options === void 0 ? void 0 : options.tracingOptions) })) {
                        // this is too big - throw an error
                        throw new ServiceBusError("Messages were too big to fit in a single batch. Remove some messages and try again or create your own batch using createBatch(), which gives more fine-grained control.", "MessageSizeExceeded");
                    }
                }
            }
            const sendSpan = createSendSpan(getParentSpan(options === null || options === void 0 ? void 0 : options.tracingOptions), batch._messageSpanContexts, this.entityPath, this._context.config.host);
            try {
                const result = yield this._sender.sendBatch(batch, options);
                sendSpan.setStatus({ code: CanonicalCode.OK });
                return result;
            }
            catch (error) {
                sendSpan.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: error.message
                });
                throw error;
            }
            finally {
                sendSpan.end();
            }
        });
    }
    createMessageBatch(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            return this._sender.createBatch(options);
        });
    }
    scheduleMessages(messages, scheduledEnqueueTimeUtc, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "scheduledEnqueueTimeUtc", scheduledEnqueueTimeUtc);
            throwTypeErrorIfParameterMissing(this._context.connectionId, "messages", messages);
            const messagesToSchedule = Array.isArray(messages) ? messages : [messages];
            for (const message of messagesToSchedule) {
                throwIfNotValidServiceBusMessage(message, "Provided value for 'messages' must be of type ServiceBusMessage or an array of type ServiceBusMessage.");
            }
            const scheduleMessageOperationPromise = () => __awaiter(this, void 0, void 0, function* () {
                return this._context
                    .getManagementClient(this._entityPath)
                    .scheduleMessages(scheduledEnqueueTimeUtc, messagesToSchedule, Object.assign(Object.assign({}, options), { associatedLinkName: this._sender.name, requestName: "scheduleMessages", timeoutInMs: this._retryOptions.timeoutInMs }));
            });
            const config = {
                operation: scheduleMessageOperationPromise,
                connectionId: this._context.connectionId,
                operationType: RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return retry(config);
        });
    }
    cancelScheduledMessages(sequenceNumbers, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
            throwTypeErrorIfParameterNotLong(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
            const sequenceNumbersToCancel = Array.isArray(sequenceNumbers)
                ? sequenceNumbers
                : [sequenceNumbers];
            const cancelSchedulesMessagesOperationPromise = () => __awaiter(this, void 0, void 0, function* () {
                return this._context.getManagementClient(this._entityPath).cancelScheduledMessages(sequenceNumbersToCancel, Object.assign(Object.assign({}, options), { associatedLinkName: this._sender.name, requestName: "cancelScheduledMessages", timeoutInMs: this._retryOptions.timeoutInMs }));
            });
            const config = {
                operation: cancelSchedulesMessagesOperationPromise,
                connectionId: this._context.connectionId,
                operationType: RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return retry(config);
        });
    }
    // async open(options?: OperationOptionsBase): Promise<void> {
    //   this._throwIfSenderOrConnectionClosed();
    //   const config: RetryConfig<void> = {
    //     // TODO: Pass tracing options too
    //     operation: () => this._sender.open(undefined, options?.abortSignal),
    //     connectionId: this._context.connectionId,
    //     operationType: RetryOperationType.senderLink,
    //     retryOptions: this._retryOptions,
    //     abortSignal: options?.abortSignal
    //   };
    //   return retry<void>(config);
    // }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this._isClosed = true;
                yield this._sender.close();
            }
            catch (err) {
                logger.logError(err, `${this.logPrefix} An error occurred while closing the Sender`);
                throw err;
            }
        });
    }
}
/**
 * @internal
 * @hidden
 */
export function isServiceBusMessageBatch(messageBatchOrAnything) {
    if (messageBatchOrAnything == null) {
        return false;
    }
    const possibleBatch = messageBatchOrAnything;
    return (typeof possibleBatch.tryAddMessage === "function" &&
        typeof possibleBatch.maxSizeInBytes === "number" &&
        typeof possibleBatch.sizeInBytes === "number");
}
//# sourceMappingURL=sender.js.map