{"version":3,"file":"messageSession.js","sourceRoot":"","sources":["../../../src/session/messageSession.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants, ErrorNameConditionMapper, MessagingError } from \"@azure/core-amqp\";\nimport {\n  AmqpError,\n  EventContext,\n  OnAmqpEvent,\n  Receiver,\n  ReceiverEvents,\n  ReceiverOptions\n} from \"rhea-promise\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { LinkEntity } from \"../core/linkEntity\";\nimport { DispositionStatusOptions } from \"../core/managementClient\";\nimport { OnAmqpEventAsPromise, OnError, OnMessage } from \"../core/messageReceiver\";\nimport { receiverLogger as logger } from \"../log\";\nimport { DispositionType, ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport {\n  calculateRenewAfterDuration,\n  convertTicksToDate,\n  StandardAbortMessage\n} from \"../util/utils\";\nimport { BatchingReceiverLite, MinimalReceiver } from \"../core/batchingReceiver\";\nimport { onMessageSettled, DeferredPromiseAndTimer, createReceiverOptions } from \"../core/shared\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { ReceiverHelper } from \"../core/receiverHelper\";\nimport {\n  ServiceBusSessionReceiverOptions,\n  ProcessErrorArgs,\n  ReceiveMode,\n  SubscribeOptions\n} from \"../models\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { abandonMessage, completeMessage } from \"../receivers/shared\";\n\n/**\n * Describes the options that need to be provided while creating a message session receiver link.\n * @internal\n * @hidden\n */\nexport interface CreateMessageSessionReceiverLinkOptions {\n  onClose: OnAmqpEventAsPromise;\n  onSessionClose: OnAmqpEventAsPromise;\n  onError: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSettled: OnAmqpEvent;\n  sessionId?: string;\n}\n\n/**\n * @internal\n * @hidden\n * Describes all the options that can be set while instantiating a MessageSession object.\n */\nexport type MessageSessionOptions = Pick<\n  ServiceBusSessionReceiverOptions,\n  \"maxAutoLockRenewalDurationInMs\" | \"abortSignal\"\n> & {\n  receiveMode?: ReceiveMode;\n};\n\n/**\n * @internal\n * @hidden\n * Describes the receiver for a Message Session.\n */\nexport class MessageSession extends LinkEntity<Receiver> {\n  /**\n   * @property {Date} [sessionLockedUntilUtc] Provides the duration until which the session is locked.\n   */\n  sessionLockedUntilUtc!: Date;\n  /**\n   * @property {string} [sessionId] The sessionId for the message session. Empty string is valid sessionId.\n   */\n  sessionId!: string;\n  /**\n   * @property {number} [maxConcurrentSessions] The maximum number of concurrent sessions that the\n   * client should initiate.\n   * - **Default**: `1`.\n   */\n  maxConcurrentSessions?: number;\n  /**\n   * @property {number} [maxConcurrentCalls] The maximum number of messages that should be\n   * processed concurrently in a session while in streaming mode. Once this limit has been reached,\n   * more messages will not be received until the user's message handler has completed processing current message.\n   * - **Default**: `1` (message in a session at a time).\n   */\n  maxConcurrentCalls: number = 1;\n  /**\n   * @property {number} [receiveMode] The mode in which messages should be received.\n   * Default: ReceiveMode.peekLock\n   */\n  receiveMode: ReceiveMode;\n  /**\n   * @property {boolean} autoComplete Indicates whether `Message.complete()` should be called\n   * automatically after the message processing is complete while receiving messages with handlers.\n   * Default: false.\n   */\n  autoComplete: boolean;\n  /**\n   * @property {number} maxAutoRenewDurationInMs The maximum duration within which the\n   * lock will be renewed automatically. This value should be greater than the longest message\n   * lock duration; for example, the `lockDuration` property on the received message.\n   *\n   * Default: `300 * 1000` (5 minutes);\n   */\n  maxAutoRenewDurationInMs: number;\n  /**\n   * @property {boolean} autoRenewLock Should lock renewal happen automatically.\n   */\n  autoRenewLock: boolean;\n  /**\n   * Denotes if we are currently receiving messages\n   */\n  get isReceivingMessages(): boolean {\n    return this._batchingReceiverLite.isReceivingMessages || this._isReceivingMessagesForSubscriber;\n  }\n\n  private _batchingReceiverLite: BatchingReceiverLite;\n  private _isReceivingMessagesForSubscriber: boolean;\n\n  /**\n   * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that\n   * are being actively disposed. It acts as a store for correlating the responses received for\n   * active dispositions.\n   */\n  private _deliveryDispositionMap: Map<number, DeferredPromiseAndTimer> = new Map<\n    number,\n    DeferredPromiseAndTimer\n  >();\n  /**\n   * @property {OnMessage} _onMessage The message handler provided by the user that will\n   * be wrapped inside _onAmqpMessage.\n   */\n  private _onMessage!: OnMessage;\n  /**\n   * @property {OnError} _onError The error handler provided by the user that will be wrapped\n   * inside _onAmqpError.\n   */\n  private _onError?: OnError;\n  /**\n   * @property {OnError} _notifyError If the user provided error handler is present then it will\n   * notify the user's error handler about the error.\n   */\n  private _notifyError: OnError;\n  /**\n   * @property {OnAmqpEventAsPromise} _onAmqpClose The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_close\" event.\n   */\n  private _onAmqpClose: OnAmqpEventAsPromise;\n  /**\n   * @property {OnAmqpEvent} _onSessionError The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEventAsPromise} _onSessionClose The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEventAsPromise;\n  /**\n   * @property {OnAmqpEvent} _onAmqpError The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_error\" event.\n   */\n  private _onAmqpError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onSettled The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"settled\" event.\n   */\n  private _onSettled: OnAmqpEvent;\n  /**\n   * @property {NodeJS.Timer} _sessionLockRenewalTimer The session lock renewal timer that keeps\n   * track of when the MessageSession is due for session lock renewal.\n   */\n  private _sessionLockRenewalTimer?: NodeJS.Timer;\n\n  private _totalAutoLockRenewDuration: number;\n\n  public get receiverHelper(): ReceiverHelper {\n    return this._receiverHelper;\n  }\n  private _receiverHelper: ReceiverHelper;\n\n  /**\n   * Ensures that the session lock is renewed before it expires. The lock will not be renewed for\n   * more than the configured totalAutoLockRenewDuration.\n   */\n  private _ensureSessionLockRenewal(): void {\n    if (\n      this.autoRenewLock &&\n      new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc! &&\n      Date.now() < this._totalAutoLockRenewDuration &&\n      this.isOpen()\n    ) {\n      const nextRenewalTimeout = calculateRenewAfterDuration(this.sessionLockedUntilUtc!);\n      this._sessionLockRenewalTimer = setTimeout(async () => {\n        try {\n          logger.verbose(\n            \"%s Attempting to renew the session lock for MessageSession '%s' \" + \"with name '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n            this.name\n          );\n          this.sessionLockedUntilUtc = await this._context\n            .getManagementClient(this.entityPath)\n            .renewSessionLock(this.sessionId, {\n              associatedLinkName: this.name,\n              timeoutInMs: 10000\n            });\n          logger.verbose(\n            \"%s Successfully renewed the session lock for MessageSession '%s' \" + \"with name '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n            this.name\n          );\n          logger.verbose(\n            \"%s Calling _ensureSessionLockRenewal() again for MessageSession '%s'.\",\n            this.logPrefix,\n            this.sessionId\n          );\n          this._ensureSessionLockRenewal();\n        } catch (err) {\n          logger.logError(\n            err,\n            \"%s An error occurred while renewing the session lock for MessageSession '%s'\",\n            this.logPrefix,\n            this.sessionId\n          );\n        }\n      }, nextRenewalTimeout);\n      logger.verbose(\n        \"%s MessageSession '%s' has next session lock renewal in %d milliseconds @(%s).\",\n        this.logPrefix,\n        this.sessionId,\n        nextRenewalTimeout,\n        new Date(Date.now() + nextRenewalTimeout).toString()\n      );\n    }\n  }\n\n  protected createRheaLink(\n    options: ReceiverOptions,\n    _abortSignal?: AbortSignalLike\n  ): Promise<Receiver> {\n    return this._context.connection.createReceiver(options);\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   */\n  private async _init(abortSignal?: AbortSignalLike): Promise<void> {\n    try {\n      const options = this._createMessageSessionOptions();\n      await this.initLink(options, abortSignal);\n\n      if (this.link == null) {\n        throw new Error(\"INTERNAL ERROR: failed to create receiver but without an error.\");\n      }\n\n      const receivedSessionId =\n        this.link.source &&\n        this.link.source.filter &&\n        this.link.source.filter[Constants.sessionFilterName];\n\n      let errorMessage: string = \"\";\n\n      if (this._providedSessionId == null && receivedSessionId == null) {\n        // Ideally this code path should never be reached as `MessageSession.createReceiver()` should fail instead\n        // TODO: https://github.com/Azure/azure-sdk-for-js/issues/9775 to figure out why this code path indeed gets hit.\n        errorMessage = `Failed to create a receiver. No unlocked sessions available.`;\n      } else if (this._providedSessionId != null && receivedSessionId !== this._providedSessionId) {\n        // This code path is reached if the session is already locked by another receiver.\n        // TODO: Check why the service would not throw an error or just timeout instead of giving a misleading successful receiver\n        errorMessage = `Failed to create a receiver for the requested session '${this._providedSessionId}'. It may be locked by another receiver.`;\n      }\n\n      if (errorMessage) {\n        const error = translateServiceBusError({\n          description: errorMessage,\n          condition: ErrorNameConditionMapper.SessionCannotBeLockedError\n        });\n        logger.logError(error, this.logPrefix);\n        throw error;\n      }\n      if (this._providedSessionId == null) this.sessionId = receivedSessionId;\n      this.sessionLockedUntilUtc = convertTicksToDate(\n        this.link.properties[\"com.microsoft:locked-until-utc\"]\n      );\n      logger.verbose(\n        \"%s Session with id '%s' is locked until: '%s'.\",\n        this.logPrefix,\n        this.sessionId,\n        this.sessionLockedUntilUtc.toISOString()\n      );\n      logger.verbose(\"%s Receiver created with receiver options: %O\", this.logPrefix, options);\n      if (!this._context.messageSessions[this.name]) {\n        this._context.messageSessions[this.name] = this;\n      }\n      this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;\n      this._ensureSessionLockRenewal();\n    } catch (err) {\n      const errObj = translateServiceBusError(err);\n      logger.logError(errObj, \"%s An error occured while creating the receiver\", this.logPrefix);\n\n      // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.\n      if ((errObj as MessagingError).code === \"OperationTimeoutError\") {\n        if (this._providedSessionId) {\n          errObj.message = `Failed to create a receiver for the requested session '${this._providedSessionId}' within allocated time and retry attempts.`;\n        } else {\n          errObj.message = \"Failed to create a receiver within allocated time and retry attempts.\";\n        }\n      }\n      throw errObj;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   */\n  private _createMessageSessionOptions(): ReceiverOptions {\n    const rcvrOptions: ReceiverOptions = createReceiverOptions(\n      this.name,\n      this.receiveMode,\n      {\n        address: this.address,\n        filter: { [Constants.sessionFilterName]: this.sessionId }\n      },\n      {\n        onClose: (context) =>\n          this._onAmqpClose(context).catch(() => {\n            /* */\n          }),\n        onSessionClose: (context) =>\n          this._onSessionClose(context).catch(() => {\n            /* */\n          }),\n        onError: this._onAmqpError,\n        onSessionError: this._onSessionError,\n        onSettled: this._onSettled\n      }\n    );\n\n    return rcvrOptions;\n  }\n\n  /**\n   * Constructs a MessageSession instance which lets you receive messages as batches\n   * or via callbacks using subscribe.\n   *\n   * @param _providedSessionId The sessionId provided by the user. This can be the\n   * name of a session ID to open (empty string is also valid) or it can be undefined,\n   * to indicate we want the next unlocked non-empty session.\n   */\n  constructor(\n    context: ConnectionContext,\n    entityPath: string,\n    private _providedSessionId: string | undefined,\n    options?: MessageSessionOptions\n  ) {\n    super(entityPath, entityPath, context, \"session\", logger, {\n      address: entityPath,\n      audience: `${context.config.endpoint}${entityPath}`\n    });\n    this._receiverHelper = new ReceiverHelper(() => ({\n      receiver: this.link,\n      logPrefix: this.logPrefix\n    }));\n    if (!options) options = {};\n    this.autoComplete = false;\n    if (this._providedSessionId != undefined) this.sessionId = this._providedSessionId;\n    this.receiveMode = options.receiveMode || \"peekLock\";\n    this.maxAutoRenewDurationInMs =\n      options.maxAutoLockRenewalDurationInMs != null\n        ? options.maxAutoLockRenewalDurationInMs\n        : 300 * 1000;\n    this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;\n    this.autoRenewLock = this.maxAutoRenewDurationInMs > 0 && this.receiveMode === \"peekLock\";\n\n    this._isReceivingMessagesForSubscriber = false;\n    this._batchingReceiverLite = new BatchingReceiverLite(\n      context,\n      entityPath,\n      async (_abortSignal?: AbortSignalLike): Promise<MinimalReceiver> => {\n        return this.link!;\n      },\n      this.receiveMode\n    );\n\n    // setting all the handlers\n    this._onSettled = (context: EventContext) => {\n      const delivery = context.delivery;\n\n      onMessageSettled(this.logPrefix, delivery, this._deliveryDispositionMap);\n    };\n\n    this._notifyError = (args: ProcessErrorArgs) => {\n      if (this._onError) {\n        this._onError(args);\n        logger.verbose(\n          \"%s Notified the user's error handler about the error received by the Receiver\",\n          this.logPrefix\n        );\n      }\n    };\n\n    this._onAmqpError = (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        if (sbError.code === \"SessionLockLostError\") {\n          sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;\n        }\n        logger.logError(sbError, \"%s An error occurred for Receiver\", this.logPrefix);\n        this._notifyError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host\n        });\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const connectionId = this._context.connectionId;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError);\n        logger.logError(\n          sbError,\n          \"[%s] An error occurred on the session for Receiver '%s': %O.\",\n          connectionId,\n          this.name,\n          sbError\n        );\n        this._notifyError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host\n        });\n      }\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const connectionId = this._context.connectionId;\n      const receiverError = context.receiver && context.receiver.error;\n      const receiver = this.link || context.receiver!;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        logger.logError(\n          sbError,\n          \"[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. \" +\n            \"The associated error is: %O\",\n          connectionId,\n          this.name,\n          this.sessionId,\n          sbError\n        );\n        // no need to notify the user's error handler since rhea guarantees that receiver_error\n        // will always be emitted before receiver_close.\n      }\n      if (receiver && !receiver.isItselfClosed()) {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver for sessionId '%s' \" +\n            \"and the sdk did not initiate this. Hence, let's gracefully close the receiver.\",\n          this.logPrefix,\n          this.sessionId\n        );\n        try {\n          await this.close();\n        } catch (err) {\n          logger.logError(\n            err,\n            \"%s An error occurred while closing the receiver for sessionId '%s'.\",\n            this.logPrefix,\n            this.sessionId\n          );\n        }\n      } else {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver for sessionId '%s' \" +\n            \"because the sdk initiated it. Hence no need to gracefully close the receiver\",\n          this.logPrefix,\n          this.sessionId\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const receiver = this.link || context.receiver!;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError);\n        logger.logError(\n          sbError,\n          \"%s 'session_close' event occurred for receiver for sessionId '%s'. \" +\n            \"The associated error is\",\n          this.logPrefix,\n          this.sessionId\n        );\n        // no need to notify the user's error handler since rhea guarantees that session_error\n        // will always be emitted before session_close.\n      }\n\n      if (receiver && !receiver.isSessionItselfClosed()) {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the receiver for sessionId '%s' \" +\n            \"and the sdk did not initiate this. Hence, let's gracefully close the receiver.\",\n          this.logPrefix,\n          this.sessionId\n        );\n        try {\n          await this.close();\n        } catch (err) {\n          logger.logError(\n            err,\n            \"%s An error occurred while closing the receiver for sessionId '%s'\",\n            this.logPrefix,\n            this.sessionId\n          );\n        }\n      } else {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the receiver for sessionId'%s' \" +\n            \"because the sdk initiated it. Hence no need to gracefully close the receiver\",\n          this.logPrefix,\n          this.sessionId\n        );\n      }\n    };\n  }\n\n  /**\n   * Closes the underlying AMQP receiver link.\n   */\n  async close(): Promise<void> {\n    try {\n      this._isReceivingMessagesForSubscriber = false;\n      if (this._sessionLockRenewalTimer) clearTimeout(this._sessionLockRenewalTimer);\n      logger.verbose(\n        \"%s Cleared the timers for 'no new message received' task and \" +\n          \"'session lock renewal' task.\",\n        this.logPrefix\n      );\n\n      await super.close();\n\n      await this._batchingReceiverLite.close();\n    } catch (err) {\n      logger.logError(\n        err,\n        \"%s An error occurred while closing the message session with id '%s'\",\n        this.logPrefix,\n        this.sessionId\n      );\n    }\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   */\n  isOpen(): boolean {\n    const result: boolean = this.link! && this.link!.isOpen();\n    logger.verbose(\n      \"%s Receiver for sessionId '%s' is open? -> %s\",\n      this.logPrefix,\n      this.sessionId,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the SessionReceiver or set the property\n   * `newMessageWaitTimeoutInMs` in the options to provide a timeout.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control whether messages should be automatically completed. You can\n   * also provide a timeout in milliseconds to denote the amount of time to wait for a new message\n   * before closing the receiver.\n   *\n   * @returns void\n   */\n  subscribe(onMessage: OnMessage, onError: OnError, options: SubscribeOptions): void {\n    if (!options) options = {};\n\n    if (options.abortSignal?.aborted) {\n      throw new AbortError(StandardAbortMessage);\n    }\n\n    this._isReceivingMessagesForSubscriber = true;\n    if (typeof options.maxConcurrentCalls === \"number\" && options.maxConcurrentCalls > 0) {\n      this.maxConcurrentCalls = options.maxConcurrentCalls;\n    }\n\n    // If explicitly set to false then autoComplete is false else true (default).\n    this.autoComplete =\n      options.autoCompleteMessages === false ? options.autoCompleteMessages : true;\n    this._onMessage = onMessage;\n    this._onError = onError;\n\n    if (this.link && this.link.isOpen()) {\n      const onSessionMessage = async (context: EventContext): Promise<void> => {\n        // If the receiver got closed in PeekLock mode, avoid processing the message as we\n        // cannot settle the message.\n        if (this.receiveMode === \"peekLock\" && (!this.link || !this.link.isOpen())) {\n          logger.verbose(\n            \"%s Not calling the user's message handler for the current message \" +\n              \"as the receiver is closed\",\n            this.logPrefix\n          );\n          return;\n        }\n\n        const bMessage = new ServiceBusMessageImpl(\n          context.message!,\n          context.delivery!,\n          true,\n          this.receiveMode\n        );\n\n        try {\n          await this._onMessage(bMessage);\n        } catch (err) {\n          logger.logError(\n            err,\n            \"%s An error occurred while running user's message handler for the message \" +\n              \"with id '%s' on the receiver\",\n            this.logPrefix,\n            bMessage.messageId\n          );\n          this._onError!({\n            error: err,\n            errorSource: \"processMessageCallback\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host\n          });\n\n          const error = translateServiceBusError(err);\n          // Nothing much to do if user's message handler throws. Let us try abandoning the message.\n          if (\n            !bMessage.delivery.remote_settled &&\n            this.receiveMode === \"peekLock\" &&\n            this.isOpen() // only try to abandon the messages if the connection is still open\n          ) {\n            try {\n              logger.logError(\n                error,\n                \"%s Abandoning the message with id '%s' on the receiver since an error occured\",\n                this.logPrefix,\n                bMessage.messageId\n              );\n              await abandonMessage(bMessage, this._context, this.entityPath);\n            } catch (abandonError) {\n              const translatedError = translateServiceBusError(abandonError);\n              logger.logError(\n                translatedError,\n                \"%s An error occurred while abandoning the message with id '%s' on the \" +\n                  \"receiver\",\n                this.logPrefix,\n                bMessage.messageId,\n                translatedError\n              );\n              this._notifyError({\n                error: translatedError,\n                errorSource: \"abandon\",\n                entityPath: this.entityPath,\n                fullyQualifiedNamespace: this._context.config.host\n              });\n            }\n          }\n          return;\n        } finally {\n          this.receiverHelper.addCredit(1);\n        }\n\n        // If we've made it this far, then user's message handler completed fine. Let us try\n        // completing the message.\n        if (\n          this.autoComplete &&\n          this.receiveMode === \"peekLock\" &&\n          !bMessage.delivery.remote_settled\n        ) {\n          try {\n            logger.verbose(\n              \"%s Auto completing the message with id '%s' on the receiver.\",\n              this.logPrefix,\n              bMessage.messageId\n            );\n            await completeMessage(bMessage, this._context, this.entityPath);\n          } catch (completeError) {\n            const translatedError = translateServiceBusError(completeError);\n            logger.logError(\n              translatedError,\n              \"%s An error occurred while completing the message with id '%s' on the \" + \"receiver\",\n              this.logPrefix,\n              bMessage.messageId\n            );\n            this._notifyError({\n              error: translatedError,\n              errorSource: \"complete\",\n              entityPath: this.entityPath,\n              fullyQualifiedNamespace: this._context.config.host\n            });\n          }\n        }\n      };\n      // setting the \"message\" event listener.\n      this.link.on(ReceiverEvents.message, onSessionMessage);\n      // adding credit\n      this.receiverHelper.addCredit(this.maxConcurrentCalls);\n    } else {\n      this._isReceivingMessagesForSubscriber = false;\n      const msg =\n        `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` +\n        `has either not been created or is not open.`;\n      logger.verbose(\"[%s] %s\", this._context.connectionId, msg);\n      this._notifyError({\n        error: new Error(msg),\n        // This is _probably_ the right error code since we require that\n        // the message session is created before we even give back the receiver. So it not\n        // being open at this point is either:\n        //\n        // 1. we didn't acquire the lock\n        // 2. the connection was broken (we don't reconnect)\n        //\n        // If any of these becomes untrue you'll probably want to re-evaluate this classification.\n        errorSource: \"receive\",\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host\n      });\n    }\n  }\n\n  /**\n   * Returns a batch of messages based on given count and timeout over an AMQP receiver link\n   * from a Queue/Subscription.\n   *\n   * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.\n   * @param maxWaitTimeInMs The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.\n   */\n  async receiveMessages(\n    maxMessageCount: number,\n    maxWaitTimeInMs: number,\n    maxTimeAfterFirstMessageInMs: number,\n    options: OperationOptionsBase\n  ): Promise<ServiceBusMessageImpl[]> {\n    try {\n      return await this._batchingReceiverLite.receiveMessages({\n        maxMessageCount,\n        maxWaitTimeInMs,\n        maxTimeAfterFirstMessageInMs,\n        ...options\n      });\n    } catch (error) {\n      logger.logError(error, `${this.logPrefix} Rejecting receiveMessages() with error`);\n      throw error;\n    }\n  }\n\n  /**\n   * Settles the message with the specified disposition.\n   * @param message The ServiceBus Message that needs to be settled.\n   * @param operation The disposition type.\n   * @param options Optional parameters that can be provided while disposing the message.\n   */\n  async settleMessage(\n    message: ServiceBusMessageImpl,\n    operation: DispositionType,\n    options?: DispositionStatusOptions\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      if (!options) options = {};\n      if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {\n        return reject(new Error(`operation: '${operation}' is not a valid operation.`));\n      }\n      const delivery = message.delivery;\n      const timer = setTimeout(() => {\n        this._deliveryDispositionMap.delete(delivery.id);\n        logger.verbose(\n          \"[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. \" +\n            \"Hence rejecting the promise with timeout error\",\n          this._context.connectionId,\n          delivery.id,\n          Constants.defaultOperationTimeoutInMs\n        );\n\n        const e: AmqpError = {\n          condition: ErrorNameConditionMapper.ServiceUnavailableError,\n          description:\n            \"Operation to settle the message has timed out. The disposition of the \" +\n            \"message may or may not be successful\"\n        };\n        return reject(translateServiceBusError(e));\n      }, Constants.defaultOperationTimeoutInMs);\n      this._deliveryDispositionMap.set(delivery.id, {\n        resolve: resolve,\n        reject: reject,\n        timer: timer\n      });\n      if (operation === DispositionType.complete) {\n        delivery.accept();\n      } else if (operation === DispositionType.abandon) {\n        const params: any = {\n          undeliverable_here: false\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.defer) {\n        const params: any = {\n          undeliverable_here: true\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.deadletter) {\n        const error: AmqpError = {\n          condition: Constants.deadLetterName,\n          info: {\n            ...options.propertiesToModify,\n            DeadLetterReason: options.deadLetterReason,\n            DeadLetterErrorDescription: options.deadLetterDescription\n          }\n        };\n        delivery.reject(error);\n      }\n    });\n  }\n\n  /**\n   * Creates a new instance of the MessageSession based on the provided parameters.\n   * @param context The client entity context\n   * @param options Options that can be provided while creating the MessageSession.\n   */\n  static async create(\n    context: ConnectionContext,\n    entityPath: string,\n    sessionId: string | undefined,\n    options?: MessageSessionOptions\n  ): Promise<MessageSession> {\n    throwErrorIfConnectionClosed(context);\n    const messageSession = new MessageSession(context, entityPath, sessionId, options);\n    await messageSession._init(options?.abortSignal);\n    return messageSession;\n  }\n}\n"]}