{"version":3,"file":"messageSender.js","sourceRoot":"","sources":["../../../src/core/messageSender.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { senderLogger as logger } from \"../log\";\nimport {\n  AmqpError,\n  AwaitableSender,\n  AwaitableSenderOptions,\n  EventContext,\n  OnAmqpEvent,\n  message as RheaMessageUtil,\n  messageProperties,\n  Message as RheaMessage\n} from \"rhea-promise\";\nimport {\n  Constants,\n  ErrorNameConditionMapper,\n  MessagingError,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  delay,\n  retry\n} from \"@azure/core-amqp\";\nimport {\n  ServiceBusMessage,\n  getMessagePropertyTypeMismatchError,\n  toRheaMessage\n} from \"../serviceBusMessage\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { getUniqueName, waitForTimeoutOrAbortOrResolve } from \"../util/utils\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport { ServiceBusMessageBatch, ServiceBusMessageBatchImpl } from \"../serviceBusMessageBatch\";\nimport { CreateMessageBatchOptions } from \"../models\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { defaultDataTransformer } from \"../dataTransformer\";\n\n/**\n * @internal\n * @hidden\n * Describes the MessageSender that will send messages to ServiceBus.\n * @class MessageSender\n */\nexport class MessageSender extends LinkEntity<AwaitableSender> {\n  /**\n   * @property {OnAmqpEvent} _onAmqpError The handler function to handle errors that happen on the\n   * underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onAmqpClose The handler function to handle \"sender_close\" event\n   * that happens on the underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpClose: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onSessionError The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onSessionClose The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEvent;\n  private _retryOptions: RetryOptions;\n\n  constructor(context: ConnectionContext, entityPath: string, retryOptions: RetryOptions) {\n    super(entityPath, entityPath, context, \"sender\", logger, {\n      address: entityPath,\n      audience: `${context.config.endpoint}${entityPath}`\n    });\n    this._retryOptions = retryOptions;\n    this._onAmqpError = (context: EventContext) => {\n      const senderError = context.sender && context.sender.error;\n      logger.logError(\n        senderError,\n        \"%s 'sender_error' event occurred on the sender '%s' with address '%s'. \" +\n          \"The associated error\",\n        this.logPrefix,\n        this.name,\n        this.address\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n      logger.logError(\n        sessionError,\n        \"%s 'session_error' event occurred on the session of sender '%s' with address '%s'. \" +\n          \"The associated error\",\n        this.logPrefix,\n        this.name,\n        this.address\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const senderError = context.sender && context.sender.error;\n\n      logger.logError(\n        senderError,\n        `${this.logPrefix} 'sender_close' event occurred. The associated error is`\n      );\n\n      await this.onDetached().catch((err) => {\n        logger.logError(\n          err,\n          `${this.logPrefix} error when closing sender after 'sender_close' event`\n        );\n      });\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n\n      logger.logError(\n        sessionError,\n        `${this.logPrefix} 'session_close' event occurred. The associated error is`\n      );\n\n      await this.onDetached().catch((err) => {\n        logger.logError(\n          err,\n          `${this.logPrefix} error when closing sender after 'session_close' event`\n        );\n      });\n    };\n  }\n\n  private _createSenderOptions(timeoutInMs: number, newName?: boolean): AwaitableSenderOptions {\n    if (newName) this.name = getUniqueName(this.baseName);\n    const srOptions: AwaitableSenderOptions = {\n      name: this.name,\n      target: {\n        address: this.address\n      },\n      onError: this._onAmqpError,\n      onClose: this._onAmqpClose,\n      onSessionError: this._onSessionError,\n      onSessionClose: this._onSessionClose,\n      sendTimeoutInSeconds: timeoutInMs / 1000\n    };\n    logger.verbose(`${this.logPrefix} Creating sender with options: %O`, srOptions);\n    return srOptions;\n  }\n\n  /**\n   * Tries to send the message to ServiceBus if there is enough credit to send them\n   * and the circular buffer has available space to settle the message after sending them.\n   *\n   * We have implemented a synchronous send over here in the sense that we shall be waiting\n   * for the message to be accepted or rejected and accordingly resolve or reject the promise.\n   *\n   * @param encodedMessage The encoded message to be sent to ServiceBus.\n   * @param sendBatch Boolean indicating whether the encoded message represents a batch of messages or not\n   * @return {Promise<Delivery>} Promise<Delivery>\n   */\n  private _trySend(\n    encodedMessage: Buffer,\n    sendBatch: boolean,\n    options: OperationOptionsBase | undefined\n  ): Promise<void> {\n    const abortSignal = options?.abortSignal;\n    const timeoutInMs =\n      this._retryOptions.timeoutInMs == undefined\n        ? Constants.defaultOperationTimeoutInMs\n        : this._retryOptions.timeoutInMs;\n\n    const sendEventPromise = () =>\n      new Promise<void>(async (resolve, reject) => {\n        const initStartTime = Date.now();\n        if (!this.isOpen()) {\n          try {\n            await waitForTimeoutOrAbortOrResolve({\n              actionFn: () => this.open(undefined, options?.abortSignal),\n              abortSignal: options?.abortSignal,\n              timeoutMs: timeoutInMs,\n              timeoutMessage:\n                `[${this._context.connectionId}] Sender \"${this.name}\" ` +\n                `with address \"${this.address}\", was not able to send the message right now, due ` +\n                `to operation timeout.`\n            });\n          } catch (err) {\n            err = translateServiceBusError(err);\n            logger.logError(\n              err,\n              \"%s An error occurred while creating the sender\",\n              this.logPrefix,\n              this.name\n            );\n            return reject(err);\n          }\n        }\n\n        try {\n          const timeTakenByInit = Date.now() - initStartTime;\n\n          logger.verbose(\n            \"%s Sender '%s', credit: %d available: %d\",\n            this.logPrefix,\n            this.name,\n            this.link?.credit,\n            this.link?.session?.outgoing?.available()\n          );\n\n          if (!this.link?.sendable()) {\n            logger.verbose(\n              \"%s Sender '%s', waiting for 1 second for sender to become sendable\",\n              this.logPrefix,\n              this.name\n            );\n\n            await delay(1000);\n\n            logger.verbose(\n              \"%s Sender '%s' after waiting for a second, credit: %d available: %d\",\n              this.logPrefix,\n              this.name,\n              this.link?.credit,\n              this.link?.session?.outgoing?.available()\n            );\n          }\n          if (this.link?.sendable()) {\n            if (timeoutInMs <= timeTakenByInit) {\n              const desc: string =\n                `${this.logPrefix} Sender \"${this.name}\" ` +\n                `with address \"${this.address}\", was not able to send the message right now, due ` +\n                `to operation timeout.`;\n              logger.warning(desc);\n              const e: AmqpError = {\n                condition: ErrorNameConditionMapper.ServiceUnavailableError,\n                description: desc\n              };\n              return reject(translateServiceBusError(e));\n            }\n            try {\n              this.link.sendTimeoutInSeconds = (timeoutInMs - timeTakenByInit) / 1000;\n              const delivery = await this.link!.send(\n                encodedMessage,\n                undefined,\n                sendBatch ? 0x80013700 : 0\n              );\n              logger.verbose(\n                \"%s Sender '%s', sent message with delivery id: %d\",\n                this.logPrefix,\n                this.name,\n                delivery.id\n              );\n              return resolve();\n            } catch (error) {\n              error = translateServiceBusError(error.innerError || error);\n              logger.logError(\n                error,\n                `${this.logPrefix} An error occurred while sending the message`\n              );\n              return reject(error);\n            }\n          } else {\n            // let us retry to send the message after some time.\n            const msg =\n              `[${this.logPrefix}] Sender \"${this.name}\", ` +\n              `cannot send the message right now. Please try later.`;\n            logger.warning(msg);\n            const amqpError: AmqpError = {\n              condition: ErrorNameConditionMapper.SenderBusyError,\n              description: msg\n            };\n            reject(translateServiceBusError(amqpError));\n          }\n        } catch (err) {\n          reject(err);\n        }\n      });\n\n    const config: RetryConfig<void> = {\n      operation: sendEventPromise,\n      connectionId: this._context.connectionId!,\n      operationType: RetryOperationType.sendMessage,\n      retryOptions: this._retryOptions,\n      abortSignal: abortSignal\n    };\n\n    return retry<void>(config);\n  }\n\n  protected async createRheaLink(options: AwaitableSenderOptions): Promise<AwaitableSender> {\n    const sender = await this._context.connection.createAwaitableSender(options);\n    sender.setMaxListeners(1000);\n    return sender;\n  }\n\n  /**\n   * Initializes the sender session on the connection.\n   */\n  public async open(\n    options?: AwaitableSenderOptions,\n    abortSignal?: AbortSignalLike\n  ): Promise<void> {\n    try {\n      if (!options) {\n        options = this._createSenderOptions(Constants.defaultOperationTimeoutInMs);\n      }\n      await this.initLink(options, abortSignal);\n    } catch (err) {\n      err = translateServiceBusError(err);\n      logger.logError(err, `${this.logPrefix} An error occurred while creating the sender`);\n      // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.\n      if ((err as MessagingError).code === \"OperationTimeoutError\") {\n        err.message = \"Failed to create a sender within allocated time and retry attempts.\";\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Closes the rhea link.\n   * To be called when connection is disconnected, onAmqpClose and onSessionClose events.\n   * @returns {Promise<void>} Promise<void>.\n   */\n  async onDetached(): Promise<void> {\n    // Clears the token renewal timer. Closes the link and its session if they are open.\n    // Removes the link and its session if they are present in rhea's cache.\n    await this.closeLink();\n  }\n\n  /**\n   * Determines whether the AMQP sender link is open. If open then returns true else returns false.\n   * @return {boolean} boolean\n   */\n  isOpen(): boolean {\n    const result: boolean = this.link == null ? false : this.link.isOpen();\n    logger.verbose(\n      \"%s Sender '%s' with address '%s' is open? -> %s\",\n      this.logPrefix,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Sends the given message, with the given options on this link\n   *\n   * @param {ServiceBusMessage} data Message to send.  Will be sent as UTF8-encoded JSON string.\n   * @returns {Promise<void>}\n   */\n  async send(data: ServiceBusMessage, options?: OperationOptionsBase): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const amqpMessage = toRheaMessage(data);\n      amqpMessage.body = defaultDataTransformer.encode(data.body);\n\n      // TODO: this body of logic is really similar to what's in sendMessages. Unify what we can.\n      let encodedMessage;\n      try {\n        encodedMessage = RheaMessageUtil.encode(amqpMessage);\n      } catch (error) {\n        if (error instanceof TypeError || error.name === \"TypeError\") {\n          // `RheaMessageUtil.encode` can fail if message properties are of invalid type\n          // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too\n          // Errors in such cases do not have user-friendly message or call stack\n          // So use `getMessagePropertyTypeMismatchError` to get a better error message\n          throw getMessagePropertyTypeMismatchError(data) || error;\n        }\n        throw error;\n      }\n      logger.verbose(\"%s Sender '%s', trying to send message: %O\", this.logPrefix, this.name, data);\n      return await this._trySend(encodedMessage, false, options);\n    } catch (err) {\n      logger.logError(\n        err,\n        \"%s An error occurred while sending the message: %O\\nError\",\n        this.logPrefix,\n        data\n      );\n      throw err;\n    }\n  }\n\n  // Not exposed to the users\n  /**\n   * Send a batch of Message to the ServiceBus in a single AMQP message. The \"message_annotations\",\n   * \"application_properties\" and \"properties\" of the first message will be set as that\n   * of the envelope (batch message).\n   * @param {Array<Message>} inputMessages  An array of Message objects to be sent in a\n   * Batch message.\n   * @return {Promise<void>}\n   */\n  async sendMessages(\n    inputMessages: ServiceBusMessage[],\n    options?: OperationOptionsBase\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      if (!Array.isArray(inputMessages)) {\n        inputMessages = [inputMessages];\n      }\n      logger.verbose(\n        \"%s Sender '%s', trying to send Message[]: %O\",\n        this.logPrefix,\n        this.name,\n        inputMessages\n      );\n      const amqpMessages: RheaMessage[] = [];\n      const encodedMessages = [];\n      // Convert Message to AmqpMessage.\n      for (let i = 0; i < inputMessages.length; i++) {\n        const amqpMessage = toRheaMessage(inputMessages[i]);\n        amqpMessage.body = defaultDataTransformer.encode(inputMessages[i].body);\n        amqpMessages[i] = amqpMessage;\n        try {\n          encodedMessages[i] = RheaMessageUtil.encode(amqpMessage);\n        } catch (error) {\n          if (error instanceof TypeError || error.name === \"TypeError\") {\n            throw getMessagePropertyTypeMismatchError(inputMessages[i]) || error;\n          }\n          throw error;\n        }\n      }\n\n      // Convert every encoded message to amqp data section\n      const batchMessage: RheaMessage = {\n        body: RheaMessageUtil.data_sections(encodedMessages)\n      };\n      // Set message_annotations, application_properties and properties of the first message as\n      // that of the envelope (batch message).\n      if (amqpMessages[0].message_annotations) {\n        batchMessage.message_annotations = amqpMessages[0].message_annotations;\n      }\n      if (amqpMessages[0].application_properties) {\n        batchMessage.application_properties = amqpMessages[0].application_properties;\n      }\n      for (const prop of messageProperties) {\n        if ((amqpMessages[0] as any)[prop]) {\n          (batchMessage as any)[prop] = (amqpMessages[0] as any)[prop];\n        }\n      }\n\n      // Finally encode the envelope (batch message).\n      const encodedBatchMessage = RheaMessageUtil.encode(batchMessage);\n\n      logger.verbose(\n        \"%s Sender '%s', sending encoded batch message.\",\n        this.logPrefix,\n        this.name,\n        encodedBatchMessage\n      );\n      return await this._trySend(encodedBatchMessage, true, options);\n    } catch (err) {\n      logger.logError(\n        err,\n        \"%s Sender '%s': An error occurred while sending the messages: %O\\nError\",\n        this.logPrefix,\n        this.name,\n        inputMessages\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Returns maximum message size on the AMQP sender link.\n   *\n   * Options to configure the `createBatch` method on the `Sender`.\n   * - `maxSizeInBytes`: The upper limit for the size of batch.\n   *\n   * Example usage:\n   * ```js\n   * {\n   *     retryOptions: { maxRetries: 5; timeoutInMs: 10 }\n   * }\n   * ```\n   * @param {{retryOptions?: RetryOptions}} [options={}]\n   * @returns {Promise<number>}\n   */\n  async getMaxMessageSize(\n    options: {\n      retryOptions?: RetryOptions;\n    } & Pick<OperationOptionsBase, \"abortSignal\"> = {}\n  ): Promise<number> {\n    const retryOptions = options.retryOptions || {};\n    if (this.isOpen()) {\n      return this.link!.maxMessageSize;\n    }\n    return new Promise<number>(async (resolve, reject) => {\n      try {\n        const config: RetryConfig<void> = {\n          operation: () => this.open(undefined, options?.abortSignal),\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.senderLink,\n          retryOptions: retryOptions,\n          abortSignal: options?.abortSignal\n        };\n\n        await retry<void>(config);\n\n        return resolve(this.link!.maxMessageSize);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }\n\n  async createBatch(options?: CreateMessageBatchOptions): Promise<ServiceBusMessageBatch> {\n    throwErrorIfConnectionClosed(this._context);\n    let maxMessageSize = await this.getMaxMessageSize({\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    });\n    if (options?.maxSizeInBytes) {\n      if (options.maxSizeInBytes > maxMessageSize!) {\n        const error = new Error(\n          `Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`\n        );\n        throw error;\n      }\n      maxMessageSize = options.maxSizeInBytes;\n    }\n    return new ServiceBusMessageBatchImpl(this._context, maxMessageSize!);\n  }\n\n  async sendBatch(\n    batchMessage: ServiceBusMessageBatch,\n    options?: OperationOptionsBase\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      logger.verbose(\n        \"%s Sender '%s', sending encoded batch message.\",\n        this.logPrefix,\n        this.name,\n        batchMessage\n      );\n      return await this._trySend(batchMessage._generateMessage(), true, options);\n    } catch (err) {\n      logger.logError(\n        err,\n        \"%s Sender '%s': An error occurred while sending the messages: %O\\nError\",\n        this.logPrefix,\n        this.name,\n        batchMessage\n      );\n      throw err;\n    }\n  }\n\n  static create(\n    context: ConnectionContext,\n    entityPath: string,\n    retryOptions: RetryOptions\n  ): MessageSender {\n    throwErrorIfConnectionClosed(context);\n\n    const sbSender = new MessageSender(context, entityPath, retryOptions);\n    context.senders[sbSender.name] = sbSender;\n    return sbSender;\n  }\n}\n"]}