// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import { senderLogger as logger } from "../log";
import { message as RheaMessageUtil, messageProperties } from "rhea-promise";
import { Constants, ErrorNameConditionMapper, RetryOperationType, delay, retry } from "@azure/core-amqp";
import { getMessagePropertyTypeMismatchError, toRheaMessage } from "../serviceBusMessage";
import { LinkEntity } from "./linkEntity";
import { getUniqueName, waitForTimeoutOrAbortOrResolve } from "../util/utils";
import { throwErrorIfConnectionClosed } from "../util/errors";
import { ServiceBusMessageBatchImpl } from "../serviceBusMessageBatch";
import { translateServiceBusError } from "../serviceBusError";
import { defaultDataTransformer } from "../dataTransformer";
/**
 * @internal
 * @hidden
 * Describes the MessageSender that will send messages to ServiceBus.
 * @class MessageSender
 */
export class MessageSender extends LinkEntity {
    constructor(context, entityPath, retryOptions) {
        super(entityPath, entityPath, context, "sender", logger, {
            address: entityPath,
            audience: `${context.config.endpoint}${entityPath}`
        });
        this._retryOptions = retryOptions;
        this._onAmqpError = (context) => {
            const senderError = context.sender && context.sender.error;
            logger.logError(senderError, "%s 'sender_error' event occurred on the sender '%s' with address '%s'. " +
                "The associated error", this.logPrefix, this.name, this.address);
            // TODO: Consider rejecting promise in trySendBatch() or createBatch()
        };
        this._onSessionError = (context) => {
            const sessionError = context.session && context.session.error;
            logger.logError(sessionError, "%s 'session_error' event occurred on the session of sender '%s' with address '%s'. " +
                "The associated error", this.logPrefix, this.name, this.address);
            // TODO: Consider rejecting promise in trySendBatch() or createBatch()
        };
        this._onAmqpClose = (context) => __awaiter(this, void 0, void 0, function* () {
            const senderError = context.sender && context.sender.error;
            logger.logError(senderError, `${this.logPrefix} 'sender_close' event occurred. The associated error is`);
            yield this.onDetached().catch((err) => {
                logger.logError(err, `${this.logPrefix} error when closing sender after 'sender_close' event`);
            });
        });
        this._onSessionClose = (context) => __awaiter(this, void 0, void 0, function* () {
            const sessionError = context.session && context.session.error;
            logger.logError(sessionError, `${this.logPrefix} 'session_close' event occurred. The associated error is`);
            yield this.onDetached().catch((err) => {
                logger.logError(err, `${this.logPrefix} error when closing sender after 'session_close' event`);
            });
        });
    }
    _createSenderOptions(timeoutInMs, newName) {
        if (newName)
            this.name = getUniqueName(this.baseName);
        const srOptions = {
            name: this.name,
            target: {
                address: this.address
            },
            onError: this._onAmqpError,
            onClose: this._onAmqpClose,
            onSessionError: this._onSessionError,
            onSessionClose: this._onSessionClose,
            sendTimeoutInSeconds: timeoutInMs / 1000
        };
        logger.verbose(`${this.logPrefix} Creating sender with options: %O`, srOptions);
        return srOptions;
    }
    /**
     * Tries to send the message to ServiceBus if there is enough credit to send them
     * and the circular buffer has available space to settle the message after sending them.
     *
     * We have implemented a synchronous send over here in the sense that we shall be waiting
     * for the message to be accepted or rejected and accordingly resolve or reject the promise.
     *
     * @param encodedMessage The encoded message to be sent to ServiceBus.
     * @param sendBatch Boolean indicating whether the encoded message represents a batch of messages or not
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    _trySend(encodedMessage, sendBatch, options) {
        const abortSignal = options === null || options === void 0 ? void 0 : options.abortSignal;
        const timeoutInMs = this._retryOptions.timeoutInMs == undefined
            ? Constants.defaultOperationTimeoutInMs
            : this._retryOptions.timeoutInMs;
        const sendEventPromise = () => new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const initStartTime = Date.now();
            if (!this.isOpen()) {
                try {
                    yield waitForTimeoutOrAbortOrResolve({
                        actionFn: () => this.open(undefined, options === null || options === void 0 ? void 0 : options.abortSignal),
                        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
                        timeoutMs: timeoutInMs,
                        timeoutMessage: `[${this._context.connectionId}] Sender "${this.name}" ` +
                            `with address "${this.address}", was not able to send the message right now, due ` +
                            `to operation timeout.`
                    });
                }
                catch (err) {
                    err = translateServiceBusError(err);
                    logger.logError(err, "%s An error occurred while creating the sender", this.logPrefix, this.name);
                    return reject(err);
                }
            }
            try {
                const timeTakenByInit = Date.now() - initStartTime;
                logger.verbose("%s Sender '%s', credit: %d available: %d", this.logPrefix, this.name, (_a = this.link) === null || _a === void 0 ? void 0 : _a.credit, (_d = (_c = (_b = this.link) === null || _b === void 0 ? void 0 : _b.session) === null || _c === void 0 ? void 0 : _c.outgoing) === null || _d === void 0 ? void 0 : _d.available());
                if (!((_e = this.link) === null || _e === void 0 ? void 0 : _e.sendable())) {
                    logger.verbose("%s Sender '%s', waiting for 1 second for sender to become sendable", this.logPrefix, this.name);
                    yield delay(1000);
                    logger.verbose("%s Sender '%s' after waiting for a second, credit: %d available: %d", this.logPrefix, this.name, (_f = this.link) === null || _f === void 0 ? void 0 : _f.credit, (_j = (_h = (_g = this.link) === null || _g === void 0 ? void 0 : _g.session) === null || _h === void 0 ? void 0 : _h.outgoing) === null || _j === void 0 ? void 0 : _j.available());
                }
                if ((_k = this.link) === null || _k === void 0 ? void 0 : _k.sendable()) {
                    if (timeoutInMs <= timeTakenByInit) {
                        const desc = `${this.logPrefix} Sender "${this.name}" ` +
                            `with address "${this.address}", was not able to send the message right now, due ` +
                            `to operation timeout.`;
                        logger.warning(desc);
                        const e = {
                            condition: ErrorNameConditionMapper.ServiceUnavailableError,
                            description: desc
                        };
                        return reject(translateServiceBusError(e));
                    }
                    try {
                        this.link.sendTimeoutInSeconds = (timeoutInMs - timeTakenByInit) / 1000;
                        const delivery = yield this.link.send(encodedMessage, undefined, sendBatch ? 0x80013700 : 0);
                        logger.verbose("%s Sender '%s', sent message with delivery id: %d", this.logPrefix, this.name, delivery.id);
                        return resolve();
                    }
                    catch (error) {
                        error = translateServiceBusError(error.innerError || error);
                        logger.logError(error, `${this.logPrefix} An error occurred while sending the message`);
                        return reject(error);
                    }
                }
                else {
                    // let us retry to send the message after some time.
                    const msg = `[${this.logPrefix}] Sender "${this.name}", ` +
                        `cannot send the message right now. Please try later.`;
                    logger.warning(msg);
                    const amqpError = {
                        condition: ErrorNameConditionMapper.SenderBusyError,
                        description: msg
                    };
                    reject(translateServiceBusError(amqpError));
                }
            }
            catch (err) {
                reject(err);
            }
        }));
        const config = {
            operation: sendEventPromise,
            connectionId: this._context.connectionId,
            operationType: RetryOperationType.sendMessage,
            retryOptions: this._retryOptions,
            abortSignal: abortSignal
        };
        return retry(config);
    }
    createRheaLink(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const sender = yield this._context.connection.createAwaitableSender(options);
            sender.setMaxListeners(1000);
            return sender;
        });
    }
    /**
     * Initializes the sender session on the connection.
     */
    open(options, abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!options) {
                    options = this._createSenderOptions(Constants.defaultOperationTimeoutInMs);
                }
                yield this.initLink(options, abortSignal);
            }
            catch (err) {
                err = translateServiceBusError(err);
                logger.logError(err, `${this.logPrefix} An error occurred while creating the sender`);
                // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.
                if (err.code === "OperationTimeoutError") {
                    err.message = "Failed to create a sender within allocated time and retry attempts.";
                }
                throw err;
            }
        });
    }
    /**
     * Closes the rhea link.
     * To be called when connection is disconnected, onAmqpClose and onSessionClose events.
     * @returns {Promise<void>} Promise<void>.
     */
    onDetached() {
        return __awaiter(this, void 0, void 0, function* () {
            // Clears the token renewal timer. Closes the link and its session if they are open.
            // Removes the link and its session if they are present in rhea's cache.
            yield this.closeLink();
        });
    }
    /**
     * Determines whether the AMQP sender link is open. If open then returns true else returns false.
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this.link == null ? false : this.link.isOpen();
        logger.verbose("%s Sender '%s' with address '%s' is open? -> %s", this.logPrefix, this.name, this.address, result);
        return result;
    }
    /**
     * Sends the given message, with the given options on this link
     *
     * @param {ServiceBusMessage} data Message to send.  Will be sent as UTF8-encoded JSON string.
     * @returns {Promise<void>}
     */
    send(data, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const amqpMessage = toRheaMessage(data);
                amqpMessage.body = defaultDataTransformer.encode(data.body);
                // TODO: this body of logic is really similar to what's in sendMessages. Unify what we can.
                let encodedMessage;
                try {
                    encodedMessage = RheaMessageUtil.encode(amqpMessage);
                }
                catch (error) {
                    if (error instanceof TypeError || error.name === "TypeError") {
                        // `RheaMessageUtil.encode` can fail if message properties are of invalid type
                        // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too
                        // Errors in such cases do not have user-friendly message or call stack
                        // So use `getMessagePropertyTypeMismatchError` to get a better error message
                        throw getMessagePropertyTypeMismatchError(data) || error;
                    }
                    throw error;
                }
                logger.verbose("%s Sender '%s', trying to send message: %O", this.logPrefix, this.name, data);
                return yield this._trySend(encodedMessage, false, options);
            }
            catch (err) {
                logger.logError(err, "%s An error occurred while sending the message: %O\nError", this.logPrefix, data);
                throw err;
            }
        });
    }
    // Not exposed to the users
    /**
     * Send a batch of Message to the ServiceBus in a single AMQP message. The "message_annotations",
     * "application_properties" and "properties" of the first message will be set as that
     * of the envelope (batch message).
     * @param {Array<Message>} inputMessages  An array of Message objects to be sent in a
     * Batch message.
     * @return {Promise<void>}
     */
    sendMessages(inputMessages, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                if (!Array.isArray(inputMessages)) {
                    inputMessages = [inputMessages];
                }
                logger.verbose("%s Sender '%s', trying to send Message[]: %O", this.logPrefix, this.name, inputMessages);
                const amqpMessages = [];
                const encodedMessages = [];
                // Convert Message to AmqpMessage.
                for (let i = 0; i < inputMessages.length; i++) {
                    const amqpMessage = toRheaMessage(inputMessages[i]);
                    amqpMessage.body = defaultDataTransformer.encode(inputMessages[i].body);
                    amqpMessages[i] = amqpMessage;
                    try {
                        encodedMessages[i] = RheaMessageUtil.encode(amqpMessage);
                    }
                    catch (error) {
                        if (error instanceof TypeError || error.name === "TypeError") {
                            throw getMessagePropertyTypeMismatchError(inputMessages[i]) || error;
                        }
                        throw error;
                    }
                }
                // Convert every encoded message to amqp data section
                const batchMessage = {
                    body: RheaMessageUtil.data_sections(encodedMessages)
                };
                // Set message_annotations, application_properties and properties of the first message as
                // that of the envelope (batch message).
                if (amqpMessages[0].message_annotations) {
                    batchMessage.message_annotations = amqpMessages[0].message_annotations;
                }
                if (amqpMessages[0].application_properties) {
                    batchMessage.application_properties = amqpMessages[0].application_properties;
                }
                for (const prop of messageProperties) {
                    if (amqpMessages[0][prop]) {
                        batchMessage[prop] = amqpMessages[0][prop];
                    }
                }
                // Finally encode the envelope (batch message).
                const encodedBatchMessage = RheaMessageUtil.encode(batchMessage);
                logger.verbose("%s Sender '%s', sending encoded batch message.", this.logPrefix, this.name, encodedBatchMessage);
                return yield this._trySend(encodedBatchMessage, true, options);
            }
            catch (err) {
                logger.logError(err, "%s Sender '%s': An error occurred while sending the messages: %O\nError", this.logPrefix, this.name, inputMessages);
                throw err;
            }
        });
    }
    /**
     * Returns maximum message size on the AMQP sender link.
     *
     * Options to configure the `createBatch` method on the `Sender`.
     * - `maxSizeInBytes`: The upper limit for the size of batch.
     *
     * Example usage:
     * ```js
     * {
     *     retryOptions: { maxRetries: 5; timeoutInMs: 10 }
     * }
     * ```
     * @param {{retryOptions?: RetryOptions}} [options={}]
     * @returns {Promise<number>}
     */
    getMaxMessageSize(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const retryOptions = options.retryOptions || {};
            if (this.isOpen()) {
                return this.link.maxMessageSize;
            }
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const config = {
                        operation: () => this.open(undefined, options === null || options === void 0 ? void 0 : options.abortSignal),
                        connectionId: this._context.connectionId,
                        operationType: RetryOperationType.senderLink,
                        retryOptions: retryOptions,
                        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
                    };
                    yield retry(config);
                    return resolve(this.link.maxMessageSize);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    createBatch(options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            let maxMessageSize = yield this.getMaxMessageSize({
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            });
            if (options === null || options === void 0 ? void 0 : options.maxSizeInBytes) {
                if (options.maxSizeInBytes > maxMessageSize) {
                    const error = new Error(`Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`);
                    throw error;
                }
                maxMessageSize = options.maxSizeInBytes;
            }
            return new ServiceBusMessageBatchImpl(this._context, maxMessageSize);
        });
    }
    sendBatch(batchMessage, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                logger.verbose("%s Sender '%s', sending encoded batch message.", this.logPrefix, this.name, batchMessage);
                return yield this._trySend(batchMessage._generateMessage(), true, options);
            }
            catch (err) {
                logger.logError(err, "%s Sender '%s': An error occurred while sending the messages: %O\nError", this.logPrefix, this.name, batchMessage);
                throw err;
            }
        });
    }
    static create(context, entityPath, retryOptions) {
        throwErrorIfConnectionClosed(context);
        const sbSender = new MessageSender(context, entityPath, retryOptions);
        context.senders[sbSender.name] = sbSender;
        return sbSender;
    }
}
//# sourceMappingURL=messageSender.js.map