// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import Long from "long";
import { message as RheaMessageUtil, generate_uuid, string_to_uuid, types, ReceiverEvents } from "rhea-promise";
import { ConditionErrorNameMapper, Constants, RequestResponseLink } from "@azure/core-amqp";
import { DispositionType, ServiceBusMessageImpl, getMessagePropertyTypeMismatchError, toRheaMessage, fromRheaMessage } from "../serviceBusMessage";
import { LinkEntity } from "./linkEntity";
import { managementClientLogger, receiverLogger, senderLogger } from "../log";
import { toBuffer } from "../util/utils";
import { InvalidMaxMessageCountError, throwErrorIfConnectionClosed, throwTypeErrorIfParameterIsEmptyString, throwTypeErrorIfParameterMissing, throwTypeErrorIfParameterNotLong, throwTypeErrorIfParameterTypeMismatch } from "../util/errors";
import { max32BitNumber } from "../util/constants";
import { Buffer } from "buffer";
import { translateServiceBusError } from "../serviceBusError";
import { defaultDataTransformer } from "../dataTransformer";
/**
 * @internal
 * @hidden
 */
const correlationProperties = [
    "correlationId",
    "messageId",
    "to",
    "replyTo",
    "subject",
    "sessionId",
    "replyToSessionId",
    "contentType",
    "applicationProperties"
];
/**
 * @internal
 * @hidden
 * @class ManagementClient
 * Describes the ServiceBus Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
export class ManagementClient extends LinkEntity {
    /**
     * @constructor
     * Instantiates the management client.
     * @param context The connection context
     * @param entityPath - The name/path of the entity (queue/topic/subscription name)
     * for which the management request needs to be made.
     * @param {ManagementClientOptions} [options] Options to be provided for creating the
     * "$management" client.
     */
    constructor(context, entityPath, options) {
        super(`${entityPath}/$management`, entityPath, context, "mgmt", managementClientLogger, {
            address: options && options.address ? options.address : Constants.management,
            audience: options && options.audience
                ? options.audience
                : `${context.config.endpoint}${entityPath}/$management`
        });
        /**
         * @property {string} replyTo The reply to Guid for the management client.
         */
        this.replyTo = generate_uuid();
        /**
         * @property _lastPeekedSequenceNumber Provides the sequence number of the last peeked message.
         */
        this._lastPeekedSequenceNumber = Long.ZERO;
        this._context = context;
    }
    _init(abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const rxopt = {
                    source: { address: this.address },
                    name: this.replyTo,
                    target: { address: this.replyTo },
                    onSessionError: (context) => {
                        const sbError = translateServiceBusError(context.session.error);
                        managementClientLogger.logError(sbError, `${this.logPrefix} An error occurred on the session for request/response links for $management`);
                    }
                };
                const sropt = {
                    target: { address: this.address },
                    onError: (context) => {
                        const ehError = translateServiceBusError(context.sender.error);
                        managementClientLogger.logError(ehError, `${this.logPrefix} An error occurred on the $management sender link`);
                    }
                };
                // Even if multiple parallel requests reach here, the initLink secures a lock
                // to ensure there won't be multiple initializations
                yield this.initLink({
                    senderOptions: sropt,
                    receiverOptions: rxopt
                }, abortSignal);
            }
            catch (err) {
                err = translateServiceBusError(err);
                managementClientLogger.logError(err, `${this.logPrefix} An error occurred while establishing the $management links`);
                throw err;
            }
        });
    }
    createRheaLink(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const rheaLink = yield RequestResponseLink.create(this._context.connection, options.senderOptions, options.receiverOptions);
            // Attach listener for the `receiver_error` events to log the errors.
            // "message" event listener is added in core-amqp.
            // "rhea" doesn't allow setting only the "onError" handler in the options if it is not accompanied by an "onMessage" handler.
            // Hence, not passing onError handler in the receiver options, adding a handler below.
            rheaLink.receiver.on(ReceiverEvents.receiverError, (context) => {
                const ehError = translateServiceBusError(context.receiver.error);
                managementClientLogger.logError(ehError, `${this.logPrefix} An error occurred on the $management receiver link`);
            });
            return rheaLink;
        });
    }
    /**
     * Given array of typed values, returns the element in given index
     */
    _safelyGetTypedValueFromArray(data, index) {
        return Array.isArray(data) && data.length > index && data[index]
            ? data[index].value
            : undefined;
    }
    _makeManagementRequest(request, internalLogger, sendRequestOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (request.message_id == undefined) {
                request.message_id = generate_uuid();
            }
            const retryTimeoutInMs = (_a = sendRequestOptions.timeoutInMs) !== null && _a !== void 0 ? _a : Constants.defaultOperationTimeoutInMs;
            const initOperationStartTime = Date.now();
            const actionAfterTimeout = (reject) => {
                const desc = `The request with message_id "${request.message_id}" timed out. Please try again later.`;
                const e = {
                    name: "OperationTimeoutError",
                    message: desc
                };
                reject(e);
            };
            let waitTimer;
            const operationTimeout = new Promise((_, reject) => {
                waitTimer = setTimeout(() => actionAfterTimeout(reject), retryTimeoutInMs);
            });
            internalLogger.verbose(`${this.logPrefix} Acquiring lock to get the management req res link.`);
            try {
                if (!this.isOpen()) {
                    yield Promise.race([this._init(sendRequestOptions === null || sendRequestOptions === void 0 ? void 0 : sendRequestOptions.abortSignal), operationTimeout]);
                }
            }
            finally {
                clearTimeout(waitTimer);
            }
            // time taken by the init operation
            const timeTakenByInit = Date.now() - initOperationStartTime;
            // Left over time
            sendRequestOptions.timeoutInMs = retryTimeoutInMs - timeTakenByInit;
            try {
                if (!request.message_id)
                    request.message_id = generate_uuid();
                return yield this.link.sendRequest(request, sendRequestOptions);
            }
            catch (err) {
                err = translateServiceBusError(err);
                internalLogger.logError(err, "%s An error occurred during send on management request-response link with address " +
                    "'%s': %O", this.logPrefix, this.address, err);
                throw err;
            }
        });
    }
    /**
     * Closes the AMQP management session to the ServiceBus namespace for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @return Promise<void>
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Always clear the timeout, as the isOpen check may report
                // false without ever having cleared the timeout otherwise.
                // NOTE: management link currently doesn't have a separate concept of "detaching" like
                // the other links do. When we add handling of this (via the onDetached call, like other links)
                // we can change this back to closeLink("permanent").
                yield this.closeLink();
                managementClientLogger.verbose("Successfully closed the management session.");
            }
            catch (err) {
                managementClientLogger.logError(err, `${this.logPrefix} An error occurred while closing the management session`);
                throw err;
            }
        });
    }
    /**
     * Fetches the next batch of active messages. The first call to `peek()` fetches the first
     * active message for this client. Each subsequent call fetches the subsequent message in the
     * entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. This method will
     * also fetch even Deferred messages (but not Deadlettered message).
     *
     * @param messageCount The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     */
    peek(messageCount, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, undefined, options);
        });
    }
    /**
     * Fetches the next batch of active messages in the current MessageSession. The first call to
     * `peek()` fetches the first active message for this client. Each subsequent call fetches the
     * subsequent message in the entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`.  This method will
     * also fetch even Deferred messages (but not Deadlettered message).
     *
     * @param sessionId The sessionId from which messages need to be peeked.
     * @param messageCount The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedMessageInfo[]>
     */
    peekMessagesBySession(sessionId, messageCount, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, sessionId, options);
        });
    }
    /**
     * Peeks the desired number of messages from the specified sequence number.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param messageCount The number of messages to retrieve. Default value `1`.
     * @param sessionId The sessionId from which messages need to be peeked.
     * @returns Promise<ReceivedMessageInfo[]>
     */
    peekBySequenceNumber(fromSequenceNumber, maxMessageCount, sessionId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            const connId = this._context.connectionId;
            // Checks for fromSequenceNumber
            throwTypeErrorIfParameterMissing(connId, "fromSequenceNumber", fromSequenceNumber);
            throwTypeErrorIfParameterNotLong(connId, "fromSequenceNumber", fromSequenceNumber);
            // Checks for maxMessageCount
            throwTypeErrorIfParameterMissing(this._context.connectionId, "maxMessageCount", maxMessageCount);
            throwTypeErrorIfParameterTypeMismatch(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");
            if (isNaN(maxMessageCount) || maxMessageCount < 1) {
                throw new TypeError(InvalidMaxMessageCountError);
            }
            const messageList = [];
            try {
                const messageBody = {};
                messageBody[Constants.fromSequenceNumber] = types.wrap_long(Buffer.from(fromSequenceNumber.toBytesBE()));
                messageBody[Constants.messageCount] = types.wrap_int(maxMessageCount);
                if (sessionId != undefined) {
                    messageBody[Constants.sessionIdMapKey] = sessionId;
                }
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.peekMessage
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[Constants.trackingId] = generate_uuid();
                // TODO: it'd be nice to attribute this peek request to the actual receiver that made it. So have them pass in a
                // log prefix rather than just falling back to the management links.
                receiverLogger.verbose("%s Peek by sequence number request body: %O.", this.logPrefix, request.body);
                const result = yield this._makeManagementRequest(request, receiverLogger, options);
                if (result.application_properties.statusCode !== 204) {
                    const messages = result.body.messages;
                    for (const msg of messages) {
                        const decodedMessage = RheaMessageUtil.decode(msg.message);
                        const message = fromRheaMessage(decodedMessage);
                        message.body = defaultDataTransformer.decode(message.body);
                        messageList.push(message);
                        this._lastPeekedSequenceNumber = message.sequenceNumber;
                    }
                }
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to peek messages to $management endpoint`);
                // statusCode == 404 then do not throw
                if (error.code !== ConditionErrorNameMapper["com.microsoft:message-not-found"]) {
                    throw error;
                }
            }
            return messageList;
        });
    }
    /**
     * Renews the lock on the message. The lock will be renewed based on the setting specified on
     * the queue.
     *
     * When a message is received in `PeekLock` mode, the message is locked on the server for this
     * receiver instance for a duration as specified during the Queue/Subscription creation
     * (LockDuration). If processing of the message requires longer than this duration, the
     * lock needs to be renewed. For each renewal, it resets the time the message is locked by the
     * LockDuration set on the Entity.
     *
     * @param lockToken Lock token of the message
     * @param options Options that can be set while sending the request.
     * @returns Promise<Date> New lock token expiry date and time in UTC format.
     */
    renewLock(lockToken, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (!options)
                options = {};
            if (options.timeoutInMs == null)
                options.timeoutInMs = 5000;
            try {
                const messageBody = {};
                messageBody[Constants.lockTokens] = types.wrap_array([string_to_uuid(lockToken)], 0x98, undefined);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.renewLock
                    }
                };
                request.application_properties[Constants.trackingId] = generate_uuid();
                if (options.associatedLinkName) {
                    request.application_properties[Constants.associatedLinkName] = options.associatedLinkName;
                }
                receiverLogger.verbose("[%s] Renew message Lock request: %O.", this._context.connectionId, request);
                const result = yield this._makeManagementRequest(request, receiverLogger, {
                    abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
                    requestName: "renewLock"
                });
                const lockedUntilUtc = new Date(result.body.expirations[0]);
                return lockedUntilUtc;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Schedules an array of messages to appear on Service Bus at a later time.
     *
     * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
     * @param messages - An array of messages that needs to be scheduled.
     * @returns Promise<number> The sequence numbers of messages that were scheduled.
     */
    scheduleMessages(scheduledEnqueueTimeUtc, messages, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (!messages.length) {
                return [];
            }
            const messageBody = [];
            for (let i = 0; i < messages.length; i++) {
                const item = messages[i];
                if (!item.messageId)
                    item.messageId = generate_uuid();
                item.scheduledEnqueueTimeUtc = scheduledEnqueueTimeUtc;
                const amqpMessage = toRheaMessage(item);
                amqpMessage.body = defaultDataTransformer.encode(amqpMessage.body);
                try {
                    const entry = {
                        message: RheaMessageUtil.encode(amqpMessage),
                        "message-id": item.messageId
                    };
                    if (item.sessionId) {
                        entry[Constants.sessionIdMapKey] = item.sessionId;
                    }
                    if (item.partitionKey) {
                        entry["partition-key"] = item.partitionKey;
                    }
                    // Will be required later for implementing Transactions
                    // if (item.viaPartitionKey) {
                    //   entry["via-partition-key"] = item.viaPartitionKey;
                    // }
                    const wrappedEntry = types.wrap_map(entry);
                    messageBody.push(wrappedEntry);
                }
                catch (err) {
                    let error;
                    if (err instanceof TypeError || err.name === "TypeError") {
                        // `RheaMessageUtil.encode` can fail if message properties are of invalid type
                        // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too
                        // Errors in such cases do not have user-friendly message or call stack
                        // So use `getMessagePropertyTypeMismatchError` to get a better error message
                        error = translateServiceBusError(getMessagePropertyTypeMismatchError(item) || err);
                    }
                    else {
                        error = translateServiceBusError(err);
                    }
                    senderLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the messages array`);
                    throw error;
                }
            }
            try {
                const request = {
                    body: { messages: messageBody },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.scheduleMessage
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[Constants.trackingId] = generate_uuid();
                senderLogger.verbose("%s Schedule messages request body: %O.", this.logPrefix, request.body);
                const result = yield this._makeManagementRequest(request, senderLogger, options);
                const sequenceNumbers = result.body[Constants.sequenceNumbers];
                const sequenceNumbersAsLong = [];
                for (let i = 0; i < sequenceNumbers.length; i++) {
                    if (typeof sequenceNumbers[i] === "number") {
                        sequenceNumbersAsLong.push(Long.fromNumber(sequenceNumbers[i]));
                    }
                    else {
                        sequenceNumbersAsLong.push(Long.fromBytesBE(sequenceNumbers[i]));
                    }
                }
                return sequenceNumbersAsLong;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                senderLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to schedule messages to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Cancels an array of messages that were scheduled.
     * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.
     * @returns Promise<void>
     */
    cancelScheduledMessages(sequenceNumbers, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (!sequenceNumbers.length) {
                return;
            }
            const messageBody = {};
            messageBody[Constants.sequenceNumbers] = [];
            for (let i = 0; i < sequenceNumbers.length; i++) {
                const sequenceNumber = sequenceNumbers[i];
                try {
                    messageBody[Constants.sequenceNumbers].push(Buffer.from(sequenceNumber.toBytesBE()));
                }
                catch (err) {
                    const error = translateServiceBusError(err);
                    senderLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`);
                    throw error;
                }
            }
            try {
                messageBody[Constants.sequenceNumbers] = types.wrap_array(messageBody[Constants.sequenceNumbers], 0x81, undefined);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.cancelScheduledMessage
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[Constants.trackingId] = generate_uuid();
                senderLogger.verbose("%s Cancel scheduled messages request body: %O.", this.logPrefix, request.body);
                yield this._makeManagementRequest(request, senderLogger, options);
                return;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                senderLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to cancel the scheduled message to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Receives a list of deferred messages identified by `sequenceNumbers`.
     *
     * @param sequenceNumbers A list containing the sequence numbers to receive.
     * @param receiveMode The mode in which the receiver was created.
     * @returns Promise<ServiceBusMessage[]>
     * - Returns a list of messages identified by the given sequenceNumbers.
     * - Returns an empty list if no messages are found.
     * - Throws an error if the messages have not been deferred.
     */
    receiveDeferredMessages(sequenceNumbers, receiveMode, sessionId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (!sequenceNumbers.length) {
                return [];
            }
            const messageList = [];
            const messageBody = {};
            messageBody[Constants.sequenceNumbers] = [];
            for (let i = 0; i < sequenceNumbers.length; i++) {
                const sequenceNumber = sequenceNumbers[i];
                try {
                    messageBody[Constants.sequenceNumbers].push(Buffer.from(sequenceNumber.toBytesBE()));
                }
                catch (err) {
                    const error = translateServiceBusError(err);
                    receiverLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`);
                    throw error;
                }
            }
            try {
                messageBody[Constants.sequenceNumbers] = types.wrap_array(messageBody[Constants.sequenceNumbers], 0x81, undefined);
                const receiverSettleMode = receiveMode === "receiveAndDelete" ? 0 : 1;
                messageBody[Constants.receiverSettleMode] = types.wrap_uint(receiverSettleMode);
                if (sessionId != null) {
                    messageBody[Constants.sessionIdMapKey] = sessionId;
                }
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.receiveBySequenceNumber
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[Constants.trackingId] = generate_uuid();
                receiverLogger.verbose("%s Receive deferred messages request body: %O.", this.logPrefix, request.body);
                const result = yield this._makeManagementRequest(request, receiverLogger, options);
                const messages = result.body.messages;
                for (const msg of messages) {
                    const decodedMessage = RheaMessageUtil.decode(msg.message);
                    const message = new ServiceBusMessageImpl(decodedMessage, { tag: msg["lock-token"] }, false, receiveMode);
                    messageList.push(message);
                }
                return messageList;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to receive deferred messages to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Updates the disposition status of deferred messages.
     *
     * @param lockTokens Message lock tokens to update disposition status.
     * @param dispositionStatus The disposition status to be set
     * @param options Optional parameters that can be provided while updating the disposition status.
     *
     * @returns Promise<void>
     */
    updateDispositionStatus(lockToken, dispositionType, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (!options)
                options = {};
            try {
                let dispositionStatus;
                if (dispositionType === DispositionType.abandon)
                    dispositionStatus = "abandoned";
                else if (dispositionType === DispositionType.complete)
                    dispositionStatus = "completed";
                else if (dispositionType === DispositionType.defer)
                    dispositionStatus = "defered";
                else if (dispositionType === DispositionType.deadletter)
                    dispositionStatus = "suspended";
                else
                    throw new Error(`Provided "dispositionType" - ${dispositionType} is invalid`);
                const messageBody = {};
                const lockTokenBuffer = [];
                lockTokenBuffer.push(string_to_uuid(lockToken));
                messageBody[Constants.lockTokens] = types.wrap_array(lockTokenBuffer, 0x98, undefined);
                messageBody[Constants.dispositionStatus] = dispositionStatus;
                if (options.deadLetterDescription != null) {
                    messageBody[Constants.deadLetterDescription] = options.deadLetterDescription;
                }
                if (options.deadLetterReason != null) {
                    messageBody[Constants.deadLetterReason] = options.deadLetterReason;
                }
                if (options.propertiesToModify != null) {
                    messageBody[Constants.propertiesToModify] = options.propertiesToModify;
                }
                if (options.sessionId != null) {
                    messageBody[Constants.sessionIdMapKey] = options.sessionId;
                }
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.updateDisposition
                    }
                };
                if (options.associatedLinkName) {
                    request.application_properties[Constants.associatedLinkName] = options.associatedLinkName;
                }
                request.application_properties[Constants.trackingId] = generate_uuid();
                receiverLogger.verbose("%s Update disposition status request body: %O.", this.logPrefix, request.body);
                yield this._makeManagementRequest(request, receiverLogger, options);
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to update disposition status to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Renews the lock for the specified session.
     *
     * @param sessionId Id of the session for which the lock needs to be renewed
     * @param options Options that can be set while sending the request.
     * @returns Promise<Date> New lock token expiry date and time in UTC format.
     */
    renewSessionLock(sessionId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const messageBody = {};
                messageBody[Constants.sessionIdMapKey] = sessionId;
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.renewSessionLock
                    }
                };
                request.application_properties[Constants.trackingId] = generate_uuid();
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                receiverLogger.verbose("%s Renew Session Lock request body: %O.", this.logPrefix, request.body);
                const result = yield this._makeManagementRequest(request, receiverLogger, options);
                const lockedUntilUtc = new Date(result.body.expiration);
                receiverLogger.verbose("%s Lock for session '%s' will expire at %s.", this.logPrefix, sessionId, lockedUntilUtc.toString());
                return lockedUntilUtc;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Sets the state of the specified session.
     *
     * @param sessionId The session for which the state needs to be set
     * @param state The state that needs to be set.
     * @returns Promise<void>
     */
    setSessionState(sessionId, state, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const messageBody = {};
                messageBody[Constants.sessionIdMapKey] = sessionId;
                messageBody["session-state"] = toBuffer(state);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.setSessionState
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[Constants.trackingId] = generate_uuid();
                receiverLogger.verbose("%s Set Session state request body: %O.", this.logPrefix, request.body);
                yield this._makeManagementRequest(request, receiverLogger, options);
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Gets the state of the specified session.
     *
     * @param sessionId The session for which the state needs to be retrieved.
     * @returns Promise<any> The state of that session
     */
    getSessionState(sessionId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const messageBody = {};
                messageBody[Constants.sessionIdMapKey] = sessionId;
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.getSessionState
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[Constants.trackingId] = generate_uuid();
                receiverLogger.verbose("%s Get session state request body: %O.", this.logPrefix, request.body);
                const result = yield this._makeManagementRequest(request, receiverLogger, options);
                return result.body["session-state"]
                    ? defaultDataTransformer.decode(result.body["session-state"])
                    : result.body["session-state"];
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Lists the sessions on the ServiceBus Queue/Topic.
     * @param lastUpdateTime Filter to include only sessions updated after a given time.
     * @param skip The number of sessions to skip
     * @param top Maximum numer of sessions.
     * @returns Promise<string[]> A list of session ids.
     */
    listMessageSessions(skip, top, lastUpdatedTime, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            const defaultLastUpdatedTimeForListingSessions = 259200000; // 3 * 24 * 3600 * 1000
            if (typeof skip !== "number") {
                throw new Error("'skip' is a required parameter and must be of type 'number'.");
            }
            if (typeof top !== "number") {
                throw new Error("'top' is a required parameter and must be of type 'number'.");
            }
            if (lastUpdatedTime && !(lastUpdatedTime instanceof Date)) {
                throw new Error("'lastUpdatedTime' must be of type 'Date'.");
            }
            if (!lastUpdatedTime) {
                lastUpdatedTime = new Date(Date.now() - defaultLastUpdatedTimeForListingSessions);
            }
            try {
                const messageBody = {};
                messageBody["last-updated-time"] = lastUpdatedTime;
                messageBody["skip"] = types.wrap_int(skip);
                messageBody["top"] = types.wrap_int(top);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.enumerateSessions
                    }
                };
                request.application_properties[Constants.trackingId] = generate_uuid();
                managementClientLogger.verbose("%s List sessions request body: %O.", this.logPrefix, request.body);
                const response = yield this._makeManagementRequest(request, managementClientLogger, options);
                return (response && response.body && response.body["sessions-ids"]) || [];
            }
            catch (err) {
                const error = translateServiceBusError(err);
                managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Get all the rules on the Subscription.
     * @returns Promise<RuleDescription[]> A list of rules.
     */
    getRules(options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const request = {
                    body: {
                        top: types.wrap_int(max32BitNumber),
                        skip: types.wrap_int(0)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.enumerateRules
                    }
                };
                request.application_properties[Constants.trackingId] = generate_uuid();
                managementClientLogger.verbose("%s Get rules request body: %O.", this.logPrefix, request.body);
                const response = yield this._makeManagementRequest(request, managementClientLogger, options);
                if (response.application_properties.statusCode === 204 ||
                    !response.body ||
                    !Array.isArray(response.body.rules)) {
                    return [];
                }
                // Reference: https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-request-response#response-11
                const result = response.body.rules || [];
                const rules = [];
                result.forEach((x) => {
                    const ruleDescriptor = x["rule-description"];
                    // We use the first three elements of the `ruleDescriptor.value` to get filter, action, name
                    if (!ruleDescriptor ||
                        !ruleDescriptor.descriptor ||
                        ruleDescriptor.descriptor.value !== Constants.descriptorCodes.ruleDescriptionList ||
                        !Array.isArray(ruleDescriptor.value) ||
                        ruleDescriptor.value.length < 3) {
                        return;
                    }
                    const filtersRawData = ruleDescriptor.value[0];
                    const actionsRawData = ruleDescriptor.value[1];
                    const rule = {
                        name: ruleDescriptor.value[2].value
                    };
                    switch (filtersRawData.descriptor.value) {
                        case Constants.descriptorCodes.trueFilterList:
                            rule.filter = "1=1";
                            break;
                        case Constants.descriptorCodes.falseFilterList:
                            rule.filter = "1=0";
                            break;
                        case Constants.descriptorCodes.sqlFilterList:
                            rule.filter = this._safelyGetTypedValueFromArray(filtersRawData.value, 0);
                            break;
                        case Constants.descriptorCodes.correlationFilterList:
                            rule.filter = {
                                correlationId: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),
                                messageId: this._safelyGetTypedValueFromArray(filtersRawData.value, 1),
                                to: this._safelyGetTypedValueFromArray(filtersRawData.value, 2),
                                replyTo: this._safelyGetTypedValueFromArray(filtersRawData.value, 3),
                                subject: this._safelyGetTypedValueFromArray(filtersRawData.value, 4),
                                sessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 5),
                                replyToSessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 6),
                                contentType: this._safelyGetTypedValueFromArray(filtersRawData.value, 7),
                                applicationProperties: this._safelyGetTypedValueFromArray(filtersRawData.value, 8)
                            };
                            break;
                        default:
                            managementClientLogger.warning(`${this.logPrefix} Found unexpected descriptor code for the filter: ${filtersRawData.descriptor.value}`);
                            break;
                    }
                    if (actionsRawData.descriptor.value === Constants.descriptorCodes.sqlRuleActionList &&
                        Array.isArray(actionsRawData.value) &&
                        actionsRawData.value.length) {
                        rule.action = this._safelyGetTypedValueFromArray(actionsRawData.value, 0);
                    }
                    rules.push(rule);
                });
                return rules;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the get rules request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Removes the rule on the Subscription identified by the given rule name.
     * @param ruleName
     */
    removeRule(ruleName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            throwTypeErrorIfParameterMissing(this._context.connectionId, "ruleName", ruleName);
            ruleName = String(ruleName);
            throwTypeErrorIfParameterIsEmptyString(this._context.connectionId, "ruleName", ruleName);
            try {
                const request = {
                    body: {
                        "rule-name": types.wrap_string(ruleName)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.removeRule
                    }
                };
                request.application_properties[Constants.trackingId] = generate_uuid();
                managementClientLogger.verbose("%s Remove Rule request body: %O.", this.logPrefix, request.body);
                yield this._makeManagementRequest(request, managementClientLogger, options);
            }
            catch (err) {
                const error = translateServiceBusError(err);
                managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the remove rule request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Adds a rule on the subscription as defined by the given rule name, filter and action
     * @param ruleName Name of the rule
     * @param filter A Boolean, SQL expression or a Correlation filter
     * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression
     */
    addRule(ruleName, filter, sqlRuleActionExpression, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            throwTypeErrorIfParameterMissing(this._context.connectionId, "ruleName", ruleName);
            ruleName = String(ruleName);
            throwTypeErrorIfParameterIsEmptyString(this._context.connectionId, "ruleName", ruleName);
            throwTypeErrorIfParameterMissing(this._context.connectionId, "filter", filter);
            if (typeof filter !== "boolean" &&
                typeof filter !== "string" &&
                !correlationProperties.some((validProperty) => filter.hasOwnProperty(validProperty))) {
                throw new TypeError(`The parameter "filter" should be either a boolean, string or implement the CorrelationRuleFilter interface.`);
            }
            try {
                const ruleDescription = {};
                switch (typeof filter) {
                    case "boolean":
                        ruleDescription["sql-filter"] = {
                            expression: filter ? "1=1" : "1=0"
                        };
                        break;
                    case "string":
                        ruleDescription["sql-filter"] = {
                            expression: filter
                        };
                        break;
                    default:
                        ruleDescription["correlation-filter"] = {
                            "correlation-id": filter.correlationId,
                            "message-id": filter.messageId,
                            to: filter.to,
                            "reply-to": filter.replyTo,
                            subject: filter.subject,
                            "session-id": filter.sessionId,
                            "reply-to-session-id": filter.replyToSessionId,
                            "content-type": filter.contentType,
                            applicationProperties: filter.applicationProperties
                        };
                        break;
                }
                if (sqlRuleActionExpression !== undefined) {
                    ruleDescription["sql-rule-action"] = {
                        expression: String(sqlRuleActionExpression)
                    };
                }
                const request = {
                    body: {
                        "rule-name": types.wrap_string(ruleName),
                        "rule-description": types.wrap_map(ruleDescription)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.operations.addRule
                    }
                };
                request.application_properties[Constants.trackingId] = generate_uuid();
                managementClientLogger.verbose("%s Add Rule request body: %O.", this.logPrefix, request.body);
                yield this._makeManagementRequest(request, managementClientLogger, options);
            }
            catch (err) {
                const error = translateServiceBusError(err);
                managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the Add rule request to $management endpoint`);
                throw error;
            }
        });
    }
}
//# sourceMappingURL=managementClient.js.map