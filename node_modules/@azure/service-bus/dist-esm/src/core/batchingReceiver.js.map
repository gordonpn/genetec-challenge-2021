{"version":3,"file":"batchingReceiver.js","sourceRoot":"","sources":["../../../src/core/batchingReceiver.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAElC,OAAO,EAAE,cAAc,IAAI,MAAM,EAAE,MAAM,QAAQ,CAAC;AAClD,OAAO,EAIL,cAAc,EACd,aAAa,EAGd,MAAM,cAAc,CAAC;AACtB,OAAO,EAAE,qBAAqB,EAAE,MAAM,sBAAsB,CAAC;AAC7D,OAAO,EAAE,eAAe,EAAwC,MAAM,mBAAmB,CAAC;AAE1F,OAAO,EAAE,4BAA4B,EAAE,MAAM,gBAAgB,CAAC;AAE9D,OAAO,EAAE,+BAA+B,EAAE,MAAM,eAAe,CAAC;AAEhE,OAAO,EAAE,0BAA0B,EAAE,MAAM,4CAA4C,CAAC;AAExF,OAAO,EAAE,eAAe,EAAE,wBAAwB,EAAE,MAAM,oBAAoB,CAAC;AAE/E;;;;;;;GAOG;AACH,MAAM,OAAO,gBAAiB,SAAQ,eAAe;IACnD;;;;;;OAMG;IACH,YAAY,OAA0B,EAAE,UAAkB,EAAE,OAAuB;QACjF,KAAK,CAAC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;QAEhD,IAAI,CAAC,qBAAqB,GAAG,IAAI,oBAAoB,CACnD,OAAO,EACP,UAAU,EACV,CAAO,WAA6B,EAAwC,EAAE;YAC5E,IAAI,SAAwC,CAAC;YAE7C,MAAM,WAAW,GAAG,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE;gBACrD,OAAO,EAAE,CAAC,OAAO,EAAE,EAAE;;oBACnB,SAAS,SAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,0CAAE,KAAK,CAAC;gBACvC,CAAC;gBACD,cAAc,EAAE,CAAC,OAAO,EAAE,EAAE;;oBAC1B,SAAS,SAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,OAAO,0CAAE,KAAK,CAAC;gBACtC,CAAC;gBACD,0GAA0G;gBAC1G,OAAO,EAAE,GAAS,EAAE,gDAAE,CAAC,CAAA;gBACvB,cAAc,EAAE,GAAS,EAAE,gDAAE,CAAC,CAAA;gBAC9B,wFAAwF;gBACxF,SAAS,EAAE,GAAS,EAAE,gDAAE,CAAC,CAAA;aAC1B,CAAC,CAAC;YAEH,MAAM,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;YAE3C,IAAI,SAAS,IAAI,IAAI,EAAE;gBACrB,MAAM,SAAS,CAAC;aACjB;YAED,OAAO,IAAI,CAAC,IAAI,CAAC;QACnB,CAAC,CAAA,EACD,IAAI,CAAC,WAAW,CACjB,CAAC;IACJ,CAAC;IAID,IAAI,mBAAmB;QACrB,OAAO,IAAI,CAAC,qBAAqB,CAAC,mBAAmB,CAAC;IACxD,CAAC;IAED;;;;OAIG;IACG,UAAU,CAAC,eAAmC;;YAClD,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC;YAEvB,IAAI,eAAe,IAAI,IAAI,EAAE;gBAC3B,eAAe,GAAG,IAAI,KAAK,CACzB,yEAAyE,CAC1E,CAAC;aACH;YAED,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;QACpD,CAAC;KAAA;IAED;;;;;;;;;OASG;IACG,OAAO,CACX,eAAuB,EACvB,eAAuB,EACvB,4BAAoC,EACpC,OAA6B;;YAE7B,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAE5C,IAAI;gBACF,MAAM,CAAC,OAAO,CACZ,wDAAwD,EACxD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,CACV,CAAC;gBAEF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,qBAAqB,CAAC,eAAe,iBAC/D,eAAe;oBACf,eAAe;oBACf,4BAA4B,IACzB,OAAO,EACV,CAAC;gBAEH,IAAI,IAAI,CAAC,YAAY,EAAE;oBACrB,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;wBAC9B,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,MAAM,EAAE,EAAE;4BAChD,yFAAyF;4BACzF,2EAA2E;wBAC7E,CAAC,CAAC,CAAC;qBACJ;iBACF;gBAED,OAAO,QAAQ,CAAC;aACjB;YAAC,OAAO,KAAK,EAAE;gBACd,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,kCAAkC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC3E,MAAM,KAAK,CAAC;aACb;QACH,CAAC;KAAA;IAED,MAAM,CAAC,MAAM,CACX,OAA0B,EAC1B,UAAkB,EAClB,OAAuB;QAEvB,4BAA4B,CAAC,OAAO,CAAC,CAAC;QACtC,MAAM,SAAS,GAAG,IAAI,gBAAgB,CAAC,OAAO,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;QACrE,OAAO,CAAC,gBAAgB,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC;QACrD,OAAO,SAAS,CAAC;IACnB,CAAC;CACF;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,0BAA0B,CACxC,eAAuB,EACvB,4BAAoC;IAEpC,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IAE/B,OAAO,GAAG,EAAE;QACV,MAAM,eAAe,GAAG,eAAe,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,WAAW,CAAC,CAAC;QAErE,IAAI,eAAe,GAAG,CAAC,EAAE;YACvB,OAAO,CAAC,CAAC;SACV;QAED,OAAO,IAAI,CAAC,GAAG,CAAC,eAAe,EAAE,4BAA4B,CAAC,CAAC;IACjE,CAAC,CAAC;AACJ,CAAC;AA2CD;;;;;;;;GAQG;AACH,MAAM,OAAO,oBAAoB;IAM/B,YACU,kBAAqC,EACtC,UAAkB,EACjB,mBAEiC,EACjC,YAAyB;QALzB,uBAAkB,GAAlB,kBAAkB,CAAmB;QACtC,eAAU,GAAV,UAAU,CAAQ;QACjB,wBAAmB,GAAnB,mBAAmB,CAEc;QACjC,iBAAY,GAAZ,YAAY,CAAa;QAEjC,IAAI,CAAC,2BAA2B,GAAG,0BAA0B,CAAC;QAE9D,IAAI,CAAC,wBAAwB,GAAG,CAAC,OAA2B,EAAE,EAAE;YAC9D,OAAO,IAAI,qBAAqB,CAC9B,OAAO,CAAC,OAAQ,EAChB,OAAO,CAAC,QAAS,EACjB,IAAI,EACJ,IAAI,CAAC,YAAY,CAClB,CAAC;QACJ,CAAC,CAAC;QAEF,IAAI,CAAC,2BAA2B,GAAG,CACjC,eAAuB,EACvB,4BAAoC,EACpC,EAAE,CAAC,0BAA0B,CAAC,eAAe,EAAE,4BAA4B,CAAC,CAAC;QAE/E,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;IACnC,CAAC;IAWD;;;;;OAKG;IACU,eAAe,CAAC,IAAwB;;YACnD,IAAI;gBACF,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;gBAChC,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBAElE,IAAI,QAAQ,IAAI,IAAI,EAAE;oBACpB,4DAA4D;oBAC5D,OAAO,EAAE,CAAC;iBACX;gBAED,MAAM,QAAQ,GAAG,MAAM,IAAI,OAAO,CAA0B,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,CAC9E,IAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,CAAC,CAC3D,CAAC;gBACF,IAAI,CAAC,2BAA2B,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;gBACvF,OAAO,QAAQ,CAAC;aACjB;oBAAS;gBACR,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;gBAC/B,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;aAClC;QACH,CAAC;KAAA;IAED;;;;OAIG;IACH,KAAK,CAAC,eAAmC;QACvC,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC;YACpC,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;SAChC;IACH,CAAC;IAEO,oBAAoB,CAC1B,QAAyB,EACzB,IAAwB,EACxB,WAAwD,EACxD,UAA4C;QAE5C,MAAM,wBAAwB,GAAG,IAAI,CAAC,2BAA2B,CAC/D,IAAI,CAAC,eAAe,EACpB,IAAI,CAAC,4BAA4B,CAClC,CAAC;QAEF,MAAM,gBAAgB,GAA4B,EAAE,CAAC;QACrD,MAAM,aAAa,GAAG,IAAI,QAAQ,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ,CAAC,IAAI,GAAG,CAAC;QAEvE,IAAI,cAAwC,CAAC;QAE7C,wCAAwC;QACxC,IAAI,4BAAwC,CAAC;QAE7C,MAAM,MAAM,GAAG,CAAC,GAAsB,EAAE,EAAE;YACxC,4BAA4B,EAAE,CAAC;YAC/B,UAAU,CAAC,GAAG,CAAC,CAAC;QAClB,CAAC,CAAC;QAEF,MAAM,kBAAkB,GAAG,CAAC,MAA+B,EAAE,EAAE;YAC7D,4BAA4B,EAAE,CAAC;YAC/B,WAAW,CAAC,MAAM,CAAC,CAAC;QACtB,CAAC,CAAC;QAEF,MAAM,mCAAmC,GAAG,CAAC,MAA+B,EAAE,EAAE;YAC9E,4GAA4G;YAC5G,8GAA8G;YAC9G,4GAA4G;YAC5G,wCAAwC;YACxC,8FAA8F;YAC9F,gCAAgC;YAChC,UAAU,CAAC,GAAG,EAAE;gBACd,4BAA4B,EAAE,CAAC;gBAC/B,WAAW,CAAC,MAAM,CAAC,CAAC;YACtB,CAAC,CAAC,CAAC;QACL,CAAC,CAAC;QAEF,MAAM,OAAO,GAAgB,CAAC,OAAqB,EAAE,EAAE;;YACrD,MAAM,SAAS,GAAG,OAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,KAAI,IAAI,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,gBAAgB,CAAC;YACtF,IAAI,KAAK,GAAG,OAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,YAAI,OAAO,CAAC,QAAQ,0CAAE,KAAK,CAAA,CAAC;YAE9D,IAAI,KAAK,EAAE;gBACT,KAAK,GAAG,wBAAwB,CAAC,KAAK,CAAC,CAAC;gBACxC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,aAAa,KAAK,SAAS,qCAAqC,CAAC,CAAC;aAC7F;iBAAM;gBACL,KAAK,GAAG,IAAI,eAAe,CAAC,6CAA6C,EAAE,cAAc,CAAC,CAAC;aAC5F;YACD,MAAM,CAAC,KAAK,CAAC,CAAC;QAChB,CAAC,CAAC;QAEF,IAAI,CAAC,aAAa,GAAG,CAAC,KAAyB,EAAQ,EAAE;YACvD;YACE,4DAA4D;YAC5D,KAAK,IAAI,IAAI;gBACb,oGAAoG;gBACpG,CAAC,IAAI,CAAC,YAAY,KAAK,kBAAkB,IAAI,gBAAgB,CAAC,MAAM,CAAC,EACrE;gBACA,MAAM,CAAC,OAAO,CACZ,GAAG,aAAa,4BAA4B,gBAAgB,CAAC,MAAM,YAAY,CAChF,CAAC;gBAEF,OAAO,mCAAmC,CAAC,gBAAgB,CAAC,CAAC;aAC9D;YAED,MAAM,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC,CAAC;QAC1C,CAAC,CAAC;QAEF,IAAI,0BAA0B,GAA6B,SAAS,CAAC;QAErE,qCAAqC;QACrC,kCAAkC;QAClC,6BAA6B;QAC7B,iFAAiF;QACjF,MAAM,WAAW,GAAG,GAAS,EAAE;YAC7B,6BAA6B;YAC7B,IAAI,QAAQ,CAAC,MAAM,EAAE,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC5C,MAAM,CAAC,OAAO,CAAC,GAAG,aAAa,8BAA8B,QAAQ,CAAC,MAAM,IAAI,CAAC,CAAC;gBAElF,kFAAkF;gBAClF,2FAA2F;gBAC3F,mEAAmE;gBACnE,QAAQ,CAAC,KAAK,GAAG,IAAI,CAAC;gBACtB,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;aACvB;iBAAM;gBACL,MAAM,CAAC,OAAO,CACZ,GAAG,aAAa,qCAAqC,gBAAgB,CAAC,MAAM,YAAY,CACzF,CAAC;gBAEF,yEAAyE;gBACzE,gDAAgD;gBAChD,kBAAkB,CAAC,gBAAgB,CAAC,CAAC;aACtC;QACH,CAAC,CAAC;QAEF,iDAAiD;QACjD,MAAM,gBAAgB,GAAyB,CAAO,OAAqB,EAAE,EAAE;YAC7E,oFAAoF;YACpF,uFAAuF;YACvF,qBAAqB;YACrB,IAAI,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;gBACpC,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC,EAAE;oBACjC,+EAA+E;oBAC/E,gFAAgF;oBAChF,EAAE;oBACF,oFAAoF;oBACpF,+EAA+E;oBAC/E,eAAe;oBACf,IAAI,cAAc;wBAAE,YAAY,CAAC,cAAc,CAAC,CAAC;oBACjD,MAAM,qBAAqB,GAAG,wBAAwB,EAAE,CAAC;oBACzD,cAAc,GAAG,UAAU,CAAC,GAAG,EAAE;wBAC/B,MAAM,CAAC,OAAO,CACZ,GAAG,aAAa,yBAAyB,qBAAqB,kDAAkD,CACjH,CAAC;wBACF,WAAW,EAAE,CAAC;oBAChB,CAAC,EAAE,qBAAqB,CAAC,CAAC;iBAC3B;aACF;YAED,IAAI;gBACF,MAAM,IAAI,GAA0B,IAAI,CAAC,wBAAwB,CAAC,OAAO,CAAC,CAAC;gBAC3E,IAAI,gBAAgB,CAAC,MAAM,GAAG,IAAI,CAAC,eAAe,EAAE;oBAClD,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC7B;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,MAAM,GAAG,GAAG,YAAY,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC3E,MAAM,CAAC,QAAQ,CACb,GAAG,EACH,GAAG,aAAa,sEAAsE,CACvF,CAAC;gBACF,MAAM,CAAC,MAAM,CAAC,CAAC;aAChB;YACD,IAAI,gBAAgB,CAAC,MAAM,KAAK,IAAI,CAAC,eAAe,EAAE;gBACpD,WAAW,EAAE,CAAC;aACf;QACH,CAAC,CAAA,CAAC;QAEF,MAAM,OAAO,GAAyB,CAAO,OAAqB,EAAE,EAAE;;YACpE,MAAM,IAAI,GAAG,OAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,KAAI,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,iBAAiB,CAAC;YACnF,MAAM,KAAK,GAAG,OAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,YAAI,OAAO,CAAC,QAAQ,0CAAE,KAAK,CAAA,CAAC;YAEhE,IAAI,KAAK,EAAE;gBACT,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,aAAa,KAAK,IAAI,wCAAwC,CAAC,CAAC;aAC3F;QACH,CAAC,CAAA,CAAC;QAEF,0DAA0D;QAC1D,MAAM,cAAc,GAAgB,GAAG,EAAE;YACvC,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;YACxE,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAC;YAEvB,MAAM,CAAC,OAAO,CACZ,GAAG,aAAa,8CAA8C,gBAAgB,CAAC,MAAM,YAAY,CAClG,CAAC;YAEF,mCAAmC,CAAC,gBAAgB,CAAC,CAAC;QACxD,CAAC,CAAC;QAEF,4BAA4B,GAAG,GAAS,EAAE;YACxC,IAAI,QAAQ,IAAI,IAAI,EAAE;gBACpB,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;gBAC/D,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;gBAClE,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,aAAa,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;gBACrE,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;gBAC/D,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,aAAa,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;gBACrE,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;aACzE;YAED,IAAI,cAAc,EAAE;gBAClB,YAAY,CAAC,cAAc,CAAC,CAAC;aAC9B;YAED,IAAI,0BAA0B,EAAE;gBAC9B,0BAA0B,EAAE,CAAC;aAC9B;YACD,0BAA0B,GAAG,SAAS,CAAC;QACzC,CAAC,CAAC;QAEF,0BAA0B,GAAG,+BAA+B,CAAC,CAAC,GAAG,EAAE,EAAE;YACnE,MAAM,CAAC,GAAG,CAAC,CAAC;QACd,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;QAErB,MAAM,CAAC,OAAO,CACZ,GAAG,aAAa,gCAAgC,IAAI,CAAC,eAAe,YAAY,CACjF,CAAC;QAEF,6FAA6F;QAC7F,yFAAyF;QACzF,8EAA8E;QAC9E,mEAAmE;QACnE,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAEzC,MAAM,CAAC,OAAO,CACZ,GAAG,aAAa,+BAA+B,IAAI,CAAC,eAAe,gBAAgB,CACpF,CAAC;QAEF,cAAc,GAAG,UAAU,CAAC,GAAG,EAAE;YAC/B,MAAM,CAAC,OAAO,CACZ,GAAG,aAAa,uCAAuC,IAAI,CAAC,eAAe,gBAAgB,CAC5F,CAAC;YACF,WAAW,EAAE,CAAC;QAChB,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;QAEzB,QAAQ,CAAC,EAAE,CAAC,cAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;QACtD,QAAQ,CAAC,EAAE,CAAC,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;QACnD,QAAQ,CAAC,EAAE,CAAC,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;QACnD,QAAQ,CAAC,EAAE,CAAC,cAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;QAE5D,QAAQ,CAAC,OAAO,CAAC,EAAE,CAAC,aAAa,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;QACzD,QAAQ,CAAC,OAAO,CAAC,EAAE,CAAC,aAAa,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;IAC3D,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { receiverLogger as logger } from \"../log\";\nimport {\n  AmqpError,\n  EventContext,\n  OnAmqpEvent,\n  ReceiverEvents,\n  SessionEvents,\n  Receiver,\n  Session\n} from \"rhea-promise\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { MessageReceiver, OnAmqpEventAsPromise, ReceiveOptions } from \"./messageReceiver\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { checkAndRegisterWithAbortSignal } from \"../util/utils\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { createAndEndProcessingSpan } from \"../diagnostics/instrumentServiceBusMessage\";\nimport { ReceiveMode } from \"../models\";\nimport { ServiceBusError, translateServiceBusError } from \"../serviceBusError\";\n\n/**\n * Describes the batching receiver where the user can receive a specified number of messages for\n * a predefined time.\n * @internal\n * @hidden\n * @class BatchingReceiver\n * @extends MessageReceiver\n */\nexport class BatchingReceiver extends MessageReceiver {\n  /**\n   * Instantiate a new BatchingReceiver.\n   *\n   * @constructor\n   * @param {ClientEntityContext} context The client entity context.\n   * @param {ReceiveOptions} [options]  Options for how you'd like to connect.\n   */\n  constructor(context: ConnectionContext, entityPath: string, options: ReceiveOptions) {\n    super(context, entityPath, \"batching\", options);\n\n    this._batchingReceiverLite = new BatchingReceiverLite(\n      context,\n      entityPath,\n      async (abortSignal?: AbortSignalLike): Promise<MinimalReceiver | undefined> => {\n        let lastError: Error | AmqpError | undefined;\n\n        const rcvrOptions = this._createReceiverOptions(false, {\n          onError: (context) => {\n            lastError = context?.receiver?.error;\n          },\n          onSessionError: (context) => {\n            lastError = context?.session?.error;\n          },\n          // ignored for now - the next call will just fail so they'll get an appropriate error from somewhere else.\n          onClose: async () => {},\n          onSessionClose: async () => {},\n          // we don't add credits initially so we don't need to worry about handling any messages.\n          onMessage: async () => {}\n        });\n\n        await this._init(rcvrOptions, abortSignal);\n\n        if (lastError != null) {\n          throw lastError;\n        }\n\n        return this.link;\n      },\n      this.receiveMode\n    );\n  }\n\n  private _batchingReceiverLite: BatchingReceiverLite;\n\n  get isReceivingMessages(): boolean {\n    return this._batchingReceiverLite.isReceivingMessages;\n  }\n\n  /**\n   * To be called when connection is disconnected to gracefully close ongoing receive request.\n   * @param {AmqpError | Error} [connectionError] The connection error if any.\n   * @returns {Promise<void>} Promise<void>.\n   */\n  async onDetached(connectionError?: AmqpError | Error): Promise<void> {\n    await this.closeLink();\n\n    if (connectionError == null) {\n      connectionError = new Error(\n        \"Unknown error occurred on the AMQP connection while receiving messages.\"\n      );\n    }\n\n    this._batchingReceiverLite.close(connectionError);\n  }\n\n  /**\n   * Receives a batch of messages from a ServiceBus Queue/Topic.\n   * @param maxMessageCount The maximum number of messages to receive.\n   * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.\n   * @param maxWaitTimeInMs The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.\n   * @param maxTimeAfterFirstMessageInMs The total amount of time to wait after the first message\n   * has been received. Defaults to 1 second.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * @returns {Promise<ServiceBusMessageImpl[]>} A promise that resolves with an array of Message objects.\n   */\n  async receive(\n    maxMessageCount: number,\n    maxWaitTimeInMs: number,\n    maxTimeAfterFirstMessageInMs: number,\n    options: OperationOptionsBase\n  ): Promise<ServiceBusMessageImpl[]> {\n    throwErrorIfConnectionClosed(this._context);\n\n    try {\n      logger.verbose(\n        \"[%s] Receiver '%s', setting max concurrent calls to 0.\",\n        this.logPrefix,\n        this.name\n      );\n\n      const messages = await this._batchingReceiverLite.receiveMessages({\n        maxMessageCount,\n        maxWaitTimeInMs,\n        maxTimeAfterFirstMessageInMs,\n        ...options\n      });\n\n      if (this._lockRenewer) {\n        for (const message of messages) {\n          this._lockRenewer.start(this, message, (_error) => {\n            // the auto lock renewer already logs this in a detailed way. So this hook is mainly here\n            // to potentially forward the error to the user (which we're not doing yet)\n          });\n        }\n      }\n\n      return messages;\n    } catch (error) {\n      logger.logError(error, \"[%s] Rejecting receiveMessages()\", this.logPrefix);\n      throw error;\n    }\n  }\n\n  static create(\n    context: ConnectionContext,\n    entityPath: string,\n    options: ReceiveOptions\n  ): BatchingReceiver {\n    throwErrorIfConnectionClosed(context);\n    const bReceiver = new BatchingReceiver(context, entityPath, options);\n    context.messageReceivers[bReceiver.name] = bReceiver;\n    return bReceiver;\n  }\n}\n\n/**\n * Gets a function that returns the smaller of the two timeouts,\n * taking into account elapsed time from when getRemainingWaitTimeInMsFn\n * was called.\n *\n * @param maxWaitTimeInMs Maximum time to wait for the first message\n * @param maxTimeAfterFirstMessageInMs Maximum time to wait after the first message before completing the receive.\n *\n * @internal\n * @hidden\n */\nexport function getRemainingWaitTimeInMsFn(\n  maxWaitTimeInMs: number,\n  maxTimeAfterFirstMessageInMs: number\n): () => number {\n  const startTimeMs = Date.now();\n\n  return () => {\n    const remainingTimeMs = maxWaitTimeInMs - (Date.now() - startTimeMs);\n\n    if (remainingTimeMs < 0) {\n      return 0;\n    }\n\n    return Math.min(remainingTimeMs, maxTimeAfterFirstMessageInMs);\n  };\n}\n\n/**\n * Useful interface that mimics EventEmitter without requiring us to actually\n * import the events definition (which is annoying with browsers).\n *\n * @internal\n * @hidden\n */\ntype EventEmitterLike<T extends Receiver | Session> = Pick<T, \"once\" | \"removeListener\" | \"on\">;\n\n/**\n * The bare minimum needed to receive messages for batched\n * message receiving.\n *\n * @internal\n * @hidden\n */\nexport type MinimalReceiver = Pick<Receiver, \"name\" | \"isOpen\" | \"credit\" | \"addCredit\" | \"drain\"> &\n  EventEmitterLike<Receiver> & {\n    session: EventEmitterLike<Session>;\n  } & {\n    connection: {\n      id: string;\n    };\n  };\n\n/**\n * @internal\n * @hidden\n */\ntype MessageAndDelivery = Pick<EventContext, \"message\" | \"delivery\">;\n\n/**\n * @internal\n * @hidden\n */\ninterface ReceiveMessageArgs extends OperationOptionsBase {\n  maxMessageCount: number;\n  maxWaitTimeInMs: number;\n  maxTimeAfterFirstMessageInMs: number;\n}\n\n/**\n * The internals of a batching receiver minus anything that would require us to hold onto a client entity context\n * or a receiver on a permanent basis.\n *\n * Usable with both session and non-session receivers.\n *\n * @internal\n * @hidden\n */\nexport class BatchingReceiverLite {\n  /**\n   * NOTE: exists only to make unit testing possible.\n   */\n  private _createAndEndProcessingSpan: typeof createAndEndProcessingSpan;\n\n  constructor(\n    private _connectionContext: ConnectionContext,\n    public entityPath: string,\n    private _getCurrentReceiver: (\n      abortSignal?: AbortSignalLike\n    ) => Promise<MinimalReceiver | undefined>,\n    private _receiveMode: ReceiveMode\n  ) {\n    this._createAndEndProcessingSpan = createAndEndProcessingSpan;\n\n    this._createServiceBusMessage = (context: MessageAndDelivery) => {\n      return new ServiceBusMessageImpl(\n        context.message!,\n        context.delivery!,\n        true,\n        this._receiveMode\n      );\n    };\n\n    this._getRemainingWaitTimeInMsFn = (\n      maxWaitTimeInMs: number,\n      maxTimeAfterFirstMessageInMs: number\n    ) => getRemainingWaitTimeInMsFn(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs);\n\n    this.isReceivingMessages = false;\n  }\n\n  private _createServiceBusMessage: (\n    context: Pick<EventContext, \"message\" | \"delivery\">\n  ) => ServiceBusMessageImpl;\n\n  private _getRemainingWaitTimeInMsFn: typeof getRemainingWaitTimeInMsFn;\n  private _closeHandler: ((connectionError?: AmqpError | Error) => void) | undefined;\n\n  isReceivingMessages: boolean;\n\n  /**\n   * Receives a set of messages,\n   *\n   * @internal\n   * @hidden\n   */\n  public async receiveMessages(args: ReceiveMessageArgs): Promise<ServiceBusMessageImpl[]> {\n    try {\n      this.isReceivingMessages = true;\n      const receiver = await this._getCurrentReceiver(args.abortSignal);\n\n      if (receiver == null) {\n        // (was somehow closed in between the init() and the return)\n        return [];\n      }\n\n      const messages = await new Promise<ServiceBusMessageImpl[]>((resolve, reject) =>\n        this._receiveMessagesImpl(receiver, args, resolve, reject)\n      );\n      this._createAndEndProcessingSpan(messages, this, this._connectionContext.config, args);\n      return messages;\n    } finally {\n      this._closeHandler = undefined;\n      this.isReceivingMessages = false;\n    }\n  }\n\n  /**\n   * Closes the receiver (optionally with an error), cancelling any current operations.\n   *\n   * @param connectionError An optional error (rhea doesn't always deliver one for certain disconnection events)\n   */\n  close(connectionError?: Error | AmqpError) {\n    if (this._closeHandler) {\n      this._closeHandler(connectionError);\n      this._closeHandler = undefined;\n    }\n  }\n\n  private _receiveMessagesImpl(\n    receiver: MinimalReceiver,\n    args: ReceiveMessageArgs,\n    origResolve: (messages: ServiceBusMessageImpl[]) => void,\n    origReject: (err: Error | AmqpError) => void\n  ): void {\n    const getRemainingWaitTimeInMs = this._getRemainingWaitTimeInMsFn(\n      args.maxWaitTimeInMs,\n      args.maxTimeAfterFirstMessageInMs\n    );\n\n    const brokeredMessages: ServiceBusMessageImpl[] = [];\n    const loggingPrefix = `[${receiver.connection.id}|r:${receiver.name}]`;\n\n    let totalWaitTimer: NodeJS.Timer | undefined;\n\n    // eslint-disable-next-line prefer-const\n    let cleanupBeforeResolveOrReject: () => void;\n\n    const reject = (err: Error | AmqpError) => {\n      cleanupBeforeResolveOrReject();\n      origReject(err);\n    };\n\n    const resolveImmediately = (result: ServiceBusMessageImpl[]) => {\n      cleanupBeforeResolveOrReject();\n      origResolve(result);\n    };\n\n    const resolveAfterPendingMessageCallbacks = (result: ServiceBusMessageImpl[]) => {\n      // NOTE: through rhea-promise, most of our event handlers are made asynchronous by calling setTimeout(emit).\n      // However, a small set (*error and drain) execute immediately. This can lead to a situation where the logical\n      // ordering of events is correct but the execution order is incorrect because the events are not all getting\n      // put into the task queue the same way.\n      // setTimeout() ensures that we resolve _after_ any already-queued onMessage handlers that may\n      // be waiting in the task queue.\n      setTimeout(() => {\n        cleanupBeforeResolveOrReject();\n        origResolve(result);\n      });\n    };\n\n    const onError: OnAmqpEvent = (context: EventContext) => {\n      const eventType = context.session?.error != null ? \"session_error\" : \"receiver_error\";\n      let error = context.session?.error || context.receiver?.error;\n\n      if (error) {\n        error = translateServiceBusError(error);\n        logger.logError(error, `${loggingPrefix} '${eventType}' event occurred. Received an error`);\n      } else {\n        error = new ServiceBusError(\"An error occurred while receiving messages.\", \"GeneralError\");\n      }\n      reject(error);\n    };\n\n    this._closeHandler = (error?: AmqpError | Error): void => {\n      if (\n        // no error, just closing. Go ahead and return what we have.\n        error == null ||\n        // Return the collected messages if in ReceiveAndDelete mode because otherwise they are lost forever\n        (this._receiveMode === \"receiveAndDelete\" && brokeredMessages.length)\n      ) {\n        logger.verbose(\n          `${loggingPrefix} Closing. Resolving with ${brokeredMessages.length} messages.`\n        );\n\n        return resolveAfterPendingMessageCallbacks(brokeredMessages);\n      }\n\n      reject(translateServiceBusError(error));\n    };\n\n    let abortSignalCleanupFunction: (() => void) | undefined = undefined;\n\n    // Final action to be performed after\n    // - maxMessageCount is reached or\n    // - maxWaitTime is passed or\n    // - newMessageWaitTimeoutInSeconds is passed since the last message was received\n    const finalAction = (): void => {\n      // Drain any pending credits.\n      if (receiver.isOpen() && receiver.credit > 0) {\n        logger.verbose(`${loggingPrefix} Draining leftover credits(${receiver.credit}).`);\n\n        // setting .drain and combining it with .addCredit results in (eventually) sending\n        // a drain request to Service Bus. When the drain completes rhea will call `onReceiveDrain`\n        // at which point we'll wrap everything up and resolve the promise.\n        receiver.drain = true;\n        receiver.addCredit(1);\n      } else {\n        logger.verbose(\n          `${loggingPrefix} Resolving receiveMessages() with ${brokeredMessages.length} messages.`\n        );\n\n        // we can resolve immediately (ie, no setTimeout call) because we have no\n        // remaining messages (thus nothing to wait for)\n        resolveImmediately(brokeredMessages);\n      }\n    };\n\n    // Action to be performed on the \"message\" event.\n    const onReceiveMessage: OnAmqpEventAsPromise = async (context: EventContext) => {\n      // TODO: this appears to be aggravating a bug that we need to look into more deeply.\n      // The same timeout+drain sequence should work fine for receiveAndDelete but it appears\n      // to cause problems.\n      if (this._receiveMode === \"peekLock\") {\n        if (brokeredMessages.length === 0) {\n          // We'll now remove the old timer (which was the overall `maxWaitTimeMs` timer)\n          // and replace it with another timer that is a (probably) much shorter interval.\n          //\n          // This allows the user to get access to received messages earlier and also gives us\n          // a chance to have fewer messages internally that could get lost if the user's\n          // app crashes.\n          if (totalWaitTimer) clearTimeout(totalWaitTimer);\n          const remainingWaitTimeInMs = getRemainingWaitTimeInMs();\n          totalWaitTimer = setTimeout(() => {\n            logger.verbose(\n              `${loggingPrefix} Batching, waited for ${remainingWaitTimeInMs} milliseconds after receiving the first message.`\n            );\n            finalAction();\n          }, remainingWaitTimeInMs);\n        }\n      }\n\n      try {\n        const data: ServiceBusMessageImpl = this._createServiceBusMessage(context);\n        if (brokeredMessages.length < args.maxMessageCount) {\n          brokeredMessages.push(data);\n        }\n      } catch (err) {\n        const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));\n        logger.logError(\n          err,\n          `${loggingPrefix} Received an error while converting AmqpMessage to ServiceBusMessage`\n        );\n        reject(errObj);\n      }\n      if (brokeredMessages.length === args.maxMessageCount) {\n        finalAction();\n      }\n    };\n\n    const onClose: OnAmqpEventAsPromise = async (context: EventContext) => {\n      const type = context.session?.error != null ? \"session_closed\" : \"receiver_closed\";\n      const error = context.session?.error || context.receiver?.error;\n\n      if (error) {\n        logger.logError(error, `${loggingPrefix} '${type}' event occurred. The associated error`);\n      }\n    };\n\n    // Action to be performed on the \"receiver_drained\" event.\n    const onReceiveDrain: OnAmqpEvent = () => {\n      receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n      receiver.drain = false;\n\n      logger.verbose(\n        `${loggingPrefix} Drained, resolving receiveMessages() with ${brokeredMessages.length} messages.`\n      );\n\n      resolveAfterPendingMessageCallbacks(brokeredMessages);\n    };\n\n    cleanupBeforeResolveOrReject = (): void => {\n      if (receiver != null) {\n        receiver.removeListener(ReceiverEvents.receiverError, onError);\n        receiver.removeListener(ReceiverEvents.message, onReceiveMessage);\n        receiver.session.removeListener(SessionEvents.sessionError, onError);\n        receiver.removeListener(ReceiverEvents.receiverClose, onClose);\n        receiver.session.removeListener(SessionEvents.sessionClose, onClose);\n        receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n      }\n\n      if (totalWaitTimer) {\n        clearTimeout(totalWaitTimer);\n      }\n\n      if (abortSignalCleanupFunction) {\n        abortSignalCleanupFunction();\n      }\n      abortSignalCleanupFunction = undefined;\n    };\n\n    abortSignalCleanupFunction = checkAndRegisterWithAbortSignal((err) => {\n      reject(err);\n    }, args.abortSignal);\n\n    logger.verbose(\n      `${loggingPrefix} Adding credit for receiving ${args.maxMessageCount} messages.`\n    );\n\n    // By adding credit here, we let the service know that at max we can handle `maxMessageCount`\n    // number of messages concurrently. We will return the user an array of messages that can\n    // be of size upto maxMessageCount. Then the user needs to accordingly dispose\n    // (complete/abandon/defer/deadletter) the messages from the array.\n    receiver.addCredit(args.maxMessageCount);\n\n    logger.verbose(\n      `${loggingPrefix} Setting the wait timer for ${args.maxWaitTimeInMs} milliseconds.`\n    );\n\n    totalWaitTimer = setTimeout(() => {\n      logger.verbose(\n        `${loggingPrefix} Batching, waited for max wait time ${args.maxWaitTimeInMs} milliseconds.`\n      );\n      finalAction();\n    }, args.maxWaitTimeInMs);\n\n    receiver.on(ReceiverEvents.message, onReceiveMessage);\n    receiver.on(ReceiverEvents.receiverError, onError);\n    receiver.on(ReceiverEvents.receiverClose, onClose);\n    receiver.on(ReceiverEvents.receiverDrained, onReceiveDrain);\n\n    receiver.session.on(SessionEvents.sessionError, onError);\n    receiver.session.on(SessionEvents.sessionClose, onClose);\n  }\n}\n"]}