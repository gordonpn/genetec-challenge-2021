{"version":3,"file":"streamingReceiver.js","sourceRoot":"","sources":["../../../src/core/streamingReceiver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  MessageReceiver,\n  OnAmqpEventAsPromise,\n  OnError,\n  OnMessage,\n  ReceiveOptions\n} from \"./messageReceiver\";\nimport { ConnectionContext } from \"../connectionContext\";\n\nimport { ReceiverHelper } from \"./receiverHelper\";\n\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport {\n  RetryOperationType,\n  RetryConfig,\n  retry,\n  MessagingError,\n  RetryOptions,\n  ConditionErrorNameMapper\n} from \"@azure/core-amqp\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { receiverLogger as logger } from \"../log\";\nimport { AmqpError, EventContext, OnAmqpEvent } from \"rhea-promise\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { abandonMessage, completeMessage } from \"../receivers/shared\";\nimport { ReceiverHandlers } from \"./shared\";\n\n/**\n * @internal\n * @hidden\n */\nexport interface StreamingReceiverInitArgs\n  extends ReceiveOptions,\n    Pick<OperationOptionsBase, \"abortSignal\"> {\n  onError: OnError;\n}\n\n/**\n * @internal\n * @hidden\n * Describes the streaming receiver where the user can receive the message\n * by providing handler functions.\n * @class StreamingReceiver\n * @extends MessageReceiver\n */\nexport class StreamingReceiver extends MessageReceiver {\n  /**\n   * @property {number} [maxConcurrentCalls] The maximum number of messages that should be\n   * processed concurrently while in streaming mode. Once this limit has been reached, more\n   * messages will not be received until the user's message handler has completed processing current message.\n   * Default: 1\n   */\n  maxConcurrentCalls: number = 1;\n\n  /**\n   * Indicates whether the receiver is already actively\n   * running `onDetached`.\n   * This is expected to be true while the receiver attempts\n   * to bring its link back up due to a retryable issue.\n   */\n  private _isDetaching: boolean = false;\n  /**\n   *Retry policy options that determine the mode, number of retries, retry interval etc.\n   */\n  private _retryOptions: RetryOptions;\n\n  private _receiverHelper: ReceiverHelper;\n\n  /**\n   * Used so we can stub out retry in tests.\n   */\n  private _retry: typeof retry;\n\n  /**\n   * @property {OnAmqpEventAsPromise} _onAmqpClose The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_close\" event.\n   */\n  private _onAmqpClose: OnAmqpEventAsPromise;\n\n  /**\n   * @property {OnAmqpEventAsPromise} _onSessionClose The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEventAsPromise;\n\n  /**\n   * @property {OnAmqpEvent} _onSessionError The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onAmqpError The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_error\" event.\n   */\n  private _onAmqpError: OnAmqpEvent;\n\n  /**\n   * @property {OnAmqpEventAsPromise} _onAmqpMessage The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"message\" event.\n   */\n  protected _onAmqpMessage: OnAmqpEventAsPromise;\n\n  /**\n   * Whether we are currently registered for receiving messages.\n   */\n  public get isReceivingMessages(): boolean {\n    // for the streaming receiver so long as we can receive messages then we\n    // _are_ receiving messages - there's no in-between state like there is\n    // with BatchingReceiver.\n    return this._receiverHelper.canReceiveMessages();\n  }\n\n  /**\n   * Instantiate a new Streaming receiver for receiving messages with handlers.\n   *\n   * @constructor\n   * @param {ClientEntityContext} context                      The client entity context.\n   * @param {ReceiveOptions} [options]                         Options for how you'd like to connect.\n   */\n  constructor(context: ConnectionContext, entityPath: string, options: ReceiveOptions) {\n    super(context, entityPath, \"streaming\", options);\n\n    if (typeof options?.maxConcurrentCalls === \"number\" && options?.maxConcurrentCalls > 0) {\n      this.maxConcurrentCalls = options.maxConcurrentCalls;\n    }\n\n    this._retryOptions = options?.retryOptions || {};\n    this._retry = retry;\n\n    this._receiverHelper = new ReceiverHelper(() => ({\n      receiver: this.link,\n      logPrefix: this.logPrefix\n    }));\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      const receiver = this.link || context.receiver!;\n\n      logger.logError(\n        receiverError,\n        `${this.logPrefix} 'receiver_close' event occurred. The associated error is`\n      );\n\n      this._lockRenewer?.stopAll(this);\n\n      if (receiver && !receiver.isItselfClosed()) {\n        await this.onDetached(receiverError);\n      } else {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver '%s' with address '%s' \" +\n            \"because the sdk initiated it. Hence not calling detached from the _onAmqpClose\" +\n            \"() handler.\",\n          this.logPrefix,\n          this.name,\n          this.address\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const receiver = this.link || context.receiver!;\n      const sessionError = context.session && context.session.error;\n\n      logger.logError(\n        sessionError,\n        `${this.logPrefix} 'session_close' event occurred. The associated error is`\n      );\n\n      this._lockRenewer?.stopAll(this);\n\n      if (receiver && !receiver.isSessionItselfClosed()) {\n        await this.onDetached(sessionError);\n      } else {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the session of receiver '%s' with address \" +\n            \"'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose\" +\n            \"() handler.\",\n          this.logPrefix,\n          this.name,\n          this.address\n        );\n      }\n    };\n\n    this._onAmqpError = (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        logger.logError(\n          sbError,\n          `${this.logPrefix} 'receiver_error' event occurred. The associated error is`\n        );\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError) as MessagingError;\n        logger.logError(\n          sbError,\n          `${this.logPrefix} 'session_error' event occurred. The associated error is`\n        );\n      }\n    };\n\n    this._onAmqpMessage = async (context: EventContext) => {\n      // If the receiver got closed in PeekLock mode, avoid processing the message as we\n      // cannot settle the message.\n      if (this.receiveMode === \"peekLock\" && (!this.link || !this.link.isOpen())) {\n        logger.verbose(\n          \"%s Not calling the user's message handler for the current message \" +\n            \"as the receiver is closed\",\n          this.logPrefix\n        );\n        return;\n      }\n\n      const bMessage: ServiceBusMessageImpl = new ServiceBusMessageImpl(\n        context.message!,\n        context.delivery!,\n        true,\n        this.receiveMode\n      );\n\n      this._lockRenewer?.start(this, bMessage, (err) => {\n        if (this._onError) {\n          this._onError({\n            error: err,\n            errorSource: \"renewLock\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host\n          });\n        }\n      });\n\n      try {\n        await this._onMessage(bMessage);\n      } catch (err) {\n        logger.logError(\n          err,\n          \"%s An error occurred while running user's message handler for the message \" +\n            \"with id '%s' on the receiver '%s'\",\n          this.logPrefix,\n          bMessage.messageId,\n          this.name\n        );\n        this._onError!({\n          error: err,\n          errorSource: \"processMessageCallback\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host\n        });\n\n        // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,\n        // doing this here. Otherwise, this should be done in finally.\n        this._lockRenewer?.stop(this, bMessage);\n        const error = translateServiceBusError(err) as MessagingError;\n        // Nothing much to do if user's message handler throws. Let us try abandoning the message.\n        if (\n          !bMessage.delivery.remote_settled &&\n          error.code !== ConditionErrorNameMapper[\"com.microsoft:message-lock-lost\"] &&\n          this.receiveMode === \"peekLock\" &&\n          this.isOpen() // only try to abandon the messages if the connection is still open\n        ) {\n          try {\n            logger.logError(\n              error,\n              \"%s Abandoning the message with id '%s' on the receiver '%s' since \" +\n                \"an error occured: %O.\",\n              this.logPrefix,\n              bMessage.messageId,\n              this.name,\n              error\n            );\n            await abandonMessage(bMessage, this._context, entityPath);\n          } catch (abandonError) {\n            const translatedError = translateServiceBusError(abandonError);\n            logger.logError(\n              translatedError,\n              \"%s An error occurred while abandoning the message with id '%s' on the \" +\n                \"receiver '%s'\",\n              this.logPrefix,\n              bMessage.messageId,\n              this.name\n            );\n            this._onError!({\n              error: translatedError,\n              errorSource: \"abandon\",\n              entityPath: this.entityPath,\n              fullyQualifiedNamespace: this._context.config.host\n            });\n          }\n        }\n        return;\n      } finally {\n        this._receiverHelper.addCredit(1);\n      }\n\n      // If we've made it this far, then user's message handler completed fine. Let us try\n      // completing the message.\n      if (\n        this.autoComplete &&\n        this.receiveMode === \"peekLock\" &&\n        !bMessage.delivery.remote_settled\n      ) {\n        try {\n          logger.verbose(\n            \"%s Auto completing the message with id '%s' on \" + \"the receiver.\",\n            this.logPrefix,\n            bMessage.messageId\n          );\n          await completeMessage(bMessage, this._context, entityPath);\n        } catch (completeError) {\n          const translatedError = translateServiceBusError(completeError);\n          logger.logError(\n            translatedError,\n            \"%s An error occurred while completing the message with id '%s' on the \" +\n              \"receiver '%s'\",\n            this.logPrefix,\n            bMessage.messageId,\n            this.name\n          );\n          this._onError!({\n            error: translatedError,\n            errorSource: \"complete\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host\n          });\n        }\n      }\n    };\n  }\n\n  private _getHandlers(): ReceiverHandlers {\n    return {\n      onMessage: (context: EventContext) =>\n        this._onAmqpMessage(context).catch(() => {\n          /* */\n        }),\n      onClose: (context: EventContext) =>\n        this._onAmqpClose(context).catch(() => {\n          /* */\n        }),\n      onSessionClose: (context: EventContext) =>\n        this._onSessionClose(context).catch(() => {\n          /* */\n        }),\n      onError: this._onAmqpError,\n      onSessionError: this._onSessionError\n    };\n  }\n\n  async stopReceivingMessages(): Promise<void> {\n    await this._receiverHelper.suspend();\n  }\n\n  /**\n   * Initializes the link. This method will retry infinitely until a connection is established.\n   *\n   * The retries are broken up into cycles. For each cycle we do a set of retries, using the user's\n   * configured retryOptions. If that retry call fails we will report the error and then go into a\n   * new cycle, repeating the retries the same as before.\n   *\n   * It is completely up to the user to break out of this retry cycle in their error handler by either:\n   * 1. closing the receiver\n   * 2. Calling `close` on the subscription instance they received when they initially called subscribe().\n   * 3. aborting the abortSignal they passed in when calling subscribe (this does not apply in onDetached, however)\n   */\n  async init(\n    args: { useNewName: boolean; connectionId: string; onError: OnError } & Pick<\n      OperationOptionsBase,\n      \"abortSignal\"\n    >\n  ) {\n    let numRetryCycles = 0;\n\n    while (true) {\n      ++numRetryCycles;\n\n      const config: RetryConfig<void> = {\n        operation: () => this._initOnce(args),\n        connectionId: args.connectionId,\n        operationType: RetryOperationType.receiverLink,\n        // even though we're going to loop infinitely we allow them to control the pattern we use on each\n        // retry run. This lets them toggle things like exponential retries, etc..\n        retryOptions: this._retryOptions,\n        abortSignal: args.abortSignal\n      };\n\n      try {\n        await this._retry<void>(config);\n        break;\n      } catch (err) {\n        // we only report the error here - this avoids spamming the user with too many\n        // redundant reports of errors while still providing them incremental status on failures.\n        args.onError({\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n          error: err\n        });\n\n        // if the user aborts the operation we're immediately done.\n        if (err.name === \"AbortError\") {\n          throw err;\n        }\n\n        logger.logError(\n          err,\n          `${this.logPrefix} Error thrown in retry cycle ${numRetryCycles}, restarting retry cycle with retry options`,\n          this._retryOptions\n        );\n\n        continue;\n      }\n    }\n  }\n\n  private async _initOnce(args: {\n    useNewName: boolean;\n    abortSignal?: AbortSignalLike;\n  }): Promise<void> {\n    const options = this._createReceiverOptions(args.useNewName, this._getHandlers());\n    await this._init(options, args.abortSignal);\n\n    // this might seem odd but in reality this entire class is like one big function call that\n    // results in a receive(). Once we're being initialized we should consider ourselves the\n    // \"owner\" of the receiver and that it's now being locked into being the actual receiver.\n    this._receiverHelper.resume();\n  }\n\n  /**\n   * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.\n   *\n   * @param {OnMessage} onMessage The message handler to receive servicebus messages.\n   * @param {OnError} onError The error handler to receive an error that occurs while receivin messages.\n   */\n  subscribe(onMessage: OnMessage, onError: OnError): void {\n    throwErrorIfConnectionClosed(this._context);\n\n    this._onMessage = onMessage;\n    this._onError = onError;\n\n    this._receiverHelper.addCredit(this.maxConcurrentCalls);\n  }\n\n  /**\n   * Will reconnect the receiver link if necessary.\n   * @param receiverError The receiver error or connection error, if any.\n   * @returns {Promise<void>} Promise<void>.\n   */\n  async onDetached(receiverError?: AmqpError | Error): Promise<void> {\n    logger.verbose(`${this.logPrefix} onDetached: reinitializing link.`);\n\n    // User explicitly called `close` on the receiver, so link is already closed\n    // and we can exit early.\n    if (this.wasClosedPermanently) {\n      logger.verbose(\n        `${this.logPrefix} onDetached: link has been closed permanently, not reinitializing. `\n      );\n      return;\n    }\n\n    // Prevent multiple onDetached invocations from running concurrently.\n    if (this._isDetaching) {\n      // This can happen when the network connection goes down for some amount of time.\n      // The first connection `disconnect` will trigger `onDetached` and attempt to retry\n      // creating the connection/receiver link.\n      // While those retry attempts fail (until the network connection comes back up),\n      // we'll continue to see connection `disconnect` errors.\n      // These should be ignored until the already running `onDetached` completes\n      // its retry attempts or errors.\n      logger.verbose(\n        `${this.logPrefix} onDetached: Call to detached on streaming receiver '${this.name}' is already in progress.`\n      );\n      return;\n    }\n\n    this._isDetaching = true;\n\n    const translatedError = receiverError ? translateServiceBusError(receiverError) : receiverError;\n    logger.logError(\n      translatedError,\n      `${this.logPrefix} onDetached: Reinitializing receiver because of error`\n    );\n\n    try {\n      // Clears the token renewal timer. Closes the link and its session if they are open.\n      // Removes the link and its session if they are present in rhea's cache.\n      await this.closeLink();\n    } catch (err) {\n      logger.verbose(\n        `${this.logPrefix} onDetached: Encountered an error when closing the previous link: `,\n        err\n      );\n    }\n\n    try {\n      await this.init({\n        // provide a new name to the link while re-connecting it. This ensures that\n        // the service does not send an error stating that the link is still open.\n        useNewName: true,\n        connectionId: this._context.connectionId,\n        onError: (args) => this._onError && this._onError(args)\n      });\n\n      this._receiverHelper.addCredit(this.maxConcurrentCalls);\n      logger.verbose(\n        `${this.logPrefix} onDetached: link has been reestablished, added ${this.maxConcurrentCalls} credits.`\n      );\n    } finally {\n      this._isDetaching = false;\n    }\n  }\n}\n"]}