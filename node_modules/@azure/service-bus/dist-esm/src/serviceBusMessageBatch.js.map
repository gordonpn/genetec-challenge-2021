{"version":3,"file":"serviceBusMessageBatch.js","sourceRoot":"","sources":["../../src/serviceBusMessageBatch.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  ServiceBusMessage,\n  toRheaMessage,\n  getMessagePropertyTypeMismatchError\n} from \"./serviceBusMessage\";\nimport { throwIfNotValidServiceBusMessage, throwTypeErrorIfParameterMissing } from \"./util/errors\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport {\n  MessageAnnotations,\n  messageProperties as RheaMessagePropertiesList,\n  message as RheaMessageUtil,\n  Message as RheaMessage\n} from \"rhea-promise\";\nimport { SpanContext } from \"@opentelemetry/api\";\nimport {\n  instrumentServiceBusMessage,\n  TRACEPARENT_PROPERTY\n} from \"./diagnostics/instrumentServiceBusMessage\";\nimport { createMessageSpan } from \"./diagnostics/messageSpan\";\nimport { TryAddOptions } from \"./modelsToBeSharedWithEventHubs\";\nimport { defaultDataTransformer } from \"./dataTransformer\";\n\n/**\n * @internal\n * @hidden\n * The amount of bytes to reserve as overhead for a small message.\n */\nconst smallMessageOverhead = 5;\n/**\n * @internal\n * @hidden\n * The amount of bytes to reserve as overhead for a large message.\n */\nconst largeMessageOverhead = 8;\n/**\n * @internal\n * @hidden\n * The maximum number of bytes that a message may be to be considered small.\n */\nconst smallMessageMaxBytes = 255;\n\n/**\n * A batch of messages that you can create using the {@link createBatch} method.\n *\n * @export\n */\nexport interface ServiceBusMessageBatch {\n  /**\n   * Size of the batch in bytes after the events added to it have been encoded into a single AMQP\n   * message.\n   * @readonly\n   */\n  readonly sizeInBytes: number;\n\n  /**\n   * Number of messages added to the batch.\n   * @readonly\n   */\n  readonly count: number;\n\n  /**\n   * The maximum size of the batch, in bytes. The `tryAddMessage` function on the batch will return `false`\n   * if the message being added causes the size of the batch to exceed this limit. Use the `createMessageBatch()` method on\n   * the `Sender` to set the maxSizeInBytes.\n   * @readonly.\n   */\n  readonly maxSizeInBytes: number;\n\n  /**\n   * Adds a message to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param message  An individual service bus message.\n   * @returns A boolean value indicating if the message has been added to the batch or not.\n   */\n  tryAddMessage(message: ServiceBusMessage, options?: TryAddOptions): boolean;\n\n  /**\n   * The AMQP message containing encoded events that were added to the batch.\n   * Used internally by the `sendBatch()` method on the `Sender`.\n   * This is not meant for the user to use directly.\n   *\n   * @readonly\n   * @internal\n   * @hidden\n   */\n  _generateMessage(): Buffer;\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * Used internally by the `sendBatch()` method to set up the right spans in traces if tracing is enabled.\n   * @internal\n   * @hidden\n   */\n  readonly _messageSpanContexts: SpanContext[];\n}\n\n/**\n * An internal class representing a batch of messages which can be used to send messages to Service Bus.\n *\n * @class\n * @internal\n * @hidden\n */\nexport class ServiceBusMessageBatchImpl implements ServiceBusMessageBatch {\n  /**\n   * @property Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * @property Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: SpanContext[] = [];\n  /**\n   * ServiceBusMessageBatch should not be constructed using `new ServiceBusMessageBatch()`\n   * Use the `createBatch()` method on your `Sender` instead.\n   * @constructor\n   * @internal\n   * @hidden\n   */\n  constructor(private _context: ConnectionContext, private _maxSizeInBytes: number) {\n    this._sizeInBytes = 0;\n    this._batchMessageProperties = {};\n  }\n\n  /**\n   * @property The maximum size of the batch, in bytes.\n   * @readonly\n   */\n  get maxSizeInBytes(): number {\n    return this._maxSizeInBytes;\n  }\n\n  /**\n   * @property Size of the `ServiceBusMessageBatch` instance after the messages added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * @property Number of messages in the `ServiceBusMessageBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._encodedMessages.length;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding messages to the batch.\n   * @internal\n   * @hidden\n   */\n  get _messageSpanContexts(): SpanContext[] {\n    return this._spanContexts;\n  }\n\n  /**\n   * Generates an AMQP message that contains the provided encoded messages and annotations.\n   *\n   * @private\n   * @param {Buffer[]} encodedMessages The already encoded messages to include in the AMQP batch.\n   * @param {MessageAnnotations} [annotations] The message annotations to set on the batch.\n   * @param {{ [key: string]: any }} [applicationProperties] The application properties to set on the batch.\n   * @param {{ [key: string]: string }} [messageProperties] The message properties to set on the batch.\n   * @returns {Buffer}\n   * @memberof ServiceBusMessageBatchImpl\n   */\n  private _generateBatch(\n    encodedMessages: Buffer[],\n    annotations?: MessageAnnotations,\n    applicationProperties?: { [key: string]: any },\n    messageProperties?: { [key: string]: string }\n  ): Buffer {\n    const batchEnvelope: RheaMessage = {\n      body: RheaMessageUtil.data_sections(encodedMessages),\n      message_annotations: annotations,\n      application_properties: applicationProperties\n    };\n    if (messageProperties) {\n      for (const prop of RheaMessagePropertiesList) {\n        if ((messageProperties as any)[prop]) {\n          (batchEnvelope as any)[prop] = (messageProperties as any)[prop];\n        }\n      }\n    }\n    return RheaMessageUtil.encode(batchEnvelope);\n  }\n\n  /**\n   * @property Represents the single AMQP message which is the result of encoding all the events\n   * added into the `ServiceBusMessageBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `ServiceBusMessageBatch` instance is passed to the `sendBatch()` method on the `Sender`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  _generateMessage(): Buffer {\n    return this._generateBatch(\n      this._encodedMessages,\n      this._batchAnnotations,\n      this._batchApplicationProperties,\n      this._batchMessageProperties\n    );\n  }\n\n  /**\n   * The message annotations to apply on the batch envelope.\n   * This will reflect the message annotations on the first message\n   * that was added to the batch.\n   */\n  private _batchAnnotations?: MessageAnnotations;\n  /**\n   * The message properties to apply on the batch envelope.\n   * This will reflect the message properties on the first message\n   * that was added to the batch.\n   */\n  private _batchMessageProperties?: { [key: string]: string };\n  /**\n   * The application properties to apply on the batch envelope.\n   * This will reflect the application properties on the first message\n   * that was added to the batch.\n   */\n  private _batchApplicationProperties?: { [key: string]: any };\n\n  /**\n   * Tries to add a message to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next message.\n   *\n   * @param message  An individual service bus message.\n   * @returns A boolean value indicating if the message has been added to the batch or not.\n   */\n  public tryAddMessage(message: ServiceBusMessage, options: TryAddOptions = {}): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"message\", message);\n    throwIfNotValidServiceBusMessage(\n      message,\n      \"Provided value for 'message' must be of type ServiceBusMessage.\"\n    );\n\n    // check if the event has already been instrumented\n    const previouslyInstrumented = Boolean(\n      message.applicationProperties && message.applicationProperties[TRACEPARENT_PROPERTY]\n    );\n    let spanContext: SpanContext | undefined;\n    if (!previouslyInstrumented) {\n      const messageSpan = createMessageSpan(options?.parentSpan, this._context.config);\n      message = instrumentServiceBusMessage(message, messageSpan);\n      spanContext = messageSpan.context();\n      messageSpan.end();\n    }\n\n    // Convert ServiceBusMessage to AmqpMessage.\n    const amqpMessage = toRheaMessage(message);\n    amqpMessage.body = defaultDataTransformer.encode(message.body);\n\n    let encodedMessage: Buffer;\n    try {\n      encodedMessage = RheaMessageUtil.encode(amqpMessage);\n    } catch (error) {\n      if (error instanceof TypeError || error.name === \"TypeError\") {\n        throw getMessagePropertyTypeMismatchError(message) || error;\n      }\n      throw error;\n    }\n\n    let currentSize = this._sizeInBytes;\n\n    // The first time an event is added, we need to calculate\n    // the overhead of creating an AMQP batch, including the\n    // message_annotations, application_properties and message_properties\n    // that are taken from the 1st message.\n    if (this.count === 0) {\n      if (amqpMessage.message_annotations) {\n        this._batchAnnotations = amqpMessage.message_annotations;\n      }\n      if (amqpMessage.application_properties) {\n        this._batchApplicationProperties = amqpMessage.application_properties;\n      }\n      for (const prop of RheaMessagePropertiesList) {\n        if ((amqpMessage as any)[prop]) {\n          (this._batchMessageProperties as any)[prop] = (amqpMessage as any)[prop];\n        }\n      }\n      // Figure out the overhead of creating a batch by generating an empty batch\n      // with the expected batch annotations.\n      currentSize += this._generateBatch(\n        [],\n        this._batchAnnotations,\n        this._batchApplicationProperties,\n        this._batchMessageProperties\n      ).length;\n    }\n\n    const messageSize = encodedMessage.length;\n    const messageOverhead =\n      messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;\n    currentSize += messageSize + messageOverhead;\n    // Check if the size of the batch exceeds the maximum allowed size\n    // once we add the new event to it.\n    if (currentSize > this._maxSizeInBytes) {\n      return false;\n    }\n\n    // The message will fit in the batch, so it is now safe to store it.\n    this._encodedMessages.push(encodedMessage);\n    if (spanContext) {\n      this._spanContexts.push(spanContext);\n    }\n\n    this._sizeInBytes = currentSize;\n    return true;\n  }\n}\n"]}