'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var coreAmqp = require('@azure/core-amqp');
var tslib = require('tslib');
var coreAuth = require('@azure/core-auth');
var coreHttp = require('@azure/core-http');
var logger$1 = require('@azure/logger');
var buffer = require('buffer');
var Long = _interopDefault(require('long'));
var rheaPromise = require('rhea-promise');
var isBuffer = _interopDefault(require('is-buffer'));
var abortController = require('@azure/abort-controller');
var jssha = _interopDefault(require('jssha'));
var crypto = _interopDefault(require('crypto'));
var coreTracing = require('@azure/core-tracing');
var api = require('@opentelemetry/api');
var os = require('os');
require('@azure/core-asynciterator-polyfill');

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 * This will output logs using the `azure:service-bus` namespace prefix.
 * @internal
 * @hidden
 */
const logger = createServiceBusLogger("service-bus");
/**
 * Logging for ServiceBusReceivers of any type (session, non-session)
 * @internal
 * @hidden
 */
const receiverLogger = createServiceBusLogger("service-bus:receiver");
/**
 * Logging for ServiceBusSenders
 * @internal
 * @hidden
 */
const senderLogger = createServiceBusLogger("service-bus:sender");
/**
 * Logging for connection management
 * @internal
 * @hidden
 */
const connectionLogger = createServiceBusLogger("service-bus:connection");
/**
 * Logging for the ServiceBusAdministrationClient
 * @internal
 * @hidden
 */
const administrationLogger = createServiceBusLogger("service-bus:administration");
/**
 * Logging related to message encoding/decoding.
 * @internal
 * @hidden
 */
const messageLogger = createServiceBusLogger("service-bus:messages");
/**
 * Logging related to message encoding/decoding.
 * @internal
 * @hidden
 */
const managementClientLogger = createServiceBusLogger("service-bus:management");
/**
 * Logs the error's stack trace to "verbose" if a stack trace is available.
 * @param error Error containing a stack trace.
 * @internal
 * @hidden
 */
function logErrorStackTrace(_logger, error) {
    if (error && error.stack) {
        _logger.verbose(error.stack);
    }
}
/**
 * Creates an AzureLogger with any additional methods for standardized logging (for example, with errors)
 * @internal
 * @hidden
 */
function createServiceBusLogger(namespace) {
    const _logger = logger$1.createClientLogger(namespace);
    _logger["logError"] = (err, ...args) => {
        let l;
        // abort errors are user initiated so we don't have to treat them as warnings, like we
        // would with other errors.
        if (isError(err) && err.name === "AbortError") {
            l = _logger.info;
        }
        else {
            l = _logger.warning;
        }
        // tack on the error object so it also gets logged.
        args.push(":", err);
        // let the normal formatting work and include the error at the end.
        l(...args);
        // optionally log the stack trace if it's available but this always goes to verbose
        if (err && err.stack) {
            _logger.verbose(err.stack);
        }
    };
    return _logger;
}
/**
 * @internal
 * @hidden
 */
function isError(err) {
    return err != null && err.name != null;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * @hidden
 */
const packageJsonInfo = {
    name: "@azure/service-bus",
    version: "7.0.3"
};
/**
 * @internal
 * @hidden
 */
const max32BitNumber = Math.pow(2, 31) - 1;
/**
 * Queue name identifier
 * @internal
 * @hidden
 */
const QUEUE_NAME = "QueueName";
/**
 * Topic name identifier
 * @internal
 * @hidden
 */
const TOPIC_NAME = "TopicName";
/**
 * Subscription name identifier
 * @internal
 * @hidden
 */
const SUBSCRIPTION_NAME = "SubscriptionName";
/**
 * Accessed at field
 * @internal
 * @hidden
 */
const ACCESSED_AT = "AccessedAt";
/**
 * Updated at field
 * @internal
 * @hidden
 */
const UPDATED_AT = "UpdatedAt";
/**
 * Created at field
 * @internal
 * @hidden
 */
const CREATED_AT = "CreatedAt";
/**
 * Authorization rules on the entity
 * @internal
 * @hidden
 */
const AUTHORIZATION_RULES = "AuthorizationRules";
/**
 * Entity Availability Status field
 * @internal
 * @hidden
 */
const ENTITY_AVAILABILITY_STATUS = "EntityAvailabilityStatus";
/**
 * Enable express option
 * @internal
 * @hidden
 */
const ENABLE_EXPRESS = "EnableExpress";
/**
 * The entity's size in bytes.
 *
 * @internal
 * @hidden
 */
const SIZE_IN_BYTES = "SizeInBytes";
/**
 * The entity's message count.
 *
 * @internal
 * @hidden
 */
const MESSAGE_COUNT = "MessageCount";
/**
 * The topic's subscription count.
 *
 * @internal
 * @hidden
 */
const SUBSCRIPTION_COUNT = "SubscriptionCount";
/**
 * The topic / subscription's count details.
 *
 * @internal
 * @hidden
 */
const COUNT_DETAILS = "CountDetails";
/**
 * Max idle time before entity is deleted.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 * @hidden
 */
const AUTO_DELETE_ON_IDLE = "AutoDeleteOnIdle";
/**
 * The status information on response
 *
 * @internal
 * @hidden
 */
const STATUS = "Status";
/**
 * The URL of Service Bus entity to forward messages to.
 *
 * @internal
 * @hidden
 */
const FORWARD_TO = "ForwardTo";
/**
 * The user meta data information
 *
 * @internal
 * @hidden
 */
const USER_METADATA = "UserMetadata";
/**
 * The maximum size in megabytes.
 *
 * @internal
 * @hidden
 */
const MAX_SIZE_IN_MEGABYTES = "MaxSizeInMegabytes";
/**
 * The default message time to live.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 * @hidden
 */
const DEFAULT_MESSAGE_TIME_TO_LIVE = "DefaultMessageTimeToLive";
/**
 * The lock duration.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 * @hidden
 */
const LOCK_DURATION = "LockDuration";
/**
 * The indication if session is required or not.
 *
 * @internal
 * @hidden
 */
const REQUIRES_SESSION = "RequiresSession";
/**
 * The indication if duplicate detection is required or not.
 *
 * @internal
 * @hidden
 */
const REQUIRES_DUPLICATE_DETECTION = "RequiresDuplicateDetection";
/**
 * The indication if dead lettering on message expiration. If it is enabled and a message expires,
 * the Service Bus moves the message from the queue into the entity dead-letter sub-queue.
 * If disabled, message will be permanently deleted from the main entity.
 * Settable only at entity creation time.
 *
 * @internal
 * @hidden
 */
const DEAD_LETTERING_ON_MESSAGE_EXPIRATION = "DeadLetteringOnMessageExpiration";
/**
 * The indication if dead lettering on filter evaluation exceptions.
 *
 * @internal
 * @hidden
 */
const DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS = "DeadLetteringOnFilterEvaluationExceptions";
/**
 * The history time window for duplicate detection.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 * @hidden
 */
const DUPLICATE_DETECTION_HISTORY_TIME_WINDOW = "DuplicateDetectionHistoryTimeWindow";
/**
 * The maximum delivery count of messages after which if it is still not settled, gets moved to the dead-letter sub-queue.
 *
 * @internal
 * @hidden
 */
const MAX_DELIVERY_COUNT = "MaxDeliveryCount";
/**
 * Indicates if the queue has enabled batch operations.
 *
 * @internal
 * @hidden
 */
const ENABLE_BATCHED_OPERATIONS = "EnableBatchedOperations";
/**
 * Indicates whether the topic can be ordered
 *
 * @internal
 * @hidden
 */
const SUPPORT_ORDERING = "SupportOrdering";
/**
 * Indicates whether the topic/queue should be split across multiple partitions
 *
 * @internal
 * @hidden
 */
const ENABLE_PARTITIONING = "EnablePartitioning";
/**
 * The URL of Service Bus entity to forward deadlettered messages to.
 *
 * @internal
 * @hidden
 */
const FORWARD_DEADLETTERED_MESSAGES_TO = "ForwardDeadLetteredMessagesTo";
/**
 * Query string parameter to set Service Bus API version
 *
 * @internal
 * @hidden
 */
const API_VERSION_QUERY_KEY = "api-version";
/**
 * Current API version being sent to service bus
 *
 * @internal
 * @hidden
 */
const CURRENT_API_VERSION = "2017-04";
/**
 * Marker for atom metadata.
 *
 * @internal
 * @hidden
 */
const XML_METADATA_MARKER = "$";
/**
 * Marker for atom value.
 *
 * @internal
 * @hidden
 */
const XML_VALUE_MARKER = "_";
/**
 * Constant representing the property where the atom default elements are stored.
 *
 * @internal
 * @hidden
 */
const ATOM_METADATA_MARKER = "_";
/**
 * Known HTTP status codes as documented and referenced in ATOM based management API feature
 * https://docs.microsoft.com/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
 * @internal
 * @hidden
 */
const HttpResponseCodes = {
    100: "Continue",
    101: "SwitchingProtocols",
    200: "Ok",
    201: "Created",
    202: "Accepted",
    203: "NonAuthoritativeInformation",
    204: "NoContent",
    205: "ResetContent",
    206: "PartialContent",
    300: "MultipleChoices",
    301: "Moved",
    302: "Redirect",
    303: "RedirectMethod",
    304: "NotModified",
    305: "UseProxy",
    306: "Unused",
    400: "BadRequest",
    401: "Unauthorized",
    402: "PaymentRequired",
    403: "Forbidden",
    404: "NotFound",
    405: "MethodNotAllowed",
    406: "NotAcceptable",
    407: "ProxyAuthenticationRequired",
    409: "Conflict",
    410: "Gone",
    411: "LengthRequired",
    412: "PreconditionFailed",
    413: "RequestEntityTooLarge",
    414: "RequestUriTooLong",
    415: "UnsupportedMediaType",
    416: "RequestRangeNotSatisfiable",
    417: "ExpectationFailed",
    426: "UpgradeRequired",
    500: "InternalServerError",
    501: "NotImplemented",
    502: "BadGateway",
    503: "ServiceUnavailable",
    504: "GatewayTimeout",
    505: "HttpVersionNotSupported"
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 * @hidden
 */
const url = require("url");
/**
 * @internal
 * @hidden
 * @param {string} rawUrl
 */
const parseURL = (rawUrl) => {
    return new url.URL(rawUrl);
};

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Provides a uniue name by appending a string guid to the given string in the following format:
 * `{name}-{uuid}`.
 * @param name The nme of the entity
 */
function getUniqueName(name) {
    return `${name}-${rheaPromise.generate_uuid()}`;
}
/**
 * @internal
 * @hidden
 * If you try to turn a Guid into a Buffer in .NET, the bytes of the first three groups get
 * flipped within the group, but the last two groups don't get flipped, so we end up with a
 * different byte order. This is the order of bytes needed to make Service Bus recognize the token.
 *
 * @param lockToken The lock token whose bytes need to be reorded.
 * @returns Buffer - Buffer representing reordered bytes.
 */
function reorderLockToken(lockTokenBytes) {
    if (!lockTokenBytes || !buffer.Buffer.isBuffer(lockTokenBytes)) {
        return lockTokenBytes;
    }
    return buffer.Buffer.from([
        lockTokenBytes[3],
        lockTokenBytes[2],
        lockTokenBytes[1],
        lockTokenBytes[0],
        lockTokenBytes[5],
        lockTokenBytes[4],
        lockTokenBytes[7],
        lockTokenBytes[6],
        lockTokenBytes[8],
        lockTokenBytes[9],
        lockTokenBytes[10],
        lockTokenBytes[11],
        lockTokenBytes[12],
        lockTokenBytes[13],
        lockTokenBytes[14],
        lockTokenBytes[15]
    ]);
}
/**
 * @internal
 * @hidden
 * Provides the time in milliseconds after which the lock renewal should occur.
 * @param lockedUntilUtc - The time until which the message is locked.
 */
function calculateRenewAfterDuration(lockedUntilUtc) {
    const now = Date.now();
    const lockedUntil = lockedUntilUtc.getTime();
    const remainingTime = lockedUntil - now;
    receiverLogger.verbose("Locked until utc  : %d", lockedUntil);
    receiverLogger.verbose("Current time is   : %d", now);
    receiverLogger.verbose("Remaining time is : %d", remainingTime);
    if (remainingTime < 1000) {
        return 0;
    }
    const buffer = Math.min(remainingTime / 2, 10000); // 10 seconds
    const renewAfter = remainingTime - buffer;
    receiverLogger.verbose("Renew after       : %d", renewAfter);
    return renewAfter;
}
/**
 * @internal
 * @hidden
 * Converts the .net ticks to a JS Date object.
 *
 * - The epoch for the DateTimeOffset type is `0000-01-01`, while the epoch for JS Dates is
 * `1970-01-01`.
 * - The DateTimeOffset ticks value for the date `1970-01-01` is `621355968000000000`.
 *   - Hence, to convert it to the JS epoch; we `subtract` the delta from the given value.
 * - Ticks in DateTimeOffset is `1/10000000` second, while ticks in JS Date is `1/1000` second.
 *   - Thus, we `divide` the value by `10000` to convert it to JS Date ticks.
 *
 * @param buf Input as a Buffer
 * @returns Date The JS Date object.
 */
function convertTicksToDate(buf) {
    const epochMicroDiff = 621355968000000000;
    const longValue = Long.fromBytesBE(buf);
    const timeInMS = longValue
        .sub(epochMicroDiff)
        .div(10000)
        .toNumber();
    const result = new Date(timeInMS);
    logger.verbose("The converted date is: %s", result.toString());
    return result;
}
/**
 * @internal
 * @hidden
 * Converts any given input to a Buffer.
 * @param input The input that needs to be converted to a Buffer.
 */
function toBuffer(input) {
    let result;
    messageLogger.verbose("[utils.toBuffer] The given message body that needs to be converted to buffer is: ", input);
    if (isBuffer(input)) {
        result = input;
    }
    else {
        // string, undefined, null, boolean, array, object, number should end up here
        // coercing undefined to null as that will ensure that null value will be given to the
        // customer on receive.
        if (input === undefined)
            input = null;
        try {
            const inputStr = JSON.stringify(input);
            result = buffer.Buffer.from(inputStr, "utf8");
        }
        catch (err) {
            const msg = `An error occurred while executing JSON.stringify() on the given input ` +
                input +
                `${err instanceof Error ? err.stack : JSON.stringify(err)}`;
            messageLogger.warning("[utils.toBuffer] " + msg);
            throw err instanceof Error ? err : new Error(msg);
        }
    }
    messageLogger.verbose("[utils.toBuffer] The converted buffer is: %O.", result);
    return result;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `string` value from given string,
 * or throws error if undefined.
 * @param value
 */
function getString(value, nameOfProperty) {
    const result = getStringOrUndefined(value);
    if (result == undefined) {
        throw new Error(`"${nameOfProperty}" received from service expected to be a string value and not undefined.`);
    }
    return result;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `string` value from given input,
 * or undefined if not passed in.
 * @param value
 */
function getStringOrUndefined(value) {
    if (value == undefined) {
        return undefined;
    }
    return value.toString();
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `integer` value from given string,
 * or throws error if undefined.
 * @param value
 */
function getInteger(value, nameOfProperty) {
    const result = getIntegerOrUndefined(value);
    if (result == undefined) {
        throw new Error(`"${nameOfProperty}" received from service expected to be a number value and not undefined.`);
    }
    return result;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `integer` value from given string,
 * or undefined if not passed in.
 * @param value
 */
function getIntegerOrUndefined(value) {
    if (value == undefined) {
        return undefined;
    }
    const result = parseInt(value.toString());
    return result == NaN ? undefined : result;
}
/**
 * @internal
 * @hidden
 * Helper utility to convert ISO-8601 time into Date type.
 * @param value
 */
function getDate(value, nameOfProperty) {
    return new Date(getString(value, nameOfProperty));
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `boolean` value from given string,
 * or throws error if undefined.
 * @param value
 */
function getBoolean(value, nameOfProperty) {
    const result = getBooleanOrUndefined(value);
    if (result == undefined) {
        throw new Error(`"${nameOfProperty}" received from service expected to be a boolean value and not undefined.`);
    }
    return result;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `boolean` value from given string,
 * or undefined if not passed in.
 * @param value
 */
function getBooleanOrUndefined(value) {
    if (value == undefined) {
        return undefined;
    }
    return (value
        .toString()
        .trim()
        .toLowerCase() === "true");
}
/**
 * @internal
 * @hidden
 * Helps in differentiating JSON like objects from other kinds of objects.
 */
const EMPTY_JSON_OBJECT_CONSTRUCTOR = {}.constructor;
/**
 * @internal
 * @hidden
 * Returns `true` if given input is a JSON like object.
 * @param value
 */
function isJSONLikeObject(value) {
    // `value.constructor === {}.constructor` differentiates among the "object"s,
    //    would filter the JSON objects and won't match any array or other kinds of objects
    // -------------------------------------------------------------------------------
    // Few examples       | typeof obj ==="object" |  obj.constructor==={}.constructor
    // -------------------------------------------------------------------------------
    // {abc:1}            | true                   | true
    // ["a","b"]          | true                   | false
    // [{"a":1},{"b":2}]  | true                   | false
    // new Date()         | true                   | false
    // 123                | false                  | false
    // -------------------------------------------------------------------------------
    return typeof value === "object" && value.constructor === EMPTY_JSON_OBJECT_CONSTRUCTOR;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve message count details from given input,
 * @param value
 */
function getMessageCountDetails(value) {
    const xmlnsPrefix = getXMLNSPrefix(value);
    if (value == undefined) {
        value = {};
    }
    return {
        activeMessageCount: parseInt(value[`${xmlnsPrefix}:ActiveMessageCount`]) || 0,
        deadLetterMessageCount: parseInt(value[`${xmlnsPrefix}:DeadLetterMessageCount`]) || 0,
        scheduledMessageCount: parseInt(value[`${xmlnsPrefix}:ScheduledMessageCount`]) || 0,
        transferMessageCount: parseInt(value[`${xmlnsPrefix}:TransferMessageCount`]) || 0,
        transferDeadLetterMessageCount: parseInt(value[`${xmlnsPrefix}:TransferDeadLetterMessageCount`]) || 0
    };
}
/**
 * @internal
 * @hidden
 * Gets the xmlns prefix from the root of the objects that are part of the parsed response body.
 */
function getXMLNSPrefix(value) {
    if (!value[XML_METADATA_MARKER]) {
        throw new Error(`Error occurred while parsing the response body - cannot find the XML_METADATA_MARKER "$" on the object ${JSON.stringify(value)}`);
    }
    const keys = Object.keys(value[XML_METADATA_MARKER]);
    if (keys.length !== 1) {
        throw new Error(`Error occurred while parsing the response body - unexpected number of "xmlns:\${prefix}" keys at ${JSON.stringify(value[XML_METADATA_MARKER])}`);
    }
    if (!keys[0].startsWith("xmlns:")) {
        throw new Error(`Error occurred while parsing the response body - unexpected key at ${JSON.stringify(value[XML_METADATA_MARKER])}`);
    }
    // Pick the substring that's after "xmlns:"
    const xmlnsPrefix = keys[0].substring(6);
    if (!xmlnsPrefix) {
        throw new Error(`Error occurred while parsing the response body - unexpected xmlns prefix at ${JSON.stringify(value[XML_METADATA_MARKER])}`);
    }
    return xmlnsPrefix;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve array of `AuthorizationRule` from given input,
 * or undefined if not passed in.
 * @param value
 */
function getAuthorizationRulesOrUndefined(value) {
    const authorizationRules = [];
    // Ignore special case as Service Bus treats "" as a valid value for authorization rules
    if (typeof value === "string" && value.trim() === "") {
        return undefined;
    }
    if (value == undefined) {
        return undefined;
    }
    const rawAuthorizationRules = value.AuthorizationRule;
    if (Array.isArray(rawAuthorizationRules)) {
        for (let i = 0; i < rawAuthorizationRules.length; i++) {
            authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules[i]));
        }
    }
    else {
        authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules));
    }
    return authorizationRules;
}
/**
 * @internal
 * @hidden
 * Helper utility to build an instance of parsed authorization rule as `AuthorizationRule` from given input.
 * @param value
 */
function buildAuthorizationRule(value) {
    let accessRights;
    if (value["Rights"] != undefined) {
        accessRights = value["Rights"]["AccessRights"];
    }
    const authorizationRule = {
        claimType: value["ClaimType"],
        accessRights,
        keyName: value["KeyName"],
        primaryKey: value["PrimaryKey"],
        secondaryKey: value["SecondaryKey"]
    };
    if (authorizationRule.accessRights && !Array.isArray(authorizationRule.accessRights)) {
        authorizationRule.accessRights = [authorizationRule.accessRights];
    }
    return authorizationRule;
}
/**
 * @internal
 * @hidden
 * Helper utility to extract output containing array of `RawAuthorizationRule` instances from given input,
 * or undefined if not passed in.
 * @param value
 */
function getRawAuthorizationRules(authorizationRules) {
    if (authorizationRules == undefined) {
        return undefined;
    }
    if (!Array.isArray(authorizationRules)) {
        throw new TypeError(`authorizationRules must be an array of AuthorizationRule objects or undefined, but received ${JSON.stringify(authorizationRules, undefined, 2)}`);
    }
    const rawAuthorizationRules = [];
    for (let i = 0; i < authorizationRules.length; i++) {
        rawAuthorizationRules.push(buildRawAuthorizationRule(authorizationRules[i]));
    }
    return { AuthorizationRule: rawAuthorizationRules };
}
/**
 * @internal
 * @hidden
 * Helper utility to build an instance of raw authorization rule as RawAuthorizationRule from given `AuthorizationRule` input.
 * @param authorizationRule parsed Authorization Rule instance
 */
function buildRawAuthorizationRule(authorizationRule) {
    if (!isJSONLikeObject(authorizationRule) || authorizationRule === null) {
        throw new TypeError(`Expected authorizationRule input to be a JS object value, but received ${JSON.stringify(authorizationRule, undefined, 2)}`);
    }
    const rawAuthorizationRule = {
        ClaimType: authorizationRule.claimType,
        // ClaimValue is not settable by the users, but service expects the value for PUT requests
        ClaimValue: "None",
        Rights: {
            AccessRights: authorizationRule.accessRights
        },
        KeyName: authorizationRule.keyName,
        PrimaryKey: authorizationRule.primaryKey,
        SecondaryKey: authorizationRule.secondaryKey
    };
    rawAuthorizationRule[XML_METADATA_MARKER] = {
        "p5:type": "SharedAccessAuthorizationRule",
        "xmlns:p5": "http://www.w3.org/2001/XMLSchema-instance"
    };
    return rawAuthorizationRule;
}
/**
 * @internal
 * @hidden
 * Helper utility to check if given string is an absolute URL
 * @param url
 */
function isAbsoluteUrl(url) {
    const _url = url.toLowerCase();
    return _url.startsWith("sb://") || _url.startsWith("http://") || _url.startsWith("https://");
}
/**
 * @internal
 * @hidden
 */
const StandardAbortMessage = "The operation was aborted.";
/**
 * An executor for a function that returns a Promise that obeys both a timeout and an
 * optional AbortSignal.
 * @param timeoutMs - The number of milliseconds to allow before throwing an OperationTimeoutError.
 * @param timeoutMessage - The message to place in the .description field for the thrown exception for Timeout.
 * @param abortSignal - The abortSignal associated with containing operation.
 * @param abortErrorMsg - The abort error message associated with containing operation.
 * @param value - The value to be resolved with after a timeout of t milliseconds.
 * @returns {Promise<T>} - Resolved promise
 *
 * @internal
 * @hidden
 */
function waitForTimeoutOrAbortOrResolve(args) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        if (args.abortSignal && args.abortSignal.aborted) {
            throw new abortController.AbortError(StandardAbortMessage);
        }
        let timer = undefined;
        let clearAbortSignal = undefined;
        const clearAbortSignalAndTimer = () => {
            var _a, _b;
            ((_b = (_a = args.timeoutFunctions) === null || _a === void 0 ? void 0 : _a.clearTimeoutFn) !== null && _b !== void 0 ? _b : clearTimeout)(timer);
            if (clearAbortSignal) {
                clearAbortSignal();
            }
        };
        // eslint-disable-next-line promise/param-names
        const abortOrTimeoutPromise = new Promise((_resolve, reject) => {
            var _a, _b;
            clearAbortSignal = checkAndRegisterWithAbortSignal(reject, args.abortSignal);
            timer = ((_b = (_a = args.timeoutFunctions) === null || _a === void 0 ? void 0 : _a.setTimeoutFn) !== null && _b !== void 0 ? _b : setTimeout)(() => {
                reject(new rheaPromise.OperationTimeoutError(args.timeoutMessage));
            }, args.timeoutMs);
        });
        try {
            return yield Promise.race([abortOrTimeoutPromise, args.actionFn()]);
        }
        finally {
            clearAbortSignalAndTimer();
        }
    });
}
/**
 * Registers listener to the abort event on the abortSignal to call your abortFn and
 * returns a function that will clear the same listener.
 *
 * If abort signal is already aborted, then throws an AbortError and returns a function that does nothing
 *
 * @returns A function that removes any of our attached event listeners on the abort signal or an empty function if
 * the abortSignal was not defined.
 *
 * @internal
 * @hidden
 */
function checkAndRegisterWithAbortSignal(onAbortFn, abortSignal) {
    if (abortSignal == null) {
        return () => { };
    }
    if (abortSignal.aborted) {
        throw new abortController.AbortError(StandardAbortMessage);
    }
    const onAbort = () => {
        abortSignal.removeEventListener("abort", onAbort);
        onAbortFn(new abortController.AbortError(StandardAbortMessage));
    };
    abortSignal.addEventListener("abort", onAbort);
    return () => abortSignal.removeEventListener("abort", onAbort);
}
/**
 * @internal
 * @hidden
 * @property {string} libInfo The user agent prefix string for the ServiceBus client.
 * See guideline at https://azure.github.io/azure-sdk/general_azurecore.html#telemetry-policy
 */
const libInfo = `azsdk-js-azureservicebus/${packageJsonInfo.version}`;
/**
 * @internal
 * @hidden
 * Returns the formatted prefix by removing the spaces, by appending the libInfo.
 *
 * @param {string} [prefix]
 * @returns {string}
 */
function formatUserAgentPrefix(prefix) {
    let userAgentPrefix = `${(prefix || "").replace(" ", "")}`;
    userAgentPrefix = userAgentPrefix.length > 0 ? userAgentPrefix + " " : "";
    return `${userAgentPrefix}${libInfo}`;
}
/**
 * @internal
 * @hidden
 * Helper method which returns `HttpResponse` from an object of shape `HttpOperationResponse`.
 * @returns {HttpResponse}
 */
const getHttpResponseOnly = ({ request, status, headers }) => ({
    request,
    status,
    headers
});

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Utility to execute Atom XML operations as HTTP requests
 * @param webResource
 * @param serializer
 */
function executeAtomXmlOperation(serviceBusAtomManagementClient, webResource, serializer, operationOptions) {
    var _a, _b, _c, _d, _e;
    return tslib.__awaiter(this, void 0, void 0, function* () {
        if (webResource.body) {
            const content = serializer.serialize(webResource.body);
            webResource.body = coreHttp.stringifyXML(content, { rootName: "entry" });
        }
        if (webResource.method == "PUT") {
            webResource.headers.set("content-length", buffer.Buffer.byteLength(webResource.body));
        }
        administrationLogger.verbose(`Executing ATOM based HTTP request: ${webResource.body}`);
        const reqPrepareOptions = Object.assign(Object.assign({}, webResource), { headers: (_a = operationOptions.requestOptions) === null || _a === void 0 ? void 0 : _a.customHeaders, onUploadProgress: (_b = operationOptions.requestOptions) === null || _b === void 0 ? void 0 : _b.onUploadProgress, onDownloadProgress: (_c = operationOptions.requestOptions) === null || _c === void 0 ? void 0 : _c.onDownloadProgress, abortSignal: operationOptions.abortSignal, spanOptions: (_d = operationOptions.tracingOptions) === null || _d === void 0 ? void 0 : _d.spanOptions, disableJsonStringifyOnBody: true });
        webResource = webResource.prepare(reqPrepareOptions);
        webResource.timeout = ((_e = operationOptions.requestOptions) === null || _e === void 0 ? void 0 : _e.timeout) || 0;
        const response = yield serviceBusAtomManagementClient.sendRequest(webResource);
        administrationLogger.verbose(`Received ATOM based HTTP response: ${response.bodyAsText}`);
        try {
            if (response.bodyAsText) {
                response.parsedBody = yield coreHttp.parseXML(response.bodyAsText, { includeRoot: true });
            }
        }
        catch (err) {
            const error = new coreHttp.RestError(`Error occurred while parsing the response body - expected the service to return valid xml content.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
            administrationLogger.logError(err, "Error parsing response body from Service");
            throw error;
        }
        return serializer.deserialize(response);
    });
}
/**
 * @internal
 * @hidden
 * The key-value pairs having undefined/null as the values would lead to the empty tags in the serialized XML request.
 * Empty tags in the request body is problematic because of the following reasons.
 * - ATOM based management operations throw a "Bad Request" error if empty tags are included in the XML request body at top level.
 * - At the inner levels, Service assigns the empty strings as values to the empty tags instead of throwing an error.
 *
 * This method recursively removes the key-value pairs with undefined/null as the values from the request object that is to be serialized.
 *
 * @param {{ [key: string]: any }} resource
 */
function sanitizeSerializableObject(resource) {
    Object.keys(resource).forEach(function (property) {
        if (resource[property] == undefined) {
            delete resource[property];
        }
        else if (isJSONLikeObject(resource[property])) {
            sanitizeSerializableObject(resource[property]);
        }
    });
}
/**
 * @internal
 * @hidden
 * Serializes input information to construct the Atom XML request
 * @param resourceName Name of the resource to be serialized like `QueueDescription`
 * @param resource The entity details
 * @param allowedProperties The set of properties that are allowed by the service for the
 * associated operation(s);
 */
function serializeToAtomXmlRequest(resourceName, resource) {
    const content = {};
    content[resourceName] = Object.assign({}, resource);
    sanitizeSerializableObject(content[resourceName]);
    content[resourceName][XML_METADATA_MARKER] = {
        xmlns: "http://schemas.microsoft.com/netservices/2010/10/servicebus/connect",
        "xmlns:i": "http://www.w3.org/2001/XMLSchema-instance"
    };
    content[XML_METADATA_MARKER] = { type: "application/xml" };
    const requestDetails = {
        updated: new Date().toISOString(),
        content: content
    };
    requestDetails[XML_METADATA_MARKER] = {
        xmlns: "http://www.w3.org/2005/Atom"
    };
    return requestDetails;
}
/**
 * @internal
 * @hidden
 * Transforms response to contain the parsed data.
 * @param nameProperties The set of 'name' properties to be constructed on the
 * resultant object e.g., QueueName, TopicName, etc.
 * @param response
 * @param shouldParseResponse
 */
function deserializeAtomXmlResponse(nameProperties, response) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        // If received data is a non-valid HTTP response, the body is expected to contain error information
        if (response.status < 200 || response.status >= 300) {
            throw buildError(response);
        }
        parseAtomResult(response, nameProperties);
        return response;
    });
}
/**
 * @internal
 * @hidden
 * Utility to deserialize the given JSON content in response body based on
 * if it's a single `entry` or `feed` and updates the `response.parsedBody` to hold the evaluated output.
 * @param response Response containing the JSON value in `response.parsedBody`
 * @nameProperties The set of 'name' properties to be constructed on the
 * resultant object e.g., QueueName, TopicName, etc.
 * */
function parseAtomResult(response, nameProperties) {
    const atomResponseInJson = response.parsedBody;
    let result;
    if (!atomResponseInJson) {
        response.parsedBody = undefined;
        return;
    }
    if (atomResponseInJson.feed) {
        result = parseFeedResult(atomResponseInJson.feed);
    }
    else if (atomResponseInJson.entry) {
        result = parseEntryResult(atomResponseInJson.entry);
    }
    if (result) {
        if (Array.isArray(result)) {
            result.forEach((entry) => {
                setName(entry, nameProperties);
            });
        }
        else {
            setName(result, nameProperties);
        }
        response.parsedBody = result;
        return;
    }
    administrationLogger.warning("Failure in parsing response body from service. Expected response to be in Atom XML format and have either feed or entry components, but received - %0", atomResponseInJson);
    throw new coreHttp.RestError("Error occurred while parsing the response body - expected the service to return atom xml content with either feed or entry elements.", coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
}
/**
 * @internal
 * @hidden
 * Utility to help parse given `entry` result
 * @param entry
 */
function parseEntryResult(entry) {
    let result;
    if (typeof entry !== "object" ||
        entry == null ||
        typeof entry.content !== "object" ||
        entry.content == null) {
        return undefined;
    }
    const contentElementNames = Object.keys(entry.content).filter(function (key) {
        return key !== XML_METADATA_MARKER;
    });
    if (contentElementNames && contentElementNames[0]) {
        const contentRootElementName = contentElementNames[0];
        delete entry.content[contentRootElementName][XML_METADATA_MARKER];
        result = entry.content[contentRootElementName];
        if (result) {
            if (entry[XML_METADATA_MARKER]) {
                result[ATOM_METADATA_MARKER] = entry[XML_METADATA_MARKER];
            }
            else {
                result[ATOM_METADATA_MARKER] = {};
            }
            result[ATOM_METADATA_MARKER]["ContentRootElement"] = contentRootElementName;
            Object.keys(entry).forEach((property) => {
                if (property !== "content" && property !== XML_METADATA_MARKER) {
                    result[ATOM_METADATA_MARKER][property] = entry[property];
                }
            });
            return result;
        }
    }
    return undefined;
}
/**
 * @internal
 * @hidden
 * Utility to help parse link info from the given `feed` result
 * @param feedLink
 */
function parseLinkInfo(feedLink, relationship) {
    if (!feedLink || !Array.isArray(feedLink)) {
        return undefined;
    }
    for (const linkInfo of feedLink) {
        if (linkInfo[XML_METADATA_MARKER].rel === relationship) {
            return linkInfo[XML_METADATA_MARKER].href;
        }
    }
    return undefined;
}
/**
 * @internal
 * @hidden
 * Utility to help parse given `feed` result
 * @param feed
 */
function parseFeedResult(feed) {
    const result = [];
    if (typeof feed === "object" && feed != null && feed.entry) {
        if (Array.isArray(feed.entry)) {
            feed.entry.forEach((entry) => {
                const parsedEntryResult = parseEntryResult(entry);
                if (parsedEntryResult) {
                    result.push(parsedEntryResult);
                }
            });
        }
        else {
            const parsedEntryResult = parseEntryResult(feed.entry);
            if (parsedEntryResult) {
                result.push(parsedEntryResult);
            }
        }
        result.nextLink = parseLinkInfo(feed.link, "next");
    }
    return result;
}
/**
 * @internal
 * @hidden
 * @param {number} statusCode
 * @returns {statusCode is keyof typeof Constants.HttpResponseCodes}
 */
function isKnownResponseCode(statusCode) {
    return !!HttpResponseCodes[statusCode];
}
/**
 * @internal
 * @hidden
 * Extracts the applicable entity name(s) from the URL based on the known structure
 * and instantiates the corresponding name properties to the deserialized response
 *
 * The pattern matching checks to extract entity names are based on following
 * constraints dictated by the service
 * - '/' is allowed in Queue and Topic names
 * - '/' is not allowed in Namespace, Subscription and Rule names
 * - Valid pathname URL structures used in the ATOM based management API are
 *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>/Rules/<rule-name>`
 *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>`
 *     - `<namespace-component>/<any-entity-name>`
 *
 * @param entry
 * @param nameProperties
 */
function setName(entry, nameProperties) {
    if (entry[ATOM_METADATA_MARKER]) {
        let rawUrl = entry[ATOM_METADATA_MARKER].id;
        // The parsedUrl gets constructed differently for browser vs Node.
        // It is specifically behaves different for some of the Atom based management API where
        // the received URL in "id" element is of type "sb:// ... " and not a standard HTTP one
        // Hence, normalizing the URL for parsing to work as expected in browser
        if (rawUrl.startsWith("sb://")) {
            rawUrl = "https://" + rawUrl.substring(5);
        }
        const parsedUrl = parseURL(rawUrl);
        const pathname = parsedUrl.pathname;
        const firstIndexOfDelimiter = pathname.indexOf("/");
        if (pathname.match("(.*)/(.*)/Subscriptions/(.*)/Rules/(.*)")) {
            const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf("/Subscriptions/");
            const firstIndexOfRulesDelimiter = pathname.indexOf("/Rules/");
            entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1, lastIndexOfSubscriptionsDelimiter);
            entry[nameProperties[1]] = pathname.substring(lastIndexOfSubscriptionsDelimiter + 15, firstIndexOfRulesDelimiter);
            entry[nameProperties[2]] = pathname.substring(firstIndexOfRulesDelimiter + 7);
        }
        else if (pathname.match("(.*)/(.*)/Subscriptions/(.*)")) {
            const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf("/Subscriptions/");
            entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1, lastIndexOfSubscriptionsDelimiter);
            entry[nameProperties[1]] = pathname.substring(lastIndexOfSubscriptionsDelimiter + 15);
        }
        else if (pathname.match("(.*)/(.*)")) {
            entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1);
        }
    }
}
/**
 * @internal
 * @hidden
 * Utility to help construct the normalized `RestError` object based on given error
 * information and other data present in the received `response` object.
 * @param response
 */
function buildError(response) {
    if (!isKnownResponseCode(response.status)) {
        throw new coreHttp.RestError(`Service returned an error response with an unrecognized HTTP status code - ${response.status}`, "ServiceError", response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
    }
    const errorBody = response.parsedBody;
    let errorMessage;
    if (typeof errorBody === "string") {
        errorMessage = errorBody;
    }
    else {
        if (errorBody == undefined ||
            errorBody.Error == undefined ||
            errorBody.Error.Detail == undefined) {
            errorMessage =
                "Detailed error message information not available. Look at the 'code' property on error for more information.";
        }
        else {
            errorMessage = errorBody.Error.Detail;
        }
    }
    const errorCode = getErrorCode(response, errorMessage);
    const error = new coreHttp.RestError(errorMessage, errorCode, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
    return error;
}
/**
 * @internal
 * @hidden
 * Helper utility to construct user friendly error codes based on based on given error
 * information and other data present in the received `response` object.
 * @param response
 * @param errorMessage
 */
function getErrorCode(response, errorMessage) {
    if (response.status == 401) {
        return "UnauthorizedRequestError";
    }
    if (response.status == 404) {
        return "MessageEntityNotFoundError";
    }
    if (response.status == 409) {
        if (response.request.method == "DELETE") {
            return "ServiceError";
        }
        if (response.request.method == "PUT" && response.request.headers.get("If-Match") == "*") {
            return "ServiceError";
        }
        if (errorMessage && errorMessage.toLowerCase().includes("subcode=40901")) {
            return "ServiceError";
        }
        return "MessageEntityAlreadyExistsError";
    }
    if (response.status == 403) {
        if (errorMessage && errorMessage.toLowerCase().includes("subcode=40301")) {
            return "InvalidOperationError";
        }
        return "QuotaExceededError";
    }
    if (response.status == 400) {
        return "ServiceError";
    }
    if (response.status == 503) {
        return "ServerBusyError";
    }
    return HttpResponseCodes[response.status];
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Builds the namespace object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawNamespace
 */
function buildNamespace(rawNamespace) {
    const messagingSku = (getString(rawNamespace["MessagingSKU"], "messagingSku"));
    return {
        createdAt: getDate(rawNamespace["CreatedTime"], "createdAt"),
        messagingSku: messagingSku,
        modifiedAt: getDate(rawNamespace["ModifiedTime"], "modifiedAt"),
        name: getString(rawNamespace["Name"], "name"),
        messagingUnits: messagingSku === "Premium"
            ? getInteger(rawNamespace["MessagingUnits"], "messagingUnits")
            : undefined
    };
}
/**
 * @internal
 * @hidden
 * Atom XML Serializer for Namespaces.
 */
class NamespaceResourceSerializer {
    serialize() {
        return serializeToAtomXmlRequest("NamespaceProperties", {});
    }
    deserialize(response) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return deserializeAtomXmlResponse(["name"], response);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Builds the queue options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 * @param queue
 */
function buildQueueOptions(queue) {
    return {
        LockDuration: queue.lockDuration,
        MaxSizeInMegabytes: getStringOrUndefined(queue.maxSizeInMegabytes),
        RequiresDuplicateDetection: getStringOrUndefined(queue.requiresDuplicateDetection),
        RequiresSession: getStringOrUndefined(queue.requiresSession),
        DefaultMessageTimeToLive: queue.defaultMessageTimeToLive,
        DeadLetteringOnMessageExpiration: getStringOrUndefined(queue.deadLetteringOnMessageExpiration),
        DuplicateDetectionHistoryTimeWindow: queue.duplicateDetectionHistoryTimeWindow,
        MaxDeliveryCount: getStringOrUndefined(queue.maxDeliveryCount),
        EnableBatchedOperations: getStringOrUndefined(queue.enableBatchedOperations),
        AuthorizationRules: getRawAuthorizationRules(queue.authorizationRules),
        Status: getStringOrUndefined(queue.status),
        AutoDeleteOnIdle: getStringOrUndefined(queue.autoDeleteOnIdle),
        EnablePartitioning: getStringOrUndefined(queue.enablePartitioning),
        ForwardDeadLetteredMessagesTo: getStringOrUndefined(queue.forwardDeadLetteredMessagesTo),
        ForwardTo: getStringOrUndefined(queue.forwardTo),
        UserMetadata: getStringOrUndefined(queue.userMetadata),
        EntityAvailabilityStatus: getStringOrUndefined(queue.availabilityStatus),
        EnableExpress: getStringOrUndefined(queue.enableExpress)
    };
}
/**
 * @internal
 * @hidden
 * Builds the queue object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawQueue
 */
function buildQueue(rawQueue) {
    return {
        name: getString(rawQueue[QUEUE_NAME], "queueName"),
        forwardTo: getStringOrUndefined(rawQueue[FORWARD_TO]),
        userMetadata: rawQueue[USER_METADATA],
        lockDuration: getString(rawQueue[LOCK_DURATION], "lockDuration"),
        maxSizeInMegabytes: getInteger(rawQueue[MAX_SIZE_IN_MEGABYTES], "maxSizeInMegabytes"),
        maxDeliveryCount: getInteger(rawQueue[MAX_DELIVERY_COUNT], "maxDeliveryCount"),
        enablePartitioning: getBoolean(rawQueue[ENABLE_PARTITIONING], "enablePartitioning"),
        requiresSession: getBoolean(rawQueue[REQUIRES_SESSION], "requiresSession"),
        enableBatchedOperations: getBoolean(rawQueue[ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
        defaultMessageTimeToLive: getString(rawQueue[DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTimeToLive"),
        autoDeleteOnIdle: rawQueue[AUTO_DELETE_ON_IDLE],
        requiresDuplicateDetection: getBoolean(rawQueue[REQUIRES_DUPLICATE_DETECTION], "requiresDuplicateDetection"),
        duplicateDetectionHistoryTimeWindow: getString(rawQueue[DUPLICATE_DETECTION_HISTORY_TIME_WINDOW], "duplicateDetectionHistoryTimeWindow"),
        deadLetteringOnMessageExpiration: getBoolean(rawQueue[DEAD_LETTERING_ON_MESSAGE_EXPIRATION], "deadLetteringOnMessageExpiration"),
        forwardDeadLetteredMessagesTo: getStringOrUndefined(rawQueue[FORWARD_DEADLETTERED_MESSAGES_TO]),
        authorizationRules: getAuthorizationRulesOrUndefined(rawQueue[AUTHORIZATION_RULES]),
        status: rawQueue[STATUS],
        enableExpress: getBoolean(rawQueue[ENABLE_EXPRESS], "enableExpress"),
        availabilityStatus: rawQueue[ENTITY_AVAILABILITY_STATUS]
    };
}
/**
 * @internal
 * @hidden
 * Builds the queue runtime info object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawQueue
 */
function buildQueueRuntimeProperties(rawQueue) {
    const messageCountDetails = getMessageCountDetails(rawQueue[COUNT_DETAILS]);
    return Object.assign(Object.assign({ name: getString(rawQueue[QUEUE_NAME], "queueName"), sizeInBytes: getIntegerOrUndefined(rawQueue[SIZE_IN_BYTES]), totalMessageCount: getIntegerOrUndefined(rawQueue[MESSAGE_COUNT]) }, messageCountDetails), { createdAt: getDate(rawQueue[CREATED_AT], "createdAt"), modifiedAt: getDate(rawQueue[UPDATED_AT], "modifiedAt"), accessedAt: getDate(rawQueue[ACCESSED_AT], "accessedAt") });
}
/**
 * @internal
 * @hidden
 * Atom XML Serializer for Queues.
 */
class QueueResourceSerializer {
    serialize(resource) {
        return serializeToAtomXmlRequest("QueueDescription", resource);
    }
    deserialize(response) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return deserializeAtomXmlResponse(["QueueName"], response);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Builds the rule object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawRule
 */
function buildRule(rawRule) {
    return {
        name: getString(rawRule["RuleName"], "ruleName"),
        filter: getTopicFilter(rawRule["Filter"]),
        action: getRuleAction(rawRule["Action"])
    };
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `filter` value from given input,
 * or undefined if not passed in.
 * @param value
 */
function getTopicFilter(value) {
    let result;
    if (value["SqlExpression"] != undefined) {
        result = {
            sqlExpression: value["SqlExpression"],
            sqlParameters: getKeyValuePairsOrUndefined(value["Parameters"], "SQLParameters")
        };
    }
    else {
        result = {
            correlationId: getStringOrUndefined(value["CorrelationId"]),
            subject: getStringOrUndefined(value["Label"]),
            to: getStringOrUndefined(value["To"]),
            replyTo: getStringOrUndefined(value["ReplyTo"]),
            replyToSessionId: getStringOrUndefined(value["ReplyToSessionId"]),
            sessionId: getStringOrUndefined(value["SessionId"]),
            messageId: getStringOrUndefined(value["MessageId"]),
            contentType: getStringOrUndefined(value["ContentType"]),
            applicationProperties: getKeyValuePairsOrUndefined(value["Properties"], "ApplicationProperties")
        };
    }
    return result;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve rule `action` value from given input.
 * @param value
 */
function getRuleAction(value) {
    return {
        sqlExpression: value["SqlExpression"],
        sqlParameters: getKeyValuePairsOrUndefined(value["Parameters"], "SQLParameters")
    };
}
/**
 * @internal
 * @hidden
 *
 * @param {CreateRuleOptions} rule
 */
function buildInternalRuleResource(rule) {
    const resource = {
        Filter: {},
        Action: {},
        Name: rule.name
    };
    if (rule.filter == undefined) {
        // Defaults to creating a true filter if none specified
        resource.Filter = {
            SqlExpression: "1=1"
        };
        resource.Filter[XML_METADATA_MARKER] = {
            "p4:type": "SqlFilter",
            "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
        };
    }
    else {
        if (rule.filter.hasOwnProperty("sqlExpression")) {
            const sqlFilter = rule.filter;
            resource.Filter = {
                SqlExpression: sqlFilter.sqlExpression,
                Parameters: buildInternalRawKeyValuePairs(sqlFilter.sqlParameters, "sqlParameters")
            };
            resource.Filter[XML_METADATA_MARKER] = {
                "p4:type": "SqlFilter",
                "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
            };
        }
        else {
            const correlationFilter = rule.filter;
            resource.Filter = {
                CorrelationId: correlationFilter.correlationId,
                Label: correlationFilter.subject,
                To: correlationFilter.to,
                ReplyTo: correlationFilter.replyTo,
                ReplyToSessionId: correlationFilter.replyToSessionId,
                ContentType: correlationFilter.contentType,
                SessionId: correlationFilter.sessionId,
                MessageId: correlationFilter.messageId,
                Properties: buildInternalRawKeyValuePairs(correlationFilter.applicationProperties, "applicationProperties")
            };
            resource.Filter[XML_METADATA_MARKER] = {
                "p4:type": "CorrelationFilter",
                "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
            };
        }
    }
    if (rule.action == undefined || rule.action.sqlExpression == undefined) {
        // Defaults to creating an empty rule action instance if none specified
        resource.Action = {};
        resource.Action[XML_METADATA_MARKER] = {
            "p4:type": "EmptyRuleAction",
            "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
        };
    }
    else {
        resource.Action = {
            SqlExpression: rule.action.sqlExpression,
            Parameters: buildInternalRawKeyValuePairs(rule.action.sqlParameters, "sqlParameters")
        };
        resource.Action[XML_METADATA_MARKER] = {
            "p4:type": "SqlRuleAction",
            "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
        };
    }
    return resource;
}
/**
 * @internal
 * @hidden
 * RuleResourceSerializer for serializing / deserializing Rule entities
 */
class RuleResourceSerializer {
    serialize(rule) {
        return serializeToAtomXmlRequest("RuleDescription", buildInternalRuleResource(rule));
    }
    deserialize(response) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return deserializeAtomXmlResponse(["TopicName", "SubscriptionName", "RuleName"], response);
        });
    }
}
/**
 * @internal
 * @hidden
 */
function isSqlRuleAction(action) {
    return action != null && typeof action === "object" && "sqlExpression" in action;
}
/**
 * Service expects the XML request with the special type names serialized in the request,
 * the request would fail otherwise.
 *
 * @internal
 * @hidden
 */
var TypeMapForRequestSerialization;
(function (TypeMapForRequestSerialization) {
    TypeMapForRequestSerialization["double"] = "l28:double";
    TypeMapForRequestSerialization["string"] = "l28:string";
    TypeMapForRequestSerialization["long"] = "l28:long";
    TypeMapForRequestSerialization["date"] = "l28:dateTime";
    TypeMapForRequestSerialization["boolean"] = "l28:boolean";
})(TypeMapForRequestSerialization || (TypeMapForRequestSerialization = {}));
/**
 * @internal
 * @hidden
 */
var TypeMapForResponseDeserialization;
(function (TypeMapForResponseDeserialization) {
    TypeMapForResponseDeserialization["int"] = "int";
    TypeMapForResponseDeserialization["double"] = "double";
    TypeMapForResponseDeserialization["string"] = "string";
    TypeMapForResponseDeserialization["boolean"] = "boolean";
    TypeMapForResponseDeserialization["date"] = "dateTime";
})(TypeMapForResponseDeserialization || (TypeMapForResponseDeserialization = {}));
/**
 * Key-value pairs are supposed to be wrapped with this tag in the XML request, they are ignored otherwise.
 *
 * @internal
 * @hidden
 */
const keyValuePairXMLTag = "KeyValueOfstringanyType";
/**
 * @internal
 * @hidden
 * Helper utility to retrieve the key-value pairs from the RawKeyValue object from given input,
 * or undefined if not passed in.
 * @param value
 */
function getKeyValuePairsOrUndefined(value, attribute) {
    var _a;
    if (!value) {
        return undefined;
    }
    const properties = {};
    let rawProperties;
    if (!Array.isArray(value[keyValuePairXMLTag]) && ((_a = value[keyValuePairXMLTag]) === null || _a === void 0 ? void 0 : _a.Key)) {
        // When a single property is present,
        //    value["KeyValueOfstringanyType"] is { Key: <key>, Value: [Object] }
        // When multiple properties are present,
        //    value["KeyValueOfstringanyType"] is [ { Key: <key-1>, Value: [Object] }, { Key: <key-2>, Value: [Object] } ]
        // For consistency, wrapping `value["KeyValueOfstringanyType"]` as an array for the "single property" case.
        rawProperties = [value[keyValuePairXMLTag]];
    }
    else {
        rawProperties = value[keyValuePairXMLTag];
    }
    if (Array.isArray(rawProperties)) {
        for (const rawProperty of rawProperties) {
            const key = rawProperty.Key;
            const value = rawProperty.Value["_"];
            const encodedValueType = rawProperty.Value["$"]["i:type"].toString().substring(5);
            if (encodedValueType === TypeMapForResponseDeserialization.int ||
                encodedValueType === TypeMapForResponseDeserialization.double) {
                properties[key] = Number(value);
            }
            else if (encodedValueType === TypeMapForResponseDeserialization.string) {
                properties[key] = value;
            }
            else if (encodedValueType === TypeMapForResponseDeserialization.boolean) {
                properties[key] = value === "true" ? true : false;
            }
            else if (encodedValueType === TypeMapForResponseDeserialization.date) {
                properties[key] = new Date(value);
            }
            else {
                throw new TypeError(`Unable to parse the key-value pairs in the response - ${JSON.stringify(rawProperty)}`);
            }
        }
    }
    else {
        throw new TypeError(`${attribute} in the response is not an array, unable to parse the response - ${JSON.stringify(value)}`);
    }
    return properties;
}
/**
 * @internal
 * @hidden
 * Helper utility to extract array of user properties key-value instances from given input,
 * or undefined if not passed in.
 * @param value
 */
function buildInternalRawKeyValuePairs(parameters, attribute) {
    if (parameters == undefined) {
        return undefined;
    }
    if (Array.isArray(parameters) ||
        typeof parameters === "string" ||
        typeof parameters !== "object" ||
        Object.entries(parameters).length < 1) {
        throw new TypeError(`Unsupported value for the ${attribute} ${JSON.stringify(parameters)}, expected a JSON object with key-value pairs.`);
    }
    const rawParameters = [];
    for (let [key, value] of Object.entries(parameters)) {
        let type;
        if (typeof value === "number") {
            type = TypeMapForRequestSerialization.double;
        }
        else if (typeof value === "string") {
            type = TypeMapForRequestSerialization.string;
        }
        else if (typeof value === "boolean") {
            type = TypeMapForRequestSerialization.boolean;
        }
        else if (value instanceof Date && !isNaN(value.valueOf())) {
            type = TypeMapForRequestSerialization.date;
            value = value.toJSON();
        }
        else {
            throw new TypeError(`Unsupported type for the value in the ${attribute} for the key '${key}'`);
        }
        const rawParameter = {
            Key: key,
            Value: {
                [XML_METADATA_MARKER]: {
                    "p4:type": type,
                    "xmlns:l28": "http://www.w3.org/2001/XMLSchema"
                },
                [XML_VALUE_MARKER]: value
            }
        };
        rawParameters.push(rawParameter);
    }
    return {
        [keyValuePairXMLTag]: rawParameters
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Builds the subscription options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 * @param subscription
 */
function buildSubscriptionOptions(subscription) {
    return {
        LockDuration: subscription.lockDuration,
        RequiresSession: getStringOrUndefined(subscription.requiresSession),
        DefaultMessageTimeToLive: getStringOrUndefined(subscription.defaultMessageTimeToLive),
        DeadLetteringOnMessageExpiration: getStringOrUndefined(subscription.deadLetteringOnMessageExpiration),
        DeadLetteringOnFilterEvaluationExceptions: getStringOrUndefined(subscription.deadLetteringOnFilterEvaluationExceptions),
        DefaultRuleDescription: subscription.defaultRuleOptions
            ? buildInternalRuleResource(subscription.defaultRuleOptions)
            : undefined,
        MaxDeliveryCount: getStringOrUndefined(subscription.maxDeliveryCount),
        EnableBatchedOperations: getStringOrUndefined(subscription.enableBatchedOperations),
        Status: getStringOrUndefined(subscription.status),
        ForwardTo: getStringOrUndefined(subscription.forwardTo),
        UserMetadata: getStringOrUndefined(subscription.userMetadata),
        ForwardDeadLetteredMessagesTo: getStringOrUndefined(subscription.forwardDeadLetteredMessagesTo),
        AutoDeleteOnIdle: getStringOrUndefined(subscription.autoDeleteOnIdle),
        EntityAvailabilityStatus: getStringOrUndefined(subscription.availabilityStatus)
    };
}
/**
 * @internal
 * @hidden
 * Builds the subscription object from the raw json object gotten after deserializing
 * the response from the service
 * @param rawSubscription
 */
function buildSubscription(rawSubscription) {
    return {
        subscriptionName: getString(rawSubscription[SUBSCRIPTION_NAME], "subscriptionName"),
        topicName: getString(rawSubscription[TOPIC_NAME], "topicName"),
        lockDuration: getString(rawSubscription[LOCK_DURATION], "lockDuration"),
        maxDeliveryCount: getInteger(rawSubscription[MAX_DELIVERY_COUNT], "maxDeliveryCount"),
        requiresSession: getBoolean(rawSubscription[REQUIRES_SESSION], "requiresSession"),
        enableBatchedOperations: getBoolean(rawSubscription[ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
        defaultMessageTimeToLive: getString(rawSubscription[DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTimeToLive"),
        autoDeleteOnIdle: getString(rawSubscription[AUTO_DELETE_ON_IDLE], "autoDeleteOnIdle"),
        deadLetteringOnMessageExpiration: getBoolean(rawSubscription[DEAD_LETTERING_ON_MESSAGE_EXPIRATION], "deadLetteringOnMessageExpiration"),
        deadLetteringOnFilterEvaluationExceptions: getBoolean(rawSubscription[DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS], "deadLetteringOnFilterEvaluationExceptions"),
        forwardDeadLetteredMessagesTo: getStringOrUndefined(rawSubscription[FORWARD_DEADLETTERED_MESSAGES_TO]),
        forwardTo: getStringOrUndefined(rawSubscription[FORWARD_TO]),
        userMetadata: rawSubscription[USER_METADATA],
        status: getString(rawSubscription[STATUS], "status"),
        availabilityStatus: getString(rawSubscription[ENTITY_AVAILABILITY_STATUS], "availabilityStatus")
    };
}
/**
 * @internal
 * @hidden
 * Builds the subscription runtime info object from the raw json object gotten after deserializing
 * the response from the service
 * @param rawSubscription
 */
function buildSubscriptionRuntimeProperties(rawSubscription) {
    const messageCountDetails = getMessageCountDetails(rawSubscription[COUNT_DETAILS]);
    return {
        subscriptionName: getString(rawSubscription[SUBSCRIPTION_NAME], "subscriptionName"),
        topicName: getString(rawSubscription[TOPIC_NAME], "topicName"),
        totalMessageCount: getInteger(rawSubscription[MESSAGE_COUNT], "messageCount"),
        activeMessageCount: messageCountDetails.activeMessageCount,
        deadLetterMessageCount: messageCountDetails.deadLetterMessageCount,
        transferDeadLetterMessageCount: messageCountDetails.transferDeadLetterMessageCount,
        transferMessageCount: messageCountDetails.transferMessageCount,
        createdAt: getDate(rawSubscription[CREATED_AT], "createdAt"),
        modifiedAt: getDate(rawSubscription[UPDATED_AT], "modifiedAt"),
        accessedAt: getDate(rawSubscription[ACCESSED_AT], "accessedAt")
    };
}
/**
 * @internal
 * @hidden
 * SubscriptionResourceSerializer for serializing / deserializing Subscription entities
 */
class SubscriptionResourceSerializer {
    serialize(resource) {
        return serializeToAtomXmlRequest("SubscriptionDescription", resource);
    }
    deserialize(response) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return deserializeAtomXmlResponse(["TopicName", "SubscriptionName"], response);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Builds the topic options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 * @param topic
 */
function buildTopicOptions(topic) {
    return {
        DefaultMessageTimeToLive: topic.defaultMessageTimeToLive,
        MaxSizeInMegabytes: getStringOrUndefined(topic.maxSizeInMegabytes),
        RequiresDuplicateDetection: getStringOrUndefined(topic.requiresDuplicateDetection),
        DuplicateDetectionHistoryTimeWindow: topic.duplicateDetectionHistoryTimeWindow,
        EnableBatchedOperations: getStringOrUndefined(topic.enableBatchedOperations),
        AuthorizationRules: getRawAuthorizationRules(topic.authorizationRules),
        Status: getStringOrUndefined(topic.status),
        UserMetadata: getStringOrUndefined(topic.userMetadata),
        SupportOrdering: getStringOrUndefined(topic.supportOrdering),
        AutoDeleteOnIdle: getStringOrUndefined(topic.autoDeleteOnIdle),
        EnablePartitioning: getStringOrUndefined(topic.enablePartitioning),
        EntityAvailabilityStatus: getStringOrUndefined(topic.availabilityStatus),
        EnableExpress: getStringOrUndefined(topic.enableExpress)
    };
}
/**
 * @internal
 * @hidden
 * Builds the topic object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawTopic
 */
function buildTopic(rawTopic) {
    return {
        name: getString(rawTopic[TOPIC_NAME], "topicName"),
        maxSizeInMegabytes: getInteger(rawTopic[MAX_SIZE_IN_MEGABYTES], "maxSizeInMegabytes"),
        enablePartitioning: getBoolean(rawTopic[ENABLE_PARTITIONING], "enablePartitioning"),
        supportOrdering: getBoolean(rawTopic[SUPPORT_ORDERING], "supportOrdering"),
        enableBatchedOperations: getBoolean(rawTopic[ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
        defaultMessageTimeToLive: getString(rawTopic[DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTimeToLive"),
        autoDeleteOnIdle: rawTopic[AUTO_DELETE_ON_IDLE],
        requiresDuplicateDetection: getBoolean(rawTopic[REQUIRES_DUPLICATE_DETECTION], "requiresDuplicateDetection"),
        duplicateDetectionHistoryTimeWindow: getString(rawTopic[DUPLICATE_DETECTION_HISTORY_TIME_WINDOW], "duplicateDetectionHistoryTimeWindow"),
        authorizationRules: getAuthorizationRulesOrUndefined(rawTopic[AUTHORIZATION_RULES]),
        userMetadata: rawTopic[USER_METADATA],
        status: rawTopic[STATUS],
        enableExpress: getBoolean(rawTopic[ENABLE_EXPRESS], "enableExpress"),
        availabilityStatus: rawTopic[ENTITY_AVAILABILITY_STATUS]
    };
}
/**
 * @internal
 * @hidden
 * Builds the topic runtime info object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawTopic
 */
function buildTopicRuntimeProperties(rawTopic) {
    return {
        name: getString(rawTopic[TOPIC_NAME], "topicName"),
        sizeInBytes: getIntegerOrUndefined(rawTopic[SIZE_IN_BYTES]),
        subscriptionCount: getIntegerOrUndefined(rawTopic[SUBSCRIPTION_COUNT]),
        createdAt: getDate(rawTopic[CREATED_AT], "createdAt"),
        scheduledMessageCount: getMessageCountDetails(rawTopic[COUNT_DETAILS])
            .scheduledMessageCount,
        modifiedAt: getDate(rawTopic[UPDATED_AT], "modifiedAt"),
        accessedAt: getDate(rawTopic[ACCESSED_AT], "accessedAt")
    };
}
/**
 * @internal
 * @hidden
 * TopicResourceSerializer for serializing / deserializing Topic entities
 */
class TopicResourceSerializer {
    serialize(resource) {
        return serializeToAtomXmlRequest("TopicDescription", resource);
    }
    deserialize(response) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return deserializeAtomXmlResponse(["TopicName"], response);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @class SharedKeyCredential
 * @internal
 * @hidden
 * Defines the SharedKeyCredential.
 */
class SharedKeyCredential {
    /**
     * Initializes a new instance of SharedKeyCredential
     * @constructor
     * @param {string} keyName - The name of the EventHub/ServiceBus key.
     * @param {string} key - The secret value associated with the above EventHub/ServiceBus key
     */
    constructor(keyName, key) {
        this.keyName = keyName;
        this.key = key;
    }
    /**
     * Gets the sas token for the specified audience
     * @param {string} [audience] - The audience for which the token is desired.
     */
    getToken(audience) {
        return this._createToken(Math.floor(Date.now() / 1000) + 3600, audience);
    }
    /**
     * Creates the sas token based on the provided information
     * @param {string | number} expiry - The time period in unix time after which the token will expire.
     * @param {string} [audience] - The audience for which the token is desired.
     * @param {string | Buffer} [hashInput] The input to be provided to hmac to create the hash.
     */
    _createToken(expiry, audience, hashInput) {
        audience = encodeURIComponent(audience);
        const keyName = encodeURIComponent(this.keyName);
        const stringToSign = audience + "\n" + expiry;
        hashInput = hashInput || this.key;
        let shaObj;
        if (isBuffer(hashInput)) {
            shaObj = new jssha("SHA-256", "ARRAYBUFFER");
            shaObj.setHMACKey(hashInput, "ARRAYBUFFER");
            shaObj.update(buffer.Buffer.from(stringToSign));
        }
        else {
            shaObj = new jssha("SHA-256", "TEXT");
            shaObj.setHMACKey(hashInput, "TEXT");
            shaObj.update(stringToSign);
        }
        const sig = encodeURIComponent(shaObj.getHMAC("B64"));
        return {
            token: `SharedAccessSignature sr=${audience}&sig=${sig}&se=${expiry}&skn=${keyName}`,
            expiresOnTimestamp: expiry
        };
    }
    /**
     * Creates a token provider from the EventHub/ServiceBus connection string;
     * @param {string} connectionString - The EventHub/ServiceBus connection string
     */
    static fromConnectionString(connectionString) {
        const parsed = coreAmqp.parseConnectionString(connectionString);
        if (parsed.SharedAccessSignature == null) {
            return new SharedKeyCredential(parsed.SharedAccessKeyName, parsed.SharedAccessKey);
        }
        else {
            return new SharedAccessSignatureCredential(parsed.SharedAccessSignature);
        }
    }
}
/**
 * A credential that takes a SharedAccessSignature:
 * `SharedAccessSignature sr=<resource>&sig=<signature>&se=<expiry>&skn=<keyname>`
 *
 * @internal
 * @hidden
 */
class SharedAccessSignatureCredential extends SharedKeyCredential {
    /**
     * @param sharedAccessSignature A shared access signature of the form
     * `SharedAccessSignature sr=<resource>&sig=<signature>&se=<expiry>&skn=<keyname>`
     */
    constructor(sharedAccessSignature) {
        super("", "");
        this._accessToken = {
            token: sharedAccessSignature,
            expiresOnTimestamp: 0
        };
    }
    /**
     * Retrieve a valid token for authenticaton.
     *
     * @param _audience Not applicable in SharedAccessSignatureCredential as the token is not re-generated at every invocation of the method
     */
    getToken(_audience) {
        return this._accessToken;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 */
function generateKey(secret, stringToSign) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const result = encodeURIComponent(crypto
            .createHmac("sha256", secret)
            .update(stringToSign)
            .digest("base64"));
        return result;
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * @class SasServiceClientCredentials
 * @implements {ServiceClientCredentials}
 */
class SasServiceClientCredentials {
    /**
     * Creates a new sasServiceClientCredentials object.
     *
     * @constructor
     * @param {string} sharedAccessKeyName The SAS key name to use.
     * @param {string} sharedAccessKey The SAS key value to use
     */
    constructor(sharedAccessKeyName, sharedAccessKey) {
        this.keyName = sharedAccessKeyName;
        this.keyValue = sharedAccessKey;
        this.sharedKeyCredential = new SharedKeyCredential(this.keyName, this.keyValue);
    }
    _generateSignature(targetUri, expirationDate) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const stringToSign = `${targetUri}\n${expirationDate}`;
            const result = yield generateKey(this.keyValue, stringToSign);
            return result;
        });
    }
    /**
     * Signs a request with the Authentication header.
     *
     * @param {WebResource} webResource The WebResource to be signed.
     * @returns {Promise<WebResource>} The signed request object.
     */
    signRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!webResource.headers)
                webResource.headers = new coreHttp.HttpHeaders();
            const targetUri = encodeURIComponent(webResource.url.toLowerCase()).toLowerCase();
            const date = new Date();
            date.setMinutes(date.getMinutes() + 5);
            const expirationDate = Math.round(date.getTime() / 1000);
            const signature = yield this._generateSignature(targetUri, expirationDate);
            webResource.headers.set("authorization", `SharedAccessSignature sig=${signature}&se=${expirationDate}&skn=${this.keyName}&sr=${targetUri}`);
            webResource.withCredentials = true;
            return webResource;
        });
    }
    getToken(audience) {
        return this.sharedKeyCredential.getToken(audience);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Creates a span using the global tracer.
 * @param name The name of the operation being performed.
 * @param operationOptions The options for the underlying http request.
 */
function createSpan(operationName, operationOptions = {}) {
    var _a, _b, _c;
    const tracer = coreTracing.getTracer();
    const spanOptions = Object.assign(Object.assign({}, (_a = operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.spanOptions), { kind: api.SpanKind.INTERNAL });
    const span = tracer.startSpan(`Azure.ServiceBus.${operationName}`, spanOptions);
    span.setAttribute("az.namespace", "Microsoft.ServiceBus");
    let newSpanOptions = ((_b = operationOptions.tracingOptions) === null || _b === void 0 ? void 0 : _b.spanOptions) || {};
    if (span.isRecording()) {
        newSpanOptions = Object.assign(Object.assign({}, (_c = operationOptions.tracingOptions) === null || _c === void 0 ? void 0 : _c.spanOptions), { parent: span.context(), attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.ServiceBus" }) });
    }
    return {
        span,
        updatedOperationOptions: Object.assign(Object.assign({}, operationOptions), { tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { spanOptions: newSpanOptions }) })
    };
}
/**
 * @internal
 * @hidden
 */
function getCanonicalCode(err) {
    if (err instanceof coreHttp.RestError) {
        switch (err.statusCode) {
            case 401:
                return api.CanonicalCode.PERMISSION_DENIED;
            case 404:
                return api.CanonicalCode.NOT_FOUND;
            case 412:
                return api.CanonicalCode.FAILED_PRECONDITION;
        }
    }
    return api.CanonicalCode.UNKNOWN;
}

// Copyright (c) Microsoft Corporation.
/**
 * All operations return promises that resolve to an object that has the relevant output.
 * These objects also have a property called `_response` that you can use if you want to
 * access the direct response from the service.
 */
class ServiceBusAdministrationClient extends coreHttp.ServiceClient {
    constructor(fullyQualifiedNamespaceOrConnectionString1, credentialOrOptions2, options3) {
        var _a;
        let options;
        let fullyQualifiedNamespace;
        let credentials;
        let authPolicy;
        if (coreAuth.isTokenCredential(credentialOrOptions2)) {
            fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;
            options = options3 || {};
            credentials = credentialOrOptions2;
            authPolicy = coreHttp.bearerTokenAuthenticationPolicy(credentials, coreAmqp.Constants.aadServiceBusScope);
        }
        else {
            const connectionString = fullyQualifiedNamespaceOrConnectionString1;
            options = credentialOrOptions2 || {};
            const connectionStringObj = coreAmqp.parseConnectionString(connectionString);
            if (connectionStringObj.Endpoint == undefined) {
                throw new Error("Missing Endpoint in connection string.");
            }
            try {
                fullyQualifiedNamespace = connectionStringObj.Endpoint.match(".*://([^/]*)")[1];
            }
            catch (error) {
                throw new Error("Endpoint in the connection string is not valid.");
            }
            credentials = new SasServiceClientCredentials(connectionStringObj.SharedAccessKeyName, connectionStringObj.SharedAccessKey);
            authPolicy = coreHttp.signingPolicy(credentials);
        }
        const userAgentPrefix = formatUserAgentPrefix((_a = options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix);
        const serviceClientOptions = coreHttp.createPipelineFromOptions(Object.assign(Object.assign({}, options), { userAgentOptions: {
                userAgentPrefix
            } }), authPolicy);
        super(credentials, serviceClientOptions);
        this.endpoint = fullyQualifiedNamespace;
        this.endpointWithProtocol = fullyQualifiedNamespace.endsWith("/")
            ? "sb://" + fullyQualifiedNamespace
            : "sb://" + fullyQualifiedNamespace + "/";
        this.credentials = credentials;
        this.namespaceResourceSerializer = new NamespaceResourceSerializer();
        this.queueResourceSerializer = new QueueResourceSerializer();
        this.topicResourceSerializer = new TopicResourceSerializer();
        this.subscriptionResourceSerializer = new SubscriptionResourceSerializer();
        this.ruleResourceSerializer = new RuleResourceSerializer();
    }
    /**
     * Returns an object representing the metadata related to a service bus namespace.
     * @param queueName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     */
    getNamespaceProperties(operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            administrationLogger.verbose(`Performing management operation - getNamespaceProperties()`);
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getNamespaceProperties", operationOptions);
            try {
                const response = yield this.getResource("$namespaceinfo", this.namespaceResourceSerializer, updatedOperationOptions);
                return this.buildNamespacePropertiesResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a queue with given name, configured using the given options
     * @param queueName
     * @param options Options to configure the Queue being created(For example, you can configure a queue to support partitions or sessions)
     *  and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    createQueue(queueName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-createQueue", options);
            try {
                administrationLogger.verbose(`Performing management operation - createQueue() for "${queueName}" with options: %j`, options);
                const response = yield this.putResource(queueName, buildQueueOptions(options || {}), this.queueResourceSerializer, false, updatedOperationOptions);
                return this.buildQueueResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns an object representing the Queue and its properties.
     * If you want to get the Queue runtime info like message count details, use `getQueueRuntimeProperties` API.
     * @param queueName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getQueue(queueName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getQueue", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - getQueue() for "${queueName}"`);
                const response = yield this.getResource(queueName, this.queueResourceSerializer, updatedOperationOptions);
                return this.buildQueueResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns an object representing the Queue runtime info like message count details.
     * @param queueName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getQueueRuntimeProperties(queueName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getQueueRuntimeProperties", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - getQueueRuntimeProperties() for "${queueName}"`);
                const response = yield this.getResource(queueName, this.queueResourceSerializer, updatedOperationOptions);
                return this.buildQueueRuntimePropertiesResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns a list of objects, each representing a Queue along with its properties.
     * If you want to get the runtime info of the queues like message count, use `getQueuesRuntimeProperties` API instead.
     * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getQueues(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getQueues", options);
            try {
                administrationLogger.verbose(`Performing management operation - getQueues() with options: %j`, options);
                const response = yield this.listResources("$Resources/Queues", updatedOperationOptions, this.queueResourceSerializer);
                return this.buildListQueuesResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listQueuesPage(marker, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listQueuesPage_1() {
            let listResponse;
            do {
                listResponse = yield tslib.__await(this.getQueues(Object.assign({ skip: Number(marker), maxCount: options.maxPageSize }, options)));
                marker = listResponse.continuationToken;
                yield yield tslib.__await(listResponse);
            } while (marker);
        });
    }
    listQueuesAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listQueuesAll_1() {
            var e_1, _a;
            let marker;
            try {
                for (var _b = tslib.__asyncValues(this.listQueuesPage(marker, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const segment = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the queues.
     *
     * .byPage() returns an async iterable iterator to list the queues in pages.
     *
     * @param {OperationOptions} [options]
     * @returns {PagedAsyncIterableIterator<
     *     QueueProperties,
     *     EntitiesResponse<QueueProperties>,
     *   >} An asyncIterableIterator that supports paging.
     * @memberof ServiceBusAdministrationClient
     */
    listQueues(options) {
        administrationLogger.verbose(`Performing management operation - listQueues() with options: %j`, options);
        const iter = this.listQueuesAll(options);
        return {
            /**
             * @member {Promise} [next] The next method, part of the iteration protocol
             */
            next() {
                return iter.next();
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listQueuesPage(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
            }
        };
    }
    /**
     * Returns a list of objects, each representing a Queue's runtime info like message count details.
     * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getQueuesRuntimeProperties(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getQueuesRuntimeProperties", options);
            try {
                administrationLogger.verbose(`Performing management operation - getQueuesRuntimeProperties() with options: %j`, options);
                const response = yield this.listResources("$Resources/Queues", updatedOperationOptions, this.queueResourceSerializer);
                return this.buildListQueuesRuntimePropertiesResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listQueuesRuntimePropertiesPage(marker, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listQueuesRuntimePropertiesPage_1() {
            let listResponse;
            do {
                listResponse = yield tslib.__await(this.getQueuesRuntimeProperties(Object.assign({ skip: Number(marker), maxCount: options.maxPageSize }, options)));
                marker = listResponse.continuationToken;
                yield yield tslib.__await(listResponse);
            } while (marker);
        });
    }
    listQueuesRuntimePropertiesAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listQueuesRuntimePropertiesAll_1() {
            var e_2, _a;
            let marker;
            try {
                for (var _b = tslib.__asyncValues(this.listQueuesRuntimePropertiesPage(marker, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const segment = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list runtime info of the queues.
     *
     * .byPage() returns an async iterable iterator to list runtime info of the queues in pages.
     *
     *
     * @param {OperationOptions} [options]
     * @returns {PagedAsyncIterableIterator<
     *     QueueRuntimeProperties,
     *     EntitiesResponse<QueueRuntimeProperties>,
     *   >} An asyncIterableIterator that supports paging.
     * @memberof ServiceBusAdministrationClient
     */
    listQueuesRuntimeProperties(options) {
        administrationLogger.verbose(`Performing management operation - listQueuesRuntimeProperties() with options: %j`, options);
        const iter = this.listQueuesRuntimePropertiesAll(options);
        return {
            /**
             * @member {Promise} [next] The next method, part of the iteration protocol
             */
            next() {
                return iter.next();
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listQueuesRuntimePropertiesPage(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
            }
        };
    }
    /**
     * Updates the queue based on the queue properties provided.
     * All queue properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getQueue()`, update the desired properties in it, and then pass the modified object to `updateQueue()`.
     *
     * See https://docs.microsoft.com/rest/api/servicebus/update-queue for more details.
     *
     * @param queue Object representing the properties of the queue and the raw response.
     * `requiresSession`, `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the queue.
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    updateQueue(queue, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-updateQueue", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - updateQueue() for "${queue.name}" with options: %j`, queue);
                if (!isJSONLikeObject(queue) || queue == null) {
                    throw new TypeError(`Parameter "queue" must be an object of type "QueueDescription" and cannot be undefined or null.`);
                }
                if (!queue.name) {
                    throw new TypeError(`"name" attribute of the parameter "queue" cannot be undefined.`);
                }
                const response = yield this.putResource(queue.name, buildQueueOptions(queue), this.queueResourceSerializer, true, updatedOperationOptions);
                return this.buildQueueResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Deletes a queue.
     * @param queueName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    deleteQueue(queueName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-deleteQueue", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - deleteQueue() for "${queueName}"`);
                const response = yield this.deleteResource(queueName, this.queueResourceSerializer, updatedOperationOptions);
                return { _response: getHttpResponseOnly(response) };
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Checks whether a given queue exists or not.
     * @param queueName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     */
    queueExists(queueName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-queueExists", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - queueExists() for "${queueName}"`);
                try {
                    yield this.getQueue(queueName, updatedOperationOptions);
                }
                catch (error) {
                    if (error.code == "MessageEntityNotFoundError") {
                        return false;
                    }
                    throw error;
                }
                return true;
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a topic with given name, configured using the given options
     * @param topicName
     * @param options Options to configure the Topic being created(For example, you can configure a topic to support partitions)
     * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    createTopic(topicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-createTopic", options);
            try {
                administrationLogger.verbose(`Performing management operation - createTopic() for "${topicName}" with options: %j`, options);
                const response = yield this.putResource(topicName, buildTopicOptions(options || {}), this.topicResourceSerializer, false, updatedOperationOptions);
                return this.buildTopicResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns an object representing the Topic and its properties.
     * If you want to get the Topic runtime info like subscription count details, use `getTopicRuntimeProperties` API.
     * @param topicName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getTopic(topicName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getTopic", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - getTopic() for "${topicName}"`);
                const response = yield this.getResource(topicName, this.topicResourceSerializer, updatedOperationOptions);
                return this.buildTopicResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns an object representing the Topic runtime info like subscription count.
     * @param topicName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getTopicRuntimeProperties(topicName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getTopicRuntimeProperties", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - getTopicRuntimeProperties() for "${topicName}"`);
                const response = yield this.getResource(topicName, this.topicResourceSerializer, updatedOperationOptions);
                return this.buildTopicRuntimePropertiesResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns a list of objects, each representing a Topic along with its properties.
     * If you want to get the runtime info of the topics like subscription count, use `getTopicsRuntimeProperties` API instead.
     * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getTopics(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getTopics", options);
            try {
                administrationLogger.verbose(`Performing management operation - getTopics() with options: %j`, options);
                const response = yield this.listResources("$Resources/Topics", updatedOperationOptions, this.topicResourceSerializer);
                return this.buildListTopicsResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listTopicsPage(marker, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listTopicsPage_1() {
            let listResponse;
            do {
                listResponse = yield tslib.__await(this.getTopics(Object.assign({ skip: Number(marker), maxCount: options.maxPageSize }, options)));
                marker = listResponse.continuationToken;
                yield yield tslib.__await(listResponse);
            } while (marker);
        });
    }
    listTopicsAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listTopicsAll_1() {
            var e_3, _a;
            let marker;
            try {
                for (var _b = tslib.__asyncValues(this.listTopicsPage(marker, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const segment = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the topics.
     *
     * .byPage() returns an async iterable iterator to list the topics in pages.
     *
     *
     * @param {OperationOptions} [options]
     * @returns {PagedAsyncIterableIterator<
     *     TopicProperties,
     *     EntitiesResponse<TopicProperties>,
     *   >} An asyncIterableIterator that supports paging.
     * @memberof ServiceBusAdministrationClient
     */
    listTopics(options) {
        administrationLogger.verbose(`Performing management operation - listTopics() with options: %j`, options);
        const iter = this.listTopicsAll(options);
        return {
            /**
             * @member {Promise} [next] The next method, part of the iteration protocol
             */
            next() {
                return iter.next();
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listTopicsPage(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
            }
        };
    }
    /**
     * Returns a list of objects, each representing a Topic's runtime info like subscription count.
     * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getTopicsRuntimeProperties(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getTopicsRuntimeProperties", options);
            try {
                administrationLogger.verbose(`Performing management operation - getTopicsRuntimeProperties() with options: %j`, options);
                const response = yield this.listResources("$Resources/Topics", updatedOperationOptions, this.topicResourceSerializer);
                return this.buildListTopicsRuntimePropertiesResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listTopicsRuntimePropertiesPage(marker, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listTopicsRuntimePropertiesPage_1() {
            let listResponse;
            do {
                listResponse = yield tslib.__await(this.getTopicsRuntimeProperties(Object.assign({ skip: Number(marker), maxCount: options.maxPageSize }, options)));
                marker = listResponse.continuationToken;
                yield yield tslib.__await(listResponse);
            } while (marker);
        });
    }
    listTopicsRuntimePropertiesAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listTopicsRuntimePropertiesAll_1() {
            var e_4, _a;
            let marker;
            try {
                for (var _b = tslib.__asyncValues(this.listTopicsRuntimePropertiesPage(marker, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const segment = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list runtime info of the topics.
     *
     * .byPage() returns an async iterable iterator to list runtime info of the topics in pages.
     *
     *
     * @param {OperationOptions} [options]
     * @returns {PagedAsyncIterableIterator<
     *     TopicRuntimeProperties,
     *     EntitiesResponse<TopicRuntimeProperties>,
  
     *   >} An asyncIterableIterator that supports paging.
     * @memberof ServiceBusAdministrationClient
     */
    listTopicsRuntimeProperties(options) {
        administrationLogger.verbose(`Performing management operation - listTopicsRuntimeProperties() with options: %j`, options);
        const iter = this.listTopicsRuntimePropertiesAll(options);
        return {
            /**
             * @member {Promise} [next] The next method, part of the iteration protocol
             */
            next() {
                return iter.next();
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listTopicsRuntimePropertiesPage(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
            }
        };
    }
    /**
     * Updates the topic based on the topic properties provided.
     * All topic properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getTopic()`, update the desired properties in it, and then pass the modified object to `updateTopic()`.
     *
     * See https://docs.microsoft.com/rest/api/servicebus/update-topic for more details.
     *
     * @param topic Object representing the properties of the topic and the raw response.
     * `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the topic.
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    updateTopic(topic, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-updateTopic", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - updateTopic() for "${topic.name}" with options: %j`, topic);
                if (!isJSONLikeObject(topic) || topic == null) {
                    throw new TypeError(`Parameter "topic" must be an object of type "TopicDescription" and cannot be undefined or null.`);
                }
                if (!topic.name) {
                    throw new TypeError(`"name" attribute of the parameter "topic" cannot be undefined.`);
                }
                const response = yield this.putResource(topic.name, buildTopicOptions(topic), this.topicResourceSerializer, true, updatedOperationOptions);
                return this.buildTopicResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Deletes a topic.
     * @param topicName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    deleteTopic(topicName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-deleteTopic", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - deleteTopic() for "${topicName}"`);
                const response = yield this.deleteResource(topicName, this.topicResourceSerializer, updatedOperationOptions);
                return { _response: getHttpResponseOnly(response) };
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Checks whether a given topic exists or not.
     * @param topicName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     */
    topicExists(topicName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-topicExists", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - topicExists() for "${topicName}"`);
                try {
                    yield this.getTopic(topicName, updatedOperationOptions);
                }
                catch (error) {
                    if (error.code == "MessageEntityNotFoundError") {
                        return false;
                    }
                    throw error;
                }
                return true;
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a subscription with given name, configured using the given options
     * @param topicName
     * @param subscriptionName
     * @param options Options to configure the Subscription being created(For example, you can configure a Subscription to support partitions or sessions)
     * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    createSubscription(topicName, subscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-createSubscription", options);
            try {
                administrationLogger.verbose(`Performing management operation - createSubscription() for "${subscriptionName}" with options: %j`, options);
                const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
                const response = yield this.putResource(fullPath, buildSubscriptionOptions(options || {}), this.subscriptionResourceSerializer, false, updatedOperationOptions);
                return this.buildSubscriptionResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns an object representing the Subscription and its properties.
     * If you want to get the Subscription runtime info like message count details, use `getSubscriptionRuntimeProperties` API.
     * @param topicName
     * @param subscriptionName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getSubscription(topicName, subscriptionName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getSubscription", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - getSubscription() for "${subscriptionName}"`);
                const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
                const response = yield this.getResource(fullPath, this.subscriptionResourceSerializer, updatedOperationOptions);
                return this.buildSubscriptionResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns an object representing the Subscription runtime info like message count details.
     * @param topicName
     * @param subscriptionName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getSubscriptionRuntimeProperties(topicName, subscriptionName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getSubscriptionRuntimeProperties", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - getSubscriptionRuntimeProperties() for "${subscriptionName}"`);
                const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
                const response = yield this.getResource(fullPath, this.subscriptionResourceSerializer, updatedOperationOptions);
                return this.buildSubscriptionRuntimePropertiesResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns a list of objects, each representing a Subscription along with its properties.
     * If you want to get the runtime info of the subscriptions like message count, use `getSubscriptionsRuntimeProperties` API instead.
     * @param topicName
     * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getSubscriptions(topicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getSubscriptions", options);
            try {
                administrationLogger.verbose(`Performing management operation - getSubscriptions() with options: %j`, options);
                const response = yield this.listResources(topicName + "/Subscriptions/", updatedOperationOptions, this.subscriptionResourceSerializer);
                return this.buildListSubscriptionsResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listSubscriptionsPage(topicName, marker, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSubscriptionsPage_1() {
            let listResponse;
            do {
                listResponse = yield tslib.__await(this.getSubscriptions(topicName, Object.assign({ skip: Number(marker), maxCount: options.maxPageSize }, options)));
                marker = listResponse.continuationToken;
                yield yield tslib.__await(listResponse);
            } while (marker);
        });
    }
    listSubscriptionsAll(topicName, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSubscriptionsAll_1() {
            var e_5, _a;
            let marker;
            try {
                for (var _b = tslib.__asyncValues(this.listSubscriptionsPage(topicName, marker, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const segment = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     *
     * Returns an async iterable iterator to list all the subscriptions
     * under the specified topic.
     *
     * .byPage() returns an async iterable iterator to list the subscriptions in pages.
     *
     * @memberof ServiceBusAdministrationClient
     * @param {string} topicName
     * @param {OperationOptions} [options]
     * @returns {PagedAsyncIterableIterator<
     *     SubscriptionProperties,
     *     EntitiesResponse<SubscriptionProperties>
     *   >} An asyncIterableIterator that supports paging.
     * @memberof ServiceBusAdministrationClient
     */
    listSubscriptions(topicName, options) {
        administrationLogger.verbose(`Performing management operation - listSubscriptions() with options: %j`, options);
        const iter = this.listSubscriptionsAll(topicName, options);
        return {
            /**
             * @member {Promise} [next] The next method, part of the iteration protocol
             */
            next() {
                return iter.next();
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listSubscriptionsPage(topicName, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
            }
        };
    }
    /**
     * Returns a list of objects, each representing a Subscription's runtime info like message count details.
     * @param topicName
     * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getSubscriptionsRuntimeProperties(topicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getSubscriptionsRuntimeProperties", options);
            try {
                administrationLogger.verbose(`Performing management operation - getSubscriptionsRuntimeProperties() with options: %j`, options);
                const response = yield this.listResources(topicName + "/Subscriptions/", updatedOperationOptions, this.subscriptionResourceSerializer);
                return this.buildListSubscriptionsRuntimePropertiesResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listSubscriptionsRuntimePropertiesPage(topicName, marker, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSubscriptionsRuntimePropertiesPage_1() {
            let listResponse;
            do {
                listResponse = yield tslib.__await(this.getSubscriptionsRuntimeProperties(topicName, Object.assign({ skip: Number(marker), maxCount: options.maxPageSize }, options)));
                marker = listResponse.continuationToken;
                yield yield tslib.__await(listResponse);
            } while (marker);
        });
    }
    listSubscriptionsRuntimePropertiesAll(topicName, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSubscriptionsRuntimePropertiesAll_1() {
            var e_6, _a;
            let marker;
            try {
                for (var _b = tslib.__asyncValues(this.listSubscriptionsRuntimePropertiesPage(topicName, marker, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const segment = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list runtime info of the subscriptions
     * under the specified topic.
     *
     * .byPage() returns an async iterable iterator to list runtime info of subscriptions in pages.
     *
     * @param {string} topicName
     * @param {OperationOptions} [options]
     * @returns {PagedAsyncIterableIterator<
     *     SubscriptionRuntimeProperties,
     *     EntitiesResponse<SubscriptionRuntimeProperties>,
  
     *   >}  An asyncIterableIterator that supports paging.
     * @memberof ServiceBusAdministrationClient
     */
    listSubscriptionsRuntimeProperties(topicName, options) {
        administrationLogger.verbose(`Performing management operation - listSubscriptionsRuntimeProperties() with options: %j`, options);
        const iter = this.listSubscriptionsRuntimePropertiesAll(topicName, options);
        return {
            /**
             * @member {Promise} [next] The next method, part of the iteration protocol
             */
            next() {
                return iter.next();
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listSubscriptionsRuntimePropertiesPage(topicName, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
            }
        };
    }
    /**
     * Updates the subscription based on the subscription properties provided.
     * All subscription properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getSubscription()`, update the desired properties in it, and then pass the modified object to `updateSubscription()`.
     *
     * @param subscription Object representing the properties of the subscription and the raw response.
     * `subscriptionName`, `topicName`, and `requiresSession` can't be updated after creating the subscription.
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    updateSubscription(subscription, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-updateSubscription", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - updateSubscription() for "${subscription.subscriptionName}" with options: %j`, subscription);
                if (!isJSONLikeObject(subscription) || subscription == null) {
                    throw new TypeError(`Parameter "subscription" must be an object of type "SubscriptionDescription" and cannot be undefined or null.`);
                }
                if (!subscription.topicName || !subscription.subscriptionName) {
                    throw new TypeError(`The attributes "topicName" and "subscriptionName" of the parameter "subscription" cannot be undefined.`);
                }
                const fullPath = this.getSubscriptionPath(subscription.topicName, subscription.subscriptionName);
                const response = yield this.putResource(fullPath, buildSubscriptionOptions(subscription), this.subscriptionResourceSerializer, true, updatedOperationOptions);
                return this.buildSubscriptionResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Deletes a subscription.
     * @param topicName
     * @param subscriptionName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    deleteSubscription(topicName, subscriptionName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-deleteSubscription", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - deleteSubscription() for "${subscriptionName}"`);
                const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
                const response = yield this.deleteResource(fullPath, this.subscriptionResourceSerializer, updatedOperationOptions);
                return { _response: getHttpResponseOnly(response) };
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Checks whether a given subscription exists in the topic or not.
     * @param topicName
     * @param subscriptionName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     */
    subscriptionExists(topicName, subscriptionName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-subscriptionExists", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - subscriptionExists() for "${topicName}" and "${subscriptionName}"`);
                try {
                    yield this.getSubscription(topicName, subscriptionName, updatedOperationOptions);
                }
                catch (error) {
                    if (error.code == "MessageEntityNotFoundError") {
                        return false;
                    }
                    throw error;
                }
                return true;
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    createRule(topicName, subscriptionName, ruleName, ruleFilter, ruleActionOrOperationOptions, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let ruleAction = undefined;
            let operOptions;
            if (ruleActionOrOperationOptions) {
                if (isSqlRuleAction(ruleActionOrOperationOptions)) {
                    // Overload#2 - where the sqlExpression in the ruleAction is defined
                    ruleAction = ruleActionOrOperationOptions;
                    operOptions = operationOptions;
                }
                else {
                    // Overload#1
                    // Overload#2 - where the sqlExpression in the ruleAction is undefined
                    operOptions = Object.assign(Object.assign({}, ruleActionOrOperationOptions), operationOptions);
                }
            }
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-createRule", operOptions);
            try {
                administrationLogger.verbose(`Performing management operation - createRule() for "${ruleName}" with filter: "%j"`, ruleFilter);
                const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
                const response = yield this.putResource(fullPath, { name: ruleName, filter: ruleFilter, action: ruleAction }, this.ruleResourceSerializer, false, updatedOperationOptions);
                return this.buildRuleResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns an object representing the Rule with the given name along with all its properties.
     * @param topicName
     * @param subscriptionName
     * @param ruleName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getRule(topicName, subscriptionName, ruleName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getRule", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - getRule() for "${ruleName}"`);
                const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
                const response = yield this.getResource(fullPath, this.ruleResourceSerializer, updatedOperationOptions);
                return this.buildRuleResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Lists existing rules.
     * @param topicName
     * @param subscriptionName
     * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getRules(topicName, subscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getRules", options);
            try {
                administrationLogger.verbose(`Performing management operation - getRules() with options: %j`, options);
                const fullPath = this.getSubscriptionPath(topicName, subscriptionName) + "/Rules/";
                const response = yield this.listResources(fullPath, updatedOperationOptions, this.ruleResourceSerializer);
                return this.buildListRulesResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listRulesPage(topicName, subscriptionName, marker, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listRulesPage_1() {
            let listResponse;
            do {
                listResponse = yield tslib.__await(this.getRules(topicName, subscriptionName, Object.assign({ skip: Number(marker), maxCount: options.maxPageSize }, options)));
                marker = listResponse.continuationToken;
                yield yield tslib.__await(listResponse);
            } while (marker);
        });
    }
    listRulesAll(topicName, subscriptionName, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listRulesAll_1() {
            var e_7, _a;
            let marker;
            try {
                for (var _b = tslib.__asyncValues(this.listRulesPage(topicName, subscriptionName, marker, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const segment = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the rules
     * under the specified subscription.
     *
     * .byPage() returns an async iterable iterator to list the rules in pages.
     *
     * @param {string} topicName
     * @param {string} subscriptionName
     * @param {OperationOptions} [options]
     * @returns {PagedAsyncIterableIterator<RuleProperties, EntitiesResponse<RuleProperties>>} An asyncIterableIterator that supports paging.
     * @memberof ServiceBusAdministrationClient
     */
    listRules(topicName, subscriptionName, options) {
        administrationLogger.verbose(`Performing management operation - listRules() with options: %j`, options);
        const iter = this.listRulesAll(topicName, subscriptionName, options);
        return {
            /**
             * @member {Promise} [next] The next method, part of the iteration protocol
             */
            next() {
                return iter.next();
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listRulesPage(topicName, subscriptionName, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
            }
        };
    }
    /**
     * Updates properties on the Rule by the given name based on the given options.
     * All rule properties must be set even if one of them is being updated.
     * Therefore, the suggested flow is to use the output from `getRule()`, update the desired properties in it, and then pass the modified object to `updateRule()`.
     *
     * @param topicName
     * @param subscriptionName
     * @param rule Options to configure the Rule being updated and the raw response.
     * For example, you can configure the filter to apply on associated Topic/Subscription.
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    updateRule(topicName, subscriptionName, rule, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-updateRule", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - updateRule() for "${rule.name}" with options: %j`, rule);
                if (!isJSONLikeObject(rule) || rule === null) {
                    throw new TypeError(`Parameter "rule" must be an object of type "RuleDescription" and cannot be undefined or null.`);
                }
                if (!rule.name) {
                    throw new TypeError(`"name" attribute of the parameter "rule" cannot be undefined.`);
                }
                const fullPath = this.getRulePath(topicName, subscriptionName, rule.name);
                const response = yield this.putResource(fullPath, rule, this.ruleResourceSerializer, true, updatedOperationOptions);
                return this.buildRuleResponse(response);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Deletes a rule.
     * @param topicName
     * @param subscriptionName
     * @param ruleName
     * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    deleteRule(topicName, subscriptionName, ruleName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-deleteRule", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - deleteRule() for "${ruleName}"`);
                const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
                const response = yield this.deleteResource(fullPath, this.ruleResourceSerializer, updatedOperationOptions);
                return { _response: getHttpResponseOnly(response) };
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Checks whether a given rule exists or not.
     *
     * @param {string} topicName
     * @param {string} subscriptionName
     * @param {string} ruleName
     * @param {OperationOptions} [operationOptions]
     */
    ruleExists(topicName, subscriptionName, ruleName, operationOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-ruleExists", operationOptions);
            try {
                administrationLogger.verbose(`Performing management operation - ruleExists() for "${ruleName}"`);
                try {
                    yield this.getRule(topicName, subscriptionName, ruleName, updatedOperationOptions);
                }
                catch (error) {
                    if (error.code == "MessageEntityNotFoundError") {
                        return false;
                    }
                    throw error;
                }
                return true;
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates or updates a resource based on `isUpdate` parameter.
     * @param name
     * @param entityFields
     * @param isUpdate
     * @param serializer
     */
    putResource(name, entityFields, serializer, isUpdate = false, operationOptions = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-putResource", operationOptions);
            try {
                const webResource = new coreHttp.WebResource(this.getUrl(name), "PUT");
                webResource.body = entityFields;
                if (isUpdate) {
                    webResource.headers.set("If-Match", "*");
                }
                const queueOrSubscriptionFields = entityFields;
                if (queueOrSubscriptionFields.ForwardTo ||
                    queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {
                    const token = this.credentials instanceof SasServiceClientCredentials
                        ? this.credentials.getToken(this.endpoint).token
                        : (yield this.credentials.getToken([coreAmqp.Constants.aadServiceBusScope])).token;
                    if (queueOrSubscriptionFields.ForwardTo) {
                        webResource.headers.set("ServiceBusSupplementaryAuthorization", token);
                        if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardTo)) {
                            queueOrSubscriptionFields.ForwardTo = this.endpointWithProtocol.concat(queueOrSubscriptionFields.ForwardTo);
                        }
                    }
                    if (queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {
                        webResource.headers.set("ServiceBusDlqSupplementaryAuthorization", token);
                        if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo)) {
                            queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo = this.endpointWithProtocol.concat(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo);
                        }
                    }
                }
                webResource.headers.set("content-type", "application/atom+xml;type=entry;charset=utf-8");
                return executeAtomXmlOperation(this, webResource, serializer, updatedOperationOptions);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Gets a resource.
     * @param name
     * @param serializer
     */
    getResource(name, serializer, operationOptions = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-getResource", operationOptions);
            try {
                const webResource = new coreHttp.WebResource(this.getUrl(name), "GET");
                const response = yield executeAtomXmlOperation(this, webResource, serializer, updatedOperationOptions);
                if (response.parsedBody == undefined ||
                    (Array.isArray(response.parsedBody) && response.parsedBody.length == 0)) {
                    const err = new coreHttp.RestError(`The messaging entity "${name}" being requested cannot be found.`, "MessageEntityNotFoundError", response.status, coreHttp.stripRequest(webResource), coreHttp.stripResponse(response));
                    throw err;
                }
                return response;
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Lists existing resources
     * @param name
     * @param options
     * @param serializer
     */
    listResources(name, options = {}, serializer) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-listResources", options);
            try {
                const queryParams = {};
                if (options) {
                    if (options.skip) {
                        queryParams["$skip"] = options.skip.toString();
                    }
                    if (options.maxCount) {
                        queryParams["$top"] = options.maxCount.toString();
                    }
                }
                const webResource = new coreHttp.WebResource(this.getUrl(name, queryParams), "GET");
                return executeAtomXmlOperation(this, webResource, serializer, updatedOperationOptions);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Deletes a resource.
     * @param name
     */
    deleteResource(name, serializer, operationOptions = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOperationOptions } = createSpan("ServiceBusAdministrationClient-deleteResource", operationOptions);
            try {
                const webResource = new coreHttp.WebResource(this.getUrl(name), "DELETE");
                return executeAtomXmlOperation(this, webResource, serializer, updatedOperationOptions);
            }
            catch (e) {
                span.setStatus({
                    code: getCanonicalCode(e),
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    getUrl(path, queryParams) {
        const baseUri = `https://${this.endpoint}/${path}`;
        const requestUrl = coreHttp.URLBuilder.parse(baseUri);
        requestUrl.setQueryParameter(API_VERSION_QUERY_KEY, CURRENT_API_VERSION);
        if (queryParams) {
            for (const key of Object.keys(queryParams)) {
                requestUrl.setQueryParameter(key, queryParams[key]);
            }
        }
        return requestUrl.toString();
    }
    getSubscriptionPath(topicName, subscriptionName) {
        return topicName + "/Subscriptions/" + subscriptionName;
    }
    getRulePath(topicName, subscriptionName, ruleName) {
        return topicName + "/Subscriptions/" + subscriptionName + "/Rules/" + ruleName;
    }
    getMarkerFromNextLinkUrl(url) {
        if (!url) {
            return undefined;
        }
        try {
            return parseURL(url).searchParams.get(XML_METADATA_MARKER + "skip");
        }
        catch (error) {
            throw new Error(`Unable to parse the '${XML_METADATA_MARKER}skip' from the next-link in the response ` +
                error);
        }
    }
    buildNamespacePropertiesResponse(response) {
        try {
            const namespace = buildNamespace(response.parsedBody);
            const namespaceResponse = Object.defineProperty(namespace || {}, "_response", { value: getHttpResponseOnly(response) });
            return namespaceResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a namespace object using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildListQueuesResponse(response) {
        try {
            const queues = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawQueueArray = response.parsedBody;
            for (let i = 0; i < rawQueueArray.length; i++) {
                const queue = buildQueue(rawQueueArray[i]);
                if (queue) {
                    queues.push(queue);
                }
            }
            const listQueuesResponse = Object.defineProperty(queues, "_response", {
                value: getHttpResponseOnly(response)
            });
            listQueuesResponse.continuationToken = nextMarker;
            return listQueuesResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildListQueuesRuntimePropertiesResponse(response) {
        try {
            const queues = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawQueueArray = response.parsedBody;
            for (let i = 0; i < rawQueueArray.length; i++) {
                const queue = buildQueueRuntimeProperties(rawQueueArray[i]);
                if (queue) {
                    queues.push(queue);
                }
            }
            const listQueuesResponse = Object.defineProperty(queues, "_response", {
                value: getHttpResponseOnly(response)
            });
            listQueuesResponse.continuationToken = nextMarker;
            return listQueuesResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildQueueResponse(response) {
        try {
            const queue = buildQueue(response.parsedBody);
            const queueResponse = Object.defineProperty(queue || {}, "_response", {
                value: getHttpResponseOnly(response)
            });
            return queueResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a queue object using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildQueueRuntimePropertiesResponse(response) {
        try {
            const queue = buildQueueRuntimeProperties(response.parsedBody);
            const queueResponse = Object.defineProperty(queue || {}, "_response", {
                value: getHttpResponseOnly(response)
            });
            return queueResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a queue object using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildListTopicsResponse(response) {
        try {
            const topics = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawTopicArray = response.parsedBody;
            for (let i = 0; i < rawTopicArray.length; i++) {
                const topic = buildTopic(rawTopicArray[i]);
                if (topic) {
                    topics.push(topic);
                }
            }
            const listTopicsResponse = Object.defineProperty(topics, "_response", {
                value: getHttpResponseOnly(response)
            });
            listTopicsResponse.continuationToken = nextMarker;
            return listTopicsResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildListTopicsRuntimePropertiesResponse(response) {
        try {
            const topics = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawTopicArray = response.parsedBody;
            for (let i = 0; i < rawTopicArray.length; i++) {
                const topic = buildTopicRuntimeProperties(rawTopicArray[i]);
                if (topic) {
                    topics.push(topic);
                }
            }
            const listTopicsResponse = Object.defineProperty(topics, "_response", {
                value: getHttpResponseOnly(response)
            });
            listTopicsResponse.continuationToken = nextMarker;
            return listTopicsResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildTopicResponse(response) {
        try {
            const topic = buildTopic(response.parsedBody);
            const topicResponse = Object.defineProperty(topic || {}, "_response", {
                value: getHttpResponseOnly(response)
            });
            return topicResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a topic object using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildTopicRuntimePropertiesResponse(response) {
        try {
            const topic = buildTopicRuntimeProperties(response.parsedBody);
            const topicResponse = Object.defineProperty(topic || {}, "_response", {
                value: getHttpResponseOnly(response)
            });
            return topicResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a topic object using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildListSubscriptionsResponse(response) {
        try {
            const subscriptions = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawSubscriptionArray = response.parsedBody;
            for (let i = 0; i < rawSubscriptionArray.length; i++) {
                const subscription = buildSubscription(rawSubscriptionArray[i]);
                if (subscription) {
                    subscriptions.push(subscription);
                }
            }
            const listSubscriptionsResponse = Object.defineProperty(subscriptions, "_response", {
                value: getHttpResponseOnly(response)
            });
            listSubscriptionsResponse.continuationToken = nextMarker;
            return listSubscriptionsResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildListSubscriptionsRuntimePropertiesResponse(response) {
        try {
            const subscriptions = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawSubscriptionArray = response.parsedBody;
            for (let i = 0; i < rawSubscriptionArray.length; i++) {
                const subscription = buildSubscriptionRuntimeProperties(rawSubscriptionArray[i]);
                if (subscription) {
                    subscriptions.push(subscription);
                }
            }
            const listSubscriptionsResponse = Object.defineProperty(subscriptions, "_response", {
                value: getHttpResponseOnly(response)
            });
            listSubscriptionsResponse.continuationToken = nextMarker;
            return listSubscriptionsResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildSubscriptionResponse(response) {
        try {
            const subscription = buildSubscription(response.parsedBody);
            const subscriptionResponse = Object.defineProperty(subscription || {}, "_response", {
                value: getHttpResponseOnly(response)
            });
            return subscriptionResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildSubscriptionRuntimePropertiesResponse(response) {
        try {
            const subscription = buildSubscriptionRuntimeProperties(response.parsedBody);
            const subscriptionResponse = Object.defineProperty(subscription || {}, "_response", {
                value: getHttpResponseOnly(response)
            });
            return subscriptionResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildListRulesResponse(response) {
        try {
            const rules = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawRuleArray = response.parsedBody;
            for (let i = 0; i < rawRuleArray.length; i++) {
                const rule = buildRule(rawRuleArray[i]);
                if (rule) {
                    rules.push(rule);
                }
            }
            const listRulesResponse = Object.defineProperty(rules, "_response", {
                value: getHttpResponseOnly(response)
            });
            listRulesResponse.continuationToken = nextMarker;
            return listRulesResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of rules using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    buildRuleResponse(response) {
        try {
            const rule = buildRule(response.parsedBody);
            const ruleResponse = Object.defineProperty(rule || {}, "_response", {
                value: getHttpResponseOnly(response)
            });
            return ruleResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreHttp.RestError(`Error occurred while parsing the response body - cannot form a rule object using the response from the service.`, coreHttp.RestError.PARSE_ERROR, response.status, coreHttp.stripRequest(response.request), coreHttp.stripResponse(response));
        }
    }
    throwIfInvalidContinuationToken(token) {
        if (!(token === undefined || (typeof token === "string" && Number(token) >= 0))) {
            throw new Error(`Invalid continuationToken ${token} provided`);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The default data transformer that will be used by the Azure SDK.
 * @internal
 * @hidden
 */
const defaultDataTransformer = {
    /**
     * A function that takes the body property from an EventData object
     * and returns an encoded body (some form of AMQP type).
     *
     * @param {*} body The AMQP message body
     * @return {DataSection} encodedBody - The encoded AMQP message body as an AMQP Data type
     * (data section in rhea terms). Section object with following properties:
     * - typecode: 117 (0x75)
     * - content: The given AMQP message body as a Buffer.
     * - multiple: true | undefined.
     */
    encode(body) {
        let result;
        if (isBuffer(body)) {
            result = rheaPromise.message.data_section(body);
        }
        else {
            // string, undefined, null, boolean, array, object, number should end up here
            // coercing undefined to null as that will ensure that null value will be given to the
            // customer on receive.
            if (body === undefined)
                body = null; // tslint:disable-line
            try {
                const bodyStr = JSON.stringify(body);
                result = rheaPromise.message.data_section(buffer.Buffer.from(bodyStr, "utf8"));
            }
            catch (err) {
                const msg = `An error occurred while executing JSON.stringify() on the given body ` +
                    body +
                    `${err ? err.stack : JSON.stringify(err)}`;
                logger.warning("[encode] " + msg);
                logErrorStackTrace(logger, err);
                throw new Error(msg);
            }
        }
        return result;
    },
    /**
     * @property {Function} [decode] A function that takes the body property from an AMQP message
     * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.
     * If it cannot decode the body then it returns the body
     * as-is.
     * @param {DataSection} body The AMQP message body
     * @return {*} decoded body or the given body as-is.
     */
    decode(body) {
        let processedBody = body;
        try {
            if (body.content && isBuffer(body.content)) {
                // This indicates that we are getting the AMQP described type. Let us try decoding it.
                processedBody = body.content;
            }
            try {
                // Trying to stringify and JSON.parse() anything else will fail flat and we shall return
                // the original type back
                const bodyStr = processedBody.toString("utf8");
                processedBody = JSON.parse(bodyStr);
            }
            catch (err) {
                logger.verbose("[decode] An error occurred while trying JSON.parse() on the received body. " +
                    "The error is %O", err);
            }
        }
        catch (err) {
            logger.verbose("[decode] An error occurred while decoding the received message body. The error is: %O", err);
        }
        return processedBody;
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 */
var DispositionType;
(function (DispositionType) {
    DispositionType["complete"] = "complete";
    DispositionType["deadletter"] = "deadletter";
    DispositionType["abandon"] = "abandon";
    DispositionType["defer"] = "defer";
})(DispositionType || (DispositionType = {}));
/**
 * @internal
 * @hidden
 * Gets the error message for when a property on given message is not of expected type
 */
function getMessagePropertyTypeMismatchError(msg) {
    if (msg.contentType != null && typeof msg.contentType !== "string") {
        return new TypeError("The property 'contentType' on the message must be of type 'string'");
    }
    if (msg.subject != null && typeof msg.subject !== "string") {
        return new TypeError("The property 'label' on the message must be of type 'string'");
    }
    if (msg.to != null && typeof msg.to !== "string") {
        return new TypeError("The property 'to' on the message must be of type 'string'");
    }
    if (msg.replyTo != null && typeof msg.replyTo !== "string") {
        return new TypeError("The property 'replyTo' on the message must be of type 'string'");
    }
    if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== "string") {
        return new TypeError("The property 'replyToSessionId' on the message must be of type 'string'");
    }
    if (msg.timeToLive != null && typeof msg.timeToLive !== "number") {
        return new TypeError("The property 'timeToLive' on the message must be of type 'number'");
    }
    if (msg.sessionId != null && typeof msg.sessionId !== "string") {
        return new TypeError("The property 'sessionId' on the message must be of type 'string'");
    }
    if (msg.messageId != null &&
        typeof msg.messageId !== "string" &&
        typeof msg.messageId !== "number" &&
        !buffer.Buffer.isBuffer(msg.messageId)) {
        return new TypeError("The property 'messageId' on the message must be of type string, number or Buffer");
    }
    if (msg.correlationId != null &&
        typeof msg.correlationId !== "string" &&
        typeof msg.correlationId !== "number" &&
        !buffer.Buffer.isBuffer(msg.correlationId)) {
        return new TypeError("The property 'correlationId' on the message must be of type string, number or Buffer");
    }
    return;
}
/**
 * @internal
 * @hidden
 * Converts given ServiceBusMessage to RheaMessage
 */
function toRheaMessage(msg) {
    const amqpMsg = {
        body: msg.body,
        message_annotations: {}
    };
    if (msg.applicationProperties != null) {
        amqpMsg.application_properties = msg.applicationProperties;
    }
    if (msg.contentType != null) {
        amqpMsg.content_type = msg.contentType;
    }
    if (msg.sessionId != null) {
        if (msg.sessionId.length > coreAmqp.Constants.maxSessionIdLength) {
            throw new Error("Length of 'sessionId' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.group_id = msg.sessionId;
    }
    if (msg.replyTo != null) {
        amqpMsg.reply_to = msg.replyTo;
    }
    if (msg.to != null) {
        amqpMsg.to = msg.to;
    }
    if (msg.subject != null) {
        amqpMsg.subject = msg.subject;
    }
    if (msg.messageId != null) {
        if (typeof msg.messageId === "string" && msg.messageId.length > coreAmqp.Constants.maxMessageIdLength) {
            throw new Error("Length of 'messageId' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.message_id = msg.messageId;
    }
    if (msg.correlationId != null) {
        amqpMsg.correlation_id = msg.correlationId;
    }
    if (msg.replyToSessionId != null) {
        amqpMsg.reply_to_group_id = msg.replyToSessionId;
    }
    if (msg.timeToLive != null && msg.timeToLive !== coreAmqp.Constants.maxDurationValue) {
        amqpMsg.ttl = msg.timeToLive;
        amqpMsg.creation_time = Date.now();
        if (coreAmqp.Constants.maxAbsoluteExpiryTime - amqpMsg.creation_time > amqpMsg.ttl) {
            amqpMsg.absolute_expiry_time = amqpMsg.creation_time + amqpMsg.ttl;
        }
        else {
            amqpMsg.absolute_expiry_time = coreAmqp.Constants.maxAbsoluteExpiryTime;
        }
    }
    if (msg.partitionKey != null) {
        if (msg.partitionKey.length > coreAmqp.Constants.maxPartitionKeyLength) {
            throw new Error("Length of 'partitionKey' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.message_annotations[coreAmqp.Constants.partitionKey] = msg.partitionKey;
    }
    // Will be required later for implementing Transactions
    // if (msg.viaPartitionKey != null) {
    //   if (msg.viaPartitionKey.length > Constants.maxPartitionKeyLength) {
    //     throw new Error(
    //       "Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters."
    //     );
    //   }
    //   amqpMsg.message_annotations![Constants.viaPartitionKey] = msg.viaPartitionKey;
    // }
    if (msg.scheduledEnqueueTimeUtc != null) {
        amqpMsg.message_annotations[coreAmqp.Constants.scheduledEnqueueTime] = msg.scheduledEnqueueTimeUtc;
    }
    messageLogger.verbose("SBMessage to RheaMessage: %O", amqpMsg);
    return amqpMsg;
}
/**
 * @internal
 * @hidden
 * Converts given RheaMessage to ServiceBusReceivedMessage
 */
function fromRheaMessage(msg, delivery, shouldReorderLockToken) {
    var _a, _b;
    if (!msg) {
        msg = {
            body: undefined
        };
    }
    const sbmsg = {
        body: msg.body
    };
    if (msg.application_properties != null) {
        sbmsg.applicationProperties = msg.application_properties;
    }
    if (msg.content_type != null) {
        sbmsg.contentType = msg.content_type;
    }
    if (msg.group_id != null) {
        sbmsg.sessionId = msg.group_id;
    }
    if (msg.reply_to != null) {
        sbmsg.replyTo = msg.reply_to;
    }
    if (msg.to != null) {
        sbmsg.to = msg.to;
    }
    if (msg.ttl != null) {
        sbmsg.timeToLive = msg.ttl;
    }
    if (msg.subject != null) {
        sbmsg.subject = msg.subject;
    }
    if (msg.message_id != null) {
        sbmsg.messageId = msg.message_id;
    }
    if (msg.correlation_id != null) {
        sbmsg.correlationId = msg.correlation_id;
    }
    if (msg.reply_to_group_id != null) {
        sbmsg.replyToSessionId = msg.reply_to_group_id;
    }
    if (msg.message_annotations != null) {
        if (msg.message_annotations[coreAmqp.Constants.partitionKey] != null) {
            sbmsg.partitionKey = msg.message_annotations[coreAmqp.Constants.partitionKey];
        }
        // Will be required later for implementing Transactions
        // if (msg.message_annotations[Constants.viaPartitionKey] != null) {
        //   sbmsg.viaPartitionKey = msg.message_annotations[Constants.viaPartitionKey];
        // }
        if (msg.message_annotations[coreAmqp.Constants.scheduledEnqueueTime] != null) {
            sbmsg.scheduledEnqueueTimeUtc = msg.message_annotations[coreAmqp.Constants.scheduledEnqueueTime];
        }
    }
    const props = {};
    if (msg.message_annotations != null) {
        if (msg.message_annotations[coreAmqp.Constants.deadLetterSource] != null) {
            props.deadLetterSource = msg.message_annotations[coreAmqp.Constants.deadLetterSource];
        }
        if (msg.message_annotations[coreAmqp.Constants.enqueueSequenceNumber] != null) {
            props.enqueuedSequenceNumber = msg.message_annotations[coreAmqp.Constants.enqueueSequenceNumber];
        }
        if (msg.message_annotations[coreAmqp.Constants.sequenceNumber] != null) {
            if (buffer.Buffer.isBuffer(msg.message_annotations[coreAmqp.Constants.sequenceNumber])) {
                props.sequenceNumber = Long.fromBytesBE(msg.message_annotations[coreAmqp.Constants.sequenceNumber]);
            }
            else {
                props.sequenceNumber = Long.fromNumber(msg.message_annotations[coreAmqp.Constants.sequenceNumber]);
            }
        }
        if (msg.message_annotations[coreAmqp.Constants.enqueuedTime] != null) {
            props.enqueuedTimeUtc = new Date(msg.message_annotations[coreAmqp.Constants.enqueuedTime]);
        }
        if (msg.message_annotations[coreAmqp.Constants.lockedUntil] != null) {
            props.lockedUntilUtc = new Date(msg.message_annotations[coreAmqp.Constants.lockedUntil]);
        }
    }
    if (msg.ttl != null && msg.ttl >= coreAmqp.Constants.maxDurationValue - props.enqueuedTimeUtc.getTime()) {
        props.expiresAtUtc = new Date(coreAmqp.Constants.maxDurationValue);
    }
    else {
        props.expiresAtUtc = new Date(props.enqueuedTimeUtc.getTime() + msg.ttl);
    }
    const rcvdsbmsg = Object.assign(Object.assign(Object.assign({ _rawAmqpMessage: coreAmqp.AmqpAnnotatedMessage.fromRheaMessage(msg), _delivery: delivery, deliveryCount: msg.delivery_count, lockToken: delivery && delivery.tag && delivery.tag.length !== 0
            ? rheaPromise.uuid_to_string(shouldReorderLockToken === true
                ? reorderLockToken(typeof delivery.tag === "string" ? buffer.Buffer.from(delivery.tag) : delivery.tag)
                : typeof delivery.tag === "string"
                    ? buffer.Buffer.from(delivery.tag)
                    : delivery.tag)
            : undefined }, sbmsg), props), { deadLetterReason: (_a = sbmsg.applicationProperties) === null || _a === void 0 ? void 0 : _a.DeadLetterReason, deadLetterErrorDescription: (_b = sbmsg.applicationProperties) === null || _b === void 0 ? void 0 : _b.DeadLetterErrorDescription });
    messageLogger.verbose("AmqpMessage to ServiceBusReceivedMessage: %O", rcvdsbmsg);
    return rcvdsbmsg;
}
/**
 * @internal
 * @hidden
 */
function isServiceBusMessage(possible) {
    return possible != null && typeof possible === "object" && "body" in possible;
}
/**
 * Describes the message received from Service Bus.
 *
 * @internal
 * @hidden
 * @class ServiceBusMessageImpl
 * @implements {ServiceBusReceivedMessage}
 */
class ServiceBusMessageImpl {
    /**
     * @internal
     */
    constructor(msg, delivery, shouldReorderLockToken, receiveMode) {
        Object.assign(this, fromRheaMessage(msg, delivery, shouldReorderLockToken));
        // Lock on a message is applicable only in peekLock mode, but the service sets
        // the lock token even in receiveAndDelete mode if the entity in question is partitioned.
        if (receiveMode === "receiveAndDelete") {
            this.lockToken = undefined;
        }
        if (msg.body) {
            this.body = defaultDataTransformer.decode(msg.body);
        }
        // TODO: _rawAmqpMessage is already being populated in fromRheaMessage(), no need to do it twice
        this._rawAmqpMessage = coreAmqp.AmqpAnnotatedMessage.fromRheaMessage(msg);
        this.delivery = delivery;
    }
    /**
     * Creates a clone of the current message to allow it to be re-sent to the queue
     * @returns ServiceBusMessage
     */
    clone() {
        // We are returning a ServiceBusMessage object because that object can then be sent to Service Bus
        const clone = {
            body: this.body,
            contentType: this.contentType,
            correlationId: this.correlationId,
            subject: this.subject,
            messageId: this.messageId,
            partitionKey: this.partitionKey,
            replyTo: this.replyTo,
            replyToSessionId: this.replyToSessionId,
            scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,
            sessionId: this.sessionId,
            timeToLive: this.timeToLive,
            to: this.to,
            applicationProperties: this.applicationProperties
            // Will be required later for implementing Transactions
            // viaPartitionKey: this.viaPartitionKey
        };
        return clone;
    }
}

/**
 * Translation between the MessagingErrorCodes into a ServiceBusCode
 *
 * @internal
 * @hidden
 */
const wellKnownMessageCodesToServiceBusCodes = new Map([
    ["MessagingEntityNotFoundError", "MessagingEntityNotFound"],
    ["MessageLockLostError", "MessageLockLost"],
    ["MessageNotFoundError", "MessageNotFound"],
    ["MessageTooLargeError", "MessageSizeExceeded"],
    ["MessagingEntityAlreadyExistsError", "MessagingEntityAlreadyExists"],
    ["MessagingEntityDisabledError", "MessagingEntityDisabled"],
    ["QuotaExceededError", "QuotaExceeded"],
    ["ServerBusyError", "ServiceBusy"],
    ["OperationTimeoutError", "ServiceTimeout"],
    ["ServiceCommunicationError", "ServiceCommunicationProblem"],
    ["SessionCannotBeLockedError", "SessionCannotBeLocked"],
    ["SessionLockLostError", "SessionLockLost"],
    ["UnauthorizedError", "UnauthorizedAccess"]
]);
/**
 * Errors that occur within Service Bus.
 */
class ServiceBusError extends coreAmqp.MessagingError {
    constructor(messageOrError, code) {
        const message = typeof messageOrError === "string" ? messageOrError : messageOrError.message;
        super(message);
        if (typeof messageOrError === "string") {
            this.code = code !== null && code !== void 0 ? code : "GeneralError";
        }
        else {
            for (const prop in messageOrError) {
                this[prop] = messageOrError[prop];
            }
            this.code = ServiceBusError.normalizeMessagingCode(messageOrError.code);
            // For GeneralErrors, prefix the error message with the MessagingError code to provide
            // more context to the user.
            if (this.code === "GeneralError" && messageOrError.code) {
                this.message = `${messageOrError.code}: ${this.message}`;
            }
        }
        this.name = "ServiceBusError";
    }
    static normalizeMessagingCode(oldCode) {
        if (oldCode == null || !wellKnownMessageCodesToServiceBusCodes.has(oldCode)) {
            return "GeneralError";
        }
        return wellKnownMessageCodesToServiceBusCodes.get(oldCode);
    }
}
/**
 * Translates an error into either an Error or a ServiceBusError which provides a `reason` code that
 * can be used by clients to programatically react to errors.
 *
 * If you are calling `@azure/core-amqp/translate` you should swap to using this function instead since it provides
 * Service Bus specific handling of the error (falling back to default translate behavior otherwise).
 *
 * @internal
 * @hidden
 */
function translateServiceBusError(err) {
    if (isServiceBusError(err)) {
        return err;
    }
    const translatedError = coreAmqp.translate(err);
    if (coreAmqp.isMessagingError(translatedError)) {
        return new ServiceBusError(translatedError);
    }
    return translatedError;
}
/**
 * Determines if an error is of type `ServiceBusError`
 *
 * @param err An error to check to see if it's of type ServiceBusError
 */
function isServiceBusError(err) {
    return (err === null || err === void 0 ? void 0 : err.name) === "ServiceBusError";
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Describes the base class for entities like MessageSender, MessageReceiver and Management client.
 */
class LinkEntity {
    /**
     * Creates a new ClientEntity instance.
     * @constructor
     * @param baseName The base name to use for the link. A unique ID will be appended to this.
     * @param entityPath The entity path (ex: 'your-queue')
     * @param context The connection context.
     * @param options Options that can be provided while creating the LinkEntity.
     */
    constructor(baseName, entityPath, context, _linkType, _logger, options) {
        this.baseName = baseName;
        this.entityPath = entityPath;
        this._linkType = _linkType;
        this._logger = _logger;
        /**
         * Indicates that close() has been called on this link and
         * that it should not be allowed to reopen.
         */
        this._wasClosedPermanently = false;
        /**
         * A lock that ensures that opening and closing this
         * link properly cooperate.
         */
        this._openLock = rheaPromise.generate_uuid();
        if (!options)
            options = {};
        this._context = context;
        this.address = options.address || "";
        this.audience = options.audience || "";
        this.name = getUniqueName(baseName);
        this._logPrefix = `[${context.connectionId}|${this._linkType}:${this.name}]`;
    }
    get logPrefix() {
        return this._logPrefix;
    }
    /**
     * Determines whether the AMQP link is open. If open then returns true else returns false.
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this._link ? this._link.isOpen() : false;
        this._logger.verbose(`${this._logPrefix} is open? ${result}`);
        return result;
    }
    /**
     * Initializes this LinkEntity, setting this._link with the result of  `createRheaLink`, which
     * is implemented by child classes.
     *
     * @returns A Promise that resolves when the link has been properly initialized
     * @throws {AbortError} if the link has been closed via 'close'
     */
    initLink(options, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // we'll check that the connection isn't in the process of recycling (and if so, wait for it to complete)
            yield this._context.readyToOpenLink();
            this._logger.verbose(`${this._logPrefix} Attempting to acquire lock token ${this._openLock} for initializing link`);
            return coreAmqp.defaultLock.acquire(this._openLock, () => {
                this._logger.verbose(`${this._logPrefix} Lock ${this._openLock} acquired for initializing link`);
                return this._initLinkImpl(options, abortSignal);
            });
        });
    }
    _initLinkImpl(options, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const checkAborted = () => {
                if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                    throw new abortController.AbortError(StandardAbortMessage);
                }
            };
            const connectionId = this._context.connectionId;
            checkAborted();
            if (options.name) {
                this.name = options.name;
                this._logPrefix = `[${connectionId}|${this._linkType}:${this.name}]`;
            }
            if (this._wasClosedPermanently) {
                this._logger.verbose(`${this._logPrefix} Link has been permanently closed. Not reopening.`);
                throw new abortController.AbortError(`Link has been permanently closed. Not reopening.`);
            }
            if (this.isOpen()) {
                this._logger.verbose(`${this._logPrefix} Link is already open. Returning.`);
                return;
            }
            this._logger.verbose(`${this._logPrefix} Is not open and is not currently connecting. Opening.`);
            try {
                yield this._negotiateClaim();
                checkAborted();
                this.checkIfConnectionReady();
                this._logger.verbose(`${this._logPrefix} Creating with options %O`, options);
                this._link = yield this.createRheaLink(options);
                checkAborted();
                this._ensureTokenRenewal();
                this._logger.verbose(`${this._logPrefix} Link has been created.`);
            }
            catch (err) {
                this._logger.logError(err, `${this._logPrefix} Error thrown when creating the link`);
                yield this.closeLinkImpl();
                throw err;
            }
        });
    }
    /**
     * Clears token renewal for current link, removes current LinkEntity instance from cache,
     * and closes the underlying AMQP link.
     * Once closed, this instance of LinkEntity is not meant to be re-used.
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Set the flag to indicate that this instance of LinkEntity is not meant to be re-used.
            this._wasClosedPermanently = true;
            this._logger.verbose(`${this.logPrefix} permanently closing this link.`);
            // Remove the underlying AMQP link from the cache
            switch (this._linkType) {
                case "s": {
                    delete this._context.senders[this.name];
                    break;
                }
                case "br":
                case "sr": {
                    delete this._context.messageReceivers[this.name];
                    break;
                }
                case "ms": {
                    delete this._context.messageSessions[this.name];
                    break;
                }
            }
            yield this.closeLink();
            this._logger.verbose(`${this.logPrefix} permanently closed this link.`);
        });
    }
    /**
     * Closes the internally held rhea link, stops the token renewal timer and sets
     * the this._link field to undefined.
     */
    closeLink() {
        this._logger.verbose(`${this._logPrefix} Attempting to acquire lock token ${this._openLock} for closing link`);
        return coreAmqp.defaultLock.acquire(this._openLock, () => {
            this._logger.verbose(`${this._logPrefix} Lock ${this._openLock} acquired for closing link`);
            return this.closeLinkImpl();
        });
    }
    closeLinkImpl() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._logger.verbose(`${this._logPrefix} closeLinkImpl() called`);
            clearTimeout(this._tokenRenewalTimer);
            this._tokenRenewalTimer = undefined;
            if (this._link) {
                try {
                    const link = this._link;
                    this._link = undefined;
                    // This should take care of closing the link and it's underlying session. This should also
                    // remove them from the internal map.
                    yield link.close();
                    this._logger.verbose(`${this._logPrefix} closed.`);
                }
                catch (err) {
                    this._logger.logError(err, `${this._logPrefix} An error occurred while closing the link`);
                }
            }
        });
    }
    /**
     * Provides the current type of the ClientEntity.
     * @return {string} The entity type.
     */
    get _type() {
        let result = "LinkEntity";
        if (this.constructor && this.constructor.name) {
            result = this.constructor.name;
        }
        return result;
    }
    get wasClosedPermanently() {
        return this._wasClosedPermanently;
    }
    get link() {
        return this._link;
    }
    /**
     * Negotiates the cbs claim for the ClientEntity.
     * @param {boolean} [setTokenRenewal] Set the token renewal timer. Default false.
     * @return {Promise<void>} Promise<void>
     */
    _negotiateClaim(setTokenRenewal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._logger.verbose(`${this._logPrefix} negotiateclaim() has been called`);
            // Wait for the connectionContext to be ready to open the link.
            this.checkIfConnectionReady();
            // Acquire the lock and establish a cbs session if it does not exist on the connection.
            // Although node.js is single threaded, we need a locking mechanism to ensure that a
            // race condition does not happen while creating a shared resource (in this case the
            // cbs session, since we want to have exactly 1 cbs session per connection).
            this._logger.verbose("%s Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: " +
                "'%s' with address: '%s'.", this.logPrefix, this._context.cbsSession.cbsLock, this._type, this.name, this.address);
            yield coreAmqp.defaultLock.acquire(this._context.cbsSession.cbsLock, () => tslib.__awaiter(this, void 0, void 0, function* () {
                this.checkIfConnectionReady();
                return this._context.cbsSession.init();
            }));
            let tokenObject;
            let tokenType;
            if (this._context.tokenCredential instanceof SharedKeyCredential) {
                tokenObject = this._context.tokenCredential.getToken(this.audience);
                tokenType = coreAmqp.TokenType.CbsTokenTypeSas;
                // expiresOnTimestamp can be 0 if the token is not meant to be renewed
                // (ie, SharedAccessSignatureCredential)
                if (tokenObject.expiresOnTimestamp > 0) {
                    // renew sas token in every 45 minutes
                    this._tokenTimeout = (3600 - 900) * 1000;
                }
            }
            else {
                const aadToken = yield this._context.tokenCredential.getToken(coreAmqp.Constants.aadServiceBusScope);
                if (!aadToken) {
                    throw new Error(`Failed to get token from the provided "TokenCredential" object`);
                }
                tokenObject = aadToken;
                tokenType = coreAmqp.TokenType.CbsTokenTypeJwt;
                this._tokenTimeout = tokenObject.expiresOnTimestamp - Date.now() - 2 * 60 * 1000;
            }
            this._logger.verbose("%s %s: calling negotiateClaim for audience '%s'.", this.logPrefix, this._type, this.audience);
            // Acquire the lock to negotiate the CBS claim.
            this._logger.verbose("%s Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.", this.logPrefix, this._context.negotiateClaimLock, this._type, this.name, this.address);
            if (!tokenObject) {
                throw new Error("Token cannot be null");
            }
            yield coreAmqp.defaultLock.acquire(this._context.negotiateClaimLock, () => {
                this.checkIfConnectionReady();
                return this._context.cbsSession.negotiateClaim(this.audience, tokenObject.token, tokenType);
            });
            this._logger.verbose("%s Negotiated claim for %s '%s' with with address: %s", this.logPrefix, this._type, this.name, this.address);
            if (setTokenRenewal) {
                this._ensureTokenRenewal();
            }
        });
    }
    /**
     * Checks to see if the connection is in a "reopening" state. If it is
     * we need to _not_ use it otherwise we'll trigger some race conditions
     * within rhea (for instance, errors about _process not being defined).
     */
    checkIfConnectionReady() {
        if (!this._context.isConnectionClosing()) {
            return;
        }
        this._logger.verbose(`${this._logPrefix} Connection is reopening, aborting link initialization.`);
        const err = new ServiceBusError("Connection is reopening, aborting link initialization.", "GeneralError");
        err.retryable = true;
        throw err;
    }
    /**
     * Ensures that the token is renewed within the predefined renewal margin.
     * @returns {void}
     */
    _ensureTokenRenewal() {
        if (!this._tokenTimeout) {
            return;
        }
        // Clear the existing token renewal timer.
        // This scenario can happen if the connection goes down and is brought back up
        // before the `nextRenewalTimeout` was reached.
        if (this._tokenRenewalTimer) {
            clearTimeout(this._tokenRenewalTimer);
        }
        this._tokenRenewalTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this._negotiateClaim(true);
            }
            catch (err) {
                this._logger.logError(err, "%s %s '%s' with address %s, an error occurred while renewing the token", this.logPrefix, this._type, this.name, this.address);
            }
        }), this._tokenTimeout);
        this._logger.verbose("%s %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).", this.logPrefix, this._type, this.name, this.address, this._tokenTimeout, new Date(Date.now() + this._tokenTimeout).toString());
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Error message to use when EntityPath in connection string does not match the
 * queue or topic name passed to the methods in the ServiceBusClient that create
 * senders and receivers.
 *
 * @internal
 * @hidden
 */
const entityPathMisMatchError = "The queue or topic name provided does not match the EntityPath in the connection string passed to the ServiceBusClient constructor.";
/**
 * Error message for when maxMessageCount provided is invalid.
 *
 * @internal
 * @hidden
 */
const InvalidMaxMessageCountError = "'maxMessageCount' must be a number greater than 0.";
/**
 * @internal
 * @hidden
 * Logs and throws Error if the current AMQP connection is closed.
 * @param context The ConnectionContext associated with the current AMQP connection.
 */
function throwErrorIfConnectionClosed(context) {
    if (context && context.wasConnectionCloseCalled) {
        const errorMessage = "The underlying AMQP connection is closed.";
        const error = new Error(errorMessage);
        logger.warning(`[${context.connectionId}] %O`, error);
        throw error;
    }
}
/**
 * @internal
 * @hidden
 * Gets the error message when a sender is used when its already closed
 * @param entityPath Value of the `entityPath` property on the client which denotes its name
 */
function getSenderClosedErrorMsg(entityPath) {
    return (`The sender for "${entityPath}" has been closed and can no longer be used. ` +
        `Please create a new sender using the "createSender" method on the ServiceBusClient.`);
}
/**
 * @internal
 * @hidden
 * Gets the error message when a receiver is used when its already closed
 * @param entityPath Value of the `entityPath` property on the client which denotes its name
 * @param sessionId If using session receiver, then the id of the session
 */
function getReceiverClosedErrorMsg(entityPath, sessionId) {
    if (sessionId == undefined) {
        return (`The receiver for "${entityPath}" has been closed and can no longer be used. ` +
            `Please create a new receiver using the "createReceiver" method on the ServiceBusClient.`);
    }
    return (`The receiver for session "${sessionId}" in "${entityPath}" has been closed and can no ` +
        `longer be used. Please create a new receiver using the "acceptSession" or "acceptNextSession" method on the ServiceBusClient.`);
}
/**
 * @internal
 * @hidden
 * @param entityPath Value of the `entityPath` property on the client which denotes its name
 * @param sessionId If using session receiver, then the id of the session
 */
function getAlreadyReceivingErrorMsg(entityPath, sessionId) {
    if (sessionId == undefined) {
        return `The receiver for "${entityPath}" is already receiving messages.`;
    }
    return `The receiver for session "${sessionId}" for "${entityPath}" is already receiving messages.`;
}
/**
 * @internal
 * @hidden
 * Logs and Throws TypeError if given parameter is undefined or null
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to check
 * @param parameterValue Value of the parameter to check
 */
function throwTypeErrorIfParameterMissing(connectionId, parameterName, parameterValue) {
    if (parameterValue === undefined || parameterValue === null) {
        const error = new TypeError(`Missing parameter "${parameterName}"`);
        logger.warning(`[${connectionId}] %O`, error);
        throw error;
    }
}
/**
 * @internal
 * @hidden
 * Logs and Throws TypeError if given parameter is not of expected type
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 * @param expectedType Expected type of the parameter
 */
function throwTypeErrorIfParameterTypeMismatch(connectionId, parameterName, parameterValue, expectedType) {
    if (typeof parameterValue !== expectedType) {
        const error = new TypeError(`The parameter "${parameterName}" should be of type "${expectedType}"`);
        logger.warning(`[${connectionId}] %O`, error);
        throw error;
    }
}
/**
 * @internal
 * @hidden
 * Logs and Throws TypeError if given parameter is not of type `Long` or an array of type `Long`
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 */
function throwTypeErrorIfParameterNotLong(connectionId, parameterName, parameterValue) {
    if (Array.isArray(parameterValue)) {
        return throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue);
    }
    if (Long.isLong(parameterValue)) {
        return;
    }
    const error = new TypeError(`The parameter "${parameterName}" should be of type "Long"`);
    logger.warning(`[${connectionId}] %O`, error);
    throw error;
}
/**
 * @internal
 * @hidden
 * Logs and Throws TypeError if given parameter is not an array of type `Long`
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 */
function throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue) {
    if (parameterValue.every((item) => Long.isLong(item))) {
        return;
    }
    const error = new TypeError(`The parameter "${parameterName}" should be an array of type "Long"`);
    logger.warning(`[${connectionId}] %O`, error);
    throw error;
}
/**
 * @internal
 * @hidden
 * Logs and Throws TypeError if given parameter is an empty string
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 */
function throwTypeErrorIfParameterIsEmptyString(connectionId, parameterName, parameterValue) {
    if (parameterValue !== "") {
        return;
    }
    const error = new TypeError(`Empty string not allowed in parameter "${parameterName}"`);
    logger.warning(`[${connectionId}] %O`, error);
    throw error;
}
/**
 * @internal
 * @hidden
 * The error message for operations on the receiver that are invalid for a message received in receiveAndDelete mode.
 */
const InvalidOperationInReceiveAndDeleteMode = "The operation is not supported in 'receiveAndDelete' receive mode.";
/**
 * @internal
 * @hidden
 * The error message for operations on the receiver that are invalid for a peeked message.
 */
const InvalidOperationForPeekedMessage = "This operation is not supported for peeked messages. Only messages received using 'receiveMessages()', 'subscribe()' and 'getMessageIterator()' methods on the receiver in 'peekLock' receive mode can be settled.";
/**
 * @internal
 * @hidden
 * The error message for when one attempts to settle an already settled message.
 */
const MessageAlreadySettled = "The message has either been deleted or already settled";
/**
 * Throws error if the ServiceBusReceivedMessage cannot be settled.
 * @internal
 * @hidden
 */
function throwErrorIfInvalidOperationOnMessage(message, receiveMode, connectionId) {
    let error;
    if (receiveMode === "receiveAndDelete") {
        error = new Error(InvalidOperationInReceiveAndDeleteMode);
    }
    else if (!message.lockToken) {
        error = new Error(InvalidOperationForPeekedMessage);
    }
    if (error) {
        receiverLogger.logError(error, "[%s] An error occurred for message with id '%s'", connectionId, message.messageId);
        throw error;
    }
}
/**
 * Error message for when the ServiceBusMessage provided by the user has different values
 * for partitionKey and sessionId.
 * @internal
 * @hidden
 * @throw
 */
const PartitionKeySessionIdMismatchError = "The fields 'partitionKey' and 'sessionId' cannot have different values.";
/**
 * Throws error if the given object is not a valid ServiceBusMessage
 * @internal
 * @hidden
 * @param msg The object that needs to be validated as a ServiceBusMessage
 * @param errorMessageForWrongType The error message to use when given object is not a ServiceBusMessage
 */
function throwIfNotValidServiceBusMessage(msg, errorMessageForWrongType) {
    if (!isServiceBusMessage(msg)) {
        throw new TypeError(errorMessageForWrongType);
    }
    if (msg.partitionKey && msg.sessionId && msg.partitionKey !== msg.sessionId) {
        throw new TypeError(PartitionKeySessionIdMismatchError);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 */
const correlationProperties = [
    "correlationId",
    "messageId",
    "to",
    "replyTo",
    "subject",
    "sessionId",
    "replyToSessionId",
    "contentType",
    "applicationProperties"
];
/**
 * @internal
 * @hidden
 * @class ManagementClient
 * Describes the ServiceBus Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
class ManagementClient extends LinkEntity {
    /**
     * @constructor
     * Instantiates the management client.
     * @param context The connection context
     * @param entityPath - The name/path of the entity (queue/topic/subscription name)
     * for which the management request needs to be made.
     * @param {ManagementClientOptions} [options] Options to be provided for creating the
     * "$management" client.
     */
    constructor(context, entityPath, options) {
        super(`${entityPath}/$management`, entityPath, context, "mgmt", managementClientLogger, {
            address: options && options.address ? options.address : coreAmqp.Constants.management,
            audience: options && options.audience
                ? options.audience
                : `${context.config.endpoint}${entityPath}/$management`
        });
        /**
         * @property {string} replyTo The reply to Guid for the management client.
         */
        this.replyTo = rheaPromise.generate_uuid();
        /**
         * @property _lastPeekedSequenceNumber Provides the sequence number of the last peeked message.
         */
        this._lastPeekedSequenceNumber = Long.ZERO;
        this._context = context;
    }
    _init(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const rxopt = {
                    source: { address: this.address },
                    name: this.replyTo,
                    target: { address: this.replyTo },
                    onSessionError: (context) => {
                        const sbError = translateServiceBusError(context.session.error);
                        managementClientLogger.logError(sbError, `${this.logPrefix} An error occurred on the session for request/response links for $management`);
                    }
                };
                const sropt = {
                    target: { address: this.address },
                    onError: (context) => {
                        const ehError = translateServiceBusError(context.sender.error);
                        managementClientLogger.logError(ehError, `${this.logPrefix} An error occurred on the $management sender link`);
                    }
                };
                // Even if multiple parallel requests reach here, the initLink secures a lock
                // to ensure there won't be multiple initializations
                yield this.initLink({
                    senderOptions: sropt,
                    receiverOptions: rxopt
                }, abortSignal);
            }
            catch (err) {
                err = translateServiceBusError(err);
                managementClientLogger.logError(err, `${this.logPrefix} An error occurred while establishing the $management links`);
                throw err;
            }
        });
    }
    createRheaLink(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const rheaLink = yield coreAmqp.RequestResponseLink.create(this._context.connection, options.senderOptions, options.receiverOptions);
            // Attach listener for the `receiver_error` events to log the errors.
            // "message" event listener is added in core-amqp.
            // "rhea" doesn't allow setting only the "onError" handler in the options if it is not accompanied by an "onMessage" handler.
            // Hence, not passing onError handler in the receiver options, adding a handler below.
            rheaLink.receiver.on(rheaPromise.ReceiverEvents.receiverError, (context) => {
                const ehError = translateServiceBusError(context.receiver.error);
                managementClientLogger.logError(ehError, `${this.logPrefix} An error occurred on the $management receiver link`);
            });
            return rheaLink;
        });
    }
    /**
     * Given array of typed values, returns the element in given index
     */
    _safelyGetTypedValueFromArray(data, index) {
        return Array.isArray(data) && data.length > index && data[index]
            ? data[index].value
            : undefined;
    }
    _makeManagementRequest(request, internalLogger, sendRequestOptions = {}) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (request.message_id == undefined) {
                request.message_id = rheaPromise.generate_uuid();
            }
            const retryTimeoutInMs = (_a = sendRequestOptions.timeoutInMs) !== null && _a !== void 0 ? _a : coreAmqp.Constants.defaultOperationTimeoutInMs;
            const initOperationStartTime = Date.now();
            const actionAfterTimeout = (reject) => {
                const desc = `The request with message_id "${request.message_id}" timed out. Please try again later.`;
                const e = {
                    name: "OperationTimeoutError",
                    message: desc
                };
                reject(e);
            };
            let waitTimer;
            const operationTimeout = new Promise((_, reject) => {
                waitTimer = setTimeout(() => actionAfterTimeout(reject), retryTimeoutInMs);
            });
            internalLogger.verbose(`${this.logPrefix} Acquiring lock to get the management req res link.`);
            try {
                if (!this.isOpen()) {
                    yield Promise.race([this._init(sendRequestOptions === null || sendRequestOptions === void 0 ? void 0 : sendRequestOptions.abortSignal), operationTimeout]);
                }
            }
            finally {
                clearTimeout(waitTimer);
            }
            // time taken by the init operation
            const timeTakenByInit = Date.now() - initOperationStartTime;
            // Left over time
            sendRequestOptions.timeoutInMs = retryTimeoutInMs - timeTakenByInit;
            try {
                if (!request.message_id)
                    request.message_id = rheaPromise.generate_uuid();
                return yield this.link.sendRequest(request, sendRequestOptions);
            }
            catch (err) {
                err = translateServiceBusError(err);
                internalLogger.logError(err, "%s An error occurred during send on management request-response link with address " +
                    "'%s': %O", this.logPrefix, this.address, err);
                throw err;
            }
        });
    }
    /**
     * Closes the AMQP management session to the ServiceBus namespace for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @return Promise<void>
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                // Always clear the timeout, as the isOpen check may report
                // false without ever having cleared the timeout otherwise.
                // NOTE: management link currently doesn't have a separate concept of "detaching" like
                // the other links do. When we add handling of this (via the onDetached call, like other links)
                // we can change this back to closeLink("permanent").
                yield this.closeLink();
                managementClientLogger.verbose("Successfully closed the management session.");
            }
            catch (err) {
                managementClientLogger.logError(err, `${this.logPrefix} An error occurred while closing the management session`);
                throw err;
            }
        });
    }
    /**
     * Fetches the next batch of active messages. The first call to `peek()` fetches the first
     * active message for this client. Each subsequent call fetches the subsequent message in the
     * entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. This method will
     * also fetch even Deferred messages (but not Deadlettered message).
     *
     * @param messageCount The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     */
    peek(messageCount, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, undefined, options);
        });
    }
    /**
     * Fetches the next batch of active messages in the current MessageSession. The first call to
     * `peek()` fetches the first active message for this client. Each subsequent call fetches the
     * subsequent message in the entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`.  This method will
     * also fetch even Deferred messages (but not Deadlettered message).
     *
     * @param sessionId The sessionId from which messages need to be peeked.
     * @param messageCount The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedMessageInfo[]>
     */
    peekMessagesBySession(sessionId, messageCount, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, sessionId, options);
        });
    }
    /**
     * Peeks the desired number of messages from the specified sequence number.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param messageCount The number of messages to retrieve. Default value `1`.
     * @param sessionId The sessionId from which messages need to be peeked.
     * @returns Promise<ReceivedMessageInfo[]>
     */
    peekBySequenceNumber(fromSequenceNumber, maxMessageCount, sessionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            const connId = this._context.connectionId;
            // Checks for fromSequenceNumber
            throwTypeErrorIfParameterMissing(connId, "fromSequenceNumber", fromSequenceNumber);
            throwTypeErrorIfParameterNotLong(connId, "fromSequenceNumber", fromSequenceNumber);
            // Checks for maxMessageCount
            throwTypeErrorIfParameterMissing(this._context.connectionId, "maxMessageCount", maxMessageCount);
            throwTypeErrorIfParameterTypeMismatch(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");
            if (isNaN(maxMessageCount) || maxMessageCount < 1) {
                throw new TypeError(InvalidMaxMessageCountError);
            }
            const messageList = [];
            try {
                const messageBody = {};
                messageBody[coreAmqp.Constants.fromSequenceNumber] = rheaPromise.types.wrap_long(buffer.Buffer.from(fromSequenceNumber.toBytesBE()));
                messageBody[coreAmqp.Constants.messageCount] = rheaPromise.types.wrap_int(maxMessageCount);
                if (sessionId != undefined) {
                    messageBody[coreAmqp.Constants.sessionIdMapKey] = sessionId;
                }
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.peekMessage
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                // TODO: it'd be nice to attribute this peek request to the actual receiver that made it. So have them pass in a
                // log prefix rather than just falling back to the management links.
                receiverLogger.verbose("%s Peek by sequence number request body: %O.", this.logPrefix, request.body);
                const result = yield this._makeManagementRequest(request, receiverLogger, options);
                if (result.application_properties.statusCode !== 204) {
                    const messages = result.body.messages;
                    for (const msg of messages) {
                        const decodedMessage = rheaPromise.message.decode(msg.message);
                        const message = fromRheaMessage(decodedMessage);
                        message.body = defaultDataTransformer.decode(message.body);
                        messageList.push(message);
                        this._lastPeekedSequenceNumber = message.sequenceNumber;
                    }
                }
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to peek messages to $management endpoint`);
                // statusCode == 404 then do not throw
                if (error.code !== coreAmqp.ConditionErrorNameMapper["com.microsoft:message-not-found"]) {
                    throw error;
                }
            }
            return messageList;
        });
    }
    /**
     * Renews the lock on the message. The lock will be renewed based on the setting specified on
     * the queue.
     *
     * When a message is received in `PeekLock` mode, the message is locked on the server for this
     * receiver instance for a duration as specified during the Queue/Subscription creation
     * (LockDuration). If processing of the message requires longer than this duration, the
     * lock needs to be renewed. For each renewal, it resets the time the message is locked by the
     * LockDuration set on the Entity.
     *
     * @param lockToken Lock token of the message
     * @param options Options that can be set while sending the request.
     * @returns Promise<Date> New lock token expiry date and time in UTC format.
     */
    renewLock(lockToken, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (!options)
                options = {};
            if (options.timeoutInMs == null)
                options.timeoutInMs = 5000;
            try {
                const messageBody = {};
                messageBody[coreAmqp.Constants.lockTokens] = rheaPromise.types.wrap_array([rheaPromise.string_to_uuid(lockToken)], 0x98, undefined);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.renewLock
                    }
                };
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                if (options.associatedLinkName) {
                    request.application_properties[coreAmqp.Constants.associatedLinkName] = options.associatedLinkName;
                }
                receiverLogger.verbose("[%s] Renew message Lock request: %O.", this._context.connectionId, request);
                const result = yield this._makeManagementRequest(request, receiverLogger, {
                    abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
                    requestName: "renewLock"
                });
                const lockedUntilUtc = new Date(result.body.expirations[0]);
                return lockedUntilUtc;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Schedules an array of messages to appear on Service Bus at a later time.
     *
     * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
     * @param messages - An array of messages that needs to be scheduled.
     * @returns Promise<number> The sequence numbers of messages that were scheduled.
     */
    scheduleMessages(scheduledEnqueueTimeUtc, messages, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (!messages.length) {
                return [];
            }
            const messageBody = [];
            for (let i = 0; i < messages.length; i++) {
                const item = messages[i];
                if (!item.messageId)
                    item.messageId = rheaPromise.generate_uuid();
                item.scheduledEnqueueTimeUtc = scheduledEnqueueTimeUtc;
                const amqpMessage = toRheaMessage(item);
                amqpMessage.body = defaultDataTransformer.encode(amqpMessage.body);
                try {
                    const entry = {
                        message: rheaPromise.message.encode(amqpMessage),
                        "message-id": item.messageId
                    };
                    if (item.sessionId) {
                        entry[coreAmqp.Constants.sessionIdMapKey] = item.sessionId;
                    }
                    if (item.partitionKey) {
                        entry["partition-key"] = item.partitionKey;
                    }
                    // Will be required later for implementing Transactions
                    // if (item.viaPartitionKey) {
                    //   entry["via-partition-key"] = item.viaPartitionKey;
                    // }
                    const wrappedEntry = rheaPromise.types.wrap_map(entry);
                    messageBody.push(wrappedEntry);
                }
                catch (err) {
                    let error;
                    if (err instanceof TypeError || err.name === "TypeError") {
                        // `RheaMessageUtil.encode` can fail if message properties are of invalid type
                        // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too
                        // Errors in such cases do not have user-friendly message or call stack
                        // So use `getMessagePropertyTypeMismatchError` to get a better error message
                        error = translateServiceBusError(getMessagePropertyTypeMismatchError(item) || err);
                    }
                    else {
                        error = translateServiceBusError(err);
                    }
                    senderLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the messages array`);
                    throw error;
                }
            }
            try {
                const request = {
                    body: { messages: messageBody },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.scheduleMessage
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                senderLogger.verbose("%s Schedule messages request body: %O.", this.logPrefix, request.body);
                const result = yield this._makeManagementRequest(request, senderLogger, options);
                const sequenceNumbers = result.body[coreAmqp.Constants.sequenceNumbers];
                const sequenceNumbersAsLong = [];
                for (let i = 0; i < sequenceNumbers.length; i++) {
                    if (typeof sequenceNumbers[i] === "number") {
                        sequenceNumbersAsLong.push(Long.fromNumber(sequenceNumbers[i]));
                    }
                    else {
                        sequenceNumbersAsLong.push(Long.fromBytesBE(sequenceNumbers[i]));
                    }
                }
                return sequenceNumbersAsLong;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                senderLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to schedule messages to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Cancels an array of messages that were scheduled.
     * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.
     * @returns Promise<void>
     */
    cancelScheduledMessages(sequenceNumbers, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (!sequenceNumbers.length) {
                return;
            }
            const messageBody = {};
            messageBody[coreAmqp.Constants.sequenceNumbers] = [];
            for (let i = 0; i < sequenceNumbers.length; i++) {
                const sequenceNumber = sequenceNumbers[i];
                try {
                    messageBody[coreAmqp.Constants.sequenceNumbers].push(buffer.Buffer.from(sequenceNumber.toBytesBE()));
                }
                catch (err) {
                    const error = translateServiceBusError(err);
                    senderLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`);
                    throw error;
                }
            }
            try {
                messageBody[coreAmqp.Constants.sequenceNumbers] = rheaPromise.types.wrap_array(messageBody[coreAmqp.Constants.sequenceNumbers], 0x81, undefined);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.cancelScheduledMessage
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                senderLogger.verbose("%s Cancel scheduled messages request body: %O.", this.logPrefix, request.body);
                yield this._makeManagementRequest(request, senderLogger, options);
                return;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                senderLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to cancel the scheduled message to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Receives a list of deferred messages identified by `sequenceNumbers`.
     *
     * @param sequenceNumbers A list containing the sequence numbers to receive.
     * @param receiveMode The mode in which the receiver was created.
     * @returns Promise<ServiceBusMessage[]>
     * - Returns a list of messages identified by the given sequenceNumbers.
     * - Returns an empty list if no messages are found.
     * - Throws an error if the messages have not been deferred.
     */
    receiveDeferredMessages(sequenceNumbers, receiveMode, sessionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (!sequenceNumbers.length) {
                return [];
            }
            const messageList = [];
            const messageBody = {};
            messageBody[coreAmqp.Constants.sequenceNumbers] = [];
            for (let i = 0; i < sequenceNumbers.length; i++) {
                const sequenceNumber = sequenceNumbers[i];
                try {
                    messageBody[coreAmqp.Constants.sequenceNumbers].push(buffer.Buffer.from(sequenceNumber.toBytesBE()));
                }
                catch (err) {
                    const error = translateServiceBusError(err);
                    receiverLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`);
                    throw error;
                }
            }
            try {
                messageBody[coreAmqp.Constants.sequenceNumbers] = rheaPromise.types.wrap_array(messageBody[coreAmqp.Constants.sequenceNumbers], 0x81, undefined);
                const receiverSettleMode = receiveMode === "receiveAndDelete" ? 0 : 1;
                messageBody[coreAmqp.Constants.receiverSettleMode] = rheaPromise.types.wrap_uint(receiverSettleMode);
                if (sessionId != null) {
                    messageBody[coreAmqp.Constants.sessionIdMapKey] = sessionId;
                }
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.receiveBySequenceNumber
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                receiverLogger.verbose("%s Receive deferred messages request body: %O.", this.logPrefix, request.body);
                const result = yield this._makeManagementRequest(request, receiverLogger, options);
                const messages = result.body.messages;
                for (const msg of messages) {
                    const decodedMessage = rheaPromise.message.decode(msg.message);
                    const message = new ServiceBusMessageImpl(decodedMessage, { tag: msg["lock-token"] }, false, receiveMode);
                    messageList.push(message);
                }
                return messageList;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to receive deferred messages to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Updates the disposition status of deferred messages.
     *
     * @param lockTokens Message lock tokens to update disposition status.
     * @param dispositionStatus The disposition status to be set
     * @param options Optional parameters that can be provided while updating the disposition status.
     *
     * @returns Promise<void>
     */
    updateDispositionStatus(lockToken, dispositionType, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (!options)
                options = {};
            try {
                let dispositionStatus;
                if (dispositionType === DispositionType.abandon)
                    dispositionStatus = "abandoned";
                else if (dispositionType === DispositionType.complete)
                    dispositionStatus = "completed";
                else if (dispositionType === DispositionType.defer)
                    dispositionStatus = "defered";
                else if (dispositionType === DispositionType.deadletter)
                    dispositionStatus = "suspended";
                else
                    throw new Error(`Provided "dispositionType" - ${dispositionType} is invalid`);
                const messageBody = {};
                const lockTokenBuffer = [];
                lockTokenBuffer.push(rheaPromise.string_to_uuid(lockToken));
                messageBody[coreAmqp.Constants.lockTokens] = rheaPromise.types.wrap_array(lockTokenBuffer, 0x98, undefined);
                messageBody[coreAmqp.Constants.dispositionStatus] = dispositionStatus;
                if (options.deadLetterDescription != null) {
                    messageBody[coreAmqp.Constants.deadLetterDescription] = options.deadLetterDescription;
                }
                if (options.deadLetterReason != null) {
                    messageBody[coreAmqp.Constants.deadLetterReason] = options.deadLetterReason;
                }
                if (options.propertiesToModify != null) {
                    messageBody[coreAmqp.Constants.propertiesToModify] = options.propertiesToModify;
                }
                if (options.sessionId != null) {
                    messageBody[coreAmqp.Constants.sessionIdMapKey] = options.sessionId;
                }
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.updateDisposition
                    }
                };
                if (options.associatedLinkName) {
                    request.application_properties[coreAmqp.Constants.associatedLinkName] = options.associatedLinkName;
                }
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                receiverLogger.verbose("%s Update disposition status request body: %O.", this.logPrefix, request.body);
                yield this._makeManagementRequest(request, receiverLogger, options);
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to update disposition status to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Renews the lock for the specified session.
     *
     * @param sessionId Id of the session for which the lock needs to be renewed
     * @param options Options that can be set while sending the request.
     * @returns Promise<Date> New lock token expiry date and time in UTC format.
     */
    renewSessionLock(sessionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const messageBody = {};
                messageBody[coreAmqp.Constants.sessionIdMapKey] = sessionId;
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.renewSessionLock
                    }
                };
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                receiverLogger.verbose("%s Renew Session Lock request body: %O.", this.logPrefix, request.body);
                const result = yield this._makeManagementRequest(request, receiverLogger, options);
                const lockedUntilUtc = new Date(result.body.expiration);
                receiverLogger.verbose("%s Lock for session '%s' will expire at %s.", this.logPrefix, sessionId, lockedUntilUtc.toString());
                return lockedUntilUtc;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Sets the state of the specified session.
     *
     * @param sessionId The session for which the state needs to be set
     * @param state The state that needs to be set.
     * @returns Promise<void>
     */
    setSessionState(sessionId, state, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const messageBody = {};
                messageBody[coreAmqp.Constants.sessionIdMapKey] = sessionId;
                messageBody["session-state"] = toBuffer(state);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.setSessionState
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                receiverLogger.verbose("%s Set Session state request body: %O.", this.logPrefix, request.body);
                yield this._makeManagementRequest(request, receiverLogger, options);
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Gets the state of the specified session.
     *
     * @param sessionId The session for which the state needs to be retrieved.
     * @returns Promise<any> The state of that session
     */
    getSessionState(sessionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const messageBody = {};
                messageBody[coreAmqp.Constants.sessionIdMapKey] = sessionId;
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.getSessionState
                    }
                };
                if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
                    request.application_properties[coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
                }
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                receiverLogger.verbose("%s Get session state request body: %O.", this.logPrefix, request.body);
                const result = yield this._makeManagementRequest(request, receiverLogger, options);
                return result.body["session-state"]
                    ? defaultDataTransformer.decode(result.body["session-state"])
                    : result.body["session-state"];
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Lists the sessions on the ServiceBus Queue/Topic.
     * @param lastUpdateTime Filter to include only sessions updated after a given time.
     * @param skip The number of sessions to skip
     * @param top Maximum numer of sessions.
     * @returns Promise<string[]> A list of session ids.
     */
    listMessageSessions(skip, top, lastUpdatedTime, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            const defaultLastUpdatedTimeForListingSessions = 259200000; // 3 * 24 * 3600 * 1000
            if (typeof skip !== "number") {
                throw new Error("'skip' is a required parameter and must be of type 'number'.");
            }
            if (typeof top !== "number") {
                throw new Error("'top' is a required parameter and must be of type 'number'.");
            }
            if (lastUpdatedTime && !(lastUpdatedTime instanceof Date)) {
                throw new Error("'lastUpdatedTime' must be of type 'Date'.");
            }
            if (!lastUpdatedTime) {
                lastUpdatedTime = new Date(Date.now() - defaultLastUpdatedTimeForListingSessions);
            }
            try {
                const messageBody = {};
                messageBody["last-updated-time"] = lastUpdatedTime;
                messageBody["skip"] = rheaPromise.types.wrap_int(skip);
                messageBody["top"] = rheaPromise.types.wrap_int(top);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.enumerateSessions
                    }
                };
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                managementClientLogger.verbose("%s List sessions request body: %O.", this.logPrefix, request.body);
                const response = yield this._makeManagementRequest(request, managementClientLogger, options);
                return (response && response.body && response.body["sessions-ids"]) || [];
            }
            catch (err) {
                const error = translateServiceBusError(err);
                managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Get all the rules on the Subscription.
     * @returns Promise<RuleDescription[]> A list of rules.
     */
    getRules(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const request = {
                    body: {
                        top: rheaPromise.types.wrap_int(max32BitNumber),
                        skip: rheaPromise.types.wrap_int(0)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.enumerateRules
                    }
                };
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                managementClientLogger.verbose("%s Get rules request body: %O.", this.logPrefix, request.body);
                const response = yield this._makeManagementRequest(request, managementClientLogger, options);
                if (response.application_properties.statusCode === 204 ||
                    !response.body ||
                    !Array.isArray(response.body.rules)) {
                    return [];
                }
                // Reference: https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-request-response#response-11
                const result = response.body.rules || [];
                const rules = [];
                result.forEach((x) => {
                    const ruleDescriptor = x["rule-description"];
                    // We use the first three elements of the `ruleDescriptor.value` to get filter, action, name
                    if (!ruleDescriptor ||
                        !ruleDescriptor.descriptor ||
                        ruleDescriptor.descriptor.value !== coreAmqp.Constants.descriptorCodes.ruleDescriptionList ||
                        !Array.isArray(ruleDescriptor.value) ||
                        ruleDescriptor.value.length < 3) {
                        return;
                    }
                    const filtersRawData = ruleDescriptor.value[0];
                    const actionsRawData = ruleDescriptor.value[1];
                    const rule = {
                        name: ruleDescriptor.value[2].value
                    };
                    switch (filtersRawData.descriptor.value) {
                        case coreAmqp.Constants.descriptorCodes.trueFilterList:
                            rule.filter = "1=1";
                            break;
                        case coreAmqp.Constants.descriptorCodes.falseFilterList:
                            rule.filter = "1=0";
                            break;
                        case coreAmqp.Constants.descriptorCodes.sqlFilterList:
                            rule.filter = this._safelyGetTypedValueFromArray(filtersRawData.value, 0);
                            break;
                        case coreAmqp.Constants.descriptorCodes.correlationFilterList:
                            rule.filter = {
                                correlationId: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),
                                messageId: this._safelyGetTypedValueFromArray(filtersRawData.value, 1),
                                to: this._safelyGetTypedValueFromArray(filtersRawData.value, 2),
                                replyTo: this._safelyGetTypedValueFromArray(filtersRawData.value, 3),
                                subject: this._safelyGetTypedValueFromArray(filtersRawData.value, 4),
                                sessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 5),
                                replyToSessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 6),
                                contentType: this._safelyGetTypedValueFromArray(filtersRawData.value, 7),
                                applicationProperties: this._safelyGetTypedValueFromArray(filtersRawData.value, 8)
                            };
                            break;
                        default:
                            managementClientLogger.warning(`${this.logPrefix} Found unexpected descriptor code for the filter: ${filtersRawData.descriptor.value}`);
                            break;
                    }
                    if (actionsRawData.descriptor.value === coreAmqp.Constants.descriptorCodes.sqlRuleActionList &&
                        Array.isArray(actionsRawData.value) &&
                        actionsRawData.value.length) {
                        rule.action = this._safelyGetTypedValueFromArray(actionsRawData.value, 0);
                    }
                    rules.push(rule);
                });
                return rules;
            }
            catch (err) {
                const error = translateServiceBusError(err);
                managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the get rules request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Removes the rule on the Subscription identified by the given rule name.
     * @param ruleName
     */
    removeRule(ruleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            throwTypeErrorIfParameterMissing(this._context.connectionId, "ruleName", ruleName);
            ruleName = String(ruleName);
            throwTypeErrorIfParameterIsEmptyString(this._context.connectionId, "ruleName", ruleName);
            try {
                const request = {
                    body: {
                        "rule-name": rheaPromise.types.wrap_string(ruleName)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.removeRule
                    }
                };
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                managementClientLogger.verbose("%s Remove Rule request body: %O.", this.logPrefix, request.body);
                yield this._makeManagementRequest(request, managementClientLogger, options);
            }
            catch (err) {
                const error = translateServiceBusError(err);
                managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the remove rule request to $management endpoint`);
                throw error;
            }
        });
    }
    /**
     * Adds a rule on the subscription as defined by the given rule name, filter and action
     * @param ruleName Name of the rule
     * @param filter A Boolean, SQL expression or a Correlation filter
     * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression
     */
    addRule(ruleName, filter, sqlRuleActionExpression, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            throwTypeErrorIfParameterMissing(this._context.connectionId, "ruleName", ruleName);
            ruleName = String(ruleName);
            throwTypeErrorIfParameterIsEmptyString(this._context.connectionId, "ruleName", ruleName);
            throwTypeErrorIfParameterMissing(this._context.connectionId, "filter", filter);
            if (typeof filter !== "boolean" &&
                typeof filter !== "string" &&
                !correlationProperties.some((validProperty) => filter.hasOwnProperty(validProperty))) {
                throw new TypeError(`The parameter "filter" should be either a boolean, string or implement the CorrelationRuleFilter interface.`);
            }
            try {
                const ruleDescription = {};
                switch (typeof filter) {
                    case "boolean":
                        ruleDescription["sql-filter"] = {
                            expression: filter ? "1=1" : "1=0"
                        };
                        break;
                    case "string":
                        ruleDescription["sql-filter"] = {
                            expression: filter
                        };
                        break;
                    default:
                        ruleDescription["correlation-filter"] = {
                            "correlation-id": filter.correlationId,
                            "message-id": filter.messageId,
                            to: filter.to,
                            "reply-to": filter.replyTo,
                            subject: filter.subject,
                            "session-id": filter.sessionId,
                            "reply-to-session-id": filter.replyToSessionId,
                            "content-type": filter.contentType,
                            applicationProperties: filter.applicationProperties
                        };
                        break;
                }
                if (sqlRuleActionExpression !== undefined) {
                    ruleDescription["sql-rule-action"] = {
                        expression: String(sqlRuleActionExpression)
                    };
                }
                const request = {
                    body: {
                        "rule-name": rheaPromise.types.wrap_string(ruleName),
                        "rule-description": rheaPromise.types.wrap_map(ruleDescription)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: coreAmqp.Constants.operations.addRule
                    }
                };
                request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
                managementClientLogger.verbose("%s Add Rule request body: %O.", this.logPrefix, request.body);
                yield this._makeManagementRequest(request, managementClientLogger, options);
            }
            catch (err) {
                const error = translateServiceBusError(err);
                managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the Add rule request to $management endpoint`);
                throw error;
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Returns information about the platform this function is being run on.
 * @hidden
 * @internal
 */
function getRuntimeInfo() {
    const runtimeInfo = {
        key: "Node",
        value: process.version
    };
    const osInfo = {
        key: "OS",
        value: `(${os.arch()}-${os.type()}-${os.release()})`
    };
    return `${runtimeInfo.key}/${runtimeInfo.value} ${osInfo.key}/${osInfo.value}`;
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Helper method to call onDetached on the receivers from the connection context upon seeing an error.
 */
function callOnDetachedOnReceivers(connectionContext, contextOrConnectionError, receiverType) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const detachCalls = [];
        for (const receiverName of Object.keys(connectionContext.messageReceivers)) {
            const receiver = connectionContext.messageReceivers[receiverName];
            if (receiver && receiver.receiverType === receiverType) {
                connectionLogger.verbose("[%s] calling detached on %s receiver '%s'.", connectionContext.connection.id, receiver.receiverType, receiver.name);
                detachCalls.push(receiver.onDetached(contextOrConnectionError).catch((err) => {
                    connectionLogger.logError(err, "[%s] An error occurred while calling onDetached() on the %s receiver '%s'", connectionContext.connection.id, receiver.receiverType, receiver.name);
                }));
            }
        }
        return Promise.all(detachCalls);
    });
}
/**
 * @internal
 * @hidden
 * Helper method to get the number of receivers of specified type from the connectionContext.
 */
function getNumberOfReceivers(connectionContext, receiverType) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        if (receiverType === "session") {
            const receivers = connectionContext.messageSessions;
            return Object.keys(receivers).length;
        }
        const receivers = connectionContext.messageReceivers;
        const receiverNames = Object.keys(receivers);
        const count = receiverNames.reduce((acc, name) => (receivers[name].receiverType === receiverType ? ++acc : acc), 0);
        return count;
    });
}
/**
 * @internal
 * @hidden
 */
var ConnectionContext;
(function (ConnectionContext) {
    function create(config, tokenCredential, options) {
        var _a;
        if (!options)
            options = {};
        const userAgent = `${formatUserAgentPrefix((_a = options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix)} ${getRuntimeInfo()}`;
        const parameters = {
            config: config,
            // re-enabling this will be a post-GA discussion similar to event-hubs.
            // dataTransformer: options.dataTransformer,
            isEntityPathRequired: false,
            connectionProperties: {
                product: "MSJSClient",
                userAgent,
                version: packageJsonInfo.version
            }
        };
        // Let us create the base context and then add ServiceBus specific ConnectionContext properties.
        const connectionContext = coreAmqp.ConnectionContextBase.create(parameters);
        connectionContext.tokenCredential = tokenCredential;
        connectionContext.senders = {};
        connectionContext.messageReceivers = {};
        connectionContext.messageSessions = {};
        connectionContext.managementClients = {};
        let waitForConnectionRefreshResolve;
        let waitForConnectionRefreshPromise;
        Object.assign(connectionContext, {
            isConnectionClosing() {
                // When the connection is not open, but the remote end is open,
                // then the rhea connection is in the process of terminating.
                return Boolean(!this.connection.isOpen() && this.connection.isRemoteOpen());
            },
            readyToOpenLink() {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    connectionLogger.verbose(`[${this.connectionId}] Waiting until the connection is ready to open link.`);
                    // Check that the connection isn't in the process of closing.
                    // This can happen when the idle timeout has been reached but
                    // the underlying socket is waiting to be destroyed.
                    if (this.isConnectionClosing()) {
                        connectionLogger.verbose(`[${this.connectionId}] Connection is closing, waiting for disconnected event`);
                        // Wait for the disconnected event that indicates the underlying socket has closed.
                        yield this.waitForDisconnectedEvent();
                    }
                    // Wait for the connection to be reset.
                    yield this.waitForConnectionReset();
                    connectionLogger.verbose(`[${this.connectionId}] Connection is ready to open link.`);
                });
            },
            waitForDisconnectedEvent() {
                return new Promise((resolve) => {
                    connectionLogger.verbose(`[${this.connectionId}] Attempting to reinitialize connection` +
                        ` but the connection is in the process of closing.` +
                        ` Waiting for the disconnect event before continuing.`);
                    this.connection.once(rheaPromise.ConnectionEvents.disconnected, resolve);
                });
            },
            waitForConnectionReset() {
                // Check if the connection is currently in the process of disconnecting.
                if (waitForConnectionRefreshPromise) {
                    connectionLogger.verbose(`[${this.connectionId}] Waiting for connection reset`);
                    return waitForConnectionRefreshPromise;
                }
                connectionLogger.verbose(`[${this.connectionId}] Connection not waiting to be reset. Resolving immediately.`);
                return Promise.resolve();
            },
            getReceiverFromCache(receiverName, sessionId) {
                if (sessionId != null && this.messageSessions[receiverName]) {
                    return this.messageSessions[receiverName];
                }
                if (this.messageReceivers[receiverName]) {
                    return this.messageReceivers[receiverName];
                }
                let existingReceivers = "";
                if (sessionId != null) {
                    for (const messageSessionName of Object.keys(this.messageSessions)) {
                        if (this.messageSessions[messageSessionName].sessionId === sessionId) {
                            existingReceivers = this.messageSessions[messageSessionName].name;
                            break;
                        }
                    }
                }
                else {
                    existingReceivers +=
                        (existingReceivers ? ", " : "") + Object.keys(this.messageReceivers).join(",");
                }
                connectionLogger.verbose("[%s] Failed to find receiver '%s' among existing receivers: %s", this.connectionId, receiverName, existingReceivers);
                return;
            },
            getManagementClient(entityPath) {
                if (!this.managementClients[entityPath]) {
                    this.managementClients[entityPath] = new ManagementClient(this, entityPath, {
                        address: `${entityPath}/$management`
                    });
                }
                return this.managementClients[entityPath];
            }
        });
        // Define listeners to be added to the connection object for
        // "connection_open" and "connection_error" events.
        const onConnectionOpen = () => {
            connectionContext.wasConnectionCloseCalled = false;
            connectionLogger.verbose("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        const disconnected = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            if (waitForConnectionRefreshPromise) {
                return;
            }
            waitForConnectionRefreshPromise = new Promise((resolve) => {
                waitForConnectionRefreshResolve = resolve;
            });
            const connectionError = context.connection && context.connection.error ? context.connection.error : undefined;
            if (connectionError) {
                connectionLogger.logError(connectionError, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
            }
            const contextError = context.error;
            if (contextError) {
                connectionLogger.logError(contextError, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
            }
            const state = {
                wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                numSenders: Object.keys(connectionContext.senders).length,
                numReceivers: Object.keys(connectionContext.messageReceivers).length +
                    Object.keys(connectionContext.messageSessions).length
            };
            // Clear internal map maintained by rhea to avoid reconnecting of old links once the
            // connection is back up.
            connectionContext.connection.removeAllSessions();
            // Close the cbs session to ensure all the event handlers are released.
            yield connectionContext.cbsSession.close();
            // Close the management sessions to ensure all the event handlers are released.
            for (const entityPath of Object.keys(connectionContext.managementClients)) {
                yield connectionContext.managementClients[entityPath].close();
            }
            // Calling onDetached on sender
            if (!state.wasConnectionCloseCalled && state.numSenders) {
                // We don't do recovery for the sender:
                //   Because we don't want to keep the sender active all the time
                //   and the "next" send call would bear the burden of creating the link.
                // Call onDetached() on sender so that it can gracefully shutdown
                //   by cleaning up the timers and closing the links.
                // We don't call onDetached for sender after `refreshConnection()`
                //   because any new send calls that potentially initialize links would also get affected if called later.
                connectionLogger.verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${state.numSenders} ` +
                    `senders. We should not reconnect.`);
                const detachCalls = [];
                for (const senderName of Object.keys(connectionContext.senders)) {
                    const sender = connectionContext.senders[senderName];
                    if (sender) {
                        connectionLogger.verbose("[%s] calling detached on sender '%s'.", connectionContext.connection.id, sender.name);
                        detachCalls.push(sender.onDetached().catch((err) => {
                            connectionLogger.logError(err, "[%s] An error occurred while calling onDetached() the sender '%s'", connectionContext.connection.id, sender.name);
                        }));
                    }
                }
                yield Promise.all(detachCalls);
            }
            // Calling onDetached on batching receivers for the same reasons as sender
            const numBatchingReceivers = getNumberOfReceivers(connectionContext, "batching");
            if (!state.wasConnectionCloseCalled && numBatchingReceivers) {
                connectionLogger.verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numBatchingReceivers} ` +
                    `batching receivers. We should reconnect.`);
                // Call onDetached() on receivers so that batching receivers it can gracefully close any ongoing batch operation
                yield callOnDetachedOnReceivers(connectionContext, connectionError || contextError, "batching");
                // TODO:
                //  `callOnDetachedOnReceivers` handles "connectionContext.messageReceivers".
                //  ...What to do for sessions (connectionContext.messageSessions) ??
            }
            yield refreshConnection(connectionContext);
            waitForConnectionRefreshResolve();
            waitForConnectionRefreshPromise = undefined;
            // The connection should always be brought back up if the sdk did not call connection.close()
            // and there was at least one receiver link on the connection before it went down.
            connectionLogger.verbose("[%s] state: %O", connectionContext.connectionId, state);
            // Calling onDetached on streaming receivers
            const numStreamingReceivers = getNumberOfReceivers(connectionContext, "streaming");
            if (!state.wasConnectionCloseCalled && numStreamingReceivers) {
                connectionLogger.verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numStreamingReceivers} ` +
                    `streaming receivers. We should reconnect.`);
                // Calling `onDetached()` on streaming receivers after the refreshConnection() since `onDetached()` would
                // recover the streaming receivers and that would only be possible after the connection is refreshed.
                //
                // This is different from the batching receiver since `onDetached()` for the batching receiver would
                // return the outstanding messages and close the receive link.
                yield callOnDetachedOnReceivers(connectionContext, connectionError || contextError, "streaming");
            }
        });
        const protocolError = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            if (context.connection && context.connection.error) {
                connectionLogger.logError(context.connection.error, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
            }
            if (context.error) {
                connectionLogger.logError(context.error, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
            }
        });
        const error = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            if (context.connection && context.connection.error) {
                connectionLogger.logError(context.connection.error, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
            }
            if (context.error) {
                connectionLogger.logError(context.error, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
            }
        });
        function refreshConnection(connectionContext) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const originalConnectionId = connectionContext.connectionId;
                try {
                    yield cleanConnectionContext(connectionContext);
                }
                catch (err) {
                    connectionLogger.logError(err, `[${connectionContext.connectionId}] There was an error closing the connection before reconnecting`);
                }
                // Create a new connection, id, locks, and cbs client.
                connectionContext.refreshConnection();
                addConnectionListeners(connectionContext.connection);
                connectionLogger.verbose(`The connection "${originalConnectionId}" has been updated to "${connectionContext.connectionId}".`);
            });
        }
        function addConnectionListeners(connection) {
            // Add listeners on the connection object.
            connection.on(rheaPromise.ConnectionEvents.connectionOpen, onConnectionOpen);
            connection.on(rheaPromise.ConnectionEvents.disconnected, disconnected);
            connection.on(rheaPromise.ConnectionEvents.protocolError, protocolError);
            connection.on(rheaPromise.ConnectionEvents.error, error);
        }
        function cleanConnectionContext(connectionContext) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // Remove listeners from the connection object.
                connectionContext.connection.removeListener(rheaPromise.ConnectionEvents.connectionOpen, onConnectionOpen);
                connectionContext.connection.removeListener(rheaPromise.ConnectionEvents.disconnected, disconnected);
                connectionContext.connection.removeListener(rheaPromise.ConnectionEvents.protocolError, protocolError);
                connectionContext.connection.removeListener(rheaPromise.ConnectionEvents.error, error);
                // Close the connection
                yield connectionContext.connection.close();
            });
        }
        addConnectionListeners(connectionContext.connection);
        connectionLogger.verbose("[%s] Created connection context successfully.", connectionContext.connectionId);
        return connectionContext;
    }
    ConnectionContext.create = create;
    /**
     * Closes the AMQP connection created by this ServiceBusClient along with AMQP links for
     * sender/receivers created by the queue/topic/subscription clients created by this
     * ServiceBusClient.
     * Once closed,
     * - the clients created by this ServiceBusClient cannot be used to send/receive messages anymore.
     * - this ServiceBusClient cannot be used to create any new queues/topics/subscriptions clients.
     * @returns {Promise<any>}
     */
    function close(context) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const logPrefix = `[${context.connectionId}]`;
            try {
                connectionLogger.verbose(`${logPrefix} Permanently closing the amqp connection on the client.`);
                // Close all the senders.
                const senderNames = Object.keys(context.senders);
                connectionLogger.verbose(`${logPrefix} Permanently closing ${senderNames.length} senders.`);
                for (const senderName of senderNames) {
                    yield context.senders[senderName].close();
                }
                // Close all MessageReceiver instances
                const messageReceiverNames = Object.keys(context.messageReceivers);
                connectionLogger.verbose(`${logPrefix} Permanently closing ${messageReceiverNames.length} receivers.`);
                for (const receiverName of messageReceiverNames) {
                    yield context.messageReceivers[receiverName].close();
                }
                // Close all MessageSession instances
                const messageSessionNames = Object.keys(context.messageSessions);
                connectionLogger.verbose(`${logPrefix} Permanently closing ${messageSessionNames.length} session receivers.`);
                for (const messageSessionName of messageSessionNames) {
                    yield context.messageSessions[messageSessionName].close();
                }
                // Close all the ManagementClients.
                const managementClientsEntityPaths = Object.keys(context.managementClients);
                connectionLogger.verbose(`${logPrefix} Permanently closing ${managementClientsEntityPaths.length} session receivers.`);
                for (const entityPath of managementClientsEntityPaths) {
                    yield context.managementClients[entityPath].close();
                }
                connectionLogger.verbose(`${logPrefix} Permanently closing cbsSession`);
                yield context.cbsSession.close();
                connectionLogger.verbose(`${logPrefix} Permanently closing internal connection`);
                yield context.connection.close();
                context.wasConnectionCloseCalled = true;
                connectionLogger.verbose(`[${logPrefix} Permanently closed the amqp connection on the client.`);
            }
            catch (err) {
                const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));
                connectionLogger.logError(err, `${logPrefix} An error occurred while closing the connection`);
                throw errObj;
            }
        });
    }
    ConnectionContext.close = close;
})(ConnectionContext || (ConnectionContext = {}));

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 *
 * @param {string} connectionString
 * @param {(SharedKeyCredential | TokenCredential)} credential
 * @param {ServiceBusClientOptions} options
 */
function createConnectionContext(connectionString, credential, options) {
    var _a, _b;
    const config = coreAmqp.ConnectionConfig.create(connectionString);
    config.webSocket = (_a = options === null || options === void 0 ? void 0 : options.webSocketOptions) === null || _a === void 0 ? void 0 : _a.webSocket;
    config.webSocketEndpointPath = "$servicebus/websocket";
    config.webSocketConstructorOptions = (_b = options === null || options === void 0 ? void 0 : options.webSocketOptions) === null || _b === void 0 ? void 0 : _b.webSocketConstructorOptions;
    return ConnectionContext.create(config, credential, options);
}
/**
 * @param connectionString
 * @param options
 * @internal
 * @hidden
 */
function createConnectionContextForConnectionString(connectionString, options = {}) {
    const credential = SharedKeyCredential.fromConnectionString(connectionString);
    return createConnectionContext(connectionString, credential, options);
}
/**
 *
 * @param credential
 * @param host
 * @param options
 * @internal
 * @hidden
 */
function createConnectionContextForTokenCredential(credential, host, options = {}) {
    if (typeof host !== "string") {
        throw new TypeError("`host` parameter is not a string");
    }
    // host, credential and options based constructor was invoked
    if (!host.endsWith("/")) {
        host += "/";
    }
    const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;`;
    return createConnectionContext(connectionString, credential, options);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 */
function getParentSpan(options) {
    var _a;
    return (_a = options === null || options === void 0 ? void 0 : options.spanOptions) === null || _a === void 0 ? void 0 : _a.parent;
}
/**
 * @internal
 * @hidden
 *
 * @param {(Span | SpanContext | null)} [parentSpan]
 * @param {SpanContext[]} [spanContextsToLink=[]]
 * @param {string} [entityPath]
 * @param {string} [host]
 */
function createSendSpan(parentSpan, spanContextsToLink = [], entityPath, host) {
    const links = spanContextsToLink.map((context) => {
        return {
            context
        };
    });
    const tracer = coreTracing.getTracer();
    const span = tracer.startSpan("Azure.ServiceBus.send", {
        kind: api.SpanKind.CLIENT,
        parent: parentSpan,
        links
    });
    span.setAttribute("az.namespace", "Microsoft.ServiceBus");
    span.setAttribute("message_bus.destination", entityPath);
    span.setAttribute("peer.address", host);
    return span;
}
/**
 * Runs the `fn` passed in and marks the span as completed with an error (and the
 * corresponding message) or as OK.
 *
 * @hidden
 * @internal
 */
function trace(fn, span) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        try {
            const ret = yield fn();
            span.setStatus({ code: api.CanonicalCode.OK });
            return ret;
        }
        catch (err) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: err.message
            });
            throw err;
        }
        finally {
            span.end();
        }
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * This is the shared onSettled handler for all of the receiver implementations.
 *
 * The sequence is basically:
 * 1. User calls `await <ServiceBusMessage instance>.complete()`     (or other settlement methods)
 * 2. This creates a `Promise` that gets stored in the _deliveryDispositionMap
 * 3. When the service acknowledges the settlement this method gets called for that message.
 * 4. We resolve() the promise from the _deliveryDispositionMap.
 * 5. User's code after the settlement continues.
 *
 * @internal
 * @hidden
 */
function onMessageSettled(logPrefix, delivery, deliveryDispositionMap) {
    if (delivery) {
        const id = delivery.id;
        const state = delivery.remote_state;
        const settled = delivery.remote_settled;
        receiverLogger.verbose("%s Delivery with id %d, remote_settled: %s, remote_state: %o has been " + "received.", logPrefix, id, settled, state && state.error ? state.error : state);
        if (settled && deliveryDispositionMap.has(id)) {
            const promise = deliveryDispositionMap.get(id);
            clearTimeout(promise.timer);
            receiverLogger.verbose("%s Found the delivery with id %d in the map and cleared the timer.", logPrefix, id);
            const deleteResult = deliveryDispositionMap.delete(id);
            receiverLogger.verbose("%s Successfully deleted the delivery with id %d from the map.", logPrefix, id, deleteResult);
            if (state && state.error && (state.error.condition || state.error.description)) {
                const error = translateServiceBusError(state.error);
                return promise.reject(error);
            }
            return promise.resolve();
        }
    }
}
/**
 * Creates the options that need to be specified while creating an AMQP receiver link.
 *
 * @internal
 * @hidden
 * @param {string} name
 * @param {ReceiveMode} receiveMode
 * @param {Source} source
 * @param {ReceiverHandlers} handlers
 */
function createReceiverOptions(name, receiveMode, source, handlers) {
    const rcvrOptions = Object.assign({ name, 
        // "autoaccept" being true in the "receiveAndDelete" mode sets the "settled" flag to true on the deliveries
        // which helps in clearing the circular buffer(size=2048) as it is needed to receive messages after 2048 of them are received.
        autoaccept: receiveMode === "receiveAndDelete" ? true : false, 
        // receiveAndDelete -> first(0), peekLock -> second (1)
        rcv_settle_mode: receiveMode === "receiveAndDelete" ? 0 : 1, 
        // receiveAndDelete -> settled (1), peekLock -> unsettled (0)
        snd_settle_mode: receiveMode === "receiveAndDelete" ? 1 : 0, source, credit_window: 0 }, handlers);
    return rcvrOptions;
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Describes the MessageReceiver that will receive messages from ServiceBus.
 * @class MessageReceiver
 */
class MessageReceiver extends LinkEntity {
    constructor(context, entityPath, receiverType, options) {
        super(entityPath, entityPath, context, receiverType, receiverLogger, {
            address: entityPath,
            audience: `${context.config.endpoint}${entityPath}`
        });
        /**
         * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that
         * are being actively disposed. It acts as a store for correlating the responses received for
         * active dispositions.
         */
        this._deliveryDispositionMap = new Map();
        this.receiverType = receiverType;
        this.receiveMode = options.receiveMode || "peekLock";
        // If explicitly set to false then autoComplete is false else true (default).
        this.autoComplete =
            options.autoCompleteMessages === false ? options.autoCompleteMessages : true;
        this._lockRenewer = options.lockRenewer;
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */
    _createReceiverOptions(useNewName, handlers) {
        const rcvrOptions = createReceiverOptions(useNewName ? getUniqueName(this.baseName) : this.name, this.receiveMode, {
            address: this.address
        }, Object.assign({ onSettled: (context) => {
                return onMessageSettled(this.logPrefix, context.delivery, this._deliveryDispositionMap);
            } }, handlers));
        return rcvrOptions;
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     *
     * @returns {Promise<void>} Promise<void>.
     */
    _init(options, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this.initLink(options, abortSignal);
                // It is possible for someone to close the receiver and then start it again.
                // Thus make sure that the receiver is present in the client cache.
                this._context.messageReceivers[this.name] = this;
            }
            catch (err) {
                err = translateServiceBusError(err);
                receiverLogger.logError(err, "%s An error occured while creating the receiver", this.logPrefix);
                // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.
                if (err.code === "OperationTimeoutError") {
                    err.message = "Failed to create a receiver within allocated time and retry attempts.";
                }
                throw err;
            }
        });
    }
    createRheaLink(options, _abortSignal) {
        return this._context.connection.createReceiver(options);
    }
    /**
     * Clears lock renewal timers on all active messages, clears token remewal for current receiver,
     * removes current MessageReceiver instance from cache, and closes the underlying AMQP receiver.
     * @return {Promise<void>} Promise<void>.
     */
    close() {
        const _super = Object.create(null, {
            close: { get: () => super.close }
        });
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            (_a = this._lockRenewer) === null || _a === void 0 ? void 0 : _a.stopAll(this);
            yield _super.close.call(this);
        });
    }
    /**
     * Settles the message with the specified disposition.
     * @param message The ServiceBus Message that needs to be settled.
     * @param operation The disposition type.
     * @param options Optional parameters that can be provided while disposing the message.
     */
    settleMessage(message, operation, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                var _a;
                if (!options)
                    options = {};
                if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {
                    return reject(new Error(`operation: '${operation}' is not a valid operation.`));
                }
                (_a = this._lockRenewer) === null || _a === void 0 ? void 0 : _a.stop(this, message);
                const delivery = message.delivery;
                const timer = setTimeout(() => {
                    this._deliveryDispositionMap.delete(delivery.id);
                    receiverLogger.verbose("%s Disposition for delivery id: %d, did not complete in %d milliseconds. " +
                        "Hence rejecting the promise with timeout error.", this.logPrefix, delivery.id, coreAmqp.Constants.defaultOperationTimeoutInMs);
                    const e = {
                        condition: coreAmqp.ErrorNameConditionMapper.ServiceUnavailableError,
                        description: "Operation to settle the message has timed out. The disposition of the " +
                            "message may or may not be successful"
                    };
                    return reject(translateServiceBusError(e));
                }, coreAmqp.Constants.defaultOperationTimeoutInMs);
                this._deliveryDispositionMap.set(delivery.id, {
                    resolve: resolve,
                    reject: reject,
                    timer: timer
                });
                if (operation === DispositionType.complete) {
                    delivery.accept();
                }
                else if (operation === DispositionType.abandon) {
                    const params = {
                        undeliverable_here: false
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.defer) {
                    const params = {
                        undeliverable_here: true
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.deadletter) {
                    const error = {
                        condition: coreAmqp.Constants.deadLetterName,
                        info: Object.assign(Object.assign({}, options.propertiesToModify), { DeadLetterReason: options.deadLetterReason, DeadLetterErrorDescription: options.deadLetterDescription })
                    };
                    delivery.reject(error);
                }
            });
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Wraps the receiver with some higher level operations for managing state
 * like credits, draining, etc...
 *
 * @internal
 * @hidden
 */
class ReceiverHelper {
    constructor(_getCurrentReceiver) {
        this._getCurrentReceiver = _getCurrentReceiver;
        this._isSuspended = false;
    }
    /**
     * Adds credits to the receiver, respecting any state that
     * indicates the receiver is closed or should not continue
     * to receive more messages.
     *
     * @param credits Number of credits to add.
     * @returns true if credits were added, false if there is no current receiver instance
     * or `stopReceivingMessages` has been called.
     */
    addCredit(credits) {
        const { receiver, logPrefix } = this._getCurrentReceiver();
        if (!this.canReceiveMessages()) {
            receiverLogger.verbose(`${logPrefix} Asked to add ${credits} credits but the receiver is not able to receive messages`);
            return false;
        }
        if (receiver != null) {
            receiverLogger.verbose(`${logPrefix} Adding ${credits} credits`);
            receiver.addCredit(credits);
        }
        return true;
    }
    /**
     * Drains the credits for the receiver and prevents the `receiverHelper.addCredit()` method from adding credits.
     * Call `resume()` to enable the `addCredit()` method.
     */
    suspend() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { receiver, logPrefix } = this._getCurrentReceiver();
            this._isSuspended = true;
            if (!this._isValidReceiver(receiver)) {
                return;
            }
            receiverLogger.verbose(`${logPrefix} User has requested to stop receiving new messages, attempting to drain.`);
            return this.drain();
        });
    }
    /**
     * Resets tracking so `addCredit` works again.
     */
    resume() {
        this._isSuspended = false;
    }
    /**
     * Whether the receiver can receive messages.
     *
     * This checks if the the caller has decided to disable adding
     * credits via 'suspend' as well as whether the receiver itself is
     * still open.
     */
    canReceiveMessages() {
        const { receiver } = this._getCurrentReceiver();
        return !this._isSuspended && this._isValidReceiver(receiver);
    }
    /**
     * Initiates a drain for the current receiver and resolves when
     * the drain has completed.
     */
    drain() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { receiver, logPrefix } = this._getCurrentReceiver();
            if (!this._isValidReceiver(receiver)) {
                return;
            }
            receiverLogger.verbose(`${logPrefix} Receiver is starting drain. Remaining credits; ${receiver.credit}`);
            const drainPromise = new Promise((resolve) => {
                receiver.once(rheaPromise.ReceiverEvents.receiverDrained, () => {
                    receiverLogger.verbose(`${logPrefix} Receiver has been drained.`);
                    receiver.drain = false;
                    resolve();
                });
                receiver.drain = true;
                // this is not actually adding another credit - it'll just
                // cause the drain call to start.
                receiver.addCredit(1);
            });
            return drainPromise;
        });
    }
    _isValidReceiver(receiver) {
        return receiver != null && receiver.isOpen();
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 */
function assertValidMessageHandlers(handlers) {
    if (handlers &&
        handlers.processMessage instanceof Function &&
        handlers.processError instanceof Function) {
        return;
    }
    throw new TypeError('Invalid "MessageHandlers" provided.');
}
/**
 * @internal
 * @hidden
 */
function getMessageIterator(receiver, options) {
    return tslib.__asyncGenerator(this, arguments, function* getMessageIterator_1() {
        while (true) {
            const messages = yield tslib.__await(receiver.receiveMessages(1, options));
            if (messages.length === 0) {
                continue;
            }
            yield yield tslib.__await(messages[0]);
        }
    });
}
/**
 * @internal
 * @hidden
 */
function wrapProcessErrorHandler(handlers, logger = receiverLogger) {
    return (args) => tslib.__awaiter(this, void 0, void 0, function* () {
        try {
            args.error = translateServiceBusError(args.error);
            yield handlers.processError(args);
        }
        catch (err) {
            logger.logError(err, `An error was thrown from the user's processError handler`);
        }
    });
}
/**
 * @internal
 * @hidden
 *
 * @param {ServiceBusMessageImpl} message
 * @param {ConnectionContext} context
 * @param {string} entityPath
 */
function completeMessage(message, context, entityPath) {
    receiverLogger.verbose("[%s] Completing the message with id '%s'.", context.connectionId, message.messageId);
    return settleMessage(message, DispositionType.complete, context, entityPath);
}
/**
 * @internal
 * @hidden
 *
 * @param {ServiceBusMessageImpl} message
 * @param {ConnectionContext} context
 * @param {string} entityPath
 * @param {{ [key: string]: any }} [propertiesToModify]
 */
function abandonMessage(message, context, entityPath, propertiesToModify) {
    receiverLogger.verbose("[%s] Abandoning the message with id '%s'.", context.connectionId, message.messageId);
    return settleMessage(message, DispositionType.abandon, context, entityPath, {
        propertiesToModify
    });
}
/**
 * @internal
 * @hidden
 *
 * @param {ServiceBusMessageImpl} message
 * @param {ConnectionContext} context
 * @param {string} entityPath
 * @param {{ [key: string]: any }} [propertiesToModify]
 */
function deferMessage(message, context, entityPath, propertiesToModify) {
    receiverLogger.verbose("[%s] Deferring the message with id '%s'.", context.connectionId, message.messageId);
    return settleMessage(message, DispositionType.defer, context, entityPath, {
        propertiesToModify
    });
}
/**
 * @internal
 * @hidden
 *
 * @param {ServiceBusMessageImpl} message
 * @param {ConnectionContext} context
 * @param {string} entityPath
 * @param {(DeadLetterOptions & { [key: string]: any })} [propertiesToModify]
 */
function deadLetterMessage(message, context, entityPath, propertiesToModify) {
    receiverLogger.verbose("[%s] Deadlettering the message with id '%s'.", context.connectionId, message.messageId);
    const actualPropertiesToModify = Object.assign({}, propertiesToModify);
    // these two fields are handled specially and don't need to be in here.
    delete actualPropertiesToModify.deadLetterErrorDescription;
    delete actualPropertiesToModify.deadLetterReason;
    const dispositionStatusOptions = {
        propertiesToModify: actualPropertiesToModify,
        deadLetterReason: propertiesToModify === null || propertiesToModify === void 0 ? void 0 : propertiesToModify.deadLetterReason,
        deadLetterDescription: propertiesToModify === null || propertiesToModify === void 0 ? void 0 : propertiesToModify.deadLetterErrorDescription
    };
    return settleMessage(message, DispositionType.deadletter, context, entityPath, dispositionStatusOptions);
}
/**
 * @internal
 * @hidden
 *
 * @param {ServiceBusMessageImpl} message
 * @param {DispositionType} operation
 * @param {ConnectionContext} context
 * @param {string} entityPath
 * @param {DispositionStatusOptions} [options]
 */
function settleMessage(message, operation, context, entityPath, options) {
    const isDeferredMessage = !message.delivery.link;
    const receiver = isDeferredMessage
        ? undefined
        : context.getReceiverFromCache(message.delivery.link.name, message.sessionId);
    const associatedLinkName = receiver === null || receiver === void 0 ? void 0 : receiver.name;
    let error;
    if (message.delivery.remote_settled) {
        error = new Error(MessageAlreadySettled);
    }
    else if (!isDeferredMessage &&
        (!receiver || !receiver.isOpen()) &&
        message.sessionId != undefined) {
        error = translateServiceBusError({
            description: `Failed to ${operation} the message as the AMQP link with which the message was ` +
                `received is no longer alive.`,
            condition: coreAmqp.ErrorNameConditionMapper.SessionLockLostError
        });
    }
    if (error) {
        receiverLogger.logError(error, "[%s] An error occurred when settling a message with id '%s'", context.connectionId, message.messageId);
        throw error;
    }
    // Message Settlement with managementLink
    // 1. If the received message is deferred as such messages can only be settled using managementLink
    // 2. If the associated receiver link is not available. This does not apply to messages from sessions as we need a lock on the session to do so.
    if (isDeferredMessage || ((!receiver || !receiver.isOpen()) && message.sessionId == undefined)) {
        return context
            .getManagementClient(entityPath)
            .updateDispositionStatus(message.lockToken, operation, Object.assign(Object.assign({}, options), { associatedLinkName, sessionId: message.sessionId }))
            .catch((err) => {
            throw translateServiceBusError(err);
        });
    }
    return receiver.settleMessage(message, operation, options).catch((err) => {
        throw translateServiceBusError(err);
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Describes the streaming receiver where the user can receive the message
 * by providing handler functions.
 * @class StreamingReceiver
 * @extends MessageReceiver
 */
class StreamingReceiver extends MessageReceiver {
    /**
     * Instantiate a new Streaming receiver for receiving messages with handlers.
     *
     * @constructor
     * @param {ClientEntityContext} context                      The client entity context.
     * @param {ReceiveOptions} [options]                         Options for how you'd like to connect.
     */
    constructor(context, entityPath, options) {
        super(context, entityPath, "streaming", options);
        /**
         * @property {number} [maxConcurrentCalls] The maximum number of messages that should be
         * processed concurrently while in streaming mode. Once this limit has been reached, more
         * messages will not be received until the user's message handler has completed processing current message.
         * Default: 1
         */
        this.maxConcurrentCalls = 1;
        /**
         * Indicates whether the receiver is already actively
         * running `onDetached`.
         * This is expected to be true while the receiver attempts
         * to bring its link back up due to a retryable issue.
         */
        this._isDetaching = false;
        if (typeof (options === null || options === void 0 ? void 0 : options.maxConcurrentCalls) === "number" && (options === null || options === void 0 ? void 0 : options.maxConcurrentCalls) > 0) {
            this.maxConcurrentCalls = options.maxConcurrentCalls;
        }
        this._retryOptions = (options === null || options === void 0 ? void 0 : options.retryOptions) || {};
        this._retry = coreAmqp.retry;
        this._receiverHelper = new ReceiverHelper(() => ({
            receiver: this.link,
            logPrefix: this.logPrefix
        }));
        this._onAmqpClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const receiverError = context.receiver && context.receiver.error;
            const receiver = this.link || context.receiver;
            receiverLogger.logError(receiverError, `${this.logPrefix} 'receiver_close' event occurred. The associated error is`);
            (_a = this._lockRenewer) === null || _a === void 0 ? void 0 : _a.stopAll(this);
            if (receiver && !receiver.isItselfClosed()) {
                yield this.onDetached(receiverError);
            }
            else {
                receiverLogger.verbose("%s 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                    "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                    "() handler.", this.logPrefix, this.name, this.address);
            }
        });
        this._onSessionClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            var _b;
            const receiver = this.link || context.receiver;
            const sessionError = context.session && context.session.error;
            receiverLogger.logError(sessionError, `${this.logPrefix} 'session_close' event occurred. The associated error is`);
            (_b = this._lockRenewer) === null || _b === void 0 ? void 0 : _b.stopAll(this);
            if (receiver && !receiver.isSessionItselfClosed()) {
                yield this.onDetached(sessionError);
            }
            else {
                receiverLogger.verbose("%s 'session_close' event occurred on the session of receiver '%s' with address " +
                    "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                    "() handler.", this.logPrefix, this.name, this.address);
            }
        });
        this._onAmqpError = (context) => {
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const sbError = translateServiceBusError(receiverError);
                receiverLogger.logError(sbError, `${this.logPrefix} 'receiver_error' event occurred. The associated error is`);
            }
        };
        this._onSessionError = (context) => {
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = translateServiceBusError(sessionError);
                receiverLogger.logError(sbError, `${this.logPrefix} 'session_error' event occurred. The associated error is`);
            }
        };
        this._onAmqpMessage = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            var _c, _d;
            // If the receiver got closed in PeekLock mode, avoid processing the message as we
            // cannot settle the message.
            if (this.receiveMode === "peekLock" && (!this.link || !this.link.isOpen())) {
                receiverLogger.verbose("%s Not calling the user's message handler for the current message " +
                    "as the receiver is closed", this.logPrefix);
                return;
            }
            const bMessage = new ServiceBusMessageImpl(context.message, context.delivery, true, this.receiveMode);
            (_c = this._lockRenewer) === null || _c === void 0 ? void 0 : _c.start(this, bMessage, (err) => {
                if (this._onError) {
                    this._onError({
                        error: err,
                        errorSource: "renewLock",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host
                    });
                }
            });
            try {
                yield this._onMessage(bMessage);
            }
            catch (err) {
                receiverLogger.logError(err, "%s An error occurred while running user's message handler for the message " +
                    "with id '%s' on the receiver '%s'", this.logPrefix, bMessage.messageId, this.name);
                this._onError({
                    error: err,
                    errorSource: "processMessageCallback",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host
                });
                // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,
                // doing this here. Otherwise, this should be done in finally.
                (_d = this._lockRenewer) === null || _d === void 0 ? void 0 : _d.stop(this, bMessage);
                const error = translateServiceBusError(err);
                // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                if (!bMessage.delivery.remote_settled &&
                    error.code !== coreAmqp.ConditionErrorNameMapper["com.microsoft:message-lock-lost"] &&
                    this.receiveMode === "peekLock" &&
                    this.isOpen() // only try to abandon the messages if the connection is still open
                ) {
                    try {
                        receiverLogger.logError(error, "%s Abandoning the message with id '%s' on the receiver '%s' since " +
                            "an error occured: %O.", this.logPrefix, bMessage.messageId, this.name, error);
                        yield abandonMessage(bMessage, this._context, entityPath);
                    }
                    catch (abandonError) {
                        const translatedError = translateServiceBusError(abandonError);
                        receiverLogger.logError(translatedError, "%s An error occurred while abandoning the message with id '%s' on the " +
                            "receiver '%s'", this.logPrefix, bMessage.messageId, this.name);
                        this._onError({
                            error: translatedError,
                            errorSource: "abandon",
                            entityPath: this.entityPath,
                            fullyQualifiedNamespace: this._context.config.host
                        });
                    }
                }
                return;
            }
            finally {
                this._receiverHelper.addCredit(1);
            }
            // If we've made it this far, then user's message handler completed fine. Let us try
            // completing the message.
            if (this.autoComplete &&
                this.receiveMode === "peekLock" &&
                !bMessage.delivery.remote_settled) {
                try {
                    receiverLogger.verbose("%s Auto completing the message with id '%s' on " + "the receiver.", this.logPrefix, bMessage.messageId);
                    yield completeMessage(bMessage, this._context, entityPath);
                }
                catch (completeError) {
                    const translatedError = translateServiceBusError(completeError);
                    receiverLogger.logError(translatedError, "%s An error occurred while completing the message with id '%s' on the " +
                        "receiver '%s'", this.logPrefix, bMessage.messageId, this.name);
                    this._onError({
                        error: translatedError,
                        errorSource: "complete",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host
                    });
                }
            }
        });
    }
    /**
     * Whether we are currently registered for receiving messages.
     */
    get isReceivingMessages() {
        // for the streaming receiver so long as we can receive messages then we
        // _are_ receiving messages - there's no in-between state like there is
        // with BatchingReceiver.
        return this._receiverHelper.canReceiveMessages();
    }
    _getHandlers() {
        return {
            onMessage: (context) => this._onAmqpMessage(context).catch(() => {
                /* */
            }),
            onClose: (context) => this._onAmqpClose(context).catch(() => {
                /* */
            }),
            onSessionClose: (context) => this._onSessionClose(context).catch(() => {
                /* */
            }),
            onError: this._onAmqpError,
            onSessionError: this._onSessionError
        };
    }
    stopReceivingMessages() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            yield this._receiverHelper.suspend();
        });
    }
    /**
     * Initializes the link. This method will retry infinitely until a connection is established.
     *
     * The retries are broken up into cycles. For each cycle we do a set of retries, using the user's
     * configured retryOptions. If that retry call fails we will report the error and then go into a
     * new cycle, repeating the retries the same as before.
     *
     * It is completely up to the user to break out of this retry cycle in their error handler by either:
     * 1. closing the receiver
     * 2. Calling `close` on the subscription instance they received when they initially called subscribe().
     * 3. aborting the abortSignal they passed in when calling subscribe (this does not apply in onDetached, however)
     */
    init(args) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let numRetryCycles = 0;
            while (true) {
                ++numRetryCycles;
                const config = {
                    operation: () => this._initOnce(args),
                    connectionId: args.connectionId,
                    operationType: coreAmqp.RetryOperationType.receiverLink,
                    // even though we're going to loop infinitely we allow them to control the pattern we use on each
                    // retry run. This lets them toggle things like exponential retries, etc..
                    retryOptions: this._retryOptions,
                    abortSignal: args.abortSignal
                };
                try {
                    yield this._retry(config);
                    break;
                }
                catch (err) {
                    // we only report the error here - this avoids spamming the user with too many
                    // redundant reports of errors while still providing them incremental status on failures.
                    args.onError({
                        errorSource: "receive",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host,
                        error: err
                    });
                    // if the user aborts the operation we're immediately done.
                    if (err.name === "AbortError") {
                        throw err;
                    }
                    receiverLogger.logError(err, `${this.logPrefix} Error thrown in retry cycle ${numRetryCycles}, restarting retry cycle with retry options`, this._retryOptions);
                    continue;
                }
            }
        });
    }
    _initOnce(args) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const options = this._createReceiverOptions(args.useNewName, this._getHandlers());
            yield this._init(options, args.abortSignal);
            // this might seem odd but in reality this entire class is like one big function call that
            // results in a receive(). Once we're being initialized we should consider ourselves the
            // "owner" of the receiver and that it's now being locked into being the actual receiver.
            this._receiverHelper.resume();
        });
    }
    /**
     * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.
     *
     * @param {OnMessage} onMessage The message handler to receive servicebus messages.
     * @param {OnError} onError The error handler to receive an error that occurs while receivin messages.
     */
    subscribe(onMessage, onError) {
        throwErrorIfConnectionClosed(this._context);
        this._onMessage = onMessage;
        this._onError = onError;
        this._receiverHelper.addCredit(this.maxConcurrentCalls);
    }
    /**
     * Will reconnect the receiver link if necessary.
     * @param receiverError The receiver error or connection error, if any.
     * @returns {Promise<void>} Promise<void>.
     */
    onDetached(receiverError) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            receiverLogger.verbose(`${this.logPrefix} onDetached: reinitializing link.`);
            // User explicitly called `close` on the receiver, so link is already closed
            // and we can exit early.
            if (this.wasClosedPermanently) {
                receiverLogger.verbose(`${this.logPrefix} onDetached: link has been closed permanently, not reinitializing. `);
                return;
            }
            // Prevent multiple onDetached invocations from running concurrently.
            if (this._isDetaching) {
                // This can happen when the network connection goes down for some amount of time.
                // The first connection `disconnect` will trigger `onDetached` and attempt to retry
                // creating the connection/receiver link.
                // While those retry attempts fail (until the network connection comes back up),
                // we'll continue to see connection `disconnect` errors.
                // These should be ignored until the already running `onDetached` completes
                // its retry attempts or errors.
                receiverLogger.verbose(`${this.logPrefix} onDetached: Call to detached on streaming receiver '${this.name}' is already in progress.`);
                return;
            }
            this._isDetaching = true;
            const translatedError = receiverError ? translateServiceBusError(receiverError) : receiverError;
            receiverLogger.logError(translatedError, `${this.logPrefix} onDetached: Reinitializing receiver because of error`);
            try {
                // Clears the token renewal timer. Closes the link and its session if they are open.
                // Removes the link and its session if they are present in rhea's cache.
                yield this.closeLink();
            }
            catch (err) {
                receiverLogger.verbose(`${this.logPrefix} onDetached: Encountered an error when closing the previous link: `, err);
            }
            try {
                yield this.init({
                    // provide a new name to the link while re-connecting it. This ensures that
                    // the service does not send an error stating that the link is still open.
                    useNewName: true,
                    connectionId: this._context.connectionId,
                    onError: (args) => this._onError && this._onError(args)
                });
                this._receiverHelper.addCredit(this.maxConcurrentCalls);
                receiverLogger.verbose(`${this.logPrefix} onDetached: link has been reestablished, added ${this.maxConcurrentCalls} credits.`);
            }
            finally {
                this._isDetaching = false;
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @hidden
 */
const TRACEPARENT_PROPERTY = "Diagnostic-Id";
/**
 * Populates the `ServiceBusMessage` with `SpanContext` info to support trace propagation.
 * Creates and returns a copy of the passed in `ServiceBusMessage` unless the `ServiceBusMessage`
 * has already been instrumented.
 * @param message The `ServiceBusMessage` to instrument.
 * @param span The `Span` containing the context to propagate tracing information.
 * @hidden
 * @internal
 */
function instrumentServiceBusMessage(message, span) {
    if (message.applicationProperties && message.applicationProperties[TRACEPARENT_PROPERTY]) {
        return message;
    }
    // create a copy so the original isn't modified
    message = Object.assign(Object.assign({}, message), { applicationProperties: Object.assign({}, message.applicationProperties) });
    const traceParent = coreTracing.getTraceParentHeader(span.context());
    if (traceParent) {
        message.applicationProperties[TRACEPARENT_PROPERTY] = traceParent;
    }
    return message;
}
/**
 * Extracts the `SpanContext` from an `ServiceBusMessage` if the context exists.
 * @param message An individual `ServiceBusMessage` object.
 * @internal
 * @hidden
 */
function extractSpanContextFromServiceBusMessage(message) {
    if (!message.applicationProperties || !message.applicationProperties[TRACEPARENT_PROPERTY]) {
        return;
    }
    const diagnosticId = message.applicationProperties[TRACEPARENT_PROPERTY];
    return coreTracing.extractSpanContextFromTraceParentHeader(diagnosticId);
}
/**
 * Provides an iterable over messages, whether it is a single message or multiple
 * messages.
 *
 * @param receivedMessages A single message or a set of messages
 * @internal
 * @hidden
 */
function* getReceivedMessages(receivedMessages) {
    if (!Array.isArray(receivedMessages)) {
        yield receivedMessages;
    }
    else {
        for (const message of receivedMessages) {
            yield message;
        }
    }
}
/**
 * A span that encompasses the period when the message has been received and
 * is being processed.
 *
 * NOTE: The amount of time the user would be considered processing the message is
 * not always clear - in that case the span will have a very short lifetime
 * since we'll start the span when we receive the message and end it when we
 * give the message to the user.
 *
 * @internal
 * @hidden
 */
function createProcessingSpan(receivedMessages, 
// NOTE: the connectionConfig also has an entityPath property but that only
// represents the optional entityPath in their connection string which is NOT
// what we want for tracing.
receiver, connectionConfig, options) {
    var _a;
    const links = [];
    for (const receivedMessage of getReceivedMessages(receivedMessages)) {
        const spanContext = extractSpanContextFromServiceBusMessage(receivedMessage);
        if (spanContext == null) {
            continue;
        }
        links.push({
            context: spanContext,
            attributes: {
                enqueuedTime: (_a = receivedMessage.enqueuedTimeUtc) === null || _a === void 0 ? void 0 : _a.getTime()
            }
        });
    }
    const span = coreTracing.getTracer().startSpan("Azure.ServiceBus.process", {
        kind: api.SpanKind.CONSUMER,
        links,
        parent: getParentSpan(options === null || options === void 0 ? void 0 : options.tracingOptions)
    });
    span.setAttributes({
        "az.namespace": "Microsoft.ServiceBus",
        "message_bus.destination": receiver.entityPath,
        "peer.address": connectionConfig.host
    });
    return span;
}
/**
 * Creates and immediately ends a processing span. Used when
 * the 'processing' occurs outside of our control so we don't
 * know the scope.
 *
 * @internal
 * @hidden
 */
function createAndEndProcessingSpan(receivedMessages, receiver, connectionConfig, options) {
    const span = createProcessingSpan(receivedMessages, receiver, connectionConfig, options);
    span.setStatus({ code: api.CanonicalCode.OK });
    span.end();
}

// Copyright (c) Microsoft Corporation.
/**
 * Describes the batching receiver where the user can receive a specified number of messages for
 * a predefined time.
 * @internal
 * @hidden
 * @class BatchingReceiver
 * @extends MessageReceiver
 */
class BatchingReceiver extends MessageReceiver {
    /**
     * Instantiate a new BatchingReceiver.
     *
     * @constructor
     * @param {ClientEntityContext} context The client entity context.
     * @param {ReceiveOptions} [options]  Options for how you'd like to connect.
     */
    constructor(context, entityPath, options) {
        super(context, entityPath, "batching", options);
        this._batchingReceiverLite = new BatchingReceiverLite(context, entityPath, (abortSignal) => tslib.__awaiter(this, void 0, void 0, function* () {
            let lastError;
            const rcvrOptions = this._createReceiverOptions(false, {
                onError: (context) => {
                    var _a;
                    lastError = (_a = context === null || context === void 0 ? void 0 : context.receiver) === null || _a === void 0 ? void 0 : _a.error;
                },
                onSessionError: (context) => {
                    var _a;
                    lastError = (_a = context === null || context === void 0 ? void 0 : context.session) === null || _a === void 0 ? void 0 : _a.error;
                },
                // ignored for now - the next call will just fail so they'll get an appropriate error from somewhere else.
                onClose: () => tslib.__awaiter(this, void 0, void 0, function* () { }),
                onSessionClose: () => tslib.__awaiter(this, void 0, void 0, function* () { }),
                // we don't add credits initially so we don't need to worry about handling any messages.
                onMessage: () => tslib.__awaiter(this, void 0, void 0, function* () { })
            });
            yield this._init(rcvrOptions, abortSignal);
            if (lastError != null) {
                throw lastError;
            }
            return this.link;
        }), this.receiveMode);
    }
    get isReceivingMessages() {
        return this._batchingReceiverLite.isReceivingMessages;
    }
    /**
     * To be called when connection is disconnected to gracefully close ongoing receive request.
     * @param {AmqpError | Error} [connectionError] The connection error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    onDetached(connectionError) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.closeLink();
            if (connectionError == null) {
                connectionError = new Error("Unknown error occurred on the AMQP connection while receiving messages.");
            }
            this._batchingReceiverLite.close(connectionError);
        });
    }
    /**
     * Receives a batch of messages from a ServiceBus Queue/Topic.
     * @param maxMessageCount The maximum number of messages to receive.
     * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.
     * @param maxWaitTimeInMs The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.
     * @param maxTimeAfterFirstMessageInMs The total amount of time to wait after the first message
     * has been received. Defaults to 1 second.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * @returns {Promise<ServiceBusMessageImpl[]>} A promise that resolves with an array of Message objects.
     */
    receive(maxMessageCount, maxWaitTimeInMs, maxTimeAfterFirstMessageInMs, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                receiverLogger.verbose("[%s] Receiver '%s', setting max concurrent calls to 0.", this.logPrefix, this.name);
                const messages = yield this._batchingReceiverLite.receiveMessages(Object.assign({ maxMessageCount,
                    maxWaitTimeInMs,
                    maxTimeAfterFirstMessageInMs }, options));
                if (this._lockRenewer) {
                    for (const message of messages) {
                        this._lockRenewer.start(this, message, (_error) => {
                            // the auto lock renewer already logs this in a detailed way. So this hook is mainly here
                            // to potentially forward the error to the user (which we're not doing yet)
                        });
                    }
                }
                return messages;
            }
            catch (error) {
                receiverLogger.logError(error, "[%s] Rejecting receiveMessages()", this.logPrefix);
                throw error;
            }
        });
    }
    static create(context, entityPath, options) {
        throwErrorIfConnectionClosed(context);
        const bReceiver = new BatchingReceiver(context, entityPath, options);
        context.messageReceivers[bReceiver.name] = bReceiver;
        return bReceiver;
    }
}
/**
 * Gets a function that returns the smaller of the two timeouts,
 * taking into account elapsed time from when getRemainingWaitTimeInMsFn
 * was called.
 *
 * @param maxWaitTimeInMs Maximum time to wait for the first message
 * @param maxTimeAfterFirstMessageInMs Maximum time to wait after the first message before completing the receive.
 *
 * @internal
 * @hidden
 */
function getRemainingWaitTimeInMsFn(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs) {
    const startTimeMs = Date.now();
    return () => {
        const remainingTimeMs = maxWaitTimeInMs - (Date.now() - startTimeMs);
        if (remainingTimeMs < 0) {
            return 0;
        }
        return Math.min(remainingTimeMs, maxTimeAfterFirstMessageInMs);
    };
}
/**
 * The internals of a batching receiver minus anything that would require us to hold onto a client entity context
 * or a receiver on a permanent basis.
 *
 * Usable with both session and non-session receivers.
 *
 * @internal
 * @hidden
 */
class BatchingReceiverLite {
    constructor(_connectionContext, entityPath, _getCurrentReceiver, _receiveMode) {
        this._connectionContext = _connectionContext;
        this.entityPath = entityPath;
        this._getCurrentReceiver = _getCurrentReceiver;
        this._receiveMode = _receiveMode;
        this._createAndEndProcessingSpan = createAndEndProcessingSpan;
        this._createServiceBusMessage = (context) => {
            return new ServiceBusMessageImpl(context.message, context.delivery, true, this._receiveMode);
        };
        this._getRemainingWaitTimeInMsFn = (maxWaitTimeInMs, maxTimeAfterFirstMessageInMs) => getRemainingWaitTimeInMsFn(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs);
        this.isReceivingMessages = false;
    }
    /**
     * Receives a set of messages,
     *
     * @internal
     * @hidden
     */
    receiveMessages(args) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                this.isReceivingMessages = true;
                const receiver = yield this._getCurrentReceiver(args.abortSignal);
                if (receiver == null) {
                    // (was somehow closed in between the init() and the return)
                    return [];
                }
                const messages = yield new Promise((resolve, reject) => this._receiveMessagesImpl(receiver, args, resolve, reject));
                this._createAndEndProcessingSpan(messages, this, this._connectionContext.config, args);
                return messages;
            }
            finally {
                this._closeHandler = undefined;
                this.isReceivingMessages = false;
            }
        });
    }
    /**
     * Closes the receiver (optionally with an error), cancelling any current operations.
     *
     * @param connectionError An optional error (rhea doesn't always deliver one for certain disconnection events)
     */
    close(connectionError) {
        if (this._closeHandler) {
            this._closeHandler(connectionError);
            this._closeHandler = undefined;
        }
    }
    _receiveMessagesImpl(receiver, args, origResolve, origReject) {
        const getRemainingWaitTimeInMs = this._getRemainingWaitTimeInMsFn(args.maxWaitTimeInMs, args.maxTimeAfterFirstMessageInMs);
        const brokeredMessages = [];
        const loggingPrefix = `[${receiver.connection.id}|r:${receiver.name}]`;
        let totalWaitTimer;
        // eslint-disable-next-line prefer-const
        let cleanupBeforeResolveOrReject;
        const reject = (err) => {
            cleanupBeforeResolveOrReject();
            origReject(err);
        };
        const resolveImmediately = (result) => {
            cleanupBeforeResolveOrReject();
            origResolve(result);
        };
        const resolveAfterPendingMessageCallbacks = (result) => {
            // NOTE: through rhea-promise, most of our event handlers are made asynchronous by calling setTimeout(emit).
            // However, a small set (*error and drain) execute immediately. This can lead to a situation where the logical
            // ordering of events is correct but the execution order is incorrect because the events are not all getting
            // put into the task queue the same way.
            // setTimeout() ensures that we resolve _after_ any already-queued onMessage handlers that may
            // be waiting in the task queue.
            setTimeout(() => {
                cleanupBeforeResolveOrReject();
                origResolve(result);
            });
        };
        const onError = (context) => {
            var _a, _b, _c;
            const eventType = ((_a = context.session) === null || _a === void 0 ? void 0 : _a.error) != null ? "session_error" : "receiver_error";
            let error = ((_b = context.session) === null || _b === void 0 ? void 0 : _b.error) || ((_c = context.receiver) === null || _c === void 0 ? void 0 : _c.error);
            if (error) {
                error = translateServiceBusError(error);
                receiverLogger.logError(error, `${loggingPrefix} '${eventType}' event occurred. Received an error`);
            }
            else {
                error = new ServiceBusError("An error occurred while receiving messages.", "GeneralError");
            }
            reject(error);
        };
        this._closeHandler = (error) => {
            if (
            // no error, just closing. Go ahead and return what we have.
            error == null ||
                // Return the collected messages if in ReceiveAndDelete mode because otherwise they are lost forever
                (this._receiveMode === "receiveAndDelete" && brokeredMessages.length)) {
                receiverLogger.verbose(`${loggingPrefix} Closing. Resolving with ${brokeredMessages.length} messages.`);
                return resolveAfterPendingMessageCallbacks(brokeredMessages);
            }
            reject(translateServiceBusError(error));
        };
        let abortSignalCleanupFunction = undefined;
        // Final action to be performed after
        // - maxMessageCount is reached or
        // - maxWaitTime is passed or
        // - newMessageWaitTimeoutInSeconds is passed since the last message was received
        const finalAction = () => {
            // Drain any pending credits.
            if (receiver.isOpen() && receiver.credit > 0) {
                receiverLogger.verbose(`${loggingPrefix} Draining leftover credits(${receiver.credit}).`);
                // setting .drain and combining it with .addCredit results in (eventually) sending
                // a drain request to Service Bus. When the drain completes rhea will call `onReceiveDrain`
                // at which point we'll wrap everything up and resolve the promise.
                receiver.drain = true;
                receiver.addCredit(1);
            }
            else {
                receiverLogger.verbose(`${loggingPrefix} Resolving receiveMessages() with ${brokeredMessages.length} messages.`);
                // we can resolve immediately (ie, no setTimeout call) because we have no
                // remaining messages (thus nothing to wait for)
                resolveImmediately(brokeredMessages);
            }
        };
        // Action to be performed on the "message" event.
        const onReceiveMessage = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            // TODO: this appears to be aggravating a bug that we need to look into more deeply.
            // The same timeout+drain sequence should work fine for receiveAndDelete but it appears
            // to cause problems.
            if (this._receiveMode === "peekLock") {
                if (brokeredMessages.length === 0) {
                    // We'll now remove the old timer (which was the overall `maxWaitTimeMs` timer)
                    // and replace it with another timer that is a (probably) much shorter interval.
                    //
                    // This allows the user to get access to received messages earlier and also gives us
                    // a chance to have fewer messages internally that could get lost if the user's
                    // app crashes.
                    if (totalWaitTimer)
                        clearTimeout(totalWaitTimer);
                    const remainingWaitTimeInMs = getRemainingWaitTimeInMs();
                    totalWaitTimer = setTimeout(() => {
                        receiverLogger.verbose(`${loggingPrefix} Batching, waited for ${remainingWaitTimeInMs} milliseconds after receiving the first message.`);
                        finalAction();
                    }, remainingWaitTimeInMs);
                }
            }
            try {
                const data = this._createServiceBusMessage(context);
                if (brokeredMessages.length < args.maxMessageCount) {
                    brokeredMessages.push(data);
                }
            }
            catch (err) {
                const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));
                receiverLogger.logError(err, `${loggingPrefix} Received an error while converting AmqpMessage to ServiceBusMessage`);
                reject(errObj);
            }
            if (brokeredMessages.length === args.maxMessageCount) {
                finalAction();
            }
        });
        const onClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const type = ((_a = context.session) === null || _a === void 0 ? void 0 : _a.error) != null ? "session_closed" : "receiver_closed";
            const error = ((_b = context.session) === null || _b === void 0 ? void 0 : _b.error) || ((_c = context.receiver) === null || _c === void 0 ? void 0 : _c.error);
            if (error) {
                receiverLogger.logError(error, `${loggingPrefix} '${type}' event occurred. The associated error`);
            }
        });
        // Action to be performed on the "receiver_drained" event.
        const onReceiveDrain = () => {
            receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
            receiver.drain = false;
            receiverLogger.verbose(`${loggingPrefix} Drained, resolving receiveMessages() with ${brokeredMessages.length} messages.`);
            resolveAfterPendingMessageCallbacks(brokeredMessages);
        };
        cleanupBeforeResolveOrReject = () => {
            if (receiver != null) {
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverError, onError);
                receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                receiver.session.removeListener(rheaPromise.SessionEvents.sessionError, onError);
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverClose, onClose);
                receiver.session.removeListener(rheaPromise.SessionEvents.sessionClose, onClose);
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
            }
            if (totalWaitTimer) {
                clearTimeout(totalWaitTimer);
            }
            if (abortSignalCleanupFunction) {
                abortSignalCleanupFunction();
            }
            abortSignalCleanupFunction = undefined;
        };
        abortSignalCleanupFunction = checkAndRegisterWithAbortSignal((err) => {
            reject(err);
        }, args.abortSignal);
        receiverLogger.verbose(`${loggingPrefix} Adding credit for receiving ${args.maxMessageCount} messages.`);
        // By adding credit here, we let the service know that at max we can handle `maxMessageCount`
        // number of messages concurrently. We will return the user an array of messages that can
        // be of size upto maxMessageCount. Then the user needs to accordingly dispose
        // (complete/abandon/defer/deadletter) the messages from the array.
        receiver.addCredit(args.maxMessageCount);
        receiverLogger.verbose(`${loggingPrefix} Setting the wait timer for ${args.maxWaitTimeInMs} milliseconds.`);
        totalWaitTimer = setTimeout(() => {
            receiverLogger.verbose(`${loggingPrefix} Batching, waited for max wait time ${args.maxWaitTimeInMs} milliseconds.`);
            finalAction();
        }, args.maxWaitTimeInMs);
        receiver.on(rheaPromise.ReceiverEvents.message, onReceiveMessage);
        receiver.on(rheaPromise.ReceiverEvents.receiverError, onError);
        receiver.on(rheaPromise.ReceiverEvents.receiverClose, onClose);
        receiver.on(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
        receiver.session.on(rheaPromise.SessionEvents.sessionError, onError);
        receiver.session.on(rheaPromise.SessionEvents.sessionClose, onClose);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Tracks locks for messages, renewing until a configurable duration.
 *
 * @internal
 * @hidden
 */
class LockRenewer {
    constructor(_context, _maxAutoRenewDurationInMs) {
        this._context = _context;
        this._maxAutoRenewDurationInMs = _maxAutoRenewDurationInMs;
        /**
         * @property _messageRenewLockTimers A map of link names to individual maps for each
         * link that map a message ID to its auto-renewal timer.
         */
        this._messageRenewLockTimers = new Map();
        this._calculateRenewAfterDuration = calculateRenewAfterDuration;
    }
    /**
     * Creates an AutoLockRenewer.
     *
     * @param linkEntity Your link entity instance (probably 'this')
     * @param context The connection context for your link entity (probably 'this._context')
     * @param options The ReceiveOptions passed through to your message receiver.
     * @returns if the lock mode is peek lock (or if is unspecified, thus defaulting to peekLock)
     * and the options.maxAutoLockRenewalDurationInMs is > 0..Otherwise, returns undefined.
     */
    static create(context, maxAutoRenewLockDurationInMs, receiveMode) {
        if (receiveMode !== "peekLock") {
            return undefined;
        }
        if (maxAutoRenewLockDurationInMs <= 0) {
            return undefined;
        }
        return new LockRenewer(context, maxAutoRenewLockDurationInMs);
    }
    /**
     * Cancels all pending lock renewals for messages on given link and removes all entries from our internal cache.
     */
    stopAll(linkEntity) {
        receiverLogger.verbose(`${linkEntity.logPrefix} Clearing message renew lock timers for all the active messages.`);
        const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);
        if (messagesForLink == null) {
            return;
        }
        for (const messageId of messagesForLink.keys()) {
            this._stopAndRemoveById(linkEntity, messagesForLink, messageId);
        }
        this._messageRenewLockTimers.delete(linkEntity.name);
    }
    /**
     * Stops lock renewal for a single message.
     *
     * @param bMessage The message whose lock renewal we will stop.
     */
    stop(linkEntity, bMessage) {
        const messageId = bMessage.messageId;
        const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);
        if (messagesForLink == null) {
            return;
        }
        this._stopAndRemoveById(linkEntity, messagesForLink, messageId);
    }
    /**
     * Starts lock renewal for a single message.
     *
     * @param bMessage The message whose lock renewal we will start.
     */
    start(linkEntity, bMessage, onError) {
        try {
            const logPrefix = linkEntity.logPrefix;
            if (bMessage.lockToken == null) {
                throw new Error(`Can't start auto lock renewal for message with message id '${bMessage.messageId}' since it does not have a lock token.`);
            }
            const lockToken = bMessage.lockToken;
            const linkMessageMap = this._getOrCreateMapForLink(linkEntity);
            // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.
            // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInMs
            // - We should be able to clear the renewal timer when the user's message handler
            // is done (whether it succeeds or fails).
            // Setting the messageId with undefined value in the linkMessageMap because we
            // track state by checking the presence of messageId in the map. It is removed from the map
            // when an attempt is made to settle the message (either by the user or by the sdk) OR
            // when the execution of user's message handler completes.
            linkMessageMap.set(bMessage.messageId, undefined);
            receiverLogger.verbose(`${logPrefix} message with id '${bMessage.messageId}' is locked until ${bMessage.lockedUntilUtc.toString()}.`);
            const totalAutoLockRenewDuration = Date.now() + this._maxAutoRenewDurationInMs;
            receiverLogger.verbose(`${logPrefix} Total autolockrenew duration for message with id '${bMessage.messageId}' is: ${new Date(totalAutoLockRenewDuration).toString()}`);
            const autoRenewLockTask = () => {
                const renewalNeededToMaintainLock = 
                // if the lock expires _after_ our max auto-renew duration there's no reason to
                // spin up an auto-renewer - it's already held for the duration.
                new Date(totalAutoLockRenewDuration) > bMessage.lockedUntilUtc;
                // once we've exceeded the max amount of time we'll renew we can stop.
                const haventExceededMaxLockRenewalTime = Date.now() < totalAutoLockRenewDuration;
                if (renewalNeededToMaintainLock && haventExceededMaxLockRenewalTime) {
                    if (linkMessageMap.has(bMessage.messageId)) {
                        // TODO: We can run into problems with clock skew between the client and the server.
                        // It would be better to calculate the duration based on the "lockDuration" property
                        // of the queue. However, we do not have the management plane of the client ready for
                        // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.
                        const amount = this._calculateRenewAfterDuration(bMessage.lockedUntilUtc);
                        receiverLogger.verbose(`${logPrefix} Sleeping for ${amount} milliseconds while renewing the lock for message with id '${bMessage.messageId}'`);
                        // Setting the value of the messageId to the actual timer. This will be cleared when
                        // an attempt is made to settle the message (either by the user or by the sdk) OR
                        // when the execution of user's message handler completes.
                        const autoRenewTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
                            try {
                                receiverLogger.verbose(`${logPrefix} Attempting to renew the lock for message with id '${bMessage.messageId}'.`);
                                bMessage.lockedUntilUtc = yield this._context
                                    .getManagementClient(linkEntity.entityPath)
                                    .renewLock(lockToken, {
                                    associatedLinkName: linkEntity.name
                                });
                                receiverLogger.verbose(`${logPrefix} Successfully renewed the lock for message with id '${bMessage.messageId}'. Starting next auto-lock-renew cycle for message.`);
                                autoRenewLockTask();
                            }
                            catch (err) {
                                receiverLogger.logError(err, `${logPrefix} An error occurred while auto renewing the message lock '${bMessage.lockToken}' for message with id '${bMessage.messageId}'`);
                                onError(err);
                            }
                        }), amount);
                        // Prevent the active Timer from keeping the Node.js event loop active.
                        if (typeof autoRenewTimer.unref === "function") {
                            autoRenewTimer.unref();
                        }
                        linkMessageMap.set(bMessage.messageId, autoRenewTimer);
                    }
                    else {
                        receiverLogger.verbose(`${logPrefix} Looks like the message lock renew timer has already been cleared for message with id '${bMessage.messageId}'.`);
                    }
                }
                else {
                    receiverLogger.verbose(`${logPrefix} Current time ${new Date()} exceeds the total autolockrenew duration ${new Date(totalAutoLockRenewDuration)} for message with messageId '${bMessage.messageId}'. Hence we will stop the autoLockRenewTask.`);
                    this.stop(linkEntity, bMessage);
                }
            };
            // start
            autoRenewLockTask();
        }
        catch (err) {
            onError(err);
        }
    }
    _getOrCreateMapForLink(linkEntity) {
        if (!this._messageRenewLockTimers.has(linkEntity.name)) {
            this._messageRenewLockTimers.set(linkEntity.name, new Map());
        }
        return this._messageRenewLockTimers.get(linkEntity.name);
    }
    _stopAndRemoveById(linkEntity, linkMessageMap, messageId) {
        if (messageId == null) {
            throw new Error("Failed to stop auto lock renewal - no message ID");
        }
        // TODO: messageId doesn't actually need to be unique. Perhaps we should use lockToken
        // instead?
        if (linkMessageMap.has(messageId)) {
            clearTimeout(linkMessageMap.get(messageId));
            receiverLogger.verbose(`${linkEntity.logPrefix} Cleared the message renew lock timer for message with id '${messageId}'.`);
            linkMessageMap.delete(messageId);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 */
class ServiceBusReceiverImpl {
    /**
     * @throws Error if the underlying connection is closed.
     */
    constructor(_context, entityPath, receiveMode, maxAutoRenewLockDurationInMs, retryOptions = {}) {
        this._context = _context;
        this.entityPath = entityPath;
        this.receiveMode = receiveMode;
        /**
         * @property {boolean} [_isClosed] Denotes if close() was called on this receiver
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(_context);
        this._retryOptions = retryOptions;
        this._lockRenewer = LockRenewer.create(this._context, maxAutoRenewLockDurationInMs, receiveMode);
        this._createProcessingSpan = createProcessingSpan;
    }
    get logPrefix() {
        return `[${this._context.connectionId}|receiver:${this.entityPath}]`;
    }
    _throwIfAlreadyReceiving() {
        if (this._isReceivingMessages()) {
            const errorMessage = getAlreadyReceivingErrorMsg(this.entityPath);
            const error = new Error(errorMessage);
            receiverLogger.logError(error, `${this.logPrefix} is already receiving`);
            throw error;
        }
    }
    _throwIfReceiverOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (this.isClosed) {
            const errorMessage = getReceiverClosedErrorMsg(this.entityPath);
            const error = new Error(errorMessage);
            receiverLogger.logError(error, `${this.logPrefix} is closed`);
            throw error;
        }
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the Receiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control if messages should be automatically completed, and/or have
     * their locks automatically renewed. You can control the maximum number of messages that should
     * be concurrently processed. You can also provide a timeout in milliseconds to denote the
     * amount of time to wait for a new message before closing the receiver.
     *
     * @returns void
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if current receiver is already in state of receiving messages.
     * @throws ServiceBusError if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
     */
    _registerMessageHandler(onInitialize, onMessage, onError, options) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        const connId = this._context.connectionId;
        throwTypeErrorIfParameterMissing(connId, "onMessage", onMessage);
        throwTypeErrorIfParameterMissing(connId, "onError", onError);
        if (typeof onMessage !== "function") {
            throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
        }
        if (typeof onError !== "function") {
            throw new TypeError("The parameter 'onError' must be of type 'function'.");
        }
        this._createStreamingReceiver(Object.assign(Object.assign({}, options), { receiveMode: this.receiveMode, retryOptions: this._retryOptions, lockRenewer: this._lockRenewer, onError }))
            .then((sReceiver) => tslib.__awaiter(this, void 0, void 0, function* () {
            if (!sReceiver) {
                return;
            }
            this._streamingReceiver = sReceiver;
            try {
                yield onInitialize();
            }
            catch (err) {
                onError({
                    error: err,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host
                });
            }
            if (!this.isClosed) {
                sReceiver.subscribe(onMessage, onError);
            }
            else {
                yield sReceiver.close();
            }
            return;
        }))
            .catch((err) => {
            // TODO: being a bit broad here but the only errors that should filter out this
            // far are going to be bootstrapping the subscription.
            onError({
                error: err,
                errorSource: "receive",
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host
            });
        });
    }
    _createStreamingReceiver(options) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            if (options.autoCompleteMessages == null)
                options.autoCompleteMessages = true;
            // When the user "stops" a streaming receiver (via the returned instance from 'subscribe' we just suspend
            // it, leaving the link open). This allows users to stop the flow of messages but still be able to settle messages
            // since the link itself hasn't been shut down.
            //
            // Users can, if they want, restart their subscription (since we've got a link already established).
            // So you'll have an instance here if the user has done:
            // 1. const subscription = receiver.subscribe()
            // 2. subscription.stop()
            // 3. receiver.subscribe()
            this._streamingReceiver = (_a = this._streamingReceiver) !== null && _a !== void 0 ? _a : new StreamingReceiver(this._context, this.entityPath, options);
            // this ensures that if the outer service bus client is closed that  this receiver is cleaned up.
            // this mostly affects us if we're in the middle of init() - the connection (and receiver) are not yet
            // open but we do need to close the receiver to exit the init() loop.
            this._context.messageReceivers[this._streamingReceiver.name] = this._streamingReceiver;
            yield this._streamingReceiver.init(Object.assign({ connectionId: this._context.connectionId, useNewName: false }, options));
            return this._streamingReceiver;
        });
    }
    receiveMessages(maxMessageCount, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            this._throwIfAlreadyReceiving();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "maxMessageCount", maxMessageCount);
            throwTypeErrorIfParameterTypeMismatch(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");
            if (isNaN(maxMessageCount) || maxMessageCount < 1) {
                throw new TypeError(InvalidMaxMessageCountError);
            }
            const receiveMessages = () => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                if (!this._batchingReceiver || !this._context.messageReceivers[this._batchingReceiver.name]) {
                    const options = {
                        maxConcurrentCalls: 0,
                        receiveMode: this.receiveMode,
                        lockRenewer: this._lockRenewer
                    };
                    this._batchingReceiver = this._createBatchingReceiver(this._context, this.entityPath, options);
                }
                const receivedMessages = yield this._batchingReceiver.receive(maxMessageCount, (_a = options === null || options === void 0 ? void 0 : options.maxWaitTimeInMs) !== null && _a !== void 0 ? _a : coreAmqp.Constants.defaultOperationTimeoutInMs, defaultMaxTimeAfterFirstMessageForBatchingMs, options !== null && options !== void 0 ? options : {});
                return receivedMessages;
            });
            const config = {
                connectionHost: this._context.config.host,
                connectionId: this._context.connectionId,
                operation: receiveMessages,
                operationType: coreAmqp.RetryOperationType.receiveMessage,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
                retryOptions: this._retryOptions
            };
            return coreAmqp.retry(config).catch((err) => {
                throw translateServiceBusError(err);
            });
        });
    }
    getMessageIterator(options) {
        return getMessageIterator(this, options);
    }
    receiveDeferredMessages(sequenceNumbers, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
            throwTypeErrorIfParameterNotLong(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
            const deferredSequenceNumbers = Array.isArray(sequenceNumbers)
                ? sequenceNumbers
                : [sequenceNumbers];
            const receiveDeferredMessagesOperationPromise = () => tslib.__awaiter(this, void 0, void 0, function* () {
                const deferredMessages = yield this._context
                    .getManagementClient(this.entityPath)
                    .receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, undefined, Object.assign(Object.assign({}, options), { associatedLinkName: this._getAssociatedReceiverName(), requestName: "receiveDeferredMessages", timeoutInMs: this._retryOptions.timeoutInMs }));
                return deferredMessages;
            });
            const config = {
                operation: receiveDeferredMessagesOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return coreAmqp.retry(config);
        });
    }
    // ManagementClient methods # Begin
    peekMessages(maxMessageCount, options = {}) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            const managementRequestOptions = Object.assign(Object.assign({}, options), { associatedLinkName: this._getAssociatedReceiverName(), requestName: "peekMessages", timeoutInMs: (_a = this._retryOptions) === null || _a === void 0 ? void 0 : _a.timeoutInMs });
            const peekOperationPromise = () => tslib.__awaiter(this, void 0, void 0, function* () {
                if (options.fromSequenceNumber) {
                    return yield this._context
                        .getManagementClient(this.entityPath)
                        .peekBySequenceNumber(options.fromSequenceNumber, maxMessageCount, undefined, managementRequestOptions);
                }
                else {
                    return yield this._context
                        .getManagementClient(this.entityPath)
                        .peek(maxMessageCount, managementRequestOptions);
                }
            });
            const config = {
                operation: peekOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return coreAmqp.retry(config);
        });
    }
    subscribe(handlers, options) {
        assertValidMessageHandlers(handlers);
        options = options !== null && options !== void 0 ? options : {};
        const processError = wrapProcessErrorHandler(handlers);
        const internalMessageHandlers = handlers;
        this._registerMessageHandler(() => tslib.__awaiter(this, void 0, void 0, function* () {
            if (internalMessageHandlers === null || internalMessageHandlers === void 0 ? void 0 : internalMessageHandlers.processInitialize) {
                yield internalMessageHandlers.processInitialize();
            }
        }), (message) => tslib.__awaiter(this, void 0, void 0, function* () {
            const span = this._createProcessingSpan(message, this, this._context.config, options);
            return trace(() => handlers.processMessage(message), span);
        }), processError, options);
        return {
            close: () => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                return (_a = this._streamingReceiver) === null || _a === void 0 ? void 0 : _a.stopReceivingMessages();
            })
        };
    }
    completeMessage(message) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return completeMessage(msgImpl, this._context, this.entityPath);
        });
    }
    abandonMessage(message, propertiesToModify) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return abandonMessage(msgImpl, this._context, this.entityPath, propertiesToModify);
        });
    }
    deferMessage(message, propertiesToModify) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return deferMessage(msgImpl, this._context, this.entityPath, propertiesToModify);
        });
    }
    deadLetterMessage(message, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return deadLetterMessage(msgImpl, this._context, this.entityPath, options);
        });
    }
    renewMessageLock(message) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            let associatedLinkName;
            if (msgImpl.delivery.link) {
                const associatedReceiver = this._context.getReceiverFromCache(msgImpl.delivery.link.name);
                associatedLinkName = associatedReceiver === null || associatedReceiver === void 0 ? void 0 : associatedReceiver.name;
            }
            return this._context
                .getManagementClient(this.entityPath)
                .renewLock(message.lockToken, { associatedLinkName })
                .then((lockedUntil) => {
                message.lockedUntilUtc = lockedUntil;
                return lockedUntil;
            });
        });
    }
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                this._isClosed = true;
                if (this._context.connection && this._context.connection.isOpen()) {
                    // Close the streaming receiver.
                    if (this._streamingReceiver) {
                        yield this._streamingReceiver.close();
                    }
                    // Close the batching receiver.
                    if (this._batchingReceiver) {
                        yield this._batchingReceiver.close();
                    }
                }
            }
            catch (err) {
                receiverLogger.logError(err, `${this.logPrefix} An error occurred while closing the Receiver`);
                throw err;
            }
        });
    }
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
     */
    _isReceivingMessages() {
        if (this._streamingReceiver &&
            this._streamingReceiver.isOpen() &&
            this._streamingReceiver.isReceivingMessages) {
            return true;
        }
        if (this._batchingReceiver &&
            this._batchingReceiver.isOpen() &&
            this._batchingReceiver.isReceivingMessages) {
            return true;
        }
        return false;
    }
    _createBatchingReceiver(context, entityPath, options) {
        return BatchingReceiver.create(context, entityPath, options);
    }
    /**
     * Helper function to retrieve any active receiver name, regardless of streaming or
     * batching if it exists. This is used for optimization on the service side
     */
    _getAssociatedReceiverName() {
        if (this._streamingReceiver && this._streamingReceiver.isOpen()) {
            return this._streamingReceiver.name;
        }
        if (this._batchingReceiver &&
            this._batchingReceiver.isOpen() &&
            this._batchingReceiver.isReceivingMessages) {
            return this._batchingReceiver.name;
        }
        return;
    }
}
/**
 * The default time to wait for messages _after_ the first message
 * has been received.
 *
 * This timeout only applies to receiveMessages()
 *
 * @internal
 * @hidden
 */
const defaultMaxTimeAfterFirstMessageForBatchingMs = 1000;

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 */
class ServiceBusSessionReceiverImpl {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     * @throws Error if an open receiver is already existing for given sessionId.
     */
    constructor(_messageSession, _context, entityPath, receiveMode, _retryOptions = {}) {
        this._messageSession = _messageSession;
        this._context = _context;
        this.entityPath = entityPath;
        this.receiveMode = receiveMode;
        this._retryOptions = _retryOptions;
        /**
         * @property {boolean} [_isClosed] Denotes if close() was called on this receiver
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(_context);
        this.sessionId = _messageSession.sessionId;
        this._createProcessingSpan = createProcessingSpan;
    }
    get logPrefix() {
        return `[${this._context.connectionId}|session:${this.entityPath}]`;
    }
    _throwIfReceiverOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (this.isClosed) {
            if (this._isClosed) {
                const errorMessage = getReceiverClosedErrorMsg(this.entityPath, this.sessionId);
                const error = new Error(errorMessage);
                receiverLogger.logError(error, `${this.logPrefix} already closed`);
                throw error;
            }
            const amqpError = {
                condition: coreAmqp.ErrorNameConditionMapper.SessionLockLostError,
                description: `The session lock has expired on the session with id ${this.sessionId}`
            };
            throw translateServiceBusError(amqpError);
        }
    }
    _throwIfAlreadyReceiving() {
        if (this._isReceivingMessages()) {
            const errorMessage = getAlreadyReceivingErrorMsg(this.entityPath, this.sessionId);
            const error = new Error(errorMessage);
            receiverLogger.logError(error, `${this.logPrefix} is already receiving.`);
            throw error;
        }
    }
    get isClosed() {
        return (this._isClosed ||
            !this._context.messageSessions[this._messageSession.name] ||
            !this._messageSession.isOpen());
    }
    /**
     * @property The time in UTC until which the session is locked.
     * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock
     * duration as specified during the Queue/Subscription creation.
     *
     * When the lock on the session expires
     * - The current receiver can no longer be used to receive more messages.
     * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.
     * - Messages that were received in `peekLock` mode with this receiver but not yet settled
     * will land back in the Queue/Subscription with their delivery count incremented.
     *
     * @readonly
     */
    get sessionLockedUntilUtc() {
        return this._messageSession.sessionLockedUntilUtc;
    }
    /**
     * Renews the lock on the session for the duration as specified during the Queue/Subscription
     * creation. You can check the `sessionLockedUntilUtc` property for the time when the lock expires.
     *
     * When the lock on the session expires
     * - The current receiver can no longer be used to receive mode messages.
     * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.
     * - Messages that were received in `peekLock` mode with this receiver but not yet settled
     * will land back in the Queue/Subscription with their delivery count incremented.
     *
     * @param options - Options bag to pass an abort signal or tracing options.
     * @returns Promise<Date> - New lock token expiry date and time in UTC format.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while renewing session lock.
     */
    renewSessionLock(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            const renewSessionLockOperationPromise = () => tslib.__awaiter(this, void 0, void 0, function* () {
                this._messageSession.sessionLockedUntilUtc = yield this._context
                    .getManagementClient(this.entityPath)
                    .renewSessionLock(this.sessionId, Object.assign(Object.assign({}, options), { associatedLinkName: this._messageSession.name, requestName: "renewSessionLock", timeoutInMs: this._retryOptions.timeoutInMs }));
                return this._messageSession.sessionLockedUntilUtc;
            });
            const config = {
                operation: renewSessionLockOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return coreAmqp.retry(config);
        });
    }
    /**
     * Sets the state on the Session. For more on session states, see
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state Session State}
     * @param state The state that needs to be set.
     * @param options - Options bag to pass an abort signal or tracing options.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while setting the session state.
     */
    setSessionState(state, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            const setSessionStateOperationPromise = () => tslib.__awaiter(this, void 0, void 0, function* () {
                yield this._context
                    .getManagementClient(this.entityPath)
                    .setSessionState(this.sessionId, state, Object.assign(Object.assign({}, options), { associatedLinkName: this._messageSession.name, requestName: "setState", timeoutInMs: this._retryOptions.timeoutInMs }));
                return;
            });
            const config = {
                operation: setSessionStateOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return coreAmqp.retry(config);
        });
    }
    /**
     * Gets the state of the Session. For more on session states, see
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state Session State}
     * @param options - Options bag to pass an abort signal or tracing options.
     * @returns Promise<any> The state of that session
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while retrieving session state.
     */
    getSessionState(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            const getSessionStateOperationPromise = () => tslib.__awaiter(this, void 0, void 0, function* () {
                return this._context.getManagementClient(this.entityPath).getSessionState(this.sessionId, Object.assign(Object.assign({}, options), { associatedLinkName: this._messageSession.name, requestName: "getState", timeoutInMs: this._retryOptions.timeoutInMs }));
            });
            const config = {
                operation: getSessionStateOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return coreAmqp.retry(config);
        });
    }
    peekMessages(maxMessageCount, options = {}) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            const managementRequestOptions = Object.assign(Object.assign({}, options), { associatedLinkName: this._messageSession.name, requestName: "peekMessages", timeoutInMs: (_a = this._retryOptions) === null || _a === void 0 ? void 0 : _a.timeoutInMs });
            const peekOperationPromise = () => tslib.__awaiter(this, void 0, void 0, function* () {
                if (options.fromSequenceNumber) {
                    return yield this._context
                        .getManagementClient(this.entityPath)
                        .peekBySequenceNumber(options.fromSequenceNumber, maxMessageCount, this.sessionId, managementRequestOptions);
                }
                else {
                    return yield this._context
                        .getManagementClient(this.entityPath)
                        .peekMessagesBySession(this.sessionId, maxMessageCount, managementRequestOptions);
                }
            });
            const config = {
                operation: peekOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return coreAmqp.retry(config);
        });
    }
    receiveDeferredMessages(sequenceNumbers, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
            throwTypeErrorIfParameterNotLong(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
            const deferredSequenceNumbers = Array.isArray(sequenceNumbers)
                ? sequenceNumbers
                : [sequenceNumbers];
            const receiveDeferredMessagesOperationPromise = () => tslib.__awaiter(this, void 0, void 0, function* () {
                const deferredMessages = yield this._context
                    .getManagementClient(this.entityPath)
                    .receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, this.sessionId, Object.assign(Object.assign({}, options), { associatedLinkName: this._messageSession.name, requestName: "receiveDeferredMessages", timeoutInMs: this._retryOptions.timeoutInMs }));
                return deferredMessages;
            });
            const config = {
                operation: receiveDeferredMessagesOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return coreAmqp.retry(config);
        });
    }
    receiveMessages(maxMessageCount, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            this._throwIfAlreadyReceiving();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "maxMessageCount", maxMessageCount);
            throwTypeErrorIfParameterTypeMismatch(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");
            if (isNaN(maxMessageCount) || maxMessageCount < 1) {
                throw new TypeError(InvalidMaxMessageCountError);
            }
            const receiveBatchOperationPromise = () => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                const receivedMessages = yield this._messageSession.receiveMessages(maxMessageCount, (_a = options === null || options === void 0 ? void 0 : options.maxWaitTimeInMs) !== null && _a !== void 0 ? _a : coreAmqp.Constants.defaultOperationTimeoutInMs, defaultMaxTimeAfterFirstMessageForBatchingMs, options !== null && options !== void 0 ? options : {});
                return receivedMessages;
            });
            const config = {
                operation: receiveBatchOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.receiveMessage,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return coreAmqp.retry(config).catch((err) => {
                throw translateServiceBusError(err);
            });
        });
    }
    subscribe(handlers, options) {
        // TODO - receiverOptions for subscribe??
        assertValidMessageHandlers(handlers);
        options = options !== null && options !== void 0 ? options : {};
        const processError = wrapProcessErrorHandler(handlers);
        this._registerMessageHandler((message) => tslib.__awaiter(this, void 0, void 0, function* () {
            const span = this._createProcessingSpan(message, this, this._context.config, options);
            return trace(() => handlers.processMessage(message), span);
        }), processError, options);
        return {
            close: () => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                return (_a = this._messageSession) === null || _a === void 0 ? void 0 : _a.receiverHelper.suspend();
            })
        };
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed
     * or if the lock on the session should be automatically renewed. You can control the
     * maximum number of messages that should be concurrently processed. You can
     * also provide a timeout in milliseconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     *
     * @returns void
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if the receiver is already in state of receiving messages.
     * @throws `ServiceBusError` if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
     */
    _registerMessageHandler(onMessage, onError, options) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        const connId = this._context.connectionId;
        throwTypeErrorIfParameterMissing(connId, "onMessage", onMessage);
        throwTypeErrorIfParameterMissing(connId, "onError", onError);
        if (typeof onMessage !== "function") {
            throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
        }
        if (typeof onError !== "function") {
            throw new TypeError("The parameter 'onError' must be of type 'function'.");
        }
        try {
            this._messageSession.subscribe(onMessage, onError, options);
        }
        catch (err) {
            onError({
                error: err,
                errorSource: "receive",
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host
            });
        }
    }
    getMessageIterator(options) {
        return getMessageIterator(this, options);
    }
    completeMessage(message) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return completeMessage(msgImpl, this._context, this.entityPath);
        });
    }
    abandonMessage(message, propertiesToModify) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return abandonMessage(msgImpl, this._context, this.entityPath, propertiesToModify);
        });
    }
    deferMessage(message, propertiesToModify) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return deferMessage(msgImpl, this._context, this.entityPath, propertiesToModify);
        });
    }
    deadLetterMessage(message, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
            const msgImpl = message;
            return deadLetterMessage(msgImpl, this._context, this.entityPath, options);
        });
    }
    renewMessageLock() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throw new Error("Renewing message lock is an invalid operation when working with sessions.");
        });
    }
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this._messageSession.close();
            }
            catch (err) {
                receiverLogger.logError(err, "%s An error occurred while closing the SessionReceiver for session %s", this.logPrefix, this.sessionId);
                throw err;
            }
            finally {
                this._isClosed = true;
            }
        });
    }
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
     */
    _isReceivingMessages() {
        return this._messageSession ? this._messageSession.isReceivingMessages : false;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 */
function createMessageSpan(parentSpan, config) {
    const tracer = coreTracing.getTracer();
    const span = tracer.startSpan("Azure.ServiceBus.message", {
        kind: api.SpanKind.PRODUCER,
        parent: parentSpan
    });
    span.setAttribute("az.namespace", "Microsoft.ServiceBus");
    if (config) {
        span.setAttribute("message_bus.destination", config.entityPath);
        span.setAttribute("peer.address", config.host);
    }
    return span;
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * The amount of bytes to reserve as overhead for a small message.
 */
const smallMessageOverhead = 5;
/**
 * @internal
 * @hidden
 * The amount of bytes to reserve as overhead for a large message.
 */
const largeMessageOverhead = 8;
/**
 * @internal
 * @hidden
 * The maximum number of bytes that a message may be to be considered small.
 */
const smallMessageMaxBytes = 255;
/**
 * An internal class representing a batch of messages which can be used to send messages to Service Bus.
 *
 * @class
 * @internal
 * @hidden
 */
class ServiceBusMessageBatchImpl {
    /**
     * ServiceBusMessageBatch should not be constructed using `new ServiceBusMessageBatch()`
     * Use the `createBatch()` method on your `Sender` instead.
     * @constructor
     * @internal
     * @hidden
     */
    constructor(_context, _maxSizeInBytes) {
        this._context = _context;
        this._maxSizeInBytes = _maxSizeInBytes;
        /**
         * @property Encoded amqp messages.
         */
        this._encodedMessages = [];
        /**
         * List of 'message' span contexts.
         */
        this._spanContexts = [];
        this._sizeInBytes = 0;
        this._batchMessageProperties = {};
    }
    /**
     * @property The maximum size of the batch, in bytes.
     * @readonly
     */
    get maxSizeInBytes() {
        return this._maxSizeInBytes;
    }
    /**
     * @property Size of the `ServiceBusMessageBatch` instance after the messages added to it have been
     * encoded into a single AMQP message.
     * @readonly
     */
    get sizeInBytes() {
        return this._sizeInBytes;
    }
    /**
     * @property Number of messages in the `ServiceBusMessageBatch` instance.
     * @readonly
     */
    get count() {
        return this._encodedMessages.length;
    }
    /**
     * Gets the "message" span contexts that were created when adding messages to the batch.
     * @internal
     * @hidden
     */
    get _messageSpanContexts() {
        return this._spanContexts;
    }
    /**
     * Generates an AMQP message that contains the provided encoded messages and annotations.
     *
     * @private
     * @param {Buffer[]} encodedMessages The already encoded messages to include in the AMQP batch.
     * @param {MessageAnnotations} [annotations] The message annotations to set on the batch.
     * @param {{ [key: string]: any }} [applicationProperties] The application properties to set on the batch.
     * @param {{ [key: string]: string }} [messageProperties] The message properties to set on the batch.
     * @returns {Buffer}
     * @memberof ServiceBusMessageBatchImpl
     */
    _generateBatch(encodedMessages, annotations, applicationProperties, messageProperties) {
        const batchEnvelope = {
            body: rheaPromise.message.data_sections(encodedMessages),
            message_annotations: annotations,
            application_properties: applicationProperties
        };
        if (messageProperties) {
            for (const prop of rheaPromise.messageProperties) {
                if (messageProperties[prop]) {
                    batchEnvelope[prop] = messageProperties[prop];
                }
            }
        }
        return rheaPromise.message.encode(batchEnvelope);
    }
    /**
     * @property Represents the single AMQP message which is the result of encoding all the events
     * added into the `ServiceBusMessageBatch` instance.
     *
     * This is not meant for the user to use directly.
     *
     * When the `ServiceBusMessageBatch` instance is passed to the `sendBatch()` method on the `Sender`,
     * this single batched AMQP message is what gets sent over the wire to the service.
     * @readonly
     */
    _generateMessage() {
        return this._generateBatch(this._encodedMessages, this._batchAnnotations, this._batchApplicationProperties, this._batchMessageProperties);
    }
    /**
     * Tries to add a message to the batch if permitted by the batch's size limit.
     * **NOTE**: Always remember to check the return value of this method, before calling it again
     * for the next message.
     *
     * @param message  An individual service bus message.
     * @returns A boolean value indicating if the message has been added to the batch or not.
     */
    tryAddMessage(message, options = {}) {
        throwTypeErrorIfParameterMissing(this._context.connectionId, "message", message);
        throwIfNotValidServiceBusMessage(message, "Provided value for 'message' must be of type ServiceBusMessage.");
        // check if the event has already been instrumented
        const previouslyInstrumented = Boolean(message.applicationProperties && message.applicationProperties[TRACEPARENT_PROPERTY]);
        let spanContext;
        if (!previouslyInstrumented) {
            const messageSpan = createMessageSpan(options === null || options === void 0 ? void 0 : options.parentSpan, this._context.config);
            message = instrumentServiceBusMessage(message, messageSpan);
            spanContext = messageSpan.context();
            messageSpan.end();
        }
        // Convert ServiceBusMessage to AmqpMessage.
        const amqpMessage = toRheaMessage(message);
        amqpMessage.body = defaultDataTransformer.encode(message.body);
        let encodedMessage;
        try {
            encodedMessage = rheaPromise.message.encode(amqpMessage);
        }
        catch (error) {
            if (error instanceof TypeError || error.name === "TypeError") {
                throw getMessagePropertyTypeMismatchError(message) || error;
            }
            throw error;
        }
        let currentSize = this._sizeInBytes;
        // The first time an event is added, we need to calculate
        // the overhead of creating an AMQP batch, including the
        // message_annotations, application_properties and message_properties
        // that are taken from the 1st message.
        if (this.count === 0) {
            if (amqpMessage.message_annotations) {
                this._batchAnnotations = amqpMessage.message_annotations;
            }
            if (amqpMessage.application_properties) {
                this._batchApplicationProperties = amqpMessage.application_properties;
            }
            for (const prop of rheaPromise.messageProperties) {
                if (amqpMessage[prop]) {
                    this._batchMessageProperties[prop] = amqpMessage[prop];
                }
            }
            // Figure out the overhead of creating a batch by generating an empty batch
            // with the expected batch annotations.
            currentSize += this._generateBatch([], this._batchAnnotations, this._batchApplicationProperties, this._batchMessageProperties).length;
        }
        const messageSize = encodedMessage.length;
        const messageOverhead = messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;
        currentSize += messageSize + messageOverhead;
        // Check if the size of the batch exceeds the maximum allowed size
        // once we add the new event to it.
        if (currentSize > this._maxSizeInBytes) {
            return false;
        }
        // The message will fit in the batch, so it is now safe to store it.
        this._encodedMessages.push(encodedMessage);
        if (spanContext) {
            this._spanContexts.push(spanContext);
        }
        this._sizeInBytes = currentSize;
        return true;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Describes the MessageSender that will send messages to ServiceBus.
 * @class MessageSender
 */
class MessageSender extends LinkEntity {
    constructor(context, entityPath, retryOptions) {
        super(entityPath, entityPath, context, "sender", senderLogger, {
            address: entityPath,
            audience: `${context.config.endpoint}${entityPath}`
        });
        this._retryOptions = retryOptions;
        this._onAmqpError = (context) => {
            const senderError = context.sender && context.sender.error;
            senderLogger.logError(senderError, "%s 'sender_error' event occurred on the sender '%s' with address '%s'. " +
                "The associated error", this.logPrefix, this.name, this.address);
            // TODO: Consider rejecting promise in trySendBatch() or createBatch()
        };
        this._onSessionError = (context) => {
            const sessionError = context.session && context.session.error;
            senderLogger.logError(sessionError, "%s 'session_error' event occurred on the session of sender '%s' with address '%s'. " +
                "The associated error", this.logPrefix, this.name, this.address);
            // TODO: Consider rejecting promise in trySendBatch() or createBatch()
        };
        this._onAmqpClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const senderError = context.sender && context.sender.error;
            senderLogger.logError(senderError, `${this.logPrefix} 'sender_close' event occurred. The associated error is`);
            yield this.onDetached().catch((err) => {
                senderLogger.logError(err, `${this.logPrefix} error when closing sender after 'sender_close' event`);
            });
        });
        this._onSessionClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const sessionError = context.session && context.session.error;
            senderLogger.logError(sessionError, `${this.logPrefix} 'session_close' event occurred. The associated error is`);
            yield this.onDetached().catch((err) => {
                senderLogger.logError(err, `${this.logPrefix} error when closing sender after 'session_close' event`);
            });
        });
    }
    _createSenderOptions(timeoutInMs, newName) {
        if (newName)
            this.name = getUniqueName(this.baseName);
        const srOptions = {
            name: this.name,
            target: {
                address: this.address
            },
            onError: this._onAmqpError,
            onClose: this._onAmqpClose,
            onSessionError: this._onSessionError,
            onSessionClose: this._onSessionClose,
            sendTimeoutInSeconds: timeoutInMs / 1000
        };
        senderLogger.verbose(`${this.logPrefix} Creating sender with options: %O`, srOptions);
        return srOptions;
    }
    /**
     * Tries to send the message to ServiceBus if there is enough credit to send them
     * and the circular buffer has available space to settle the message after sending them.
     *
     * We have implemented a synchronous send over here in the sense that we shall be waiting
     * for the message to be accepted or rejected and accordingly resolve or reject the promise.
     *
     * @param encodedMessage The encoded message to be sent to ServiceBus.
     * @param sendBatch Boolean indicating whether the encoded message represents a batch of messages or not
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    _trySend(encodedMessage, sendBatch, options) {
        const abortSignal = options === null || options === void 0 ? void 0 : options.abortSignal;
        const timeoutInMs = this._retryOptions.timeoutInMs == undefined
            ? coreAmqp.Constants.defaultOperationTimeoutInMs
            : this._retryOptions.timeoutInMs;
        const sendEventPromise = () => new Promise((resolve, reject) => tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const initStartTime = Date.now();
            if (!this.isOpen()) {
                try {
                    yield waitForTimeoutOrAbortOrResolve({
                        actionFn: () => this.open(undefined, options === null || options === void 0 ? void 0 : options.abortSignal),
                        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
                        timeoutMs: timeoutInMs,
                        timeoutMessage: `[${this._context.connectionId}] Sender "${this.name}" ` +
                            `with address "${this.address}", was not able to send the message right now, due ` +
                            `to operation timeout.`
                    });
                }
                catch (err) {
                    err = translateServiceBusError(err);
                    senderLogger.logError(err, "%s An error occurred while creating the sender", this.logPrefix, this.name);
                    return reject(err);
                }
            }
            try {
                const timeTakenByInit = Date.now() - initStartTime;
                senderLogger.verbose("%s Sender '%s', credit: %d available: %d", this.logPrefix, this.name, (_a = this.link) === null || _a === void 0 ? void 0 : _a.credit, (_d = (_c = (_b = this.link) === null || _b === void 0 ? void 0 : _b.session) === null || _c === void 0 ? void 0 : _c.outgoing) === null || _d === void 0 ? void 0 : _d.available());
                if (!((_e = this.link) === null || _e === void 0 ? void 0 : _e.sendable())) {
                    senderLogger.verbose("%s Sender '%s', waiting for 1 second for sender to become sendable", this.logPrefix, this.name);
                    yield coreAmqp.delay(1000);
                    senderLogger.verbose("%s Sender '%s' after waiting for a second, credit: %d available: %d", this.logPrefix, this.name, (_f = this.link) === null || _f === void 0 ? void 0 : _f.credit, (_j = (_h = (_g = this.link) === null || _g === void 0 ? void 0 : _g.session) === null || _h === void 0 ? void 0 : _h.outgoing) === null || _j === void 0 ? void 0 : _j.available());
                }
                if ((_k = this.link) === null || _k === void 0 ? void 0 : _k.sendable()) {
                    if (timeoutInMs <= timeTakenByInit) {
                        const desc = `${this.logPrefix} Sender "${this.name}" ` +
                            `with address "${this.address}", was not able to send the message right now, due ` +
                            `to operation timeout.`;
                        senderLogger.warning(desc);
                        const e = {
                            condition: coreAmqp.ErrorNameConditionMapper.ServiceUnavailableError,
                            description: desc
                        };
                        return reject(translateServiceBusError(e));
                    }
                    try {
                        this.link.sendTimeoutInSeconds = (timeoutInMs - timeTakenByInit) / 1000;
                        const delivery = yield this.link.send(encodedMessage, undefined, sendBatch ? 0x80013700 : 0);
                        senderLogger.verbose("%s Sender '%s', sent message with delivery id: %d", this.logPrefix, this.name, delivery.id);
                        return resolve();
                    }
                    catch (error) {
                        error = translateServiceBusError(error.innerError || error);
                        senderLogger.logError(error, `${this.logPrefix} An error occurred while sending the message`);
                        return reject(error);
                    }
                }
                else {
                    // let us retry to send the message after some time.
                    const msg = `[${this.logPrefix}] Sender "${this.name}", ` +
                        `cannot send the message right now. Please try later.`;
                    senderLogger.warning(msg);
                    const amqpError = {
                        condition: coreAmqp.ErrorNameConditionMapper.SenderBusyError,
                        description: msg
                    };
                    reject(translateServiceBusError(amqpError));
                }
            }
            catch (err) {
                reject(err);
            }
        }));
        const config = {
            operation: sendEventPromise,
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.sendMessage,
            retryOptions: this._retryOptions,
            abortSignal: abortSignal
        };
        return coreAmqp.retry(config);
    }
    createRheaLink(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const sender = yield this._context.connection.createAwaitableSender(options);
            sender.setMaxListeners(1000);
            return sender;
        });
    }
    /**
     * Initializes the sender session on the connection.
     */
    open(options, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!options) {
                    options = this._createSenderOptions(coreAmqp.Constants.defaultOperationTimeoutInMs);
                }
                yield this.initLink(options, abortSignal);
            }
            catch (err) {
                err = translateServiceBusError(err);
                senderLogger.logError(err, `${this.logPrefix} An error occurred while creating the sender`);
                // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.
                if (err.code === "OperationTimeoutError") {
                    err.message = "Failed to create a sender within allocated time and retry attempts.";
                }
                throw err;
            }
        });
    }
    /**
     * Closes the rhea link.
     * To be called when connection is disconnected, onAmqpClose and onSessionClose events.
     * @returns {Promise<void>} Promise<void>.
     */
    onDetached() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Clears the token renewal timer. Closes the link and its session if they are open.
            // Removes the link and its session if they are present in rhea's cache.
            yield this.closeLink();
        });
    }
    /**
     * Determines whether the AMQP sender link is open. If open then returns true else returns false.
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this.link == null ? false : this.link.isOpen();
        senderLogger.verbose("%s Sender '%s' with address '%s' is open? -> %s", this.logPrefix, this.name, this.address, result);
        return result;
    }
    /**
     * Sends the given message, with the given options on this link
     *
     * @param {ServiceBusMessage} data Message to send.  Will be sent as UTF8-encoded JSON string.
     * @returns {Promise<void>}
     */
    send(data, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                const amqpMessage = toRheaMessage(data);
                amqpMessage.body = defaultDataTransformer.encode(data.body);
                // TODO: this body of logic is really similar to what's in sendMessages. Unify what we can.
                let encodedMessage;
                try {
                    encodedMessage = rheaPromise.message.encode(amqpMessage);
                }
                catch (error) {
                    if (error instanceof TypeError || error.name === "TypeError") {
                        // `RheaMessageUtil.encode` can fail if message properties are of invalid type
                        // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too
                        // Errors in such cases do not have user-friendly message or call stack
                        // So use `getMessagePropertyTypeMismatchError` to get a better error message
                        throw getMessagePropertyTypeMismatchError(data) || error;
                    }
                    throw error;
                }
                senderLogger.verbose("%s Sender '%s', trying to send message: %O", this.logPrefix, this.name, data);
                return yield this._trySend(encodedMessage, false, options);
            }
            catch (err) {
                senderLogger.logError(err, "%s An error occurred while sending the message: %O\nError", this.logPrefix, data);
                throw err;
            }
        });
    }
    // Not exposed to the users
    /**
     * Send a batch of Message to the ServiceBus in a single AMQP message. The "message_annotations",
     * "application_properties" and "properties" of the first message will be set as that
     * of the envelope (batch message).
     * @param {Array<Message>} inputMessages  An array of Message objects to be sent in a
     * Batch message.
     * @return {Promise<void>}
     */
    sendMessages(inputMessages, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                if (!Array.isArray(inputMessages)) {
                    inputMessages = [inputMessages];
                }
                senderLogger.verbose("%s Sender '%s', trying to send Message[]: %O", this.logPrefix, this.name, inputMessages);
                const amqpMessages = [];
                const encodedMessages = [];
                // Convert Message to AmqpMessage.
                for (let i = 0; i < inputMessages.length; i++) {
                    const amqpMessage = toRheaMessage(inputMessages[i]);
                    amqpMessage.body = defaultDataTransformer.encode(inputMessages[i].body);
                    amqpMessages[i] = amqpMessage;
                    try {
                        encodedMessages[i] = rheaPromise.message.encode(amqpMessage);
                    }
                    catch (error) {
                        if (error instanceof TypeError || error.name === "TypeError") {
                            throw getMessagePropertyTypeMismatchError(inputMessages[i]) || error;
                        }
                        throw error;
                    }
                }
                // Convert every encoded message to amqp data section
                const batchMessage = {
                    body: rheaPromise.message.data_sections(encodedMessages)
                };
                // Set message_annotations, application_properties and properties of the first message as
                // that of the envelope (batch message).
                if (amqpMessages[0].message_annotations) {
                    batchMessage.message_annotations = amqpMessages[0].message_annotations;
                }
                if (amqpMessages[0].application_properties) {
                    batchMessage.application_properties = amqpMessages[0].application_properties;
                }
                for (const prop of rheaPromise.messageProperties) {
                    if (amqpMessages[0][prop]) {
                        batchMessage[prop] = amqpMessages[0][prop];
                    }
                }
                // Finally encode the envelope (batch message).
                const encodedBatchMessage = rheaPromise.message.encode(batchMessage);
                senderLogger.verbose("%s Sender '%s', sending encoded batch message.", this.logPrefix, this.name, encodedBatchMessage);
                return yield this._trySend(encodedBatchMessage, true, options);
            }
            catch (err) {
                senderLogger.logError(err, "%s Sender '%s': An error occurred while sending the messages: %O\nError", this.logPrefix, this.name, inputMessages);
                throw err;
            }
        });
    }
    /**
     * Returns maximum message size on the AMQP sender link.
     *
     * Options to configure the `createBatch` method on the `Sender`.
     * - `maxSizeInBytes`: The upper limit for the size of batch.
     *
     * Example usage:
     * ```js
     * {
     *     retryOptions: { maxRetries: 5; timeoutInMs: 10 }
     * }
     * ```
     * @param {{retryOptions?: RetryOptions}} [options={}]
     * @returns {Promise<number>}
     */
    getMaxMessageSize(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const retryOptions = options.retryOptions || {};
            if (this.isOpen()) {
                return this.link.maxMessageSize;
            }
            return new Promise((resolve, reject) => tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    const config = {
                        operation: () => this.open(undefined, options === null || options === void 0 ? void 0 : options.abortSignal),
                        connectionId: this._context.connectionId,
                        operationType: coreAmqp.RetryOperationType.senderLink,
                        retryOptions: retryOptions,
                        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
                    };
                    yield coreAmqp.retry(config);
                    return resolve(this.link.maxMessageSize);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    createBatch(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            let maxMessageSize = yield this.getMaxMessageSize({
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            });
            if (options === null || options === void 0 ? void 0 : options.maxSizeInBytes) {
                if (options.maxSizeInBytes > maxMessageSize) {
                    const error = new Error(`Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`);
                    throw error;
                }
                maxMessageSize = options.maxSizeInBytes;
            }
            return new ServiceBusMessageBatchImpl(this._context, maxMessageSize);
        });
    }
    sendBatch(batchMessage, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            try {
                senderLogger.verbose("%s Sender '%s', sending encoded batch message.", this.logPrefix, this.name, batchMessage);
                return yield this._trySend(batchMessage._generateMessage(), true, options);
            }
            catch (err) {
                senderLogger.logError(err, "%s Sender '%s': An error occurred while sending the messages: %O\nError", this.logPrefix, this.name, batchMessage);
                throw err;
            }
        });
    }
    static create(context, entityPath, retryOptions) {
        throwErrorIfConnectionClosed(context);
        const sbSender = new MessageSender(context, entityPath, retryOptions);
        context.senders[sbSender.name] = sbSender;
        return sbSender;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * @class ServiceBusSenderImpl
 * @implements {ServiceBusSender}
 */
class ServiceBusSenderImpl {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     */
    constructor(_context, _entityPath, retryOptions = {}) {
        this._context = _context;
        this._entityPath = _entityPath;
        /**
         * @property Denotes if close() was called on this sender
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(_context);
        this.entityPath = _entityPath;
        this._sender = MessageSender.create(this._context, _entityPath, retryOptions);
        this._retryOptions = retryOptions;
    }
    get logPrefix() {
        return `[${this._context.connectionId}|sender:${this.entityPath}]`;
    }
    _throwIfSenderOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (this.isClosed) {
            const errorMessage = getSenderClosedErrorMsg(this._entityPath);
            const error = new Error(errorMessage);
            senderLogger.logError(error, `[${this._context.connectionId}] is closed`);
            throw error;
        }
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    sendMessages(messages, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "messages", messages);
            const invalidTypeErrMsg = "Provided value for 'messages' must be of type ServiceBusMessage, ServiceBusMessageBatch or an array of type ServiceBusMessage.";
            let batch;
            if (isServiceBusMessageBatch(messages)) {
                batch = messages;
            }
            else {
                if (!Array.isArray(messages)) {
                    messages = [messages];
                }
                batch = yield this.createMessageBatch(options);
                for (const message of messages) {
                    throwIfNotValidServiceBusMessage(message, invalidTypeErrMsg);
                    if (!batch.tryAddMessage(message, { parentSpan: getParentSpan(options === null || options === void 0 ? void 0 : options.tracingOptions) })) {
                        // this is too big - throw an error
                        throw new ServiceBusError("Messages were too big to fit in a single batch. Remove some messages and try again or create your own batch using createBatch(), which gives more fine-grained control.", "MessageSizeExceeded");
                    }
                }
            }
            const sendSpan = createSendSpan(getParentSpan(options === null || options === void 0 ? void 0 : options.tracingOptions), batch._messageSpanContexts, this.entityPath, this._context.config.host);
            try {
                const result = yield this._sender.sendBatch(batch, options);
                sendSpan.setStatus({ code: api.CanonicalCode.OK });
                return result;
            }
            catch (error) {
                sendSpan.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: error.message
                });
                throw error;
            }
            finally {
                sendSpan.end();
            }
        });
    }
    createMessageBatch(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            return this._sender.createBatch(options);
        });
    }
    scheduleMessages(messages, scheduledEnqueueTimeUtc, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "scheduledEnqueueTimeUtc", scheduledEnqueueTimeUtc);
            throwTypeErrorIfParameterMissing(this._context.connectionId, "messages", messages);
            const messagesToSchedule = Array.isArray(messages) ? messages : [messages];
            for (const message of messagesToSchedule) {
                throwIfNotValidServiceBusMessage(message, "Provided value for 'messages' must be of type ServiceBusMessage or an array of type ServiceBusMessage.");
            }
            const scheduleMessageOperationPromise = () => tslib.__awaiter(this, void 0, void 0, function* () {
                return this._context
                    .getManagementClient(this._entityPath)
                    .scheduleMessages(scheduledEnqueueTimeUtc, messagesToSchedule, Object.assign(Object.assign({}, options), { associatedLinkName: this._sender.name, requestName: "scheduleMessages", timeoutInMs: this._retryOptions.timeoutInMs }));
            });
            const config = {
                operation: scheduleMessageOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return coreAmqp.retry(config);
        });
    }
    cancelScheduledMessages(sequenceNumbers, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
            throwTypeErrorIfParameterNotLong(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
            const sequenceNumbersToCancel = Array.isArray(sequenceNumbers)
                ? sequenceNumbers
                : [sequenceNumbers];
            const cancelSchedulesMessagesOperationPromise = () => tslib.__awaiter(this, void 0, void 0, function* () {
                return this._context.getManagementClient(this._entityPath).cancelScheduledMessages(sequenceNumbersToCancel, Object.assign(Object.assign({}, options), { associatedLinkName: this._sender.name, requestName: "cancelScheduledMessages", timeoutInMs: this._retryOptions.timeoutInMs }));
            });
            const config = {
                operation: cancelSchedulesMessagesOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return coreAmqp.retry(config);
        });
    }
    // async open(options?: OperationOptionsBase): Promise<void> {
    //   this._throwIfSenderOrConnectionClosed();
    //   const config: RetryConfig<void> = {
    //     // TODO: Pass tracing options too
    //     operation: () => this._sender.open(undefined, options?.abortSignal),
    //     connectionId: this._context.connectionId,
    //     operationType: RetryOperationType.senderLink,
    //     retryOptions: this._retryOptions,
    //     abortSignal: options?.abortSignal
    //   };
    //   return retry<void>(config);
    // }
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                this._isClosed = true;
                yield this._sender.close();
            }
            catch (err) {
                senderLogger.logError(err, `${this.logPrefix} An error occurred while closing the Sender`);
                throw err;
            }
        });
    }
}
/**
 * @internal
 * @hidden
 */
function isServiceBusMessageBatch(messageBatchOrAnything) {
    if (messageBatchOrAnything == null) {
        return false;
    }
    const possibleBatch = messageBatchOrAnything;
    return (typeof possibleBatch.tryAddMessage === "function" &&
        typeof possibleBatch.maxSizeInBytes === "number" &&
        typeof possibleBatch.sizeInBytes === "number");
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @hidden
 * Describes the receiver for a Message Session.
 */
class MessageSession extends LinkEntity {
    /**
     * Constructs a MessageSession instance which lets you receive messages as batches
     * or via callbacks using subscribe.
     *
     * @param _providedSessionId The sessionId provided by the user. This can be the
     * name of a session ID to open (empty string is also valid) or it can be undefined,
     * to indicate we want the next unlocked non-empty session.
     */
    constructor(context, entityPath, _providedSessionId, options) {
        super(entityPath, entityPath, context, "session", receiverLogger, {
            address: entityPath,
            audience: `${context.config.endpoint}${entityPath}`
        });
        this._providedSessionId = _providedSessionId;
        /**
         * @property {number} [maxConcurrentCalls] The maximum number of messages that should be
         * processed concurrently in a session while in streaming mode. Once this limit has been reached,
         * more messages will not be received until the user's message handler has completed processing current message.
         * - **Default**: `1` (message in a session at a time).
         */
        this.maxConcurrentCalls = 1;
        /**
         * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that
         * are being actively disposed. It acts as a store for correlating the responses received for
         * active dispositions.
         */
        this._deliveryDispositionMap = new Map();
        this._receiverHelper = new ReceiverHelper(() => ({
            receiver: this.link,
            logPrefix: this.logPrefix
        }));
        if (!options)
            options = {};
        this.autoComplete = false;
        if (this._providedSessionId != undefined)
            this.sessionId = this._providedSessionId;
        this.receiveMode = options.receiveMode || "peekLock";
        this.maxAutoRenewDurationInMs =
            options.maxAutoLockRenewalDurationInMs != null
                ? options.maxAutoLockRenewalDurationInMs
                : 300 * 1000;
        this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;
        this.autoRenewLock = this.maxAutoRenewDurationInMs > 0 && this.receiveMode === "peekLock";
        this._isReceivingMessagesForSubscriber = false;
        this._batchingReceiverLite = new BatchingReceiverLite(context, entityPath, (_abortSignal) => tslib.__awaiter(this, void 0, void 0, function* () {
            return this.link;
        }), this.receiveMode);
        // setting all the handlers
        this._onSettled = (context) => {
            const delivery = context.delivery;
            onMessageSettled(this.logPrefix, delivery, this._deliveryDispositionMap);
        };
        this._notifyError = (args) => {
            if (this._onError) {
                this._onError(args);
                receiverLogger.verbose("%s Notified the user's error handler about the error received by the Receiver", this.logPrefix);
            }
        };
        this._onAmqpError = (context) => {
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const sbError = translateServiceBusError(receiverError);
                if (sbError.code === "SessionLockLostError") {
                    sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;
                }
                receiverLogger.logError(sbError, "%s An error occurred for Receiver", this.logPrefix);
                this._notifyError({
                    error: sbError,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host
                });
            }
        };
        this._onSessionError = (context) => {
            const connectionId = this._context.connectionId;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = translateServiceBusError(sessionError);
                receiverLogger.logError(sbError, "[%s] An error occurred on the session for Receiver '%s': %O.", connectionId, this.name, sbError);
                this._notifyError({
                    error: sbError,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host
                });
            }
        };
        this._onAmqpClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.connectionId;
            const receiverError = context.receiver && context.receiver.error;
            const receiver = this.link || context.receiver;
            if (receiverError) {
                const sbError = translateServiceBusError(receiverError);
                receiverLogger.logError(sbError, "[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.sessionId, sbError);
                // no need to notify the user's error handler since rhea guarantees that receiver_error
                // will always be emitted before receiver_close.
            }
            if (receiver && !receiver.isItselfClosed()) {
                receiverLogger.verbose("%s 'receiver_close' event occurred on the receiver for sessionId '%s' " +
                    "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", this.logPrefix, this.sessionId);
                try {
                    yield this.close();
                }
                catch (err) {
                    receiverLogger.logError(err, "%s An error occurred while closing the receiver for sessionId '%s'.", this.logPrefix, this.sessionId);
                }
            }
            else {
                receiverLogger.verbose("%s 'receiver_close' event occurred on the receiver for sessionId '%s' " +
                    "because the sdk initiated it. Hence no need to gracefully close the receiver", this.logPrefix, this.sessionId);
            }
        });
        this._onSessionClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const receiver = this.link || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = translateServiceBusError(sessionError);
                receiverLogger.logError(sbError, "%s 'session_close' event occurred for receiver for sessionId '%s'. " +
                    "The associated error is", this.logPrefix, this.sessionId);
                // no need to notify the user's error handler since rhea guarantees that session_error
                // will always be emitted before session_close.
            }
            if (receiver && !receiver.isSessionItselfClosed()) {
                receiverLogger.verbose("%s 'session_close' event occurred on the receiver for sessionId '%s' " +
                    "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", this.logPrefix, this.sessionId);
                try {
                    yield this.close();
                }
                catch (err) {
                    receiverLogger.logError(err, "%s An error occurred while closing the receiver for sessionId '%s'", this.logPrefix, this.sessionId);
                }
            }
            else {
                receiverLogger.verbose("%s 'session_close' event occurred on the receiver for sessionId'%s' " +
                    "because the sdk initiated it. Hence no need to gracefully close the receiver", this.logPrefix, this.sessionId);
            }
        });
    }
    /**
     * Denotes if we are currently receiving messages
     */
    get isReceivingMessages() {
        return this._batchingReceiverLite.isReceivingMessages || this._isReceivingMessagesForSubscriber;
    }
    get receiverHelper() {
        return this._receiverHelper;
    }
    /**
     * Ensures that the session lock is renewed before it expires. The lock will not be renewed for
     * more than the configured totalAutoLockRenewDuration.
     */
    _ensureSessionLockRenewal() {
        if (this.autoRenewLock &&
            new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc &&
            Date.now() < this._totalAutoLockRenewDuration &&
            this.isOpen()) {
            const nextRenewalTimeout = calculateRenewAfterDuration(this.sessionLockedUntilUtc);
            this._sessionLockRenewalTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    receiverLogger.verbose("%s Attempting to renew the session lock for MessageSession '%s' " + "with name '%s'.", this.logPrefix, this.sessionId, this.name);
                    this.sessionLockedUntilUtc = yield this._context
                        .getManagementClient(this.entityPath)
                        .renewSessionLock(this.sessionId, {
                        associatedLinkName: this.name,
                        timeoutInMs: 10000
                    });
                    receiverLogger.verbose("%s Successfully renewed the session lock for MessageSession '%s' " + "with name '%s'.", this.logPrefix, this.sessionId, this.name);
                    receiverLogger.verbose("%s Calling _ensureSessionLockRenewal() again for MessageSession '%s'.", this.logPrefix, this.sessionId);
                    this._ensureSessionLockRenewal();
                }
                catch (err) {
                    receiverLogger.logError(err, "%s An error occurred while renewing the session lock for MessageSession '%s'", this.logPrefix, this.sessionId);
                }
            }), nextRenewalTimeout);
            receiverLogger.verbose("%s MessageSession '%s' has next session lock renewal in %d milliseconds @(%s).", this.logPrefix, this.sessionId, nextRenewalTimeout, new Date(Date.now() + nextRenewalTimeout).toString());
        }
    }
    createRheaLink(options, _abortSignal) {
        return this._context.connection.createReceiver(options);
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     */
    _init(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const options = this._createMessageSessionOptions();
                yield this.initLink(options, abortSignal);
                if (this.link == null) {
                    throw new Error("INTERNAL ERROR: failed to create receiver but without an error.");
                }
                const receivedSessionId = this.link.source &&
                    this.link.source.filter &&
                    this.link.source.filter[coreAmqp.Constants.sessionFilterName];
                let errorMessage = "";
                if (this._providedSessionId == null && receivedSessionId == null) {
                    // Ideally this code path should never be reached as `MessageSession.createReceiver()` should fail instead
                    // TODO: https://github.com/Azure/azure-sdk-for-js/issues/9775 to figure out why this code path indeed gets hit.
                    errorMessage = `Failed to create a receiver. No unlocked sessions available.`;
                }
                else if (this._providedSessionId != null && receivedSessionId !== this._providedSessionId) {
                    // This code path is reached if the session is already locked by another receiver.
                    // TODO: Check why the service would not throw an error or just timeout instead of giving a misleading successful receiver
                    errorMessage = `Failed to create a receiver for the requested session '${this._providedSessionId}'. It may be locked by another receiver.`;
                }
                if (errorMessage) {
                    const error = translateServiceBusError({
                        description: errorMessage,
                        condition: coreAmqp.ErrorNameConditionMapper.SessionCannotBeLockedError
                    });
                    receiverLogger.logError(error, this.logPrefix);
                    throw error;
                }
                if (this._providedSessionId == null)
                    this.sessionId = receivedSessionId;
                this.sessionLockedUntilUtc = convertTicksToDate(this.link.properties["com.microsoft:locked-until-utc"]);
                receiverLogger.verbose("%s Session with id '%s' is locked until: '%s'.", this.logPrefix, this.sessionId, this.sessionLockedUntilUtc.toISOString());
                receiverLogger.verbose("%s Receiver created with receiver options: %O", this.logPrefix, options);
                if (!this._context.messageSessions[this.name]) {
                    this._context.messageSessions[this.name] = this;
                }
                this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;
                this._ensureSessionLockRenewal();
            }
            catch (err) {
                const errObj = translateServiceBusError(err);
                receiverLogger.logError(errObj, "%s An error occured while creating the receiver", this.logPrefix);
                // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.
                if (errObj.code === "OperationTimeoutError") {
                    if (this._providedSessionId) {
                        errObj.message = `Failed to create a receiver for the requested session '${this._providedSessionId}' within allocated time and retry attempts.`;
                    }
                    else {
                        errObj.message = "Failed to create a receiver within allocated time and retry attempts.";
                    }
                }
                throw errObj;
            }
        });
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */
    _createMessageSessionOptions() {
        const rcvrOptions = createReceiverOptions(this.name, this.receiveMode, {
            address: this.address,
            filter: { [coreAmqp.Constants.sessionFilterName]: this.sessionId }
        }, {
            onClose: (context) => this._onAmqpClose(context).catch(() => {
                /* */
            }),
            onSessionClose: (context) => this._onSessionClose(context).catch(() => {
                /* */
            }),
            onError: this._onAmqpError,
            onSessionError: this._onSessionError,
            onSettled: this._onSettled
        });
        return rcvrOptions;
    }
    /**
     * Closes the underlying AMQP receiver link.
     */
    close() {
        const _super = Object.create(null, {
            close: { get: () => super.close }
        });
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                this._isReceivingMessagesForSubscriber = false;
                if (this._sessionLockRenewalTimer)
                    clearTimeout(this._sessionLockRenewalTimer);
                receiverLogger.verbose("%s Cleared the timers for 'no new message received' task and " +
                    "'session lock renewal' task.", this.logPrefix);
                yield _super.close.call(this);
                yield this._batchingReceiverLite.close();
            }
            catch (err) {
                receiverLogger.logError(err, "%s An error occurred while closing the message session with id '%s'", this.logPrefix, this.sessionId);
            }
        });
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     */
    isOpen() {
        const result = this.link && this.link.isOpen();
        receiverLogger.verbose("%s Receiver for sessionId '%s' is open? -> %s", this.logPrefix, this.sessionId, result);
        return result;
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver or set the property
     * `newMessageWaitTimeoutInMs` in the options to provide a timeout.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed. You can
     * also provide a timeout in milliseconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     *
     * @returns void
     */
    subscribe(onMessage, onError, options) {
        var _a;
        if (!options)
            options = {};
        if ((_a = options.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {
            throw new abortController.AbortError(StandardAbortMessage);
        }
        this._isReceivingMessagesForSubscriber = true;
        if (typeof options.maxConcurrentCalls === "number" && options.maxConcurrentCalls > 0) {
            this.maxConcurrentCalls = options.maxConcurrentCalls;
        }
        // If explicitly set to false then autoComplete is false else true (default).
        this.autoComplete =
            options.autoCompleteMessages === false ? options.autoCompleteMessages : true;
        this._onMessage = onMessage;
        this._onError = onError;
        if (this.link && this.link.isOpen()) {
            const onSessionMessage = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                // If the receiver got closed in PeekLock mode, avoid processing the message as we
                // cannot settle the message.
                if (this.receiveMode === "peekLock" && (!this.link || !this.link.isOpen())) {
                    receiverLogger.verbose("%s Not calling the user's message handler for the current message " +
                        "as the receiver is closed", this.logPrefix);
                    return;
                }
                const bMessage = new ServiceBusMessageImpl(context.message, context.delivery, true, this.receiveMode);
                try {
                    yield this._onMessage(bMessage);
                }
                catch (err) {
                    receiverLogger.logError(err, "%s An error occurred while running user's message handler for the message " +
                        "with id '%s' on the receiver", this.logPrefix, bMessage.messageId);
                    this._onError({
                        error: err,
                        errorSource: "processMessageCallback",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host
                    });
                    const error = translateServiceBusError(err);
                    // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                    if (!bMessage.delivery.remote_settled &&
                        this.receiveMode === "peekLock" &&
                        this.isOpen() // only try to abandon the messages if the connection is still open
                    ) {
                        try {
                            receiverLogger.logError(error, "%s Abandoning the message with id '%s' on the receiver since an error occured", this.logPrefix, bMessage.messageId);
                            yield abandonMessage(bMessage, this._context, this.entityPath);
                        }
                        catch (abandonError) {
                            const translatedError = translateServiceBusError(abandonError);
                            receiverLogger.logError(translatedError, "%s An error occurred while abandoning the message with id '%s' on the " +
                                "receiver", this.logPrefix, bMessage.messageId, translatedError);
                            this._notifyError({
                                error: translatedError,
                                errorSource: "abandon",
                                entityPath: this.entityPath,
                                fullyQualifiedNamespace: this._context.config.host
                            });
                        }
                    }
                    return;
                }
                finally {
                    this.receiverHelper.addCredit(1);
                }
                // If we've made it this far, then user's message handler completed fine. Let us try
                // completing the message.
                if (this.autoComplete &&
                    this.receiveMode === "peekLock" &&
                    !bMessage.delivery.remote_settled) {
                    try {
                        receiverLogger.verbose("%s Auto completing the message with id '%s' on the receiver.", this.logPrefix, bMessage.messageId);
                        yield completeMessage(bMessage, this._context, this.entityPath);
                    }
                    catch (completeError) {
                        const translatedError = translateServiceBusError(completeError);
                        receiverLogger.logError(translatedError, "%s An error occurred while completing the message with id '%s' on the " + "receiver", this.logPrefix, bMessage.messageId);
                        this._notifyError({
                            error: translatedError,
                            errorSource: "complete",
                            entityPath: this.entityPath,
                            fullyQualifiedNamespace: this._context.config.host
                        });
                    }
                }
            });
            // setting the "message" event listener.
            this.link.on(rheaPromise.ReceiverEvents.message, onSessionMessage);
            // adding credit
            this.receiverHelper.addCredit(this.maxConcurrentCalls);
        }
        else {
            this._isReceivingMessagesForSubscriber = false;
            const msg = `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` +
                `has either not been created or is not open.`;
            receiverLogger.verbose("[%s] %s", this._context.connectionId, msg);
            this._notifyError({
                error: new Error(msg),
                // This is _probably_ the right error code since we require that
                // the message session is created before we even give back the receiver. So it not
                // being open at this point is either:
                //
                // 1. we didn't acquire the lock
                // 2. the connection was broken (we don't reconnect)
                //
                // If any of these becomes untrue you'll probably want to re-evaluate this classification.
                errorSource: "receive",
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host
            });
        }
    }
    /**
     * Returns a batch of messages based on given count and timeout over an AMQP receiver link
     * from a Queue/Subscription.
     *
     * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
     * @param maxWaitTimeInMs The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
     */
    receiveMessages(maxMessageCount, maxWaitTimeInMs, maxTimeAfterFirstMessageInMs, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this._batchingReceiverLite.receiveMessages(Object.assign({ maxMessageCount,
                    maxWaitTimeInMs,
                    maxTimeAfterFirstMessageInMs }, options));
            }
            catch (error) {
                receiverLogger.logError(error, `${this.logPrefix} Rejecting receiveMessages() with error`);
                throw error;
            }
        });
    }
    /**
     * Settles the message with the specified disposition.
     * @param message The ServiceBus Message that needs to be settled.
     * @param operation The disposition type.
     * @param options Optional parameters that can be provided while disposing the message.
     */
    settleMessage(message, operation, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (!options)
                    options = {};
                if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {
                    return reject(new Error(`operation: '${operation}' is not a valid operation.`));
                }
                const delivery = message.delivery;
                const timer = setTimeout(() => {
                    this._deliveryDispositionMap.delete(delivery.id);
                    receiverLogger.verbose("[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. " +
                        "Hence rejecting the promise with timeout error", this._context.connectionId, delivery.id, coreAmqp.Constants.defaultOperationTimeoutInMs);
                    const e = {
                        condition: coreAmqp.ErrorNameConditionMapper.ServiceUnavailableError,
                        description: "Operation to settle the message has timed out. The disposition of the " +
                            "message may or may not be successful"
                    };
                    return reject(translateServiceBusError(e));
                }, coreAmqp.Constants.defaultOperationTimeoutInMs);
                this._deliveryDispositionMap.set(delivery.id, {
                    resolve: resolve,
                    reject: reject,
                    timer: timer
                });
                if (operation === DispositionType.complete) {
                    delivery.accept();
                }
                else if (operation === DispositionType.abandon) {
                    const params = {
                        undeliverable_here: false
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.defer) {
                    const params = {
                        undeliverable_here: true
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.deadletter) {
                    const error = {
                        condition: coreAmqp.Constants.deadLetterName,
                        info: Object.assign(Object.assign({}, options.propertiesToModify), { DeadLetterReason: options.deadLetterReason, DeadLetterErrorDescription: options.deadLetterDescription })
                    };
                    delivery.reject(error);
                }
            });
        });
    }
    /**
     * Creates a new instance of the MessageSession based on the provided parameters.
     * @param context The client entity context
     * @param options Options that can be provided while creating the MessageSession.
     */
    static create(context, entityPath, sessionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(context);
            const messageSession = new MessageSession(context, entityPath, sessionId, options);
            yield messageSession._init(options === null || options === void 0 ? void 0 : options.abortSignal);
            return messageSession;
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * A client that can create Sender instances for sending messages to queues and
 * topics as well as Receiver instances to receive messages from queues and subscriptions.
 */
class ServiceBusClient {
    constructor(fullyQualifiedNamespaceOrConnectionString1, credentialOrOptions2, options3) {
        if (coreAuth.isTokenCredential(credentialOrOptions2)) {
            const fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;
            const credential = credentialOrOptions2;
            this._clientOptions = options3 || {};
            this._connectionContext = createConnectionContextForTokenCredential(credential, fullyQualifiedNamespace, this._clientOptions);
        }
        else {
            const connectionString = fullyQualifiedNamespaceOrConnectionString1;
            this._clientOptions = credentialOrOptions2 || {};
            this._connectionContext = createConnectionContextForConnectionString(connectionString, this._clientOptions);
        }
        this.fullyQualifiedNamespace = this._connectionContext.config.host;
        this._clientOptions.retryOptions = this._clientOptions.retryOptions || {};
        const timeoutInMs = this._clientOptions.retryOptions.timeoutInMs;
        if (timeoutInMs != undefined &&
            (typeof timeoutInMs !== "number" || !isFinite(timeoutInMs) || timeoutInMs <= 0)) {
            throw new Error(`${timeoutInMs} is an invalid value for retryOptions.timeoutInMs`);
        }
    }
    createReceiver(queueOrTopicName1, optionsOrSubscriptionName2, options3) {
        validateEntityPath(this._connectionContext.config, queueOrTopicName1);
        // NOTE: we don't currently have any options for this kind of receiver but
        // when we do make sure you pass them in and extract them.
        const { entityPath, receiveMode, options } = extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionName2, options3);
        let entityPathWithSubQueue = entityPath;
        if (options === null || options === void 0 ? void 0 : options.subQueueType) {
            switch (options === null || options === void 0 ? void 0 : options.subQueueType) {
                case "deadLetter":
                    entityPathWithSubQueue += "/$DeadLetterQueue";
                    break;
                case "transferDeadLetter":
                    entityPathWithSubQueue += "/$Transfer/$DeadLetterQueue";
                    break;
                default:
                    throw new Error(`Invalid subQueueType '${options === null || options === void 0 ? void 0 : options.subQueueType}' provided. Valid values are 'deadLetter' and 'transferDeadLetter'`);
            }
        }
        const maxLockAutoRenewDurationInMs = (options === null || options === void 0 ? void 0 : options.maxAutoLockRenewalDurationInMs) != null
            ? options.maxAutoLockRenewalDurationInMs
            : 5 * 60 * 1000;
        return new ServiceBusReceiverImpl(this._connectionContext, entityPathWithSubQueue, receiveMode, maxLockAutoRenewDurationInMs, this._clientOptions.retryOptions);
    }
    acceptSession(queueOrTopicName1, optionsOrSubscriptionNameOrSessionId2, optionsOrSessionId3, options4) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateEntityPath(this._connectionContext.config, queueOrTopicName1);
            let sessionId;
            let entityPath;
            let receiveMode;
            let options;
            if (typeof queueOrTopicName1 === "string" &&
                typeof optionsOrSubscriptionNameOrSessionId2 === "string" &&
                typeof optionsOrSessionId3 === "string") {
                // subscription constructor
                sessionId = optionsOrSessionId3;
                ({ entityPath, receiveMode, options } = extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionNameOrSessionId2, 
                // skip the session ID parameter (3)
                options4));
            }
            else if (typeof queueOrTopicName1 === "string" &&
                typeof optionsOrSubscriptionNameOrSessionId2 === "string" &&
                typeof optionsOrSessionId3 !== "string") {
                // queue constructor (but only because we know we're not a subscription constructor)
                sessionId = optionsOrSubscriptionNameOrSessionId2;
                ({ entityPath, receiveMode, options } = extractReceiverArguments(queueOrTopicName1, 
                // skip the session ID parameter (2)
                optionsOrSessionId3, undefined));
            }
            else {
                throw new Error("Unhandled set of parameters");
            }
            const messageSession = yield MessageSession.create(this._connectionContext, entityPath, sessionId, {
                maxAutoLockRenewalDurationInMs: options === null || options === void 0 ? void 0 : options.maxAutoLockRenewalDurationInMs,
                receiveMode,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            });
            const sessionReceiver = new ServiceBusSessionReceiverImpl(messageSession, this._connectionContext, entityPath, receiveMode, this._clientOptions.retryOptions);
            return sessionReceiver;
        });
    }
    acceptNextSession(queueOrTopicName1, optionsOrSubscriptionName2, options3) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateEntityPath(this._connectionContext.config, queueOrTopicName1);
            const { entityPath, receiveMode, options } = extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionName2, options3);
            const messageSession = yield MessageSession.create(this._connectionContext, entityPath, undefined, {
                maxAutoLockRenewalDurationInMs: options === null || options === void 0 ? void 0 : options.maxAutoLockRenewalDurationInMs,
                receiveMode,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            });
            const sessionReceiver = new ServiceBusSessionReceiverImpl(messageSession, this._connectionContext, entityPath, receiveMode, this._clientOptions.retryOptions);
            return sessionReceiver;
        });
    }
    /**
     * Creates a Sender which can be used to send messages, schedule messages to be
     * sent at a later time and cancel such scheduled messages. No connection is made
     * to the service until one of the methods on the sender is called.
     * @param queueOrTopicName The name of a queue or topic to send messages to.
     */
    createSender(queueOrTopicName) {
        validateEntityPath(this._connectionContext.config, queueOrTopicName);
        return new ServiceBusSenderImpl(this._connectionContext, queueOrTopicName, this._clientOptions.retryOptions);
    }
    /**
     * Closes the underlying AMQP connection.
     * NOTE: this will also disconnect any Receiver or Sender instances created from this
     * instance.
     */
    close() {
        return ConnectionContext.close(this._connectionContext);
    }
}
/**
 * Helper to validate and extract the common arguments from both the create*Receiver() overloads that
 * have this pattern:
 *
 * queue, options
 * topic, subscription, options
 *
 * @internal
 * @hidden
 */
function extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionName2, definitelyOptions3) {
    let entityPath;
    let options;
    if (typeof optionsOrSubscriptionName2 === "string") {
        const topic = queueOrTopicName1;
        const subscription = optionsOrSubscriptionName2;
        entityPath = `${topic}/Subscriptions/${subscription}`;
        options = definitelyOptions3;
    }
    else {
        entityPath = queueOrTopicName1;
        options = optionsOrSubscriptionName2;
    }
    let receiveMode;
    if ((options === null || options === void 0 ? void 0 : options.receiveMode) == undefined || options.receiveMode === "peekLock") {
        receiveMode = "peekLock";
    }
    else if (options.receiveMode === "receiveAndDelete") {
        receiveMode = "receiveAndDelete";
    }
    else {
        throw new TypeError(`Invalid receiveMode '${options === null || options === void 0 ? void 0 : options.receiveMode}' provided. Valid values are 'peekLock' and 'receiveAndDelete'`);
    }
    options === null || options === void 0 ? true : delete options.receiveMode;
    return {
        entityPath,
        receiveMode,
        options
    };
}
/**
 * Validates that the EntityPath in the connection string (if any) matches with the
 * queue or topic name passed to the methods that create senders and receivers.
 *
 * @internal
 * @hidden
 */
function validateEntityPath(connectionConfig, queueOrTopicName) {
    if (connectionConfig.entityPath && connectionConfig.entityPath !== queueOrTopicName) {
        throw new Error(entityPathMisMatchError);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Parses given connection string into the different properties applicable to Azure Service Bus.
 * The properties are useful to then construct a ServiceBusClient.
 * @param connectionString The connection string associated with the Shared Access Policy created
 * for the Service Bus namespace, queue or topic.
 */
function parseServiceBusConnectionString(connectionString) {
    const parsedResult = coreAmqp.parseConnectionString(connectionString);
    if (!parsedResult.Endpoint) {
        throw new Error("Connection string should have an Endpoint key.");
    }
    if (parsedResult.SharedAccessSignature) {
        if (parsedResult.SharedAccessKey || parsedResult.SharedAccessKeyName) {
            throw new Error("Connection string cannot have both SharedAccessSignature and SharedAccessKey keys.");
        }
    }
    else if (parsedResult.SharedAccessKey && !parsedResult.SharedAccessKeyName) {
        throw new Error("Connection string with SharedAccessKey should have SharedAccessKeyName.");
    }
    else if (!parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {
        throw new Error("Connection string with SharedAccessKeyName should have SharedAccessKey as well.");
    }
    const output = {
        fullyQualifiedNamespace: (parsedResult.Endpoint.match(".*://([^/]*)") || [])[1],
        endpoint: parsedResult.Endpoint
    };
    if (parsedResult.EntityPath) {
        output.entityPath = parsedResult.EntityPath;
    }
    if (parsedResult.SharedAccessSignature) {
        output.sharedAccessSignature = parsedResult.SharedAccessSignature;
    }
    if (parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {
        output.sharedAccessKey = parsedResult.SharedAccessKey;
        output.sharedAccessKeyName = parsedResult.SharedAccessKeyName;
    }
    return output;
}

Object.defineProperty(exports, 'MessagingError', {
    enumerable: true,
    get: function () {
        return coreAmqp.MessagingError;
    }
});
Object.defineProperty(exports, 'TokenType', {
    enumerable: true,
    get: function () {
        return coreAmqp.TokenType;
    }
});
Object.defineProperty(exports, 'delay', {
    enumerable: true,
    get: function () {
        return coreAmqp.delay;
    }
});
exports.ServiceBusAdministrationClient = ServiceBusAdministrationClient;
exports.ServiceBusClient = ServiceBusClient;
exports.ServiceBusError = ServiceBusError;
exports.isServiceBusError = isServiceBusError;
exports.parseServiceBusConnectionString = parseServiceBusConnectionString;
//# sourceMappingURL=index.js.map
