{"version":3,"file":"index.js","sources":["../src/log.ts","../src/util/constants.ts","../src/util/parseUrl.ts","../src/util/utils.ts","../src/util/atomXmlHelper.ts","../src/serializers/namespaceResourceSerializer.ts","../src/serializers/queueResourceSerializer.ts","../src/serializers/ruleResourceSerializer.ts","../src/serializers/subscriptionResourceSerializer.ts","../src/serializers/topicResourceSerializer.ts","../src/servicebusSharedKeyCredential.ts","../src/util/crypto.ts","../src/util/sasServiceClientCredentials.ts","../src/util/tracing.ts","../src/serviceBusAtomManagementClient.ts","../src/dataTransformer.ts","../src/serviceBusMessage.ts","../src/serviceBusError.ts","../src/core/linkEntity.ts","../src/util/errors.ts","../src/core/managementClient.ts","../src/util/runtimeInfo.ts","../src/connectionContext.ts","../src/constructorHelpers.ts","../src/modelsToBeSharedWithEventHubs.ts","../src/core/shared.ts","../src/core/messageReceiver.ts","../src/core/receiverHelper.ts","../src/receivers/shared.ts","../src/core/streamingReceiver.ts","../src/diagnostics/instrumentServiceBusMessage.ts","../src/core/batchingReceiver.ts","../src/core/autoLockRenewer.ts","../src/receivers/receiver.ts","../src/receivers/sessionReceiver.ts","../src/diagnostics/messageSpan.ts","../src/serviceBusMessageBatch.ts","../src/core/messageSender.ts","../src/sender.ts","../src/session/messageSession.ts","../src/serviceBusClient.ts","../src/util/connectionStringUtils.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AzureLogger, createClientLogger } from \"@azure/logger\";\nimport { AmqpError } from \"rhea-promise\";\n\n/**\n * The @azure/logger configuration for this package.\n * This will output logs using the `azure:service-bus` namespace prefix.\n * @internal\n * @hidden\n */\nexport const logger = createServiceBusLogger(\"service-bus\");\n\n/**\n * Logging for ServiceBusReceivers of any type (session, non-session)\n * @internal\n * @hidden\n */\nexport const receiverLogger = createServiceBusLogger(\"service-bus:receiver\");\n\n/**\n * Logging for ServiceBusSenders\n * @internal\n * @hidden\n */\nexport const senderLogger = createServiceBusLogger(\"service-bus:sender\");\n\n/**\n * Logging for connection management\n * @internal\n * @hidden\n */\nexport const connectionLogger = createServiceBusLogger(\"service-bus:connection\");\n\n/**\n * Logging for the ServiceBusAdministrationClient\n * @internal\n * @hidden\n */\nexport const administrationLogger = createServiceBusLogger(\"service-bus:administration\");\n\n/**\n * Logging related to message encoding/decoding.\n * @internal\n * @hidden\n */\nexport const messageLogger = createServiceBusLogger(\"service-bus:messages\");\n\n/**\n * Logging related to message encoding/decoding.\n * @internal\n * @hidden\n */\nexport const managementClientLogger = createServiceBusLogger(\"service-bus:management\");\n\n/**\n * Logs the error's stack trace to \"verbose\" if a stack trace is available.\n * @param error Error containing a stack trace.\n * @internal\n * @hidden\n */\nexport function logErrorStackTrace(_logger: AzureLogger, error: any) {\n  if (error && error.stack) {\n    _logger.verbose(error.stack);\n  }\n}\n\n/**\n * @internal\n * @hidden\n */\nexport interface ServiceBusLogger extends AzureLogger {\n  /**\n   * Logs an error with an associated message, formatted. If there is a stack\n   * trace in the error that will be logged to the verbose stream.\n   *\n   * Example:\n   *   receiverLogger.logError(new Error(\"hello, this is the error\"), \"this is my message\");\n   * will output:\n   *   azure:service-bus:receiver:warning this is my message : Error: hello, this is the error\n   * @param err\n   * @param args\n   */\n  logError(err: Error | AmqpError | undefined, ...args: any[]): void;\n}\n\n/**\n * Creates an AzureLogger with any additional methods for standardized logging (for example, with errors)\n * @internal\n * @hidden\n */\nexport function createServiceBusLogger(namespace: string) {\n  const _logger = createClientLogger(namespace) as ServiceBusLogger;\n\n  _logger[\"logError\"] = (err: Error | AmqpError | undefined, ...args: any[]): void => {\n    let l: typeof logger.info;\n\n    // abort errors are user initiated so we don't have to treat them as warnings, like we\n    // would with other errors.\n    if (isError(err) && err.name === \"AbortError\") {\n      l = _logger.info;\n    } else {\n      l = _logger.warning;\n    }\n\n    // tack on the error object so it also gets logged.\n    args.push(\":\", err);\n\n    // let the normal formatting work and include the error at the end.\n    l(...args);\n\n    // optionally log the stack trace if it's available but this always goes to verbose\n    if (err && (err as any).stack) {\n      _logger.verbose((err as any).stack);\n    }\n  };\n\n  return _logger;\n}\n\n/**\n * @internal\n * @hidden\n */\nfunction isError(err: Error | AmqpError | undefined): err is Error {\n  return err != null && (err as any).name != null;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * @internal\n * @hidden\n */\nexport const packageJsonInfo = {\n  name: \"@azure/service-bus\",\n  version: \"7.0.3\"\n};\n\n/**\n * @internal\n * @hidden\n */\nexport const messageDispositionTimeout = 20000;\n\n/**\n * @internal\n * @hidden\n */\nexport const max32BitNumber = Math.pow(2, 31) - 1;\n\n/**\n * Queue name identifier\n * @internal\n * @hidden\n */\nexport const QUEUE_NAME = \"QueueName\";\n\n/**\n * Topic name identifier\n * @internal\n * @hidden\n */\nexport const TOPIC_NAME = \"TopicName\";\n\n/**\n * Subscription name identifier\n * @internal\n * @hidden\n */\nexport const SUBSCRIPTION_NAME = \"SubscriptionName\";\n\n/**\n * Rule name identifier\n * @internal\n * @hidden\n */\nexport const RULE_NAME = \"RuleName\";\n\n/**\n * Accessed at field\n * @internal\n * @hidden\n */\nexport const ACCESSED_AT = \"AccessedAt\";\n\n/**\n * Updated at field\n * @internal\n * @hidden\n */\nexport const UPDATED_AT = \"UpdatedAt\";\n\n/**\n * Created at field\n * @internal\n * @hidden\n */\nexport const CREATED_AT = \"CreatedAt\";\n\n/**\n * Authorization rules on the entity\n * @internal\n * @hidden\n */\nexport const AUTHORIZATION_RULES = \"AuthorizationRules\";\n\n/**\n * Is Anonymous Accessible field\n * @internal\n * @hidden\n */\nexport const IS_ANONYMOUS_ACCESSIBLE = \"IsAnonymousAccessible\";\n\n/**\n * Entity Availability Status field\n * @internal\n * @hidden\n */\nexport const ENTITY_AVAILABILITY_STATUS = \"EntityAvailabilityStatus\";\n\n/**\n * Enable express option\n * @internal\n * @hidden\n */\nexport const ENABLE_EXPRESS = \"EnableExpress\";\n\n/**\n * Is express option\n * @internal\n * @hidden\n */\nexport const IS_EXPRESS = \"IsExpress\";\n\n/**\n * Enable Subscription Partitioning option\n * @internal\n * @hidden\n */\nexport const ENABLE_SUBSCRIPTION_PARTITIONING = \"EnableSubscriptionPartitioning\";\n\n/**\n * Filtering Messages Before Publishing option\n * @internal\n * @hidden\n */\nexport const FILTER_MESSAGES_BEFORE_PUBLISHING = \"FilteringMessagesBeforePublishing\";\n\n/**\n * The entity's size in bytes.\n *\n * @internal\n * @hidden\n */\nexport const SIZE_IN_BYTES = \"SizeInBytes\";\n\n/**\n * The entity's message count.\n *\n * @internal\n * @hidden\n */\nexport const MESSAGE_COUNT = \"MessageCount\";\n\n/**\n * The topic's subscription count.\n *\n * @internal\n * @hidden\n */\nexport const SUBSCRIPTION_COUNT = \"SubscriptionCount\";\n\n/**\n * The topic / subscription's count details.\n *\n * @internal\n * @hidden\n */\nexport const COUNT_DETAILS = \"CountDetails\";\n\n/**\n * The default rule name.\n *\n * @internal\n * @hidden\n */\nexport const DEFAULT_RULE_NAME = \"$Default\";\n\n/**\n * Max idle time before entity is deleted.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n * @internal\n * @hidden\n */\nexport const AUTO_DELETE_ON_IDLE = \"AutoDeleteOnIdle\";\n\n/**\n * The status information on response\n *\n * @internal\n * @hidden\n */\nexport const STATUS = \"Status\";\n\n/**\n * The URL of Service Bus entity to forward messages to.\n *\n * @internal\n * @hidden\n */\nexport const FORWARD_TO = \"ForwardTo\";\n\n/**\n * The user meta data information\n *\n * @internal\n * @hidden\n */\nexport const USER_METADATA = \"UserMetadata\";\n\n/**\n * The maximum size in megabytes.\n *\n * @internal\n * @hidden\n */\nexport const MAX_SIZE_IN_MEGABYTES = \"MaxSizeInMegabytes\";\n\n/**\n * The default message time to live.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n * @internal\n * @hidden\n */\nexport const DEFAULT_MESSAGE_TIME_TO_LIVE = \"DefaultMessageTimeToLive\";\n\n/**\n * The lock duration.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n * @internal\n * @hidden\n */\nexport const LOCK_DURATION = \"LockDuration\";\n\n/**\n * The indication if session is required or not.\n *\n * @internal\n * @hidden\n */\nexport const REQUIRES_SESSION = \"RequiresSession\";\n\n/**\n * The indication if duplicate detection is required or not.\n *\n * @internal\n * @hidden\n */\nexport const REQUIRES_DUPLICATE_DETECTION = \"RequiresDuplicateDetection\";\n\n/**\n * The indication if dead lettering on message expiration. If it is enabled and a message expires,\n * the Service Bus moves the message from the queue into the entity dead-letter sub-queue.\n * If disabled, message will be permanently deleted from the main entity.\n * Settable only at entity creation time.\n *\n * @internal\n * @hidden\n */\nexport const DEAD_LETTERING_ON_MESSAGE_EXPIRATION = \"DeadLetteringOnMessageExpiration\";\n\n/**\n * The indication if dead lettering on filter evaluation exceptions.\n *\n * @internal\n * @hidden\n */\nexport const DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS =\n  \"DeadLetteringOnFilterEvaluationExceptions\";\n\n/**\n * The history time window for duplicate detection.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n * @internal\n * @hidden\n */\nexport const DUPLICATE_DETECTION_HISTORY_TIME_WINDOW = \"DuplicateDetectionHistoryTimeWindow\";\n\n/**\n * The maximum delivery count of messages after which if it is still not settled, gets moved to the dead-letter sub-queue.\n *\n * @internal\n * @hidden\n */\nexport const MAX_DELIVERY_COUNT = \"MaxDeliveryCount\";\n\n/**\n * Indicates if the queue has enabled batch operations.\n *\n * @internal\n * @hidden\n */\nexport const ENABLE_BATCHED_OPERATIONS = \"EnableBatchedOperations\";\n\n/**\n * Indicates whether the topic can be ordered\n *\n * @internal\n * @hidden\n */\nexport const SUPPORT_ORDERING = \"SupportOrdering\";\n\n/**\n * Indicates whether the topic/queue should be split across multiple partitions\n *\n * @internal\n * @hidden\n */\nexport const ENABLE_PARTITIONING = \"EnablePartitioning\";\n\n/**\n * The URL of Service Bus entity to forward deadlettered messages to.\n *\n * @internal\n * @hidden\n */\nexport const FORWARD_DEADLETTERED_MESSAGES_TO = \"ForwardDeadLetteredMessagesTo\";\n\n/**\n * Query string parameter to set Service Bus API version\n *\n * @internal\n * @hidden\n */\nexport const API_VERSION_QUERY_KEY = \"api-version\";\n\n/**\n * Current API version being sent to service bus\n *\n * @internal\n * @hidden\n */\nexport const CURRENT_API_VERSION = \"2017-04\";\n\n/**\n * Constant representing the Odata Error 'message' property\n *\n * @internal\n * @hidden\n */\nexport const ODATA_ERROR_MESSAGE = \"message\";\n/**\n * Constant representing the 'value' property of Odata Error 'message' property\n *\n * @internal\n * @hidden\n */\nexport const ODATA_ERROR_MESSAGE_VALUE = \"value\";\n\n/**\n * Marker for atom metadata.\n *\n * @internal\n * @hidden\n */\nexport const XML_METADATA_MARKER = \"$\";\n\n/**\n * Marker for atom value.\n *\n * @internal\n * @hidden\n */\nexport const XML_VALUE_MARKER = \"_\";\n\n/**\n * Constant representing the property where the atom default elements are stored.\n *\n * @internal\n * @hidden\n */\nexport const ATOM_METADATA_MARKER = \"_\";\n\n/**\n * Known HTTP status codes as documented and referenced in ATOM based management API feature\n * https://docs.microsoft.com/dotnet/api/system.net.httpstatuscode?view=netframework-4.8\n * @internal\n * @hidden\n */\nexport const HttpResponseCodes = {\n  100: \"Continue\",\n  101: \"SwitchingProtocols\",\n  200: \"Ok\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"NonAuthoritativeInformation\",\n  204: \"NoContent\",\n  205: \"ResetContent\",\n  206: \"PartialContent\",\n  300: \"MultipleChoices\",\n  301: \"Moved\",\n  302: \"Redirect\",\n  303: \"RedirectMethod\",\n  304: \"NotModified\",\n  305: \"UseProxy\",\n  306: \"Unused\",\n  400: \"BadRequest\",\n  401: \"Unauthorized\",\n  402: \"PaymentRequired\",\n  403: \"Forbidden\",\n  404: \"NotFound\",\n  405: \"MethodNotAllowed\",\n  406: \"NotAcceptable\",\n  407: \"ProxyAuthenticationRequired\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"LengthRequired\",\n  412: \"PreconditionFailed\",\n  413: \"RequestEntityTooLarge\",\n  414: \"RequestUriTooLong\",\n  415: \"UnsupportedMediaType\",\n  416: \"RequestRangeNotSatisfiable\",\n  417: \"ExpectationFailed\",\n  426: \"UpgradeRequired\",\n  500: \"InternalServerError\",\n  501: \"NotImplemented\",\n  502: \"BadGateway\",\n  503: \"ServiceUnavailable\",\n  504: \"GatewayTimeout\",\n  505: \"HttpVersionNotSupported\"\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * @internal\n * @hidden\n */\nconst url = require(\"url\");\n\n/**\n * @internal\n * @hidden\n * @param {string} rawUrl\n */\nexport const parseURL = (rawUrl: string) => {\n  return new url.URL(rawUrl);\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport Long from \"long\";\nimport { logger, receiverLogger, messageLogger } from \"../log\";\nimport { OperationTimeoutError, generate_uuid } from \"rhea-promise\";\nimport isBuffer from \"is-buffer\";\nimport { Buffer } from \"buffer\";\nimport * as Constants from \"../util/constants\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { HttpOperationResponse, HttpResponse, isNode } from \"@azure/core-http\";\n\n// This is the only dependency we have on DOM types, so rather than require\n// the DOM lib we can just shim this in.\n/**\n * @hidden\n * @internal\n */\ninterface Navigator {\n  hardwareConcurrency: number;\n}\n/**\n * @hidden\n * @internal\n */\ndeclare const navigator: Navigator;\n\n/**\n * @internal\n * @hidden\n * Provides a uniue name by appending a string guid to the given string in the following format:\n * `{name}-{uuid}`.\n * @param name The nme of the entity\n */\nexport function getUniqueName(name: string): string {\n  return `${name}-${generate_uuid()}`;\n}\n\n/**\n * @internal\n * @hidden\n * If you try to turn a Guid into a Buffer in .NET, the bytes of the first three groups get\n * flipped within the group, but the last two groups don't get flipped, so we end up with a\n * different byte order. This is the order of bytes needed to make Service Bus recognize the token.\n *\n * @param lockToken The lock token whose bytes need to be reorded.\n * @returns Buffer - Buffer representing reordered bytes.\n */\nexport function reorderLockToken(lockTokenBytes: Buffer): Buffer {\n  if (!lockTokenBytes || !Buffer.isBuffer(lockTokenBytes)) {\n    return lockTokenBytes;\n  }\n\n  return Buffer.from([\n    lockTokenBytes[3],\n    lockTokenBytes[2],\n    lockTokenBytes[1],\n    lockTokenBytes[0],\n\n    lockTokenBytes[5],\n    lockTokenBytes[4],\n\n    lockTokenBytes[7],\n    lockTokenBytes[6],\n\n    lockTokenBytes[8],\n    lockTokenBytes[9],\n\n    lockTokenBytes[10],\n    lockTokenBytes[11],\n    lockTokenBytes[12],\n    lockTokenBytes[13],\n    lockTokenBytes[14],\n    lockTokenBytes[15]\n  ]);\n}\n\n/**\n * @internal\n * @hidden\n * Provides the time in milliseconds after which the lock renewal should occur.\n * @param lockedUntilUtc - The time until which the message is locked.\n */\nexport function calculateRenewAfterDuration(lockedUntilUtc: Date): number {\n  const now = Date.now();\n  const lockedUntil = lockedUntilUtc.getTime();\n  const remainingTime = lockedUntil - now;\n  receiverLogger.verbose(\"Locked until utc  : %d\", lockedUntil);\n  receiverLogger.verbose(\"Current time is   : %d\", now);\n  receiverLogger.verbose(\"Remaining time is : %d\", remainingTime);\n  if (remainingTime < 1000) {\n    return 0;\n  }\n  const buffer = Math.min(remainingTime / 2, 10000); // 10 seconds\n  const renewAfter = remainingTime - buffer;\n  receiverLogger.verbose(\"Renew after       : %d\", renewAfter);\n  return renewAfter;\n}\n\n/**\n * @internal\n * @hidden\n * Converts the .net ticks to a JS Date object.\n *\n * - The epoch for the DateTimeOffset type is `0000-01-01`, while the epoch for JS Dates is\n * `1970-01-01`.\n * - The DateTimeOffset ticks value for the date `1970-01-01` is `621355968000000000`.\n *   - Hence, to convert it to the JS epoch; we `subtract` the delta from the given value.\n * - Ticks in DateTimeOffset is `1/10000000` second, while ticks in JS Date is `1/1000` second.\n *   - Thus, we `divide` the value by `10000` to convert it to JS Date ticks.\n *\n * @param buf Input as a Buffer\n * @returns Date The JS Date object.\n */\nexport function convertTicksToDate(buf: number[]): Date {\n  const epochMicroDiff: number = 621355968000000000;\n  const longValue: Long = Long.fromBytesBE(buf);\n  const timeInMS = longValue\n    .sub(epochMicroDiff)\n    .div(10000)\n    .toNumber();\n  const result = new Date(timeInMS);\n  logger.verbose(\"The converted date is: %s\", result.toString());\n  return result;\n}\n\n/**\n * @internal\n * @hidden\n * Returns the number of logical processors in the system.\n */\nexport function getProcessorCount(): number {\n  if (isNode) {\n    const os = require(\"os\");\n    return os.cpus().length;\n  } else {\n    return navigator.hardwareConcurrency || 1;\n  }\n}\n\n/**\n * @internal\n * @hidden\n * Converts any given input to a Buffer.\n * @param input The input that needs to be converted to a Buffer.\n */\nexport function toBuffer(input: any): Buffer {\n  let result: any;\n  messageLogger.verbose(\n    \"[utils.toBuffer] The given message body that needs to be converted to buffer is: \",\n    input\n  );\n  if (isBuffer(input)) {\n    result = input;\n  } else {\n    // string, undefined, null, boolean, array, object, number should end up here\n    // coercing undefined to null as that will ensure that null value will be given to the\n    // customer on receive.\n    if (input === undefined) input = null;\n    try {\n      const inputStr = JSON.stringify(input);\n      result = Buffer.from(inputStr, \"utf8\");\n    } catch (err) {\n      const msg =\n        `An error occurred while executing JSON.stringify() on the given input ` +\n        input +\n        `${err instanceof Error ? err.stack : JSON.stringify(err)}`;\n      messageLogger.warning(\"[utils.toBuffer] \" + msg);\n      throw err instanceof Error ? err : new Error(msg);\n    }\n  }\n  messageLogger.verbose(\"[utils.toBuffer] The converted buffer is: %O.\", result);\n  return result;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to retrieve `string` value from given string,\n * or throws error if undefined.\n * @param value\n */\nexport function getString(value: any, nameOfProperty: string): string {\n  const result = getStringOrUndefined(value);\n  if (result == undefined) {\n    throw new Error(\n      `\"${nameOfProperty}\" received from service expected to be a string value and not undefined.`\n    );\n  }\n  return result;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to retrieve `string` value from given input,\n * or undefined if not passed in.\n * @param value\n */\nexport function getStringOrUndefined(value: any): string | undefined {\n  if (value == undefined) {\n    return undefined;\n  }\n  return value.toString();\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to retrieve `integer` value from given string,\n * or throws error if undefined.\n * @param value\n */\nexport function getInteger(value: any, nameOfProperty: string): number {\n  const result = getIntegerOrUndefined(value);\n  if (result == undefined) {\n    throw new Error(\n      `\"${nameOfProperty}\" received from service expected to be a number value and not undefined.`\n    );\n  }\n  return result;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to retrieve `integer` value from given string,\n * or undefined if not passed in.\n * @param value\n */\nexport function getIntegerOrUndefined(value: any): number | undefined {\n  if (value == undefined) {\n    return undefined;\n  }\n  const result = parseInt(value.toString());\n  return result == NaN ? undefined : result;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to convert ISO-8601 time into Date type.\n * @param value\n */\nexport function getDate(value: string, nameOfProperty: string): Date {\n  return new Date(getString(value, nameOfProperty));\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to retrieve `boolean` value from given string,\n * or throws error if undefined.\n * @param value\n */\nexport function getBoolean(value: any, nameOfProperty: string): boolean {\n  const result = getBooleanOrUndefined(value);\n  if (result == undefined) {\n    throw new Error(\n      `\"${nameOfProperty}\" received from service expected to be a boolean value and not undefined.`\n    );\n  }\n  return result;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to retrieve `boolean` value from given string,\n * or undefined if not passed in.\n * @param value\n */\nexport function getBooleanOrUndefined(value: any): boolean | undefined {\n  if (value == undefined) {\n    return undefined;\n  }\n  return (\n    value\n      .toString()\n      .trim()\n      .toLowerCase() === \"true\"\n  );\n}\n\n/**\n * @internal\n * @hidden\n * Helps in differentiating JSON like objects from other kinds of objects.\n */\nconst EMPTY_JSON_OBJECT_CONSTRUCTOR = {}.constructor;\n\n/**\n * @internal\n * @hidden\n * Returns `true` if given input is a JSON like object.\n * @param value\n */\nexport function isJSONLikeObject(value: any): boolean {\n  // `value.constructor === {}.constructor` differentiates among the \"object\"s,\n  //    would filter the JSON objects and won't match any array or other kinds of objects\n\n  // -------------------------------------------------------------------------------\n  // Few examples       | typeof obj ===\"object\" |  obj.constructor==={}.constructor\n  // -------------------------------------------------------------------------------\n  // {abc:1}            | true                   | true\n  // [\"a\",\"b\"]          | true                   | false\n  // [{\"a\":1},{\"b\":2}]  | true                   | false\n  // new Date()         | true                   | false\n  // 123                | false                  | false\n  // -------------------------------------------------------------------------------\n  return typeof value === \"object\" && value.constructor === EMPTY_JSON_OBJECT_CONSTRUCTOR;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to retrieve message count details from given input,\n * @param value\n */\nexport function getMessageCountDetails(value: any): MessageCountDetails {\n  const xmlnsPrefix = getXMLNSPrefix(value);\n  if (value == undefined) {\n    value = {};\n  }\n  return {\n    activeMessageCount: parseInt(value[`${xmlnsPrefix}:ActiveMessageCount`]) || 0,\n    deadLetterMessageCount: parseInt(value[`${xmlnsPrefix}:DeadLetterMessageCount`]) || 0,\n    scheduledMessageCount: parseInt(value[`${xmlnsPrefix}:ScheduledMessageCount`]) || 0,\n    transferMessageCount: parseInt(value[`${xmlnsPrefix}:TransferMessageCount`]) || 0,\n    transferDeadLetterMessageCount:\n      parseInt(value[`${xmlnsPrefix}:TransferDeadLetterMessageCount`]) || 0\n  };\n}\n\n/**\n * @internal\n * @hidden\n * Gets the xmlns prefix from the root of the objects that are part of the parsed response body.\n */\nexport function getXMLNSPrefix(value: any) {\n  if (!value[Constants.XML_METADATA_MARKER]) {\n    throw new Error(\n      `Error occurred while parsing the response body - cannot find the XML_METADATA_MARKER \"$\" on the object ${JSON.stringify(\n        value\n      )}`\n    );\n  }\n  const keys = Object.keys(value[Constants.XML_METADATA_MARKER]);\n  if (keys.length !== 1) {\n    throw new Error(\n      `Error occurred while parsing the response body - unexpected number of \"xmlns:\\${prefix}\" keys at ${JSON.stringify(\n        value[Constants.XML_METADATA_MARKER]\n      )}`\n    );\n  }\n  if (!keys[0].startsWith(\"xmlns:\")) {\n    throw new Error(\n      `Error occurred while parsing the response body - unexpected key at ${JSON.stringify(\n        value[Constants.XML_METADATA_MARKER]\n      )}`\n    );\n  }\n  // Pick the substring that's after \"xmlns:\"\n  const xmlnsPrefix = keys[0].substring(6);\n  if (!xmlnsPrefix) {\n    throw new Error(\n      `Error occurred while parsing the response body - unexpected xmlns prefix at ${JSON.stringify(\n        value[Constants.XML_METADATA_MARKER]\n      )}`\n    );\n  }\n  return xmlnsPrefix;\n}\n\n/**\n * Represents type of message count details in ATOM based management operations.\n * @internal\n * @hidden\n */\nexport type MessageCountDetails = {\n  activeMessageCount: number;\n  deadLetterMessageCount: number;\n  scheduledMessageCount: number;\n  transferMessageCount: number;\n  transferDeadLetterMessageCount: number;\n};\n\n/**\n * Represents type of `AuthorizationRule` in ATOM based management operations.\n */\nexport interface AuthorizationRule {\n  /**\n   * The claim type.\n   */\n  claimType: string;\n  /**\n   * The list of rights(\"Manage\" | \"Send\" | \"Listen\").\n   */\n  accessRights?: (\"Manage\" | \"Send\" | \"Listen\")[];\n  /**\n   * The authorization rule key name.\n   */\n  keyName: string;\n  /**\n   * The primary key for the authorization rule.\n   */\n  primaryKey?: string;\n  /**\n   * The secondary key for the authorization rule.\n   */\n  secondaryKey?: string;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to retrieve array of `AuthorizationRule` from given input,\n * or undefined if not passed in.\n * @param value\n */\nexport function getAuthorizationRulesOrUndefined(value: any): AuthorizationRule[] | undefined {\n  const authorizationRules: AuthorizationRule[] = [];\n\n  // Ignore special case as Service Bus treats \"\" as a valid value for authorization rules\n  if (typeof value === \"string\" && value.trim() === \"\") {\n    return undefined;\n  }\n\n  if (value == undefined) {\n    return undefined;\n  }\n\n  const rawAuthorizationRules = value.AuthorizationRule;\n  if (Array.isArray(rawAuthorizationRules)) {\n    for (let i = 0; i < rawAuthorizationRules.length; i++) {\n      authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules[i]));\n    }\n  } else {\n    authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules));\n  }\n  return authorizationRules;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to build an instance of parsed authorization rule as `AuthorizationRule` from given input.\n * @param value\n */\nfunction buildAuthorizationRule(value: any): AuthorizationRule {\n  let accessRights;\n  if (value[\"Rights\"] != undefined) {\n    accessRights = value[\"Rights\"][\"AccessRights\"];\n  }\n\n  const authorizationRule: AuthorizationRule = {\n    claimType: value[\"ClaimType\"],\n    accessRights,\n    keyName: value[\"KeyName\"],\n    primaryKey: value[\"PrimaryKey\"],\n    secondaryKey: value[\"SecondaryKey\"]\n  };\n\n  if (authorizationRule.accessRights && !Array.isArray(authorizationRule.accessRights)) {\n    authorizationRule.accessRights = [authorizationRule.accessRights];\n  }\n  return authorizationRule;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to extract output containing array of `RawAuthorizationRule` instances from given input,\n * or undefined if not passed in.\n * @param value\n */\nexport function getRawAuthorizationRules(authorizationRules: AuthorizationRule[] | undefined): any {\n  if (authorizationRules == undefined) {\n    return undefined;\n  }\n\n  if (!Array.isArray(authorizationRules)) {\n    throw new TypeError(\n      `authorizationRules must be an array of AuthorizationRule objects or undefined, but received ${JSON.stringify(\n        authorizationRules,\n        undefined,\n        2\n      )}`\n    );\n  }\n\n  const rawAuthorizationRules: any[] = [];\n  for (let i = 0; i < authorizationRules.length; i++) {\n    rawAuthorizationRules.push(buildRawAuthorizationRule(authorizationRules[i]));\n  }\n  return { AuthorizationRule: rawAuthorizationRules };\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to build an instance of raw authorization rule as RawAuthorizationRule from given `AuthorizationRule` input.\n * @param authorizationRule parsed Authorization Rule instance\n */\nfunction buildRawAuthorizationRule(authorizationRule: AuthorizationRule): any {\n  if (!isJSONLikeObject(authorizationRule) || authorizationRule === null) {\n    throw new TypeError(\n      `Expected authorizationRule input to be a JS object value, but received ${JSON.stringify(\n        authorizationRule,\n        undefined,\n        2\n      )}`\n    );\n  }\n\n  const rawAuthorizationRule: any = {\n    ClaimType: authorizationRule.claimType,\n    // ClaimValue is not settable by the users, but service expects the value for PUT requests\n    ClaimValue: \"None\",\n    Rights: {\n      AccessRights: authorizationRule.accessRights\n    },\n    KeyName: authorizationRule.keyName,\n    PrimaryKey: authorizationRule.primaryKey,\n    SecondaryKey: authorizationRule.secondaryKey\n  };\n  rawAuthorizationRule[Constants.XML_METADATA_MARKER] = {\n    \"p5:type\": \"SharedAccessAuthorizationRule\",\n    \"xmlns:p5\": \"http://www.w3.org/2001/XMLSchema-instance\"\n  };\n  return rawAuthorizationRule;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to check if given string is an absolute URL\n * @param url\n */\nexport function isAbsoluteUrl(url: string) {\n  const _url = url.toLowerCase();\n  return _url.startsWith(\"sb://\") || _url.startsWith(\"http://\") || _url.startsWith(\"https://\");\n}\n\n/**\n * Possible values for `status` of the Service Bus messaging entities.\n */\nexport type EntityStatus =\n  | \"Active\"\n  | \"Creating\"\n  | \"Deleting\"\n  | \"ReceiveDisabled\"\n  | \"SendDisabled\"\n  | \"Disabled\"\n  | \"Renaming\"\n  | \"Restoring\"\n  | \"Unknown\";\n\n/**\n * Possible values for `availabilityStatus` of the Service Bus messaging entities.\n */\nexport type EntityAvailabilityStatus =\n  | \"Available\"\n  | \"Limited\"\n  | \"Renaming\"\n  | \"Restoring\"\n  | \"Unknown\";\n\n/**\n * @internal\n * @hidden\n */\nexport const StandardAbortMessage = \"The operation was aborted.\";\n\n/**\n * An executor for a function that returns a Promise that obeys both a timeout and an\n * optional AbortSignal.\n * @param timeoutMs - The number of milliseconds to allow before throwing an OperationTimeoutError.\n * @param timeoutMessage - The message to place in the .description field for the thrown exception for Timeout.\n * @param abortSignal - The abortSignal associated with containing operation.\n * @param abortErrorMsg - The abort error message associated with containing operation.\n * @param value - The value to be resolved with after a timeout of t milliseconds.\n * @returns {Promise<T>} - Resolved promise\n *\n * @internal\n * @hidden\n */\nexport async function waitForTimeoutOrAbortOrResolve<T>(args: {\n  actionFn: () => Promise<T>;\n  timeoutMs: number;\n  timeoutMessage: string;\n  abortSignal?: AbortSignalLike;\n  // these are optional and only here for testing.\n  timeoutFunctions?: {\n    setTimeoutFn: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => any;\n    clearTimeoutFn: (timeoutId: any) => void;\n  };\n}): Promise<T> {\n  if (args.abortSignal && args.abortSignal.aborted) {\n    throw new AbortError(StandardAbortMessage);\n  }\n\n  let timer: any | undefined = undefined;\n  let clearAbortSignal: (() => void) | undefined = undefined;\n\n  const clearAbortSignalAndTimer = (): void => {\n    (args.timeoutFunctions?.clearTimeoutFn ?? clearTimeout)(timer);\n\n    if (clearAbortSignal) {\n      clearAbortSignal();\n    }\n  };\n\n  // eslint-disable-next-line promise/param-names\n  const abortOrTimeoutPromise = new Promise<T>((_resolve, reject) => {\n    clearAbortSignal = checkAndRegisterWithAbortSignal(reject, args.abortSignal);\n\n    timer = (args.timeoutFunctions?.setTimeoutFn ?? setTimeout)(() => {\n      reject(new OperationTimeoutError(args.timeoutMessage));\n    }, args.timeoutMs);\n  });\n\n  try {\n    return await Promise.race([abortOrTimeoutPromise, args.actionFn()]);\n  } finally {\n    clearAbortSignalAndTimer();\n  }\n}\n\n/**\n * Registers listener to the abort event on the abortSignal to call your abortFn and\n * returns a function that will clear the same listener.\n *\n * If abort signal is already aborted, then throws an AbortError and returns a function that does nothing\n *\n * @returns A function that removes any of our attached event listeners on the abort signal or an empty function if\n * the abortSignal was not defined.\n *\n * @internal\n * @hidden\n */\nexport function checkAndRegisterWithAbortSignal(\n  onAbortFn: (abortError: AbortError) => void,\n  abortSignal?: AbortSignalLike\n): () => void {\n  if (abortSignal == null) {\n    return () => {};\n  }\n\n  if (abortSignal.aborted) {\n    throw new AbortError(StandardAbortMessage);\n  }\n\n  const onAbort = (): void => {\n    abortSignal.removeEventListener(\"abort\", onAbort);\n    onAbortFn(new AbortError(StandardAbortMessage));\n  };\n\n  abortSignal.addEventListener(\"abort\", onAbort);\n\n  return () => abortSignal.removeEventListener(\"abort\", onAbort);\n}\n\n/**\n * @internal\n * @hidden\n * @property {string} libInfo The user agent prefix string for the ServiceBus client.\n * See guideline at https://azure.github.io/azure-sdk/general_azurecore.html#telemetry-policy\n */\nexport const libInfo: string = `azsdk-js-azureservicebus/${Constants.packageJsonInfo.version}`;\n\n/**\n * @internal\n * @hidden\n * Returns the formatted prefix by removing the spaces, by appending the libInfo.\n *\n * @param {string} [prefix]\n * @returns {string}\n */\nexport function formatUserAgentPrefix(prefix?: string): string {\n  let userAgentPrefix = `${(prefix || \"\").replace(\" \", \"\")}`;\n  userAgentPrefix = userAgentPrefix.length > 0 ? userAgentPrefix + \" \" : \"\";\n  return `${userAgentPrefix}${libInfo}`;\n}\n\n/**\n * @internal\n * @hidden\n * Helper method which returns `HttpResponse` from an object of shape `HttpOperationResponse`.\n * @returns {HttpResponse}\n */\nexport const getHttpResponseOnly = ({\n  request,\n  status,\n  headers\n}: HttpOperationResponse): HttpResponse => ({\n  request,\n  status,\n  headers\n});\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  HttpOperationResponse,\n  RestError,\n  ServiceClient,\n  WebResource,\n  parseXML,\n  stringifyXML,\n  stripRequest,\n  stripResponse,\n  RequestPrepareOptions,\n  OperationOptions\n} from \"@azure/core-http\";\n\nimport * as Constants from \"./constants\";\nimport { administrationLogger as logger } from \"../log\";\nimport { Buffer } from \"buffer\";\n\nimport { parseURL } from \"./parseUrl\";\nimport { isJSONLikeObject } from \"./utils\";\n\n/**\n * @internal\n * @hidden\n * Represents the internal ATOM XML serializer interface\n */\nexport interface AtomXmlSerializer {\n  serialize(requestBodyInJson: object): object;\n\n  deserialize(response: HttpOperationResponse): Promise<HttpOperationResponse>;\n}\n\n/**\n * @internal\n * @hidden\n * Utility to execute Atom XML operations as HTTP requests\n * @param webResource\n * @param serializer\n */\nexport async function executeAtomXmlOperation(\n  serviceBusAtomManagementClient: ServiceClient,\n  webResource: WebResource,\n  serializer: AtomXmlSerializer,\n  operationOptions: OperationOptions\n): Promise<HttpOperationResponse> {\n  if (webResource.body) {\n    const content: object = serializer.serialize(webResource.body);\n    webResource.body = stringifyXML(content, { rootName: \"entry\" });\n  }\n\n  if (webResource.method == \"PUT\") {\n    webResource.headers.set(\"content-length\", Buffer.byteLength(webResource.body));\n  }\n\n  logger.verbose(`Executing ATOM based HTTP request: ${webResource.body}`);\n\n  const reqPrepareOptions: RequestPrepareOptions = {\n    ...webResource,\n    headers: operationOptions.requestOptions?.customHeaders,\n    onUploadProgress: operationOptions.requestOptions?.onUploadProgress,\n    onDownloadProgress: operationOptions.requestOptions?.onDownloadProgress,\n    abortSignal: operationOptions.abortSignal,\n    spanOptions: operationOptions.tracingOptions?.spanOptions,\n    disableJsonStringifyOnBody: true\n  };\n  webResource = webResource.prepare(reqPrepareOptions);\n  webResource.timeout = operationOptions.requestOptions?.timeout || 0;\n  const response: HttpOperationResponse = await serviceBusAtomManagementClient.sendRequest(\n    webResource\n  );\n\n  logger.verbose(`Received ATOM based HTTP response: ${response.bodyAsText}`);\n\n  try {\n    if (response.bodyAsText) {\n      response.parsedBody = await parseXML(response.bodyAsText, { includeRoot: true });\n    }\n  } catch (err) {\n    const error = new RestError(\n      `Error occurred while parsing the response body - expected the service to return valid xml content.`,\n      RestError.PARSE_ERROR,\n      response.status,\n      stripRequest(response.request),\n      stripResponse(response)\n    );\n    logger.logError(err, \"Error parsing response body from Service\");\n    throw error;\n  }\n\n  return serializer.deserialize(response);\n}\n\n/**\n * @internal\n * @hidden\n * The key-value pairs having undefined/null as the values would lead to the empty tags in the serialized XML request.\n * Empty tags in the request body is problematic because of the following reasons.\n * - ATOM based management operations throw a \"Bad Request\" error if empty tags are included in the XML request body at top level.\n * - At the inner levels, Service assigns the empty strings as values to the empty tags instead of throwing an error.\n *\n * This method recursively removes the key-value pairs with undefined/null as the values from the request object that is to be serialized.\n *\n * @param {{ [key: string]: any }} resource\n */\nexport function sanitizeSerializableObject(resource: { [key: string]: any }) {\n  Object.keys(resource).forEach(function(property) {\n    if (resource[property] == undefined) {\n      delete resource[property];\n    } else if (isJSONLikeObject(resource[property])) {\n      sanitizeSerializableObject(resource[property]);\n    }\n  });\n}\n\n/**\n * @internal\n * @hidden\n * Serializes input information to construct the Atom XML request\n * @param resourceName Name of the resource to be serialized like `QueueDescription`\n * @param resource The entity details\n * @param allowedProperties The set of properties that are allowed by the service for the\n * associated operation(s);\n */\nexport function serializeToAtomXmlRequest(resourceName: string, resource: any): object {\n  const content: any = {};\n\n  content[resourceName] = Object.assign({}, resource);\n  sanitizeSerializableObject(content[resourceName]);\n\n  content[resourceName][Constants.XML_METADATA_MARKER] = {\n    xmlns: \"http://schemas.microsoft.com/netservices/2010/10/servicebus/connect\",\n    \"xmlns:i\": \"http://www.w3.org/2001/XMLSchema-instance\"\n  };\n\n  content[Constants.XML_METADATA_MARKER] = { type: \"application/xml\" };\n  const requestDetails: any = {\n    updated: new Date().toISOString(),\n    content: content\n  };\n  requestDetails[Constants.XML_METADATA_MARKER] = {\n    xmlns: \"http://www.w3.org/2005/Atom\"\n  };\n  return requestDetails;\n}\n\n/**\n * @internal\n * @hidden\n * Transforms response to contain the parsed data.\n * @param nameProperties The set of 'name' properties to be constructed on the\n * resultant object e.g., QueueName, TopicName, etc.\n * @param response\n * @param shouldParseResponse\n */\nexport async function deserializeAtomXmlResponse(\n  nameProperties: string[],\n  response: HttpOperationResponse\n): Promise<HttpOperationResponse> {\n  // If received data is a non-valid HTTP response, the body is expected to contain error information\n  if (response.status < 200 || response.status >= 300) {\n    throw buildError(response);\n  }\n\n  parseAtomResult(response, nameProperties);\n\n  return response;\n}\n\n/**\n * @internal\n * @hidden\n * Utility to deserialize the given JSON content in response body based on\n * if it's a single `entry` or `feed` and updates the `response.parsedBody` to hold the evaluated output.\n * @param response Response containing the JSON value in `response.parsedBody`\n * @nameProperties The set of 'name' properties to be constructed on the\n * resultant object e.g., QueueName, TopicName, etc.\n * */\nfunction parseAtomResult(response: HttpOperationResponse, nameProperties: string[]): void {\n  const atomResponseInJson = response.parsedBody;\n\n  let result: any;\n  if (!atomResponseInJson) {\n    response.parsedBody = undefined;\n    return;\n  }\n\n  if (atomResponseInJson.feed) {\n    result = parseFeedResult(atomResponseInJson.feed);\n  } else if (atomResponseInJson.entry) {\n    result = parseEntryResult(atomResponseInJson.entry);\n  }\n\n  if (result) {\n    if (Array.isArray(result)) {\n      result.forEach((entry: object) => {\n        setName(entry, nameProperties);\n      });\n    } else {\n      setName(result, nameProperties);\n    }\n    response.parsedBody = result;\n    return;\n  }\n\n  logger.warning(\n    \"Failure in parsing response body from service. Expected response to be in Atom XML format and have either feed or entry components, but received - %0\",\n    atomResponseInJson\n  );\n  throw new RestError(\n    \"Error occurred while parsing the response body - expected the service to return atom xml content with either feed or entry elements.\",\n    RestError.PARSE_ERROR,\n    response.status,\n    stripRequest(response.request),\n    stripResponse(response)\n  );\n}\n\n/**\n * @internal\n * @hidden\n * Utility to help parse given `entry` result\n * @param entry\n */\nfunction parseEntryResult(entry: any): object | undefined {\n  let result: any;\n\n  if (\n    typeof entry !== \"object\" ||\n    entry == null ||\n    typeof entry.content !== \"object\" ||\n    entry.content == null\n  ) {\n    return undefined;\n  }\n\n  const contentElementNames = Object.keys(entry.content).filter(function(key) {\n    return key !== Constants.XML_METADATA_MARKER;\n  });\n\n  if (contentElementNames && contentElementNames[0]) {\n    const contentRootElementName = contentElementNames[0];\n    delete entry.content[contentRootElementName][Constants.XML_METADATA_MARKER];\n    result = entry.content[contentRootElementName];\n\n    if (result) {\n      if (entry[Constants.XML_METADATA_MARKER]) {\n        result[Constants.ATOM_METADATA_MARKER] = entry[Constants.XML_METADATA_MARKER];\n      } else {\n        result[Constants.ATOM_METADATA_MARKER] = {};\n      }\n\n      result[Constants.ATOM_METADATA_MARKER][\"ContentRootElement\"] = contentRootElementName;\n\n      Object.keys(entry).forEach((property: string) => {\n        if (property !== \"content\" && property !== Constants.XML_METADATA_MARKER) {\n          result[Constants.ATOM_METADATA_MARKER][property] = entry[property];\n        }\n      });\n\n      return result;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * @internal\n * @hidden\n * Utility to help parse link info from the given `feed` result\n * @param feedLink\n */\nfunction parseLinkInfo(\n  feedLink: { [Constants.XML_METADATA_MARKER]: { rel: string; href: string } }[],\n  relationship: \"self\" | \"next\"\n): string | undefined {\n  if (!feedLink || !Array.isArray(feedLink)) {\n    return undefined;\n  }\n  for (const linkInfo of feedLink) {\n    if (linkInfo[Constants.XML_METADATA_MARKER].rel === relationship) {\n      return linkInfo[Constants.XML_METADATA_MARKER].href;\n    }\n  }\n  return undefined;\n}\n\n/**\n * @internal\n * @hidden\n * Utility to help parse given `feed` result\n * @param feed\n */\nfunction parseFeedResult(feed: any): object[] & { nextLink?: string } {\n  const result: object[] & { nextLink?: string } = [];\n  if (typeof feed === \"object\" && feed != null && feed.entry) {\n    if (Array.isArray(feed.entry)) {\n      feed.entry.forEach((entry: any) => {\n        const parsedEntryResult = parseEntryResult(entry);\n        if (parsedEntryResult) {\n          result.push(parsedEntryResult);\n        }\n      });\n    } else {\n      const parsedEntryResult = parseEntryResult(feed.entry);\n      if (parsedEntryResult) {\n        result.push(parsedEntryResult);\n      }\n    }\n    result.nextLink = parseLinkInfo(feed.link, \"next\");\n  }\n  return result;\n}\n\n/**\n * @internal\n * @hidden\n * @param {number} statusCode\n * @returns {statusCode is keyof typeof Constants.HttpResponseCodes}\n */\nfunction isKnownResponseCode(\n  statusCode: number\n): statusCode is keyof typeof Constants.HttpResponseCodes {\n  return !!(Constants.HttpResponseCodes as { [statusCode: number]: string })[statusCode];\n}\n\n/**\n * @internal\n * @hidden\n * Extracts the applicable entity name(s) from the URL based on the known structure\n * and instantiates the corresponding name properties to the deserialized response\n *\n * The pattern matching checks to extract entity names are based on following\n * constraints dictated by the service\n * - '/' is allowed in Queue and Topic names\n * - '/' is not allowed in Namespace, Subscription and Rule names\n * - Valid pathname URL structures used in the ATOM based management API are\n *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>/Rules/<rule-name>`\n *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>`\n *     - `<namespace-component>/<any-entity-name>`\n *\n * @param entry\n * @param nameProperties\n */\nfunction setName(entry: any, nameProperties: any): any {\n  if (entry[Constants.ATOM_METADATA_MARKER]) {\n    let rawUrl = entry[Constants.ATOM_METADATA_MARKER].id;\n\n    // The parsedUrl gets constructed differently for browser vs Node.\n    // It is specifically behaves different for some of the Atom based management API where\n    // the received URL in \"id\" element is of type \"sb:// ... \" and not a standard HTTP one\n    // Hence, normalizing the URL for parsing to work as expected in browser\n    if (rawUrl.startsWith(\"sb://\")) {\n      rawUrl = \"https://\" + rawUrl.substring(5);\n    }\n\n    const parsedUrl = parseURL(rawUrl);\n    const pathname: string = parsedUrl.pathname;\n\n    const firstIndexOfDelimiter = pathname.indexOf(\"/\");\n\n    if (pathname.match(\"(.*)/(.*)/Subscriptions/(.*)/Rules/(.*)\")) {\n      const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf(\"/Subscriptions/\");\n      const firstIndexOfRulesDelimiter = pathname.indexOf(\"/Rules/\");\n      entry[nameProperties[0]] = pathname.substring(\n        firstIndexOfDelimiter + 1,\n        lastIndexOfSubscriptionsDelimiter\n      );\n      entry[nameProperties[1]] = pathname.substring(\n        lastIndexOfSubscriptionsDelimiter + 15,\n        firstIndexOfRulesDelimiter\n      );\n      entry[nameProperties[2]] = pathname.substring(firstIndexOfRulesDelimiter + 7);\n    } else if (pathname.match(\"(.*)/(.*)/Subscriptions/(.*)\")) {\n      const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf(\"/Subscriptions/\");\n      entry[nameProperties[0]] = pathname.substring(\n        firstIndexOfDelimiter + 1,\n        lastIndexOfSubscriptionsDelimiter\n      );\n      entry[nameProperties[1]] = pathname.substring(lastIndexOfSubscriptionsDelimiter + 15);\n    } else if (pathname.match(\"(.*)/(.*)\")) {\n      entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1);\n    }\n  }\n}\n\n/**\n * @internal\n * @hidden\n * Utility to help construct the normalized `RestError` object based on given error\n * information and other data present in the received `response` object.\n * @param response\n */\nexport function buildError(response: HttpOperationResponse): RestError {\n  if (!isKnownResponseCode(response.status)) {\n    throw new RestError(\n      `Service returned an error response with an unrecognized HTTP status code - ${response.status}`,\n      \"ServiceError\",\n      response.status,\n      stripRequest(response.request),\n      stripResponse(response)\n    );\n  }\n\n  const errorBody = response.parsedBody;\n  let errorMessage;\n  if (typeof errorBody === \"string\") {\n    errorMessage = errorBody;\n  } else {\n    if (\n      errorBody == undefined ||\n      errorBody.Error == undefined ||\n      errorBody.Error.Detail == undefined\n    ) {\n      errorMessage =\n        \"Detailed error message information not available. Look at the 'code' property on error for more information.\";\n    } else {\n      errorMessage = errorBody.Error.Detail;\n    }\n  }\n\n  const errorCode = getErrorCode(response, errorMessage);\n\n  const error: RestError = new RestError(\n    errorMessage,\n    errorCode,\n    response.status,\n    stripRequest(response.request),\n    stripResponse(response)\n  );\n  return error;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to construct user friendly error codes based on based on given error\n * information and other data present in the received `response` object.\n * @param response\n * @param errorMessage\n */\nfunction getErrorCode(response: HttpOperationResponse, errorMessage: string): string {\n  if (response.status == 401) {\n    return \"UnauthorizedRequestError\";\n  }\n  if (response.status == 404) {\n    return \"MessageEntityNotFoundError\";\n  }\n  if (response.status == 409) {\n    if (response.request.method == \"DELETE\") {\n      return \"ServiceError\";\n    }\n\n    if (response.request.method == \"PUT\" && response.request.headers.get(\"If-Match\") == \"*\") {\n      return \"ServiceError\";\n    }\n\n    if (errorMessage && errorMessage.toLowerCase().includes(\"subcode=40901\")) {\n      return \"ServiceError\";\n    }\n\n    return \"MessageEntityAlreadyExistsError\";\n  }\n\n  if (response.status == 403) {\n    if (errorMessage && errorMessage.toLowerCase().includes(\"subcode=40301\")) {\n      return \"InvalidOperationError\";\n    }\n    return \"QuotaExceededError\";\n  }\n\n  if (response.status == 400) {\n    return \"ServiceError\";\n  }\n\n  if (response.status == 503) {\n    return \"ServerBusyError\";\n  }\n\n  return (Constants.HttpResponseCodes as { [statusCode: number]: string })[response.status];\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpOperationResponse } from \"@azure/core-http\";\nimport {\n  AtomXmlSerializer,\n  deserializeAtomXmlResponse,\n  serializeToAtomXmlRequest\n} from \"../util/atomXmlHelper\";\nimport { getInteger, getString, getDate } from \"../util/utils\";\n\n/**\n * Represents the metadata related to a service bus namespace.\n *\n * @export\n * @interface NamespaceProperties\n */\nexport interface NamespaceProperties {\n  /**\n   * The time at which the namespace was created.\n   */\n  createdAt: Date;\n  /**\n   * The SKU/tier of the namespace.\n   * \"Basic\", \"Standard\" and \"Premium\"\n   */\n  messagingSku: \"Basic\" | \"Premium\" | \"Standard\";\n  /**\n   * The last time at which the namespace was modified.\n   */\n  modifiedAt: Date;\n  /**\n   * Name of the namespace.\n   */\n  name: string;\n  /**\n   * Number of messaging units allocated for namespace.\n   * Valid only for Premium namespaces.\n   * messagingUnits would be set to `undefined` for Basic and Standard namespaces.\n   */\n  messagingUnits: number | undefined;\n}\n\n/**\n * @internal\n * @hidden\n * Builds the namespace object from the raw json object gotten after deserializing the\n * response from the service\n * @param rawNamespace\n */\nexport function buildNamespace(rawNamespace: any): NamespaceProperties {\n  const messagingSku = <\"Basic\" | \"Premium\" | \"Standard\">(\n    getString(rawNamespace[\"MessagingSKU\"], \"messagingSku\")\n  );\n  return {\n    createdAt: getDate(rawNamespace[\"CreatedTime\"], \"createdAt\"),\n    messagingSku: messagingSku,\n    modifiedAt: getDate(rawNamespace[\"ModifiedTime\"], \"modifiedAt\"),\n    name: getString(rawNamespace[\"Name\"], \"name\"),\n    messagingUnits:\n      messagingSku === \"Premium\"\n        ? getInteger(rawNamespace[\"MessagingUnits\"], \"messagingUnits\")\n        : undefined\n  };\n}\n\n/**\n * @internal\n * @hidden\n * Atom XML Serializer for Namespaces.\n */\nexport class NamespaceResourceSerializer implements AtomXmlSerializer {\n  serialize(): object {\n    return serializeToAtomXmlRequest(\"NamespaceProperties\", {});\n  }\n\n  async deserialize(response: HttpOperationResponse): Promise<HttpOperationResponse> {\n    return deserializeAtomXmlResponse([\"name\"], response);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpOperationResponse, OperationOptions } from \"@azure/core-http\";\nimport {\n  AtomXmlSerializer,\n  deserializeAtomXmlResponse,\n  serializeToAtomXmlRequest\n} from \"../util/atomXmlHelper\";\nimport * as Constants from \"../util/constants\";\nimport {\n  AuthorizationRule,\n  getAuthorizationRulesOrUndefined,\n  getBoolean,\n  getMessageCountDetails,\n  getInteger,\n  getIntegerOrUndefined,\n  getRawAuthorizationRules,\n  getString,\n  getStringOrUndefined,\n  getDate,\n  EntityStatus,\n  EntityAvailabilityStatus\n} from \"../util/utils\";\n\n/**\n * @internal\n * @hidden\n * Builds the queue options object from the user provided options.\n * Handles the differences in casing for the property names,\n * converts values to string and ensures the right order as expected by the service\n * @param queue\n */\nexport function buildQueueOptions(queue: CreateQueueOptions): InternalQueueOptions {\n  return {\n    LockDuration: queue.lockDuration,\n    MaxSizeInMegabytes: getStringOrUndefined(queue.maxSizeInMegabytes),\n    RequiresDuplicateDetection: getStringOrUndefined(queue.requiresDuplicateDetection),\n    RequiresSession: getStringOrUndefined(queue.requiresSession),\n    DefaultMessageTimeToLive: queue.defaultMessageTimeToLive,\n    DeadLetteringOnMessageExpiration: getStringOrUndefined(queue.deadLetteringOnMessageExpiration),\n    DuplicateDetectionHistoryTimeWindow: queue.duplicateDetectionHistoryTimeWindow,\n    MaxDeliveryCount: getStringOrUndefined(queue.maxDeliveryCount),\n    EnableBatchedOperations: getStringOrUndefined(queue.enableBatchedOperations),\n    AuthorizationRules: getRawAuthorizationRules(queue.authorizationRules),\n    Status: getStringOrUndefined(queue.status),\n    AutoDeleteOnIdle: getStringOrUndefined(queue.autoDeleteOnIdle),\n    EnablePartitioning: getStringOrUndefined(queue.enablePartitioning),\n    ForwardDeadLetteredMessagesTo: getStringOrUndefined(queue.forwardDeadLetteredMessagesTo),\n    ForwardTo: getStringOrUndefined(queue.forwardTo),\n    UserMetadata: getStringOrUndefined(queue.userMetadata),\n    EntityAvailabilityStatus: getStringOrUndefined(queue.availabilityStatus),\n    EnableExpress: getStringOrUndefined(queue.enableExpress)\n  };\n}\n\n/**\n * @internal\n * @hidden\n * Builds the queue object from the raw json object gotten after deserializing the\n * response from the service\n * @param rawQueue\n */\nexport function buildQueue(rawQueue: any): QueueProperties {\n  return {\n    name: getString(rawQueue[Constants.QUEUE_NAME], \"queueName\"),\n\n    forwardTo: getStringOrUndefined(rawQueue[Constants.FORWARD_TO]),\n    userMetadata: rawQueue[Constants.USER_METADATA],\n\n    lockDuration: getString(rawQueue[Constants.LOCK_DURATION], \"lockDuration\"),\n    maxSizeInMegabytes: getInteger(rawQueue[Constants.MAX_SIZE_IN_MEGABYTES], \"maxSizeInMegabytes\"),\n\n    maxDeliveryCount: getInteger(rawQueue[Constants.MAX_DELIVERY_COUNT], \"maxDeliveryCount\"),\n\n    enablePartitioning: getBoolean(rawQueue[Constants.ENABLE_PARTITIONING], \"enablePartitioning\"),\n    requiresSession: getBoolean(rawQueue[Constants.REQUIRES_SESSION], \"requiresSession\"),\n    enableBatchedOperations: getBoolean(\n      rawQueue[Constants.ENABLE_BATCHED_OPERATIONS],\n      \"enableBatchedOperations\"\n    ),\n\n    defaultMessageTimeToLive: getString(\n      rawQueue[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE],\n      \"defaultMessageTimeToLive\"\n    ),\n    autoDeleteOnIdle: rawQueue[Constants.AUTO_DELETE_ON_IDLE],\n\n    requiresDuplicateDetection: getBoolean(\n      rawQueue[Constants.REQUIRES_DUPLICATE_DETECTION],\n      \"requiresDuplicateDetection\"\n    ),\n    duplicateDetectionHistoryTimeWindow: getString(\n      rawQueue[Constants.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW],\n      \"duplicateDetectionHistoryTimeWindow\"\n    ),\n    deadLetteringOnMessageExpiration: getBoolean(\n      rawQueue[Constants.DEAD_LETTERING_ON_MESSAGE_EXPIRATION],\n      \"deadLetteringOnMessageExpiration\"\n    ),\n    forwardDeadLetteredMessagesTo: getStringOrUndefined(\n      rawQueue[Constants.FORWARD_DEADLETTERED_MESSAGES_TO]\n    ),\n\n    authorizationRules: getAuthorizationRulesOrUndefined(rawQueue[Constants.AUTHORIZATION_RULES]),\n\n    status: rawQueue[Constants.STATUS],\n\n    enableExpress: getBoolean(rawQueue[Constants.ENABLE_EXPRESS], \"enableExpress\"),\n\n    availabilityStatus: rawQueue[Constants.ENTITY_AVAILABILITY_STATUS]\n  };\n}\n\n/**\n * @internal\n * @hidden\n * Builds the queue runtime info object from the raw json object gotten after deserializing the\n * response from the service\n * @param rawQueue\n */\nexport function buildQueueRuntimeProperties(rawQueue: any): QueueRuntimeProperties {\n  const messageCountDetails = getMessageCountDetails(rawQueue[Constants.COUNT_DETAILS]);\n  return {\n    name: getString(rawQueue[Constants.QUEUE_NAME], \"queueName\"),\n    sizeInBytes: getIntegerOrUndefined(rawQueue[Constants.SIZE_IN_BYTES]),\n    totalMessageCount: getIntegerOrUndefined(rawQueue[Constants.MESSAGE_COUNT]),\n    ...messageCountDetails,\n    createdAt: getDate(rawQueue[Constants.CREATED_AT], \"createdAt\"),\n    modifiedAt: getDate(rawQueue[Constants.UPDATED_AT], \"modifiedAt\"),\n    accessedAt: getDate(rawQueue[Constants.ACCESSED_AT], \"accessedAt\")\n  };\n}\n\n/**\n * Represents settable options on a queue\n */\nexport interface CreateQueueOptions extends OperationOptions {\n  /**\n   * Determines the amount of time in seconds in which a message should be locked for\n   * processing by a receiver. After this period, the message is unlocked and available\n   * for consumption by the next receiver.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  lockDuration?: string;\n\n  /**\n   * Specifies the maximum queue size in megabytes. Any attempt to enqueue a message that\n   * will cause the queue to exceed this value will fail.\n   */\n  maxSizeInMegabytes?: number;\n\n  /**\n   * If enabled, the topic will detect duplicate messages within the time\n   * span specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at queue creation time.\n   */\n  requiresDuplicateDetection?: boolean;\n\n  /**\n   * If set to true, the queue will be session-aware and only SessionReceiver\n   * will be supported. Session-aware queues are not supported through REST.\n   * Settable only at queue creation time.\n   */\n  requiresSession?: boolean;\n\n  /**\n   * Depending on whether DeadLettering is enabled, a message is automatically\n   * moved to the dead-letter sub-queue or deleted if it has been stored in the\n   * queue for longer than the specified time.\n   * This value is overwritten by a TTL specified on the message\n   * if and only if the message TTL is smaller than the TTL set on the queue.\n   * This value is immutable after the Queue has been created.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive?: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message\n   * from the queue into the queue’s dead-letter sub-queue. If disabled,\n   * message will be permanently deleted from the queue.\n   * Settable only at queue creation time.\n   */\n  deadLetteringOnMessageExpiration?: boolean;\n\n  /**\n   * Specifies the time span during which the Service Bus detects message duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  duplicateDetectionHistoryTimeWindow?: string;\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   */\n  maxDeliveryCount?: number;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations?: boolean;\n\n  /**\n   * Authorization rules on the queue\n   */\n  authorizationRules?: AuthorizationRule[];\n\n  /**\n   * Status of the messaging entity.\n   */\n  status?: EntityStatus;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the queue.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle?: string;\n\n  /**\n   * Specifies whether the queue should be partitioned.\n   */\n  enablePartitioning?: boolean;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Specifies whether express entities are enabled on queue.\n   */\n  enableExpress?: boolean;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  availabilityStatus?: EntityAvailabilityStatus;\n}\n\n/**\n * Represents the input for updateQueue.\n *\n * @export\n * @interface QueueProperties\n */\nexport interface QueueProperties {\n  /**\n   * Name of the queue\n   */\n  readonly name: string;\n\n  /**\n   * Determines the amount of time in seconds in which a message should be locked for\n   * processing by a receiver. After this period, the message is unlocked and available\n   * for consumption by the next receiver.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  lockDuration: string;\n\n  /**\n   * Specifies the maximum queue size in megabytes. Any attempt to enqueue a message that\n   * will cause the queue to exceed this value will fail.\n   */\n  maxSizeInMegabytes: number;\n\n  /**\n   * If enabled, the topic will detect duplicate messages within the time\n   * span specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at queue creation time.\n   */\n  readonly requiresDuplicateDetection: boolean;\n\n  /**\n   * If set to true, the queue will be session-aware and only SessionReceiver\n   * will be supported. Session-aware queues are not supported through REST.\n   * Settable only at queue creation time.\n   */\n  readonly requiresSession: boolean;\n\n  /**\n   * Depending on whether DeadLettering is enabled, a message is automatically\n   * moved to the dead-letter sub-queue or deleted if it has been stored in the\n   * queue for longer than the specified time.\n   * This value is overwritten by a TTL specified on the message\n   * if and only if the message TTL is smaller than the TTL set on the queue.\n   * This value is immutable after the Queue has been created.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message\n   * from the queue into the queue’s dead-letter sub-queue. If disabled,\n   * message will be permanently deleted from the queue.\n   * Settable only at queue creation time.\n   */\n  deadLetteringOnMessageExpiration: boolean;\n\n  /**\n   * Specifies the time span during which the Service Bus detects message duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  duplicateDetectionHistoryTimeWindow: string;\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   */\n  maxDeliveryCount: number;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations: boolean;\n\n  /**\n   * Authorization rules on the queue\n   */\n  authorizationRules?: AuthorizationRule[];\n\n  /**\n   * Status of the messaging entity.\n   */\n  status: EntityStatus;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the queue.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle: string;\n\n  /**\n   * Specifies whether the queue should be partitioned.\n   */\n  readonly enablePartitioning: boolean;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Specifies whether express entities are enabled on queue.\n   */\n  readonly enableExpress: boolean;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  readonly availabilityStatus: EntityAvailabilityStatus;\n}\n/**\n * @internal\n * @hidden\n * Internal representation of settable options on a queue\n */\nexport interface InternalQueueOptions {\n  /**\n   * Determines the amount of time in seconds in which a message should be locked for\n   * processing by a receiver. After this period, the message is unlocked and\n   * can be consumed by the next receiver.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  LockDuration?: string;\n\n  /**\n   * The max size in MegaBytes\n   *\n   */\n  MaxSizeInMegabytes?: string;\n\n  /**\n   *  If enabled, the topic will detect duplicate messages within the time\n   * span specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at queue creation time.\n   */\n  RequiresDuplicateDetection?: string;\n\n  /**\n   * If set to true, the queue will be session-aware and only SessionReceiver\n   * will be supported. Session-aware queues are not supported through REST.\n   * Settable only at queue creation time.\n   */\n  RequiresSession?: string;\n\n  /**\n   * Depending on whether DeadLettering is enabled, a message is automatically moved to\n   * the DeadLetterQueue or deleted if it has been stored in the queue for longer than\n   * the specified time. This value is overwritten by a TTL specified on the message\n   * if and only if the message TTL is smaller than the TTL set on the queue.\n   * This value is immutable after the Queue has been created.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  DefaultMessageTimeToLive?: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message\n   * from the queue into the queue’s dead-letter sub-queue. If disabled,\n   * message will be permanently deleted from the queue.\n   * Settable only at queue creation time.\n   */\n  DeadLetteringOnMessageExpiration?: string;\n\n  /**\n   * Specifies the time span during which the Service Bus detects message duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  DuplicateDetectionHistoryTimeWindow?: string;\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   *\n   */\n  MaxDeliveryCount?: string;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  EnableBatchedOperations?: string;\n\n  /**\n   * Authorization rules on the queue\n   */\n  AuthorizationRules?: any;\n\n  /**\n   * Status of the messaging entity.\n   */\n  Status?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  ForwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the queue.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  UserMetadata?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  AutoDeleteOnIdle?: string;\n\n  /**\n   * Specifies whether the queue should be partitioned.\n   */\n  EnablePartitioning?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  ForwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Specifies whether express entities are enabled on queue.\n   */\n  EnableExpress?: string;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  EntityAvailabilityStatus?: string;\n}\n\n/**\n * Represents runtime info attributes of a queue entity\n */\nexport interface QueueRuntimeProperties {\n  /**\n   * Name of the queue\n   */\n  name: string;\n\n  /**\n   * Created at timestamp\n   */\n  createdAt: Date;\n\n  /**\n   * Updated at timestamp\n   */\n  modifiedAt: Date;\n\n  /**\n   * Accessed at timestamp\n   */\n  accessedAt: Date;\n\n  /**\n   * The entity's message count.\n   *\n   */\n  totalMessageCount?: number;\n\n  /**\n   * The number of active messages in the queue.\n   */\n  activeMessageCount: number;\n\n  /**\n   * The number of messages that have been dead lettered.\n   */\n  deadLetterMessageCount: number;\n\n  /**\n   * The number of scheduled messages.\n   */\n  scheduledMessageCount: number;\n\n  /**\n   * The number of messages transferred to another queue, topic, or subscription\n   */\n  transferMessageCount: number;\n\n  /**\n   * The number of messages transferred to the dead letter queue.\n   */\n  transferDeadLetterMessageCount: number;\n\n  /**\n   * The entity's size in bytes.\n   *\n   */\n  sizeInBytes?: number;\n}\n\n/**\n * @internal\n * @hidden\n * Atom XML Serializer for Queues.\n */\nexport class QueueResourceSerializer implements AtomXmlSerializer {\n  serialize(resource: InternalQueueOptions): object {\n    return serializeToAtomXmlRequest(\"QueueDescription\", resource);\n  }\n\n  async deserialize(response: HttpOperationResponse): Promise<HttpOperationResponse> {\n    return deserializeAtomXmlResponse([\"QueueName\"], response);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpOperationResponse } from \"@azure/core-http\";\nimport { CorrelationRuleFilter } from \"../core/managementClient\";\nimport {\n  AtomXmlSerializer,\n  deserializeAtomXmlResponse,\n  serializeToAtomXmlRequest\n} from \"../util/atomXmlHelper\";\nimport * as Constants from \"../util/constants\";\nimport { getString, getStringOrUndefined } from \"../util/utils\";\n\n/**\n * @internal\n * @hidden\n * Builds the rule object from the raw json object gotten after deserializing the\n * response from the service\n * @param rawRule\n */\nexport function buildRule(rawRule: any): RuleProperties {\n  return {\n    name: getString(rawRule[\"RuleName\"], \"ruleName\"),\n    filter: getTopicFilter(rawRule[\"Filter\"]),\n    action: getRuleAction(rawRule[\"Action\"])\n  };\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to retrieve `filter` value from given input,\n * or undefined if not passed in.\n * @param value\n */\nfunction getTopicFilter(value: any): SqlRuleFilter | CorrelationRuleFilter {\n  let result: SqlRuleFilter | CorrelationRuleFilter;\n\n  if (value[\"SqlExpression\"] != undefined) {\n    result = {\n      sqlExpression: value[\"SqlExpression\"],\n      sqlParameters: getKeyValuePairsOrUndefined(value[\"Parameters\"], \"SQLParameters\")\n    };\n  } else {\n    result = {\n      correlationId: getStringOrUndefined(value[\"CorrelationId\"]),\n      subject: getStringOrUndefined(value[\"Label\"]),\n      to: getStringOrUndefined(value[\"To\"]),\n      replyTo: getStringOrUndefined(value[\"ReplyTo\"]),\n      replyToSessionId: getStringOrUndefined(value[\"ReplyToSessionId\"]),\n      sessionId: getStringOrUndefined(value[\"SessionId\"]),\n      messageId: getStringOrUndefined(value[\"MessageId\"]),\n      contentType: getStringOrUndefined(value[\"ContentType\"]),\n      applicationProperties: getKeyValuePairsOrUndefined(\n        value[\"Properties\"],\n        \"ApplicationProperties\"\n      )\n    };\n  }\n  return result;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to retrieve rule `action` value from given input.\n * @param value\n */\nfunction getRuleAction(value: any): SqlRuleAction {\n  return {\n    sqlExpression: value[\"SqlExpression\"],\n    sqlParameters: getKeyValuePairsOrUndefined(value[\"Parameters\"], \"SQLParameters\")\n  };\n}\n\n/**\n * Represents the options to create a rule for a subscription.\n * @internal\n * @hidden\n */\nexport interface CreateRuleOptions {\n  /**\n   * Name of the rule\n   */\n  name: string;\n\n  /**\n   * Defines the filter expression that the rule evaluates. For `SqlRuleFilter` input,\n   * the expression string is interpreted as a SQL92 expression which must\n   * evaluate to True or False. Only one between a `CorrelationRuleFilter` or\n   * a `SqlRuleFilter` can be defined.\n   */\n  filter?: SqlRuleFilter | CorrelationRuleFilter;\n\n  /**\n   * The SQL like expression that can be executed on the message should the\n   * associated filter apply.\n   */\n  action?: SqlRuleAction;\n}\n\n/**\n * Represents all the attributes of a rule.\n */\nexport interface RuleProperties {\n  /**\n   * Name of the rule\n   */\n  readonly name: string;\n\n  /**\n   * Defines the filter expression that the rule evaluates. For `SqlRuleFilter` input,\n   * the expression string is interpreted as a SQL92 expression which must\n   * evaluate to True or False. Only one between a `CorrelationRuleFilter` or\n   * a `SqlRuleFilter` can be defined.\n   */\n  filter: SqlRuleFilter | CorrelationRuleFilter;\n\n  /**\n   * The SQL like expression that can be executed on the message should the\n   * associated filter apply.\n   */\n  action: SqlRuleAction;\n}\n\n/**\n * Represents all possible fields on SqlRuleAction\n */\nexport type SqlRuleAction = {\n  /**\n   * SQL expression to use in the rule action.\n   */\n  sqlExpression?: string;\n\n  /**\n   * SQL parameters to the SQL expression in the rule action.\n   */\n  sqlParameters?: { [key: string]: string | number | boolean };\n};\n\n/**\n * Represents all possible fields on SqlRuleFilter\n */\nexport interface SqlRuleFilter {\n  /**\n   * SQL expression to use in the rule filter.\n   * Defaults to creating a true filter if none specified\n   */\n  sqlExpression: string;\n\n  /**\n   * SQL parameters to the SQL expression in the rule filter.\n   */\n  sqlParameters?: { [key: string]: string | number | boolean };\n}\n\n/**\n * @internal\n * @hidden\n *\n * @interface InternalRuleOptions\n */\nexport interface InternalRuleOptions {\n  Name: string;\n  Filter: any;\n  Action: any;\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {CreateRuleOptions} rule\n */\nexport function buildInternalRuleResource(rule: CreateRuleOptions): InternalRuleOptions {\n  const resource: InternalRuleOptions = {\n    Filter: {},\n    Action: {},\n    Name: rule.name\n  };\n\n  if (rule.filter == undefined) {\n    // Defaults to creating a true filter if none specified\n    resource.Filter = {\n      SqlExpression: \"1=1\"\n    };\n    resource.Filter[Constants.XML_METADATA_MARKER] = {\n      \"p4:type\": \"SqlFilter\",\n      \"xmlns:p4\": \"http://www.w3.org/2001/XMLSchema-instance\"\n    };\n  } else {\n    if (rule.filter.hasOwnProperty(\"sqlExpression\")) {\n      const sqlFilter: SqlRuleFilter = rule.filter as SqlRuleFilter;\n      resource.Filter = {\n        SqlExpression: sqlFilter.sqlExpression,\n        Parameters: buildInternalRawKeyValuePairs(sqlFilter.sqlParameters, \"sqlParameters\")\n      };\n      resource.Filter[Constants.XML_METADATA_MARKER] = {\n        \"p4:type\": \"SqlFilter\",\n        \"xmlns:p4\": \"http://www.w3.org/2001/XMLSchema-instance\"\n      };\n    } else {\n      const correlationFilter: CorrelationRuleFilter = rule.filter as CorrelationRuleFilter;\n\n      resource.Filter = {\n        CorrelationId: correlationFilter.correlationId,\n        Label: correlationFilter.subject,\n        To: correlationFilter.to,\n        ReplyTo: correlationFilter.replyTo,\n        ReplyToSessionId: correlationFilter.replyToSessionId,\n        ContentType: correlationFilter.contentType,\n        SessionId: correlationFilter.sessionId,\n        MessageId: correlationFilter.messageId,\n        Properties: buildInternalRawKeyValuePairs(\n          correlationFilter.applicationProperties,\n          \"applicationProperties\"\n        )\n      };\n      resource.Filter[Constants.XML_METADATA_MARKER] = {\n        \"p4:type\": \"CorrelationFilter\",\n        \"xmlns:p4\": \"http://www.w3.org/2001/XMLSchema-instance\"\n      };\n    }\n  }\n\n  if (rule.action == undefined || rule.action.sqlExpression == undefined) {\n    // Defaults to creating an empty rule action instance if none specified\n    resource.Action = {};\n    resource.Action[Constants.XML_METADATA_MARKER] = {\n      \"p4:type\": \"EmptyRuleAction\",\n      \"xmlns:p4\": \"http://www.w3.org/2001/XMLSchema-instance\"\n    };\n  } else {\n    resource.Action = {\n      SqlExpression: rule.action.sqlExpression,\n      Parameters: buildInternalRawKeyValuePairs(rule.action.sqlParameters, \"sqlParameters\")\n    };\n    resource.Action[Constants.XML_METADATA_MARKER] = {\n      \"p4:type\": \"SqlRuleAction\",\n      \"xmlns:p4\": \"http://www.w3.org/2001/XMLSchema-instance\"\n    };\n  }\n\n  return resource;\n}\n\n/**\n * @internal\n * @hidden\n * RuleResourceSerializer for serializing / deserializing Rule entities\n */\nexport class RuleResourceSerializer implements AtomXmlSerializer {\n  serialize(rule: RuleProperties): object {\n    return serializeToAtomXmlRequest(\"RuleDescription\", buildInternalRuleResource(rule));\n  }\n\n  async deserialize(response: HttpOperationResponse): Promise<HttpOperationResponse> {\n    return deserializeAtomXmlResponse([\"TopicName\", \"SubscriptionName\", \"RuleName\"], response);\n  }\n}\n\n/**\n * @internal\n * @hidden\n */\nexport function isSqlRuleAction(action: any): action is SqlRuleAction {\n  return action != null && typeof action === \"object\" && \"sqlExpression\" in action;\n}\n\n/**\n * Service expects the XML request with the special type names serialized in the request,\n * the request would fail otherwise.\n *\n * @internal\n * @hidden\n */\nenum TypeMapForRequestSerialization {\n  double = \"l28:double\",\n  string = \"l28:string\",\n  long = \"l28:long\",\n  date = \"l28:dateTime\",\n  boolean = \"l28:boolean\"\n}\n\n/**\n * @internal\n * @hidden\n */\nenum TypeMapForResponseDeserialization {\n  int = \"int\",\n  double = \"double\",\n  string = \"string\",\n  boolean = \"boolean\",\n  date = \"dateTime\"\n}\n\n/**\n * @internal\n * @hidden\n * Internal representation of key-value pair\n */\ntype RawKeyValuePair = {\n  Key: string;\n  Value: any;\n};\n\n/**\n * @internal\n * @hidden\n */\ninterface InternalRawKeyValuePairs {\n  KeyValueOfstringanyType: RawKeyValuePair[];\n}\n\n/**\n * Key-value pairs are supposed to be wrapped with this tag in the XML request, they are ignored otherwise.\n *\n * @internal\n * @hidden\n */\nconst keyValuePairXMLTag = \"KeyValueOfstringanyType\";\n\n/**\n * @internal\n * @hidden\n * Helper utility to retrieve the key-value pairs from the RawKeyValue object from given input,\n * or undefined if not passed in.\n * @param value\n */\nfunction getKeyValuePairsOrUndefined(\n  value: any,\n  attribute: \"ApplicationProperties\" | \"SQLParameters\"\n): { [key: string]: any } | undefined {\n  if (!value) {\n    return undefined;\n  }\n  const properties: any = {};\n  let rawProperties;\n  if (!Array.isArray(value[keyValuePairXMLTag]) && value[keyValuePairXMLTag]?.Key) {\n    // When a single property is present,\n    //    value[\"KeyValueOfstringanyType\"] is { Key: <key>, Value: [Object] }\n    // When multiple properties are present,\n    //    value[\"KeyValueOfstringanyType\"] is [ { Key: <key-1>, Value: [Object] }, { Key: <key-2>, Value: [Object] } ]\n    // For consistency, wrapping `value[\"KeyValueOfstringanyType\"]` as an array for the \"single property\" case.\n    rawProperties = [value[keyValuePairXMLTag]];\n  } else {\n    rawProperties = value[keyValuePairXMLTag];\n  }\n  if (Array.isArray(rawProperties)) {\n    for (const rawProperty of rawProperties) {\n      const key = rawProperty.Key;\n      const value = rawProperty.Value[\"_\"];\n      const encodedValueType = rawProperty.Value[\"$\"][\"i:type\"].toString().substring(5);\n      if (\n        encodedValueType === TypeMapForResponseDeserialization.int ||\n        encodedValueType === TypeMapForResponseDeserialization.double\n      ) {\n        properties[key] = Number(value);\n      } else if (encodedValueType === TypeMapForResponseDeserialization.string) {\n        properties[key] = value;\n      } else if (encodedValueType === TypeMapForResponseDeserialization.boolean) {\n        properties[key] = value === \"true\" ? true : false;\n      } else if (encodedValueType === TypeMapForResponseDeserialization.date) {\n        properties[key] = new Date(value);\n      } else {\n        throw new TypeError(\n          `Unable to parse the key-value pairs in the response - ${JSON.stringify(rawProperty)}`\n        );\n      }\n    }\n  } else {\n    throw new TypeError(\n      `${attribute} in the response is not an array, unable to parse the response - ${JSON.stringify(\n        value\n      )}`\n    );\n  }\n  return properties;\n}\n\n/**\n * @internal\n * @hidden\n * Helper utility to extract array of user properties key-value instances from given input,\n * or undefined if not passed in.\n * @param value\n */\nexport function buildInternalRawKeyValuePairs(\n  parameters: { [key: string]: any } | undefined,\n  attribute: \"applicationProperties\" | \"sqlParameters\"\n): InternalRawKeyValuePairs | undefined {\n  if (parameters == undefined) {\n    return undefined;\n  }\n  if (\n    Array.isArray(parameters) ||\n    typeof parameters === \"string\" ||\n    typeof parameters !== \"object\" ||\n    Object.entries(parameters).length < 1\n  ) {\n    throw new TypeError(\n      `Unsupported value for the ${attribute} ${JSON.stringify(\n        parameters\n      )}, expected a JSON object with key-value pairs.`\n    );\n  }\n  const rawParameters: RawKeyValuePair[] = [];\n  for (let [key, value] of Object.entries(parameters)) {\n    let type: string | number | boolean;\n    if (typeof value === \"number\") {\n      type = TypeMapForRequestSerialization.double;\n    } else if (typeof value === \"string\") {\n      type = TypeMapForRequestSerialization.string;\n    } else if (typeof value === \"boolean\") {\n      type = TypeMapForRequestSerialization.boolean;\n    } else if (value instanceof Date && !isNaN(value.valueOf())) {\n      type = TypeMapForRequestSerialization.date;\n      value = value.toJSON();\n    } else {\n      throw new TypeError(\n        `Unsupported type for the value in the ${attribute} for the key '${key}'`\n      );\n    }\n\n    const rawParameter: RawKeyValuePair = {\n      Key: key,\n      Value: {\n        [Constants.XML_METADATA_MARKER]: {\n          \"p4:type\": type,\n          \"xmlns:l28\": \"http://www.w3.org/2001/XMLSchema\"\n        },\n        [Constants.XML_VALUE_MARKER]: value\n      }\n    };\n    rawParameters.push(rawParameter);\n  }\n  return {\n    [keyValuePairXMLTag]: rawParameters\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpOperationResponse, OperationOptions } from \"@azure/core-http\";\nimport { CorrelationRuleFilter } from \"..\";\nimport {\n  AtomXmlSerializer,\n  deserializeAtomXmlResponse,\n  serializeToAtomXmlRequest\n} from \"../util/atomXmlHelper\";\nimport * as Constants from \"../util/constants\";\nimport {\n  EntityStatus,\n  EntityAvailabilityStatus,\n  getBoolean,\n  getMessageCountDetails,\n  getInteger,\n  getString,\n  getStringOrUndefined,\n  getDate\n} from \"../util/utils\";\nimport {\n  buildInternalRuleResource,\n  InternalRuleOptions,\n  SqlRuleAction,\n  SqlRuleFilter\n} from \"./ruleResourceSerializer\";\n\n/**\n * @internal\n * @hidden\n * Builds the subscription options object from the user provided options.\n * Handles the differences in casing for the property names,\n * converts values to string and ensures the right order as expected by the service\n * @param subscription\n */\nexport function buildSubscriptionOptions(\n  subscription: CreateSubscriptionOptions\n): InternalSubscriptionOptions {\n  return {\n    LockDuration: subscription.lockDuration,\n    RequiresSession: getStringOrUndefined(subscription.requiresSession),\n    DefaultMessageTimeToLive: getStringOrUndefined(subscription.defaultMessageTimeToLive),\n    DeadLetteringOnMessageExpiration: getStringOrUndefined(\n      subscription.deadLetteringOnMessageExpiration\n    ),\n    DeadLetteringOnFilterEvaluationExceptions: getStringOrUndefined(\n      subscription.deadLetteringOnFilterEvaluationExceptions\n    ),\n    DefaultRuleDescription: subscription.defaultRuleOptions\n      ? buildInternalRuleResource(subscription.defaultRuleOptions)\n      : undefined,\n    MaxDeliveryCount: getStringOrUndefined(subscription.maxDeliveryCount),\n    EnableBatchedOperations: getStringOrUndefined(subscription.enableBatchedOperations),\n    Status: getStringOrUndefined(subscription.status),\n    ForwardTo: getStringOrUndefined(subscription.forwardTo),\n    UserMetadata: getStringOrUndefined(subscription.userMetadata),\n    ForwardDeadLetteredMessagesTo: getStringOrUndefined(subscription.forwardDeadLetteredMessagesTo),\n    AutoDeleteOnIdle: getStringOrUndefined(subscription.autoDeleteOnIdle),\n    EntityAvailabilityStatus: getStringOrUndefined(subscription.availabilityStatus)\n  };\n}\n\n/**\n * @internal\n * @hidden\n * Builds the subscription object from the raw json object gotten after deserializing\n * the response from the service\n * @param rawSubscription\n */\nexport function buildSubscription(rawSubscription: any): SubscriptionProperties {\n  return {\n    subscriptionName: getString(rawSubscription[Constants.SUBSCRIPTION_NAME], \"subscriptionName\"),\n    topicName: getString(rawSubscription[Constants.TOPIC_NAME], \"topicName\"),\n\n    lockDuration: getString(rawSubscription[Constants.LOCK_DURATION], \"lockDuration\"),\n    maxDeliveryCount: getInteger(rawSubscription[Constants.MAX_DELIVERY_COUNT], \"maxDeliveryCount\"),\n\n    requiresSession: getBoolean(rawSubscription[Constants.REQUIRES_SESSION], \"requiresSession\"),\n    enableBatchedOperations: getBoolean(\n      rawSubscription[Constants.ENABLE_BATCHED_OPERATIONS],\n      \"enableBatchedOperations\"\n    ),\n\n    defaultMessageTimeToLive: getString(\n      rawSubscription[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE],\n      \"defaultMessageTimeToLive\"\n    ),\n    autoDeleteOnIdle: getString(rawSubscription[Constants.AUTO_DELETE_ON_IDLE], \"autoDeleteOnIdle\"),\n\n    deadLetteringOnMessageExpiration: getBoolean(\n      rawSubscription[Constants.DEAD_LETTERING_ON_MESSAGE_EXPIRATION],\n      \"deadLetteringOnMessageExpiration\"\n    ),\n    deadLetteringOnFilterEvaluationExceptions: getBoolean(\n      rawSubscription[Constants.DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS],\n      \"deadLetteringOnFilterEvaluationExceptions\"\n    ),\n    forwardDeadLetteredMessagesTo: getStringOrUndefined(\n      rawSubscription[Constants.FORWARD_DEADLETTERED_MESSAGES_TO]\n    ),\n\n    forwardTo: getStringOrUndefined(rawSubscription[Constants.FORWARD_TO]),\n    userMetadata: rawSubscription[Constants.USER_METADATA],\n\n    status: getString(rawSubscription[Constants.STATUS], \"status\") as EntityStatus,\n\n    availabilityStatus: getString(\n      rawSubscription[Constants.ENTITY_AVAILABILITY_STATUS],\n      \"availabilityStatus\"\n    ) as EntityAvailabilityStatus\n  };\n}\n\n/**\n * @internal\n * @hidden\n * Builds the subscription runtime info object from the raw json object gotten after deserializing\n * the response from the service\n * @param rawSubscription\n */\nexport function buildSubscriptionRuntimeProperties(\n  rawSubscription: any\n): SubscriptionRuntimeProperties {\n  const messageCountDetails = getMessageCountDetails(rawSubscription[Constants.COUNT_DETAILS]);\n  return {\n    subscriptionName: getString(rawSubscription[Constants.SUBSCRIPTION_NAME], \"subscriptionName\"),\n    topicName: getString(rawSubscription[Constants.TOPIC_NAME], \"topicName\"),\n    totalMessageCount: getInteger(rawSubscription[Constants.MESSAGE_COUNT], \"messageCount\"),\n    activeMessageCount: messageCountDetails.activeMessageCount,\n    deadLetterMessageCount: messageCountDetails.deadLetterMessageCount,\n    transferDeadLetterMessageCount: messageCountDetails.transferDeadLetterMessageCount,\n    transferMessageCount: messageCountDetails.transferMessageCount,\n    createdAt: getDate(rawSubscription[Constants.CREATED_AT], \"createdAt\"),\n    modifiedAt: getDate(rawSubscription[Constants.UPDATED_AT], \"modifiedAt\"),\n    accessedAt: getDate(rawSubscription[Constants.ACCESSED_AT], \"accessedAt\")\n  };\n}\n\n/**\n * Represents settable options on a subscription\n */\nexport interface CreateSubscriptionOptions extends OperationOptions {\n  /**\n   * The default lock duration is applied to subscriptions that do not define a lock\n   * duration.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  lockDuration?: string;\n\n  /**\n   * If set to true, the subscription will be session-aware and only SessionReceiver\n   * will be supported. Session-aware subscription are not supported through REST.\n   * Settable only at subscription creation time.\n   */\n  requiresSession?: boolean;\n\n  /**\n   * Determines how long a message lives in the subscription. Based on whether\n   * dead-lettering is enabled, a message whose TTL has expired will either be moved\n   * to the subscription’s associated DeadLtterQueue or permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive?: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message from\n   * the queue into the subscription’s dead-letter sub-queue. If disabled, message\n   * will be permanently deleted from the subscription’s main queue.\n   * Settable only at subscription creation time.\n   */\n  deadLetteringOnMessageExpiration?: boolean;\n\n  /**\n   * Determines how the Service Bus handles a message that causes an exception during\n   * a subscription’s filter evaluation. If the value is set to true, the message that\n   * caused the exception will be moved to the subscription’s dead-letter sub-queue.\n   * Otherwise, it will be discarded. By default this parameter is set to true,\n   * allowing the user a chance to investigate the cause of the exception.\n   * It can occur from a malformed message or some incorrect assumptions being made\n   * in the filter about the form of the message. Settable only at topic creation time.\n   */\n  deadLetteringOnFilterEvaluationExceptions?: boolean;\n\n  /**\n   * Represents the options to create the default rule for the subscription.\n   */\n  defaultRuleOptions?: {\n    /**\n     * Name of the rule\n     */\n    name: string;\n\n    /**\n     * Defines the filter expression that the rule evaluates. For `SqlRuleFilter` input,\n     * the expression string is interpreted as a SQL92 expression which must\n     * evaluate to True or False. Only one between a `CorrelationRuleFilter` or\n     * a `SqlRuleFilter` can be defined.\n     */\n    filter?: SqlRuleFilter | CorrelationRuleFilter;\n\n    /**\n     * The SQL like expression that can be executed on the message should the\n     * associated filter apply.\n     */\n    action?: SqlRuleAction;\n  };\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   *\n   */\n  maxDeliveryCount?: number;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations?: boolean;\n\n  /**\n   * Status of the messaging entity.\n   */\n  status?: EntityStatus;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the subscription.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle?: string;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  availabilityStatus?: EntityAvailabilityStatus;\n}\n\n/**\n * Represents the input for updateSubscription.\n *\n * @export\n * @interface SubscriptionProperties\n */\nexport interface SubscriptionProperties {\n  /**\n   * Name of the subscription\n   */\n  readonly subscriptionName: string;\n\n  /**\n   * Name of the topic\n   */\n  readonly topicName: string;\n\n  /**\n   * The default lock duration is applied to subscriptions that do not define a lock\n   * duration.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  lockDuration: string;\n\n  /**\n   * If set to true, the subscription will be session-aware and only SessionReceiver\n   * will be supported. Session-aware subscription are not supported through REST.\n   * Settable only at subscription creation time.\n   */\n  readonly requiresSession: boolean;\n\n  /**\n   * Determines how long a message lives in the subscription. Based on whether\n   * dead-lettering is enabled, a message whose TTL has expired will either be moved\n   * to the subscription’s associated DeadLtterQueue or permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message from\n   * the queue into the subscription’s dead-letter sub-queue. If disabled, message\n   * will be permanently deleted from the subscription’s main queue.\n   * Settable only at subscription creation time.\n   */\n  deadLetteringOnMessageExpiration: boolean;\n\n  /**\n   * Determines how the Service Bus handles a message that causes an exception during\n   * a subscription’s filter evaluation. If the value is set to true, the message that\n   * caused the exception will be moved to the subscription’s dead-letter sub-queue.\n   * Otherwise, it will be discarded. By default this parameter is set to true,\n   * allowing the user a chance to investigate the cause of the exception.\n   * It can occur from a malformed message or some incorrect assumptions being made\n   * in the filter about the form of the message. Settable only at topic creation time.\n   */\n  deadLetteringOnFilterEvaluationExceptions: boolean;\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   *\n   */\n  maxDeliveryCount: number;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations: boolean;\n\n  /**\n   * Status of the messaging entity.\n   */\n  status: EntityStatus;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the subscription.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle: string;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  availabilityStatus?: EntityAvailabilityStatus;\n}\n\n/**\n * @internal\n * @hidden\n * Internal representation of settable options on a subscription\n */\nexport interface InternalSubscriptionOptions {\n  /**\n   * The default lock duration is applied to subscriptions that do not define a lock\n   * duration.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  LockDuration?: string;\n\n  /**\n   * If set to true, the subscription will be session-aware and only SessionReceiver\n   * will be supported. Session-aware subscription are not supported through REST.\n   * Settable only at subscription creation time.\n   */\n  RequiresSession?: string;\n\n  /**\n   * Determines how long a message lives in the subscription. Based on whether\n   * dead-lettering is enabled, a message whose TTL has expired will either be moved\n   * to the subscription’s associated DeadLtterQueue or permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  DefaultMessageTimeToLive?: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message from\n   * the queue into the subscription’s dead-letter sub-queue. If disabled, message\n   * will be permanently deleted from the subscription’s main queue.\n   * Settable only at subscription creation time.\n   */\n  DeadLetteringOnMessageExpiration?: string;\n\n  /**\n   * Determines how the Service Bus handles a message that causes an exception during\n   * a subscription’s filter evaluation. If the value is set to true, the message\n   * that caused the exception will be moved to the subscription’s dead-letter sub-queue.\n   * Otherwise, it will be discarded. By default this parameter is set to true, allowing\n   * the user a chance to investigate the cause of the exception. It can occur from a\n   * malformed message or some incorrect assumptions being made in the filter about the\n   * form of the message. Settable only at topic creation time.\n   */\n  DeadLetteringOnFilterEvaluationExceptions?: string;\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   *\n   */\n  MaxDeliveryCount?: string;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  EnableBatchedOperations?: string;\n\n  /**\n   * Status of the messaging entity.\n   */\n  Status?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  ForwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the subscription.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  UserMetadata?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  ForwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  AutoDeleteOnIdle?: string;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  EntityAvailabilityStatus?: string;\n\n  DefaultRuleDescription?: InternalRuleOptions;\n}\n\n/**\n * Represents runtime info attributes of a subscription entity\n */\nexport interface SubscriptionRuntimeProperties {\n  /**\n   * Name of the subscription\n   */\n  subscriptionName: string;\n\n  /**\n   * Name of the topic\n   */\n  topicName: string;\n\n  /**\n   * The entity's message count.\n   *\n   */\n  totalMessageCount: number;\n\n  /**\n   * The number of active messages in the queue.\n   */\n  activeMessageCount: number;\n\n  /**\n   * The number of messages that have been dead lettered.\n   */\n  deadLetterMessageCount: number;\n\n  /**\n   * The number of messages transferred to another queue, topic, or subscription\n   */\n  transferMessageCount: number;\n\n  /**\n   * The number of messages transferred to the dead letter queue.\n   */\n  transferDeadLetterMessageCount: number;\n\n  /**\n   * Created at timestamp\n   */\n  createdAt: Date;\n\n  /**\n   * Updated at timestamp\n   */\n  modifiedAt: Date;\n\n  /**\n   * Accessed at timestamp\n   */\n  accessedAt: Date;\n}\n\n/**\n * @internal\n * @hidden\n * SubscriptionResourceSerializer for serializing / deserializing Subscription entities\n */\nexport class SubscriptionResourceSerializer implements AtomXmlSerializer {\n  serialize(resource: InternalSubscriptionOptions): object {\n    return serializeToAtomXmlRequest(\"SubscriptionDescription\", resource);\n  }\n\n  async deserialize(response: HttpOperationResponse): Promise<HttpOperationResponse> {\n    return deserializeAtomXmlResponse([\"TopicName\", \"SubscriptionName\"], response);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpOperationResponse, OperationOptions } from \"@azure/core-http\";\nimport {\n  AtomXmlSerializer,\n  deserializeAtomXmlResponse,\n  serializeToAtomXmlRequest\n} from \"../util/atomXmlHelper\";\nimport * as Constants from \"../util/constants\";\nimport {\n  AuthorizationRule,\n  EntityStatus,\n  EntityAvailabilityStatus,\n  getAuthorizationRulesOrUndefined,\n  getBoolean,\n  getInteger,\n  getIntegerOrUndefined,\n  getRawAuthorizationRules,\n  getString,\n  getStringOrUndefined,\n  getDate,\n  getMessageCountDetails\n} from \"../util/utils\";\n\n/**\n * @internal\n * @hidden\n * Builds the topic options object from the user provided options.\n * Handles the differences in casing for the property names,\n * converts values to string and ensures the right order as expected by the service\n * @param topic\n */\nexport function buildTopicOptions(topic: CreateTopicOptions): InternalTopicOptions {\n  return {\n    DefaultMessageTimeToLive: topic.defaultMessageTimeToLive,\n    MaxSizeInMegabytes: getStringOrUndefined(topic.maxSizeInMegabytes),\n    RequiresDuplicateDetection: getStringOrUndefined(topic.requiresDuplicateDetection),\n    DuplicateDetectionHistoryTimeWindow: topic.duplicateDetectionHistoryTimeWindow,\n    EnableBatchedOperations: getStringOrUndefined(topic.enableBatchedOperations),\n    AuthorizationRules: getRawAuthorizationRules(topic.authorizationRules),\n    Status: getStringOrUndefined(topic.status),\n    UserMetadata: getStringOrUndefined(topic.userMetadata),\n    SupportOrdering: getStringOrUndefined(topic.supportOrdering),\n    AutoDeleteOnIdle: getStringOrUndefined(topic.autoDeleteOnIdle),\n    EnablePartitioning: getStringOrUndefined(topic.enablePartitioning),\n    EntityAvailabilityStatus: getStringOrUndefined(topic.availabilityStatus),\n    EnableExpress: getStringOrUndefined(topic.enableExpress)\n  };\n}\n\n/**\n * @internal\n * @hidden\n * Builds the topic object from the raw json object gotten after deserializing the\n * response from the service\n * @param rawTopic\n */\nexport function buildTopic(rawTopic: any): TopicProperties {\n  return {\n    name: getString(rawTopic[Constants.TOPIC_NAME], \"topicName\"),\n    maxSizeInMegabytes: getInteger(rawTopic[Constants.MAX_SIZE_IN_MEGABYTES], \"maxSizeInMegabytes\"),\n\n    enablePartitioning: getBoolean(rawTopic[Constants.ENABLE_PARTITIONING], \"enablePartitioning\"),\n    supportOrdering: getBoolean(rawTopic[Constants.SUPPORT_ORDERING], \"supportOrdering\"),\n    enableBatchedOperations: getBoolean(\n      rawTopic[Constants.ENABLE_BATCHED_OPERATIONS],\n      \"enableBatchedOperations\"\n    ),\n\n    defaultMessageTimeToLive: getString(\n      rawTopic[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE],\n      \"defaultMessageTimeToLive\"\n    ),\n    autoDeleteOnIdle: rawTopic[Constants.AUTO_DELETE_ON_IDLE],\n\n    requiresDuplicateDetection: getBoolean(\n      rawTopic[Constants.REQUIRES_DUPLICATE_DETECTION],\n      \"requiresDuplicateDetection\"\n    ),\n    duplicateDetectionHistoryTimeWindow: getString(\n      rawTopic[Constants.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW],\n      \"duplicateDetectionHistoryTimeWindow\"\n    ),\n\n    authorizationRules: getAuthorizationRulesOrUndefined(rawTopic[Constants.AUTHORIZATION_RULES]),\n    userMetadata: rawTopic[Constants.USER_METADATA],\n\n    status: rawTopic[Constants.STATUS],\n\n    enableExpress: getBoolean(rawTopic[Constants.ENABLE_EXPRESS], \"enableExpress\"),\n\n    availabilityStatus: rawTopic[Constants.ENTITY_AVAILABILITY_STATUS]\n  };\n}\n\n/**\n * @internal\n * @hidden\n * Builds the topic runtime info object from the raw json object gotten after deserializing the\n * response from the service\n * @param rawTopic\n */\nexport function buildTopicRuntimeProperties(rawTopic: any): TopicRuntimeProperties {\n  return {\n    name: getString(rawTopic[Constants.TOPIC_NAME], \"topicName\"),\n    sizeInBytes: getIntegerOrUndefined(rawTopic[Constants.SIZE_IN_BYTES]),\n    subscriptionCount: getIntegerOrUndefined(rawTopic[Constants.SUBSCRIPTION_COUNT]),\n    createdAt: getDate(rawTopic[Constants.CREATED_AT], \"createdAt\"),\n    scheduledMessageCount: getMessageCountDetails(rawTopic[Constants.COUNT_DETAILS])\n      .scheduledMessageCount,\n    modifiedAt: getDate(rawTopic[Constants.UPDATED_AT], \"modifiedAt\"),\n    accessedAt: getDate(rawTopic[Constants.ACCESSED_AT], \"accessedAt\")\n  };\n}\n\n/**\n * Represents settable options on a topic\n */\nexport interface CreateTopicOptions extends OperationOptions {\n  /**\n   * Determines how long a message lives in the associated subscriptions.\n   * Subscriptions inherit the TTL from the topic unless they are created explicitly\n   * with a smaller TTL. Based on whether dead-lettering is enabled, a message whose\n   * TTL has expired will either be moved to the subscription’s associated dead-letter\n   * sub-queue or will be permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive?: string;\n\n  /**\n   * Specifies the maximum topic size in megabytes. Any attempt to enqueue a message\n   * that will cause the topic to exceed this value will fail. All messages that are\n   * stored in the topic or any of its subscriptions count towards this value.\n   * Multiple copies of a message that reside in one or multiple subscriptions count\n   * as a single messages. For example, if message m exists once in subscription s1\n   * and twice in subscription s2, m is counted as a single message.\n   */\n  maxSizeInMegabytes?: number;\n\n  /**\n   * If enabled, the topic will detect duplicate messages within the time span\n   * specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at topic creation time.\n   */\n  requiresDuplicateDetection?: boolean;\n\n  /**\n   * Specifies the time span during which the Service Bus will detect message duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  duplicateDetectionHistoryTimeWindow?: string;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations?: boolean;\n\n  /**\n   * Authorization rules on the topic\n   */\n  authorizationRules?: AuthorizationRule[];\n\n  /**\n   * Status of the messaging entity.\n   */\n  status?: EntityStatus;\n\n  /**\n   * The user provided metadata information associated with the topic.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata?: string;\n\n  /**\n   * Specifies whether the topic supports message ordering.\n   */\n  supportOrdering?: boolean;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle?: string;\n\n  /**\n   * Specifies whether the topic should be partitioned\n   */\n  enablePartitioning?: boolean;\n\n  /**\n   * Specifies whether express entities are enabled on topic.\n   */\n  enableExpress?: boolean;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  availabilityStatus?: EntityAvailabilityStatus;\n}\n\n/**\n * Represents the input for updateTopic.\n *\n * @export\n * @interface TopicProperties\n */\nexport interface TopicProperties {\n  /**\n   * Name of the topic\n   */\n  readonly name: string;\n\n  /**\n   * Determines how long a message lives in the associated subscriptions.\n   * Subscriptions inherit the TTL from the topic unless they are created explicitly\n   * with a smaller TTL. Based on whether dead-lettering is enabled, a message whose\n   * TTL has expired will either be moved to the subscription’s associated dead-letter\n   * sub-queue or will be permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive: string;\n\n  /**\n   * Specifies the maximum topic size in megabytes. Any attempt to enqueue a message\n   * that will cause the topic to exceed this value will fail. All messages that are\n   * stored in the topic or any of its subscriptions count towards this value.\n   * Multiple copies of a message that reside in one or multiple subscriptions count\n   * as a single messages. For example, if message m exists once in subscription s1\n   * and twice in subscription s2, m is counted as a single message.\n   */\n  maxSizeInMegabytes: number;\n\n  /**\n   * If enabled, the topic will detect duplicate messages within the time span\n   * specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at topic creation time.\n   */\n  readonly requiresDuplicateDetection: boolean;\n\n  /**\n   * Specifies the time span during which the Service Bus will detect message duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  duplicateDetectionHistoryTimeWindow: string;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations: boolean;\n\n  /**\n   * Authorization rules on the topic\n   */\n  authorizationRules?: AuthorizationRule[];\n\n  /**\n   * Status of the messaging entity.\n   */\n  status: EntityStatus;\n\n  /**\n   * The user provided metadata information associated with the topic.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata: string;\n\n  /**\n   * Specifies whether the topic supports message ordering.\n   */\n  supportOrdering: boolean;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle: string;\n\n  /**\n   * Specifies whether the topic should be partitioned\n   */\n  readonly enablePartitioning: boolean;\n\n  /**\n   * Specifies whether express entities are enabled on topic.\n   */\n  readonly enableExpress: boolean;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  readonly availabilityStatus: EntityAvailabilityStatus;\n}\n\n/**\n * @internal\n * @hidden\n * Internal representation of settable options on a topic\n */\nexport interface InternalTopicOptions {\n  /**\n   * Determines how long a message lives in the associated subscriptions. Subscriptions\n   * inherit the TTL from the topic unless they are created explicitly with a smaller TTL.\n   * Based on whether dead-lettering is enabled, a message whose TTL has expired will\n   * either be moved to the subscription’s associated DeadLtterQueue or will be\n   * permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  DefaultMessageTimeToLive?: string;\n\n  /**\n   * Specifies the maximum topic size in megabytes. Any attempt to enqueue a message\n   * that will cause the topic to exceed this value will fail. All messages that are\n   * stored in the topic or any of its subscriptions count towards this value.\n   * Multiple copies of a message that reside in one or multiple subscriptions count\n   * as a single messages. For example, if message m exists once in subscription s1\n   * and twice in subscription s2, m is counted as a single message.\n   */\n  MaxSizeInMegabytes?: string;\n\n  /**\n   * If enabled, the topic will detect duplicate messages within the time span\n   * specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at topic creation time.\n   */\n  RequiresDuplicateDetection?: string;\n\n  /**\n   * Specifies the time span during which the Service Bus will detect message\n   * duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  DuplicateDetectionHistoryTimeWindow?: string;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  EnableBatchedOperations?: string;\n\n  /**\n   * Authorization rules on the topic\n   */\n  AuthorizationRules?: any;\n\n  /**\n   * Status of the messaging entity.\n   */\n  Status?: string;\n\n  /**\n   * The user provided metadata information associated with the topic.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  UserMetadata?: string;\n\n  /**\n   * Specifies whether the topic supports message ordering.\n   */\n  SupportOrdering?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  AutoDeleteOnIdle?: string;\n\n  /**\n   * Specifies whether the topic should be partitioned\n   */\n  EnablePartitioning?: string;\n\n  /**\n   * Specifies whether express entities are enabled on queue.\n   */\n  EnableExpress?: string;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  EntityAvailabilityStatus?: string;\n}\n\n/**\n * Represents runtime info attributes of a topic entity\n */\nexport interface TopicRuntimeProperties {\n  /**\n   * Name of the topic\n   */\n  name: string;\n\n  /**\n   * Specifies the topic size in bytes.\n   */\n  sizeInBytes?: number;\n\n  /**\n   * The subscription count on given topic.\n   *\n   */\n  subscriptionCount?: number;\n\n  /**\n   * The number of scheduled messages.\n   */\n  scheduledMessageCount: number;\n\n  /**\n   * Created at timestamp\n   */\n  createdAt: Date;\n\n  /**\n   * Updated at timestamp\n   */\n  modifiedAt: Date;\n\n  /**\n   * Accessed at timestamp\n   */\n  accessedAt: Date;\n}\n\n/**\n * @internal\n * @hidden\n * TopicResourceSerializer for serializing / deserializing Topic entities\n */\nexport class TopicResourceSerializer implements AtomXmlSerializer {\n  serialize(resource: InternalTopicOptions): object {\n    return serializeToAtomXmlRequest(\"TopicDescription\", resource);\n  }\n  async deserialize(response: HttpOperationResponse): Promise<HttpOperationResponse> {\n    return deserializeAtomXmlResponse([\"TopicName\"], response);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { parseConnectionString } from \"@azure/core-amqp\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { Buffer } from \"buffer\";\nimport isBuffer from \"is-buffer\";\nimport jssha from \"jssha\";\n\n/**\n * @class SharedKeyCredential\n * @internal\n * @hidden\n * Defines the SharedKeyCredential.\n */\nexport class SharedKeyCredential {\n  /**\n   * @property {string} keyName - The name of the EventHub/ServiceBus key.\n   */\n  keyName: string;\n\n  /**\n   * @property {string} key - The secret value associated with the above EventHub/ServiceBus key.\n   */\n  key: string;\n\n  /**\n   * Initializes a new instance of SharedKeyCredential\n   * @constructor\n   * @param {string} keyName - The name of the EventHub/ServiceBus key.\n   * @param {string} key - The secret value associated with the above EventHub/ServiceBus key\n   */\n  constructor(keyName: string, key: string) {\n    this.keyName = keyName;\n    this.key = key;\n  }\n\n  /**\n   * Gets the sas token for the specified audience\n   * @param {string} [audience] - The audience for which the token is desired.\n   */\n  getToken(audience: string): AccessToken {\n    return this._createToken(Math.floor(Date.now() / 1000) + 3600, audience);\n  }\n\n  /**\n   * Creates the sas token based on the provided information\n   * @param {string | number} expiry - The time period in unix time after which the token will expire.\n   * @param {string} [audience] - The audience for which the token is desired.\n   * @param {string | Buffer} [hashInput] The input to be provided to hmac to create the hash.\n   */\n  protected _createToken(\n    expiry: number,\n    audience: string,\n    hashInput?: string | Buffer\n  ): AccessToken {\n    audience = encodeURIComponent(audience);\n    const keyName = encodeURIComponent(this.keyName);\n    const stringToSign = audience + \"\\n\" + expiry;\n    hashInput = hashInput || this.key;\n    let shaObj: any;\n    if (isBuffer(hashInput)) {\n      shaObj = new jssha(\"SHA-256\", \"ARRAYBUFFER\");\n      shaObj.setHMACKey(hashInput, \"ARRAYBUFFER\");\n      shaObj.update(Buffer.from(stringToSign));\n    } else {\n      shaObj = new jssha(\"SHA-256\", \"TEXT\");\n      shaObj.setHMACKey(hashInput, \"TEXT\");\n      shaObj.update(stringToSign);\n    }\n    const sig = encodeURIComponent(shaObj.getHMAC(\"B64\"));\n    return {\n      token: `SharedAccessSignature sr=${audience}&sig=${sig}&se=${expiry}&skn=${keyName}`,\n      expiresOnTimestamp: expiry\n    };\n  }\n\n  /**\n   * Creates a token provider from the EventHub/ServiceBus connection string;\n   * @param {string} connectionString - The EventHub/ServiceBus connection string\n   */\n  static fromConnectionString(connectionString: string): SharedKeyCredential {\n    const parsed = parseConnectionString<{\n      SharedAccessSignature: string;\n      SharedAccessKeyName: string;\n      SharedAccessKey: string;\n    }>(connectionString);\n\n    if (parsed.SharedAccessSignature == null) {\n      return new SharedKeyCredential(parsed.SharedAccessKeyName, parsed.SharedAccessKey);\n    } else {\n      return new SharedAccessSignatureCredential(parsed.SharedAccessSignature);\n    }\n  }\n}\n\n/**\n * A credential that takes a SharedAccessSignature:\n * `SharedAccessSignature sr=<resource>&sig=<signature>&se=<expiry>&skn=<keyname>`\n *\n * @internal\n * @hidden\n */\nexport class SharedAccessSignatureCredential extends SharedKeyCredential {\n  private _accessToken: AccessToken;\n\n  /**\n   * @param sharedAccessSignature A shared access signature of the form\n   * `SharedAccessSignature sr=<resource>&sig=<signature>&se=<expiry>&skn=<keyname>`\n   */\n  constructor(sharedAccessSignature: string) {\n    super(\"\", \"\");\n\n    this._accessToken = {\n      token: sharedAccessSignature,\n      expiresOnTimestamp: 0\n    };\n  }\n\n  /**\n   * Retrieve a valid token for authenticaton.\n   *\n   * @param _audience Not applicable in SharedAccessSignatureCredential as the token is not re-generated at every invocation of the method\n   */\n  getToken(_audience: string): AccessToken {\n    return this._accessToken;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport crypto from \"crypto\";\n\n/**\n * @internal\n * @hidden\n */\nexport async function generateKey(secret: string, stringToSign: string) {\n  const result = encodeURIComponent(\n    crypto\n      .createHmac(\"sha256\", secret)\n      .update(stringToSign)\n      .digest(\"base64\")\n  );\n  return result;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AccessToken } from \"@azure/core-auth\";\nimport { SharedKeyCredential } from \"../servicebusSharedKeyCredential\";\nimport { HttpHeaders, ServiceClientCredentials, WebResource } from \"@azure/core-http\";\nimport { generateKey } from \"./crypto\";\n\n/**\n * @internal\n * @hidden\n * @class SasServiceClientCredentials\n * @implements {ServiceClientCredentials}\n */\nexport class SasServiceClientCredentials implements ServiceClientCredentials {\n  keyName: string;\n  keyValue: string;\n  private sharedKeyCredential: SharedKeyCredential;\n  /**\n   * Creates a new sasServiceClientCredentials object.\n   *\n   * @constructor\n   * @param {string} sharedAccessKeyName The SAS key name to use.\n   * @param {string} sharedAccessKey The SAS key value to use\n   */\n  constructor(sharedAccessKeyName: string, sharedAccessKey: string) {\n    this.keyName = sharedAccessKeyName;\n    this.keyValue = sharedAccessKey;\n    this.sharedKeyCredential = new SharedKeyCredential(this.keyName, this.keyValue);\n  }\n\n  private async _generateSignature(targetUri: string, expirationDate: number): Promise<string> {\n    const stringToSign = `${targetUri}\\n${expirationDate}`;\n    const result = await generateKey(this.keyValue, stringToSign);\n    return result;\n  }\n\n  /**\n   * Signs a request with the Authentication header.\n   *\n   * @param {WebResource} webResource The WebResource to be signed.\n   * @returns {Promise<WebResource>} The signed request object.\n   */\n  async signRequest(webResource: WebResource): Promise<WebResource> {\n    if (!webResource.headers) webResource.headers = new HttpHeaders();\n\n    const targetUri = encodeURIComponent(webResource.url.toLowerCase()).toLowerCase();\n\n    const date = new Date();\n    date.setMinutes(date.getMinutes() + 5);\n    const expirationDate = Math.round(date.getTime() / 1000);\n    const signature = await this._generateSignature(targetUri, expirationDate);\n    webResource.headers.set(\n      \"authorization\",\n      `SharedAccessSignature sig=${signature}&se=${expirationDate}&skn=${this.keyName}&sr=${targetUri}`\n    );\n    webResource.withCredentials = true;\n    return webResource;\n  }\n\n  getToken(audience: string): AccessToken {\n    return this.sharedKeyCredential.getToken(audience);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions, RestError } from \"@azure/core-http\";\nimport { getTracer } from \"@azure/core-tracing\";\nimport { CanonicalCode, Span, SpanKind, SpanOptions as OTSpanOptions } from \"@opentelemetry/api\";\n\n/**\n * @internal\n * @hidden\n * Creates a span using the global tracer.\n * @param name The name of the operation being performed.\n * @param operationOptions The options for the underlying http request.\n */\nexport function createSpan(\n  operationName: string,\n  operationOptions: OperationOptions = {}\n): { span: Span; updatedOperationOptions: OperationOptions } {\n  const tracer = getTracer();\n  const spanOptions: OTSpanOptions = {\n    ...operationOptions.tracingOptions?.spanOptions,\n    kind: SpanKind.INTERNAL\n  };\n\n  const span = tracer.startSpan(`Azure.ServiceBus.${operationName}`, spanOptions);\n  span.setAttribute(\"az.namespace\", \"Microsoft.ServiceBus\");\n\n  let newSpanOptions = operationOptions.tracingOptions?.spanOptions || {};\n  if (span.isRecording()) {\n    newSpanOptions = {\n      ...operationOptions.tracingOptions?.spanOptions,\n      parent: span.context(),\n      attributes: {\n        ...spanOptions.attributes,\n        \"az.namespace\": \"Microsoft.ServiceBus\"\n      }\n    };\n  }\n\n  return {\n    span,\n    updatedOperationOptions: {\n      ...operationOptions,\n      tracingOptions: { ...operationOptions?.tracingOptions, spanOptions: newSpanOptions }\n    }\n  };\n}\n\n/**\n * @internal\n * @hidden\n */\nexport function getCanonicalCode(err: Error) {\n  if (err instanceof RestError) {\n    switch (err.statusCode) {\n      case 401:\n        return CanonicalCode.PERMISSION_DENIED;\n      case 404:\n        return CanonicalCode.NOT_FOUND;\n      case 412:\n        return CanonicalCode.FAILED_PRECONDITION;\n    }\n  }\n\n  return CanonicalCode.UNKNOWN;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants as AMQPConstants, parseConnectionString } from \"@azure/core-amqp\";\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport {\n  bearerTokenAuthenticationPolicy,\n  createPipelineFromOptions,\n  HttpOperationResponse,\n  OperationOptions,\n  RequestPolicyFactory,\n  RestError,\n  ServiceClient,\n  signingPolicy,\n  stripRequest,\n  stripResponse,\n  URLBuilder,\n  WebResource,\n  PipelineOptions,\n  HttpResponse\n} from \"@azure/core-http\";\nimport { PagedAsyncIterableIterator, PageSettings } from \"@azure/core-paging\";\nimport { CorrelationRuleFilter } from \"./core/managementClient\";\nimport { administrationLogger as logger } from \"./log\";\nimport {\n  buildNamespace,\n  NamespaceProperties,\n  NamespaceResourceSerializer\n} from \"./serializers/namespaceResourceSerializer\";\nimport {\n  buildQueue,\n  buildQueueOptions,\n  buildQueueRuntimeProperties,\n  CreateQueueOptions,\n  InternalQueueOptions,\n  QueueProperties,\n  QueueResourceSerializer,\n  QueueRuntimeProperties\n} from \"./serializers/queueResourceSerializer\";\nimport {\n  buildRule,\n  CreateRuleOptions,\n  isSqlRuleAction,\n  RuleProperties,\n  RuleResourceSerializer,\n  SqlRuleAction,\n  SqlRuleFilter\n} from \"./serializers/ruleResourceSerializer\";\nimport {\n  buildSubscription,\n  buildSubscriptionOptions,\n  buildSubscriptionRuntimeProperties,\n  CreateSubscriptionOptions,\n  InternalSubscriptionOptions,\n  SubscriptionProperties,\n  SubscriptionResourceSerializer,\n  SubscriptionRuntimeProperties\n} from \"./serializers/subscriptionResourceSerializer\";\nimport {\n  buildTopic,\n  buildTopicOptions,\n  buildTopicRuntimeProperties,\n  CreateTopicOptions,\n  InternalTopicOptions,\n  TopicProperties,\n  TopicResourceSerializer,\n  TopicRuntimeProperties\n} from \"./serializers/topicResourceSerializer\";\nimport { AtomXmlSerializer, executeAtomXmlOperation } from \"./util/atomXmlHelper\";\nimport * as Constants from \"./util/constants\";\nimport { parseURL } from \"./util/parseUrl\";\nimport { SasServiceClientCredentials } from \"./util/sasServiceClientCredentials\";\nimport { createSpan, getCanonicalCode } from \"./util/tracing\";\nimport {\n  formatUserAgentPrefix,\n  getHttpResponseOnly,\n  isAbsoluteUrl,\n  isJSONLikeObject\n} from \"./util/utils\";\n\n/**\n * Request options for list<entity-type>() operations\n */\nexport interface ListRequestOptions {\n  /**\n   * Count of entities to fetch.\n   */\n  maxCount?: number;\n\n  /**\n   * Count of entities to skip from being fetched.\n   */\n  skip?: number;\n}\n\n/**\n * Represents the returned response of the operation along with the raw response.\n */\nexport type WithResponse<T extends object> = T & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse;\n};\n\n/**\n * Represents the result of list operation on entities which also contains the `continuationToken` to start iterating over from.\n */\nexport type EntitiesResponse<T extends object> = WithResponse<Array<T>> &\n  Pick<PageSettings, \"continuationToken\">;\n\n/**\n * All operations return promises that resolve to an object that has the relevant output.\n * These objects also have a property called `_response` that you can use if you want to\n * access the direct response from the service.\n */\nexport class ServiceBusAdministrationClient extends ServiceClient {\n  /**\n   * Reference to the endpoint as extracted from input connection string.\n   */\n  private endpoint: string;\n\n  /**\n   * Reference to the endpoint with protocol prefix as extracted from input connection string.\n   */\n  private endpointWithProtocol: string;\n\n  /**\n   * Singleton instances of serializers used across the various operations.\n   */\n  private namespaceResourceSerializer: AtomXmlSerializer;\n  private queueResourceSerializer: AtomXmlSerializer;\n  private topicResourceSerializer: AtomXmlSerializer;\n  private subscriptionResourceSerializer: AtomXmlSerializer;\n  private ruleResourceSerializer: AtomXmlSerializer;\n\n  /**\n   * Credentials used to generate tokens as required for the various operations.\n   */\n  private credentials: SasServiceClientCredentials | TokenCredential;\n\n  /**\n   * Initializes a new instance of the ServiceBusAdministrationClient class.\n   * @param connectionString The connection string needed for the client to connect to Azure.\n   * @param options PipelineOptions\n   */\n  constructor(connectionString: string, options?: PipelineOptions);\n  /**\n   *\n   * @param fullyQualifiedNamespace The fully qualified namespace of your Service Bus instance which is\n   * likely to be similar to <yournamespace>.servicebus.windows.net.\n   * @param credential A credential object used by the client to get the token to authenticate the connection\n   * with the Azure Service Bus. See &commat;azure/identity for creating the credentials.\n   * If you're using your own implementation of the `TokenCredential` interface against AAD, then set the \"scopes\" for service-bus\n   * to be `[\"https://servicebus.azure.net//user_impersonation\"]` to get the appropriate token.\n   * @param options PipelineOptions\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    credential: TokenCredential,\n    options?: PipelineOptions\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    credentialOrOptions2?: TokenCredential | PipelineOptions,\n    options3?: PipelineOptions\n  ) {\n    let options: PipelineOptions;\n    let fullyQualifiedNamespace: string;\n    let credentials: SasServiceClientCredentials | TokenCredential;\n    let authPolicy: RequestPolicyFactory;\n    if (isTokenCredential(credentialOrOptions2)) {\n      fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;\n      options = options3 || {};\n      credentials = credentialOrOptions2;\n      authPolicy = bearerTokenAuthenticationPolicy(credentials, AMQPConstants.aadServiceBusScope);\n    } else {\n      const connectionString = fullyQualifiedNamespaceOrConnectionString1;\n      options = credentialOrOptions2 || {};\n      const connectionStringObj: any = parseConnectionString(connectionString);\n      if (connectionStringObj.Endpoint == undefined) {\n        throw new Error(\"Missing Endpoint in connection string.\");\n      }\n      try {\n        fullyQualifiedNamespace = connectionStringObj.Endpoint.match(\".*://([^/]*)\")[1];\n      } catch (error) {\n        throw new Error(\"Endpoint in the connection string is not valid.\");\n      }\n      credentials = new SasServiceClientCredentials(\n        connectionStringObj.SharedAccessKeyName,\n        connectionStringObj.SharedAccessKey\n      );\n      authPolicy = signingPolicy(credentials);\n    }\n    const userAgentPrefix = formatUserAgentPrefix(options.userAgentOptions?.userAgentPrefix);\n    const serviceClientOptions = createPipelineFromOptions(\n      {\n        ...options,\n        userAgentOptions: {\n          userAgentPrefix\n        }\n      },\n      authPolicy\n    );\n    super(credentials, serviceClientOptions);\n    this.endpoint = fullyQualifiedNamespace;\n    this.endpointWithProtocol = fullyQualifiedNamespace.endsWith(\"/\")\n      ? \"sb://\" + fullyQualifiedNamespace\n      : \"sb://\" + fullyQualifiedNamespace + \"/\";\n    this.credentials = credentials;\n    this.namespaceResourceSerializer = new NamespaceResourceSerializer();\n    this.queueResourceSerializer = new QueueResourceSerializer();\n    this.topicResourceSerializer = new TopicResourceSerializer();\n    this.subscriptionResourceSerializer = new SubscriptionResourceSerializer();\n    this.ruleResourceSerializer = new RuleResourceSerializer();\n  }\n\n  /**\n   * Returns an object representing the metadata related to a service bus namespace.\n   * @param queueName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   */\n  async getNamespaceProperties(\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<NamespaceProperties>> {\n    logger.verbose(`Performing management operation - getNamespaceProperties()`);\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getNamespaceProperties\",\n      operationOptions\n    );\n    try {\n      const response: HttpOperationResponse = await this.getResource(\n        \"$namespaceinfo\",\n        this.namespaceResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return this.buildNamespacePropertiesResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a queue with given name, configured using the given options\n   * @param queueName\n   * @param options Options to configure the Queue being created(For example, you can configure a queue to support partitions or sessions)\n   *  and the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async createQueue(\n    queueName: string,\n    options?: CreateQueueOptions\n  ): Promise<WithResponse<QueueProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-createQueue\",\n      options\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - createQueue() for \"${queueName}\" with options: %j`,\n        options\n      );\n      const response: HttpOperationResponse = await this.putResource(\n        queueName,\n        buildQueueOptions(options || {}),\n        this.queueResourceSerializer,\n        false,\n        updatedOperationOptions\n      );\n\n      return this.buildQueueResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an object representing the Queue and its properties.\n   * If you want to get the Queue runtime info like message count details, use `getQueueRuntimeProperties` API.\n   * @param queueName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getQueue(\n    queueName: string,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<QueueProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getQueue\",\n      operationOptions\n    );\n    try {\n      logger.verbose(`Performing management operation - getQueue() for \"${queueName}\"`);\n      const response: HttpOperationResponse = await this.getResource(\n        queueName,\n        this.queueResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return this.buildQueueResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an object representing the Queue runtime info like message count details.\n   * @param queueName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getQueueRuntimeProperties(\n    queueName: string,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<QueueRuntimeProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getQueueRuntimeProperties\",\n      operationOptions\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - getQueueRuntimeProperties() for \"${queueName}\"`\n      );\n      const response: HttpOperationResponse = await this.getResource(\n        queueName,\n        this.queueResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return this.buildQueueRuntimePropertiesResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns a list of objects, each representing a Queue along with its properties.\n   * If you want to get the runtime info of the queues like message count, use `getQueuesRuntimeProperties` API instead.\n   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getQueues(\n    options?: ListRequestOptions & OperationOptions\n  ): Promise<EntitiesResponse<QueueProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getQueues\",\n      options\n    );\n    try {\n      logger.verbose(`Performing management operation - getQueues() with options: %j`, options);\n      const response: HttpOperationResponse = await this.listResources(\n        \"$Resources/Queues\",\n        updatedOperationOptions,\n        this.queueResourceSerializer\n      );\n\n      return this.buildListQueuesResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async *listQueuesPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {}\n  ): AsyncIterableIterator<EntitiesResponse<QueueProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getQueues({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listQueuesAll(\n    options: OperationOptions = {}\n  ): AsyncIterableIterator<QueueProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listQueuesPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the queues.\n   *\n   * .byPage() returns an async iterable iterator to list the queues in pages.\n   *\n   * @param {OperationOptions} [options]\n   * @returns {PagedAsyncIterableIterator<\n   *     QueueProperties,\n   *     EntitiesResponse<QueueProperties>,\n   *   >} An asyncIterableIterator that supports paging.\n   * @memberof ServiceBusAdministrationClient\n   */\n  public listQueues(\n    options?: OperationOptions\n  ): PagedAsyncIterableIterator<QueueProperties, EntitiesResponse<QueueProperties>> {\n    logger.verbose(`Performing management operation - listQueues() with options: %j`, options);\n    const iter = this.listQueuesAll(options);\n    return {\n      /**\n       * @member {Promise} [next] The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listQueuesPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Returns a list of objects, each representing a Queue's runtime info like message count details.\n   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getQueuesRuntimeProperties(\n    options?: ListRequestOptions & OperationOptions\n  ): Promise<EntitiesResponse<QueueRuntimeProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getQueuesRuntimeProperties\",\n      options\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - getQueuesRuntimeProperties() with options: %j`,\n        options\n      );\n      const response: HttpOperationResponse = await this.listResources(\n        \"$Resources/Queues\",\n        updatedOperationOptions,\n        this.queueResourceSerializer\n      );\n\n      return this.buildListQueuesRuntimePropertiesResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async *listQueuesRuntimePropertiesPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {}\n  ): AsyncIterableIterator<EntitiesResponse<QueueRuntimeProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getQueuesRuntimeProperties({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listQueuesRuntimePropertiesAll(\n    options: OperationOptions = {}\n  ): AsyncIterableIterator<QueueRuntimeProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listQueuesRuntimePropertiesPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list runtime info of the queues.\n   *\n   * .byPage() returns an async iterable iterator to list runtime info of the queues in pages.\n   *\n   *\n   * @param {OperationOptions} [options]\n   * @returns {PagedAsyncIterableIterator<\n   *     QueueRuntimeProperties,\n   *     EntitiesResponse<QueueRuntimeProperties>,\n   *   >} An asyncIterableIterator that supports paging.\n   * @memberof ServiceBusAdministrationClient\n   */\n  public listQueuesRuntimeProperties(\n    options?: OperationOptions\n  ): PagedAsyncIterableIterator<QueueRuntimeProperties, EntitiesResponse<QueueRuntimeProperties>> {\n    logger.verbose(\n      `Performing management operation - listQueuesRuntimeProperties() with options: %j`,\n      options\n    );\n    const iter = this.listQueuesRuntimePropertiesAll(options);\n    return {\n      /**\n       * @member {Promise} [next] The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listQueuesRuntimePropertiesPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Updates the queue based on the queue properties provided.\n   * All queue properties must be set even though only a subset of them are actually updatable.\n   * Therefore, the suggested flow is to use the output from `getQueue()`, update the desired properties in it, and then pass the modified object to `updateQueue()`.\n   *\n   * See https://docs.microsoft.com/rest/api/servicebus/update-queue for more details.\n   *\n   * @param queue Object representing the properties of the queue and the raw response.\n   * `requiresSession`, `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the queue.\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateQueue(\n    queue: WithResponse<QueueProperties>,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<QueueProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-updateQueue\",\n      operationOptions\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - updateQueue() for \"${queue.name}\" with options: %j`,\n        queue\n      );\n\n      if (!isJSONLikeObject(queue) || queue == null) {\n        throw new TypeError(\n          `Parameter \"queue\" must be an object of type \"QueueDescription\" and cannot be undefined or null.`\n        );\n      }\n\n      if (!queue.name) {\n        throw new TypeError(`\"name\" attribute of the parameter \"queue\" cannot be undefined.`);\n      }\n\n      const response: HttpOperationResponse = await this.putResource(\n        queue.name,\n        buildQueueOptions(queue),\n        this.queueResourceSerializer,\n        true,\n        updatedOperationOptions\n      );\n\n      return this.buildQueueResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes a queue.\n   * @param queueName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteQueue(\n    queueName: string,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<{}>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-deleteQueue\",\n      operationOptions\n    );\n    try {\n      logger.verbose(`Performing management operation - deleteQueue() for \"${queueName}\"`);\n      const response: HttpOperationResponse = await this.deleteResource(\n        queueName,\n        this.queueResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return { _response: getHttpResponseOnly(response) };\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Checks whether a given queue exists or not.\n   * @param queueName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   */\n  async queueExists(queueName: string, operationOptions?: OperationOptions): Promise<boolean> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-queueExists\",\n      operationOptions\n    );\n    try {\n      logger.verbose(`Performing management operation - queueExists() for \"${queueName}\"`);\n      try {\n        await this.getQueue(queueName, updatedOperationOptions);\n      } catch (error) {\n        if (error.code == \"MessageEntityNotFoundError\") {\n          return false;\n        }\n        throw error;\n      }\n      return true;\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a topic with given name, configured using the given options\n   * @param topicName\n   * @param options Options to configure the Topic being created(For example, you can configure a topic to support partitions)\n   * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async createTopic(\n    topicName: string,\n    options?: CreateTopicOptions\n  ): Promise<WithResponse<TopicProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-createTopic\",\n      options\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - createTopic() for \"${topicName}\" with options: %j`,\n        options\n      );\n      const response: HttpOperationResponse = await this.putResource(\n        topicName,\n        buildTopicOptions(options || {}),\n        this.topicResourceSerializer,\n        false,\n        updatedOperationOptions\n      );\n\n      return this.buildTopicResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an object representing the Topic and its properties.\n   * If you want to get the Topic runtime info like subscription count details, use `getTopicRuntimeProperties` API.\n   * @param topicName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getTopic(\n    topicName: string,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<TopicProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getTopic\",\n      operationOptions\n    );\n    try {\n      logger.verbose(`Performing management operation - getTopic() for \"${topicName}\"`);\n      const response: HttpOperationResponse = await this.getResource(\n        topicName,\n        this.topicResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return this.buildTopicResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an object representing the Topic runtime info like subscription count.\n   * @param topicName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getTopicRuntimeProperties(\n    topicName: string,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<TopicRuntimeProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getTopicRuntimeProperties\",\n      operationOptions\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - getTopicRuntimeProperties() for \"${topicName}\"`\n      );\n      const response: HttpOperationResponse = await this.getResource(\n        topicName,\n        this.topicResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return this.buildTopicRuntimePropertiesResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns a list of objects, each representing a Topic along with its properties.\n   * If you want to get the runtime info of the topics like subscription count, use `getTopicsRuntimeProperties` API instead.\n   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getTopics(\n    options?: ListRequestOptions & OperationOptions\n  ): Promise<EntitiesResponse<TopicProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getTopics\",\n      options\n    );\n    try {\n      logger.verbose(`Performing management operation - getTopics() with options: %j`, options);\n      const response: HttpOperationResponse = await this.listResources(\n        \"$Resources/Topics\",\n        updatedOperationOptions,\n        this.topicResourceSerializer\n      );\n\n      return this.buildListTopicsResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async *listTopicsPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {}\n  ): AsyncIterableIterator<EntitiesResponse<TopicProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getTopics({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listTopicsAll(\n    options: OperationOptions = {}\n  ): AsyncIterableIterator<TopicProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listTopicsPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the topics.\n   *\n   * .byPage() returns an async iterable iterator to list the topics in pages.\n   *\n   *\n   * @param {OperationOptions} [options]\n   * @returns {PagedAsyncIterableIterator<\n   *     TopicProperties,\n   *     EntitiesResponse<TopicProperties>,\n   *   >} An asyncIterableIterator that supports paging.\n   * @memberof ServiceBusAdministrationClient\n   */\n  public listTopics(\n    options?: OperationOptions\n  ): PagedAsyncIterableIterator<TopicProperties, EntitiesResponse<TopicProperties>> {\n    logger.verbose(`Performing management operation - listTopics() with options: %j`, options);\n    const iter = this.listTopicsAll(options);\n    return {\n      /**\n       * @member {Promise} [next] The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listTopicsPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Returns a list of objects, each representing a Topic's runtime info like subscription count.\n   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getTopicsRuntimeProperties(\n    options?: ListRequestOptions & OperationOptions\n  ): Promise<EntitiesResponse<TopicRuntimeProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getTopicsRuntimeProperties\",\n      options\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - getTopicsRuntimeProperties() with options: %j`,\n        options\n      );\n      const response: HttpOperationResponse = await this.listResources(\n        \"$Resources/Topics\",\n        updatedOperationOptions,\n        this.topicResourceSerializer\n      );\n\n      return this.buildListTopicsRuntimePropertiesResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async *listTopicsRuntimePropertiesPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {}\n  ): AsyncIterableIterator<EntitiesResponse<TopicRuntimeProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getTopicsRuntimeProperties({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listTopicsRuntimePropertiesAll(\n    options: OperationOptions = {}\n  ): AsyncIterableIterator<TopicRuntimeProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listTopicsRuntimePropertiesPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list runtime info of the topics.\n   *\n   * .byPage() returns an async iterable iterator to list runtime info of the topics in pages.\n   *\n   *\n   * @param {OperationOptions} [options]\n   * @returns {PagedAsyncIterableIterator<\n   *     TopicRuntimeProperties,\n   *     EntitiesResponse<TopicRuntimeProperties>,\n\n   *   >} An asyncIterableIterator that supports paging.\n   * @memberof ServiceBusAdministrationClient\n   */\n  public listTopicsRuntimeProperties(\n    options?: OperationOptions\n  ): PagedAsyncIterableIterator<TopicRuntimeProperties, EntitiesResponse<TopicRuntimeProperties>> {\n    logger.verbose(\n      `Performing management operation - listTopicsRuntimeProperties() with options: %j`,\n      options\n    );\n    const iter = this.listTopicsRuntimePropertiesAll(options);\n    return {\n      /**\n       * @member {Promise} [next] The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listTopicsRuntimePropertiesPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Updates the topic based on the topic properties provided.\n   * All topic properties must be set even though only a subset of them are actually updatable.\n   * Therefore, the suggested flow is to use the output from `getTopic()`, update the desired properties in it, and then pass the modified object to `updateTopic()`.\n   *\n   * See https://docs.microsoft.com/rest/api/servicebus/update-topic for more details.\n   *\n   * @param topic Object representing the properties of the topic and the raw response.\n   * `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the topic.\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateTopic(\n    topic: WithResponse<TopicProperties>,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<TopicProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-updateTopic\",\n      operationOptions\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - updateTopic() for \"${topic.name}\" with options: %j`,\n        topic\n      );\n\n      if (!isJSONLikeObject(topic) || topic == null) {\n        throw new TypeError(\n          `Parameter \"topic\" must be an object of type \"TopicDescription\" and cannot be undefined or null.`\n        );\n      }\n\n      if (!topic.name) {\n        throw new TypeError(`\"name\" attribute of the parameter \"topic\" cannot be undefined.`);\n      }\n\n      const response: HttpOperationResponse = await this.putResource(\n        topic.name,\n        buildTopicOptions(topic),\n        this.topicResourceSerializer,\n        true,\n        updatedOperationOptions\n      );\n\n      return this.buildTopicResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes a topic.\n   * @param topicName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteTopic(\n    topicName: string,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<{}>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-deleteTopic\",\n      operationOptions\n    );\n    try {\n      logger.verbose(`Performing management operation - deleteTopic() for \"${topicName}\"`);\n      const response: HttpOperationResponse = await this.deleteResource(\n        topicName,\n        this.topicResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return { _response: getHttpResponseOnly(response) };\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Checks whether a given topic exists or not.\n   * @param topicName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   */\n  async topicExists(topicName: string, operationOptions?: OperationOptions): Promise<boolean> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-topicExists\",\n      operationOptions\n    );\n    try {\n      logger.verbose(`Performing management operation - topicExists() for \"${topicName}\"`);\n      try {\n        await this.getTopic(topicName, updatedOperationOptions);\n      } catch (error) {\n        if (error.code == \"MessageEntityNotFoundError\") {\n          return false;\n        }\n        throw error;\n      }\n      return true;\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a subscription with given name, configured using the given options\n   * @param topicName\n   * @param subscriptionName\n   * @param options Options to configure the Subscription being created(For example, you can configure a Subscription to support partitions or sessions)\n   * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async createSubscription(\n    topicName: string,\n    subscriptionName: string,\n    options?: CreateSubscriptionOptions\n  ): Promise<WithResponse<SubscriptionProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-createSubscription\",\n      options\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - createSubscription() for \"${subscriptionName}\" with options: %j`,\n        options\n      );\n      const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n      const response: HttpOperationResponse = await this.putResource(\n        fullPath,\n        buildSubscriptionOptions(options || {}),\n        this.subscriptionResourceSerializer,\n        false,\n        updatedOperationOptions\n      );\n\n      return this.buildSubscriptionResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an object representing the Subscription and its properties.\n   * If you want to get the Subscription runtime info like message count details, use `getSubscriptionRuntimeProperties` API.\n   * @param topicName\n   * @param subscriptionName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getSubscription(\n    topicName: string,\n    subscriptionName: string,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<SubscriptionProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getSubscription\",\n      operationOptions\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - getSubscription() for \"${subscriptionName}\"`\n      );\n      const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n      const response: HttpOperationResponse = await this.getResource(\n        fullPath,\n        this.subscriptionResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return this.buildSubscriptionResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an object representing the Subscription runtime info like message count details.\n   * @param topicName\n   * @param subscriptionName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getSubscriptionRuntimeProperties(\n    topicName: string,\n    subscriptionName: string,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<SubscriptionRuntimeProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getSubscriptionRuntimeProperties\",\n      operationOptions\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - getSubscriptionRuntimeProperties() for \"${subscriptionName}\"`\n      );\n      const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n      const response: HttpOperationResponse = await this.getResource(\n        fullPath,\n        this.subscriptionResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return this.buildSubscriptionRuntimePropertiesResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns a list of objects, each representing a Subscription along with its properties.\n   * If you want to get the runtime info of the subscriptions like message count, use `getSubscriptionsRuntimeProperties` API instead.\n   * @param topicName\n   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getSubscriptions(\n    topicName: string,\n    options?: ListRequestOptions & OperationOptions\n  ): Promise<EntitiesResponse<SubscriptionProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getSubscriptions\",\n      options\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - getSubscriptions() with options: %j`,\n        options\n      );\n      const response: HttpOperationResponse = await this.listResources(\n        topicName + \"/Subscriptions/\",\n        updatedOperationOptions,\n        this.subscriptionResourceSerializer\n      );\n\n      return this.buildListSubscriptionsResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async *listSubscriptionsPage(\n    topicName: string,\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {}\n  ): AsyncIterableIterator<EntitiesResponse<SubscriptionProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getSubscriptions(topicName, {\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listSubscriptionsAll(\n    topicName: string,\n    options: OperationOptions = {}\n  ): AsyncIterableIterator<SubscriptionProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listSubscriptionsPage(topicName, marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   *\n   * Returns an async iterable iterator to list all the subscriptions\n   * under the specified topic.\n   *\n   * .byPage() returns an async iterable iterator to list the subscriptions in pages.\n   *\n   * @memberof ServiceBusAdministrationClient\n   * @param {string} topicName\n   * @param {OperationOptions} [options]\n   * @returns {PagedAsyncIterableIterator<\n   *     SubscriptionProperties,\n   *     EntitiesResponse<SubscriptionProperties>\n   *   >} An asyncIterableIterator that supports paging.\n   * @memberof ServiceBusAdministrationClient\n   */\n  public listSubscriptions(\n    topicName: string,\n    options?: OperationOptions\n  ): PagedAsyncIterableIterator<SubscriptionProperties, EntitiesResponse<SubscriptionProperties>> {\n    logger.verbose(\n      `Performing management operation - listSubscriptions() with options: %j`,\n      options\n    );\n    const iter = this.listSubscriptionsAll(topicName, options);\n    return {\n      /**\n       * @member {Promise} [next] The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listSubscriptionsPage(topicName, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Returns a list of objects, each representing a Subscription's runtime info like message count details.\n   * @param topicName\n   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getSubscriptionsRuntimeProperties(\n    topicName: string,\n    options?: ListRequestOptions & OperationOptions\n  ): Promise<EntitiesResponse<SubscriptionRuntimeProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getSubscriptionsRuntimeProperties\",\n      options\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - getSubscriptionsRuntimeProperties() with options: %j`,\n        options\n      );\n      const response: HttpOperationResponse = await this.listResources(\n        topicName + \"/Subscriptions/\",\n        updatedOperationOptions,\n        this.subscriptionResourceSerializer\n      );\n\n      return this.buildListSubscriptionsRuntimePropertiesResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async *listSubscriptionsRuntimePropertiesPage(\n    topicName: string,\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {}\n  ): AsyncIterableIterator<EntitiesResponse<SubscriptionRuntimeProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getSubscriptionsRuntimeProperties(topicName, {\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listSubscriptionsRuntimePropertiesAll(\n    topicName: string,\n    options: OperationOptions = {}\n  ): AsyncIterableIterator<SubscriptionRuntimeProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listSubscriptionsRuntimePropertiesPage(\n      topicName,\n      marker,\n      options\n    )) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list runtime info of the subscriptions\n   * under the specified topic.\n   *\n   * .byPage() returns an async iterable iterator to list runtime info of subscriptions in pages.\n   *\n   * @param {string} topicName\n   * @param {OperationOptions} [options]\n   * @returns {PagedAsyncIterableIterator<\n   *     SubscriptionRuntimeProperties,\n   *     EntitiesResponse<SubscriptionRuntimeProperties>,\n\n   *   >}  An asyncIterableIterator that supports paging.\n   * @memberof ServiceBusAdministrationClient\n   */\n  public listSubscriptionsRuntimeProperties(\n    topicName: string,\n    options?: OperationOptions\n  ): PagedAsyncIterableIterator<\n    SubscriptionRuntimeProperties,\n    EntitiesResponse<SubscriptionRuntimeProperties>\n  > {\n    logger.verbose(\n      `Performing management operation - listSubscriptionsRuntimeProperties() with options: %j`,\n      options\n    );\n    const iter = this.listSubscriptionsRuntimePropertiesAll(topicName, options);\n    return {\n      /**\n       * @member {Promise} [next] The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listSubscriptionsRuntimePropertiesPage(topicName, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Updates the subscription based on the subscription properties provided.\n   * All subscription properties must be set even though only a subset of them are actually updatable.\n   * Therefore, the suggested flow is to use the output from `getSubscription()`, update the desired properties in it, and then pass the modified object to `updateSubscription()`.\n   *\n   * @param subscription Object representing the properties of the subscription and the raw response.\n   * `subscriptionName`, `topicName`, and `requiresSession` can't be updated after creating the subscription.\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateSubscription(\n    subscription: WithResponse<SubscriptionProperties>,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<SubscriptionProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-updateSubscription\",\n      operationOptions\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - updateSubscription() for \"${subscription.subscriptionName}\" with options: %j`,\n        subscription\n      );\n\n      if (!isJSONLikeObject(subscription) || subscription == null) {\n        throw new TypeError(\n          `Parameter \"subscription\" must be an object of type \"SubscriptionDescription\" and cannot be undefined or null.`\n        );\n      }\n\n      if (!subscription.topicName || !subscription.subscriptionName) {\n        throw new TypeError(\n          `The attributes \"topicName\" and \"subscriptionName\" of the parameter \"subscription\" cannot be undefined.`\n        );\n      }\n\n      const fullPath = this.getSubscriptionPath(\n        subscription.topicName,\n        subscription.subscriptionName\n      );\n\n      const response: HttpOperationResponse = await this.putResource(\n        fullPath,\n        buildSubscriptionOptions(subscription),\n        this.subscriptionResourceSerializer,\n        true,\n        updatedOperationOptions\n      );\n\n      return this.buildSubscriptionResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes a subscription.\n   * @param topicName\n   * @param subscriptionName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteSubscription(\n    topicName: string,\n    subscriptionName: string,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<{}>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-deleteSubscription\",\n      operationOptions\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - deleteSubscription() for \"${subscriptionName}\"`\n      );\n      const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n      const response: HttpOperationResponse = await this.deleteResource(\n        fullPath,\n        this.subscriptionResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return { _response: getHttpResponseOnly(response) };\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Checks whether a given subscription exists in the topic or not.\n   * @param topicName\n   * @param subscriptionName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   */\n  async subscriptionExists(\n    topicName: string,\n    subscriptionName: string,\n    operationOptions?: OperationOptions\n  ): Promise<boolean> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-subscriptionExists\",\n      operationOptions\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - subscriptionExists() for \"${topicName}\" and \"${subscriptionName}\"`\n      );\n      try {\n        await this.getSubscription(topicName, subscriptionName, updatedOperationOptions);\n      } catch (error) {\n        if (error.code == \"MessageEntityNotFoundError\") {\n          return false;\n        }\n        throw error;\n      }\n      return true;\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a rule with given name, configured using the given options.\n   * @param topicName\n   * @param subscriptionName\n   * @param ruleName\n   * @param ruleFilter Defines the filter expression that the rule evaluates.\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  createRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    ruleFilter: SqlRuleFilter | CorrelationRuleFilter,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<RuleProperties>>;\n  /**\n   * Creates a rule with given name, configured using the given options.\n   * @param topicName\n   * @param subscriptionName\n   * @param ruleName\n   * @param ruleFilter Defines the filter expression that the rule evaluates.\n   * @param ruleAction The SQL like expression that can be executed on the message should the associated filter apply.\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  createRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    ruleFilter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleAction: SqlRuleAction,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<RuleProperties>>;\n  async createRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    ruleFilter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleActionOrOperationOptions?: SqlRuleAction | OperationOptions,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<RuleProperties>> {\n    let ruleAction: SqlRuleAction | undefined = undefined;\n    let operOptions: OperationOptions | undefined;\n    if (ruleActionOrOperationOptions) {\n      if (isSqlRuleAction(ruleActionOrOperationOptions)) {\n        // Overload#2 - where the sqlExpression in the ruleAction is defined\n        ruleAction = ruleActionOrOperationOptions;\n        operOptions = operationOptions;\n      } else {\n        // Overload#1\n        // Overload#2 - where the sqlExpression in the ruleAction is undefined\n        operOptions = { ...ruleActionOrOperationOptions, ...operationOptions };\n      }\n    }\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-createRule\",\n      operOptions\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - createRule() for \"${ruleName}\" with filter: \"%j\"`,\n        ruleFilter\n      );\n      const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);\n      const response: HttpOperationResponse = await this.putResource(\n        fullPath,\n        { name: ruleName, filter: ruleFilter, action: ruleAction },\n        this.ruleResourceSerializer,\n        false,\n        updatedOperationOptions\n      );\n      return this.buildRuleResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an object representing the Rule with the given name along with all its properties.\n   * @param topicName\n   * @param subscriptionName\n   * @param ruleName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<RuleProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getRule\",\n      operationOptions\n    );\n    try {\n      logger.verbose(`Performing management operation - getRule() for \"${ruleName}\"`);\n      const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);\n      const response: HttpOperationResponse = await this.getResource(\n        fullPath,\n        this.ruleResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return this.buildRuleResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Lists existing rules.\n   * @param topicName\n   * @param subscriptionName\n   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getRules(\n    topicName: string,\n    subscriptionName: string,\n    options?: ListRequestOptions & OperationOptions\n  ): Promise<EntitiesResponse<RuleProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getRules\",\n      options\n    );\n    try {\n      logger.verbose(`Performing management operation - getRules() with options: %j`, options);\n      const fullPath = this.getSubscriptionPath(topicName, subscriptionName) + \"/Rules/\";\n      const response: HttpOperationResponse = await this.listResources(\n        fullPath,\n        updatedOperationOptions,\n        this.ruleResourceSerializer\n      );\n\n      return this.buildListRulesResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async *listRulesPage(\n    topicName: string,\n    subscriptionName: string,\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {}\n  ): AsyncIterableIterator<EntitiesResponse<RuleProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getRules(topicName, subscriptionName, {\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listRulesAll(\n    topicName: string,\n    subscriptionName: string,\n    options: OperationOptions = {}\n  ): AsyncIterableIterator<RuleProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listRulesPage(topicName, subscriptionName, marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the rules\n   * under the specified subscription.\n   *\n   * .byPage() returns an async iterable iterator to list the rules in pages.\n   *\n   * @param {string} topicName\n   * @param {string} subscriptionName\n   * @param {OperationOptions} [options]\n   * @returns {PagedAsyncIterableIterator<RuleProperties, EntitiesResponse<RuleProperties>>} An asyncIterableIterator that supports paging.\n   * @memberof ServiceBusAdministrationClient\n   */\n  public listRules(\n    topicName: string,\n    subscriptionName: string,\n    options?: OperationOptions\n  ): PagedAsyncIterableIterator<RuleProperties, EntitiesResponse<RuleProperties>> {\n    logger.verbose(`Performing management operation - listRules() with options: %j`, options);\n    const iter = this.listRulesAll(topicName, subscriptionName, options);\n    return {\n      /**\n       * @member {Promise} [next] The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listRulesPage(topicName, subscriptionName, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Updates properties on the Rule by the given name based on the given options.\n   * All rule properties must be set even if one of them is being updated.\n   * Therefore, the suggested flow is to use the output from `getRule()`, update the desired properties in it, and then pass the modified object to `updateRule()`.\n   *\n   * @param topicName\n   * @param subscriptionName\n   * @param rule Options to configure the Rule being updated and the raw response.\n   * For example, you can configure the filter to apply on associated Topic/Subscription.\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateRule(\n    topicName: string,\n    subscriptionName: string,\n    rule: WithResponse<RuleProperties>,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<RuleProperties>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-updateRule\",\n      operationOptions\n    );\n    try {\n      logger.verbose(\n        `Performing management operation - updateRule() for \"${rule.name}\" with options: %j`,\n        rule\n      );\n\n      if (!isJSONLikeObject(rule) || rule === null) {\n        throw new TypeError(\n          `Parameter \"rule\" must be an object of type \"RuleDescription\" and cannot be undefined or null.`\n        );\n      }\n\n      if (!rule.name) {\n        throw new TypeError(`\"name\" attribute of the parameter \"rule\" cannot be undefined.`);\n      }\n\n      const fullPath = this.getRulePath(topicName, subscriptionName, rule.name);\n      const response: HttpOperationResponse = await this.putResource(\n        fullPath,\n        rule,\n        this.ruleResourceSerializer,\n        true,\n        updatedOperationOptions\n      );\n\n      return this.buildRuleResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes a rule.\n   * @param topicName\n   * @param subscriptionName\n   * @param ruleName\n   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    operationOptions?: OperationOptions\n  ): Promise<WithResponse<{}>> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-deleteRule\",\n      operationOptions\n    );\n    try {\n      logger.verbose(`Performing management operation - deleteRule() for \"${ruleName}\"`);\n      const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);\n      const response: HttpOperationResponse = await this.deleteResource(\n        fullPath,\n        this.ruleResourceSerializer,\n        updatedOperationOptions\n      );\n\n      return { _response: getHttpResponseOnly(response) };\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Checks whether a given rule exists or not.\n   *\n   * @param {string} topicName\n   * @param {string} subscriptionName\n   * @param {string} ruleName\n   * @param {OperationOptions} [operationOptions]\n   */\n  async ruleExists(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    operationOptions?: OperationOptions\n  ): Promise<boolean> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-ruleExists\",\n      operationOptions\n    );\n    try {\n      logger.verbose(`Performing management operation - ruleExists() for \"${ruleName}\"`);\n      try {\n        await this.getRule(topicName, subscriptionName, ruleName, updatedOperationOptions);\n      } catch (error) {\n        if (error.code == \"MessageEntityNotFoundError\") {\n          return false;\n        }\n        throw error;\n      }\n      return true;\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates or updates a resource based on `isUpdate` parameter.\n   * @param name\n   * @param entityFields\n   * @param isUpdate\n   * @param serializer\n   */\n  private async putResource(\n    name: string,\n    entityFields:\n      | InternalQueueOptions\n      | InternalTopicOptions\n      | InternalSubscriptionOptions\n      | CreateRuleOptions,\n    serializer: AtomXmlSerializer,\n    isUpdate: boolean = false,\n    operationOptions: OperationOptions = {}\n  ): Promise<HttpOperationResponse> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-putResource\",\n      operationOptions\n    );\n    try {\n      const webResource: WebResource = new WebResource(this.getUrl(name), \"PUT\");\n      webResource.body = entityFields;\n      if (isUpdate) {\n        webResource.headers.set(\"If-Match\", \"*\");\n      }\n\n      const queueOrSubscriptionFields = entityFields as\n        | InternalQueueOptions\n        | InternalSubscriptionOptions;\n      if (\n        queueOrSubscriptionFields.ForwardTo ||\n        queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo\n      ) {\n        const token =\n          this.credentials instanceof SasServiceClientCredentials\n            ? this.credentials.getToken(this.endpoint).token\n            : (await this.credentials.getToken([AMQPConstants.aadServiceBusScope]))!.token;\n\n        if (queueOrSubscriptionFields.ForwardTo) {\n          webResource.headers.set(\"ServiceBusSupplementaryAuthorization\", token);\n          if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardTo)) {\n            queueOrSubscriptionFields.ForwardTo = this.endpointWithProtocol.concat(\n              queueOrSubscriptionFields.ForwardTo\n            );\n          }\n        }\n        if (queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {\n          webResource.headers.set(\"ServiceBusDlqSupplementaryAuthorization\", token);\n          if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo)) {\n            queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo = this.endpointWithProtocol.concat(\n              queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo\n            );\n          }\n        }\n      }\n\n      webResource.headers.set(\"content-type\", \"application/atom+xml;type=entry;charset=utf-8\");\n\n      return executeAtomXmlOperation(this, webResource, serializer, updatedOperationOptions);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Gets a resource.\n   * @param name\n   * @param serializer\n   */\n  private async getResource(\n    name: string,\n    serializer: AtomXmlSerializer,\n    operationOptions: OperationOptions = {}\n  ): Promise<HttpOperationResponse> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-getResource\",\n      operationOptions\n    );\n    try {\n      const webResource: WebResource = new WebResource(this.getUrl(name), \"GET\");\n\n      const response = await executeAtomXmlOperation(\n        this,\n        webResource,\n        serializer,\n        updatedOperationOptions\n      );\n      if (\n        response.parsedBody == undefined ||\n        (Array.isArray(response.parsedBody) && response.parsedBody.length == 0)\n      ) {\n        const err = new RestError(\n          `The messaging entity \"${name}\" being requested cannot be found.`,\n          \"MessageEntityNotFoundError\",\n          response.status,\n          stripRequest(webResource),\n          stripResponse(response)\n        );\n        throw err;\n      }\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Lists existing resources\n   * @param name\n   * @param options\n   * @param serializer\n   */\n  private async listResources(\n    name: string,\n    options: ListRequestOptions & OperationOptions = {},\n    serializer: AtomXmlSerializer\n  ): Promise<HttpOperationResponse> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-listResources\",\n      options\n    );\n    try {\n      const queryParams: { [key: string]: string } = {};\n      if (options) {\n        if (options.skip) {\n          queryParams[\"$skip\"] = options.skip.toString();\n        }\n        if (options.maxCount) {\n          queryParams[\"$top\"] = options.maxCount.toString();\n        }\n      }\n\n      const webResource: WebResource = new WebResource(this.getUrl(name, queryParams), \"GET\");\n\n      return executeAtomXmlOperation(this, webResource, serializer, updatedOperationOptions);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes a resource.\n   * @param name\n   */\n  private async deleteResource(\n    name: string,\n    serializer: AtomXmlSerializer,\n    operationOptions: OperationOptions = {}\n  ): Promise<HttpOperationResponse> {\n    const { span, updatedOperationOptions } = createSpan(\n      \"ServiceBusAdministrationClient-deleteResource\",\n      operationOptions\n    );\n    try {\n      const webResource: WebResource = new WebResource(this.getUrl(name), \"DELETE\");\n\n      return executeAtomXmlOperation(this, webResource, serializer, updatedOperationOptions);\n    } catch (e) {\n      span.setStatus({\n        code: getCanonicalCode(e),\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private getUrl(path: string, queryParams?: { [key: string]: string }): string {\n    const baseUri = `https://${this.endpoint}/${path}`;\n\n    const requestUrl: URLBuilder = URLBuilder.parse(baseUri);\n    requestUrl.setQueryParameter(Constants.API_VERSION_QUERY_KEY, Constants.CURRENT_API_VERSION);\n\n    if (queryParams) {\n      for (const key of Object.keys(queryParams)) {\n        requestUrl.setQueryParameter(key, queryParams[key]);\n      }\n    }\n\n    return requestUrl.toString();\n  }\n\n  private getSubscriptionPath(topicName: string, subscriptionName: string): string {\n    return topicName + \"/Subscriptions/\" + subscriptionName;\n  }\n\n  private getRulePath(topicName: string, subscriptionName: string, ruleName: string): string {\n    return topicName + \"/Subscriptions/\" + subscriptionName + \"/Rules/\" + ruleName;\n  }\n\n  private getMarkerFromNextLinkUrl(url: string): string | undefined {\n    if (!url) {\n      return undefined;\n    }\n    try {\n      return parseURL(url).searchParams.get(Constants.XML_METADATA_MARKER + \"skip\");\n    } catch (error) {\n      throw new Error(\n        `Unable to parse the '${Constants.XML_METADATA_MARKER}skip' from the next-link in the response ` +\n          error\n      );\n    }\n  }\n\n  private buildNamespacePropertiesResponse(\n    response: HttpOperationResponse\n  ): WithResponse<NamespaceProperties> {\n    try {\n      const namespace = buildNamespace(response.parsedBody);\n      const namespaceResponse: WithResponse<NamespaceProperties> = Object.defineProperty(\n        namespace || {},\n        \"_response\",\n        { value: getHttpResponseOnly(response) }\n      );\n      return namespaceResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a namespace object using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildListQueuesResponse(\n    response: HttpOperationResponse\n  ): EntitiesResponse<QueueProperties> {\n    try {\n      const queues: QueueProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawQueueArray: any = response.parsedBody;\n      for (let i = 0; i < rawQueueArray.length; i++) {\n        const queue = buildQueue(rawQueueArray[i]);\n        if (queue) {\n          queues.push(queue);\n        }\n      }\n      const listQueuesResponse: EntitiesResponse<QueueProperties> = Object.defineProperty(\n        queues,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      listQueuesResponse.continuationToken = nextMarker;\n      return listQueuesResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildListQueuesRuntimePropertiesResponse(\n    response: HttpOperationResponse\n  ): EntitiesResponse<QueueRuntimeProperties> {\n    try {\n      const queues: QueueRuntimeProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawQueueArray: any = response.parsedBody;\n      for (let i = 0; i < rawQueueArray.length; i++) {\n        const queue = buildQueueRuntimeProperties(rawQueueArray[i]);\n        if (queue) {\n          queues.push(queue);\n        }\n      }\n      const listQueuesResponse: EntitiesResponse<QueueRuntimeProperties> = Object.defineProperty(\n        queues,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      listQueuesResponse.continuationToken = nextMarker;\n      return listQueuesResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildQueueResponse(response: HttpOperationResponse): WithResponse<QueueProperties> {\n    try {\n      const queue = buildQueue(response.parsedBody);\n      const queueResponse: WithResponse<QueueProperties> = Object.defineProperty(\n        queue || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      return queueResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a queue object using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildQueueRuntimePropertiesResponse(\n    response: HttpOperationResponse\n  ): WithResponse<QueueRuntimeProperties> {\n    try {\n      const queue = buildQueueRuntimeProperties(response.parsedBody);\n      const queueResponse: WithResponse<QueueRuntimeProperties> = Object.defineProperty(\n        queue || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      return queueResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a queue object using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildListTopicsResponse(\n    response: HttpOperationResponse\n  ): EntitiesResponse<TopicProperties> {\n    try {\n      const topics: TopicProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawTopicArray: any = response.parsedBody;\n      for (let i = 0; i < rawTopicArray.length; i++) {\n        const topic = buildTopic(rawTopicArray[i]);\n        if (topic) {\n          topics.push(topic);\n        }\n      }\n      const listTopicsResponse: EntitiesResponse<TopicProperties> = Object.defineProperty(\n        topics,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      listTopicsResponse.continuationToken = nextMarker;\n      return listTopicsResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildListTopicsRuntimePropertiesResponse(\n    response: HttpOperationResponse\n  ): EntitiesResponse<TopicRuntimeProperties> {\n    try {\n      const topics: TopicRuntimeProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawTopicArray: any = response.parsedBody;\n      for (let i = 0; i < rawTopicArray.length; i++) {\n        const topic = buildTopicRuntimeProperties(rawTopicArray[i]);\n        if (topic) {\n          topics.push(topic);\n        }\n      }\n      const listTopicsResponse: EntitiesResponse<TopicRuntimeProperties> = Object.defineProperty(\n        topics,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      listTopicsResponse.continuationToken = nextMarker;\n      return listTopicsResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n  private buildTopicResponse(response: HttpOperationResponse): WithResponse<TopicProperties> {\n    try {\n      const topic = buildTopic(response.parsedBody);\n      const topicResponse: WithResponse<TopicProperties> = Object.defineProperty(\n        topic || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      return topicResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a topic object using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildTopicRuntimePropertiesResponse(\n    response: HttpOperationResponse\n  ): WithResponse<TopicRuntimeProperties> {\n    try {\n      const topic = buildTopicRuntimeProperties(response.parsedBody);\n      const topicResponse: WithResponse<TopicRuntimeProperties> = Object.defineProperty(\n        topic || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      return topicResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a topic object using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildListSubscriptionsResponse(\n    response: HttpOperationResponse\n  ): EntitiesResponse<SubscriptionProperties> {\n    try {\n      const subscriptions: SubscriptionProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawSubscriptionArray: any = response.parsedBody;\n      for (let i = 0; i < rawSubscriptionArray.length; i++) {\n        const subscription = buildSubscription(rawSubscriptionArray[i]);\n        if (subscription) {\n          subscriptions.push(subscription);\n        }\n      }\n      const listSubscriptionsResponse: EntitiesResponse<SubscriptionProperties> = Object.defineProperty(\n        subscriptions,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      listSubscriptionsResponse.continuationToken = nextMarker;\n      return listSubscriptionsResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildListSubscriptionsRuntimePropertiesResponse(\n    response: HttpOperationResponse\n  ): EntitiesResponse<SubscriptionRuntimeProperties> {\n    try {\n      const subscriptions: SubscriptionRuntimeProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawSubscriptionArray: any = response.parsedBody;\n      for (let i = 0; i < rawSubscriptionArray.length; i++) {\n        const subscription = buildSubscriptionRuntimeProperties(rawSubscriptionArray[i]);\n        if (subscription) {\n          subscriptions.push(subscription);\n        }\n      }\n      const listSubscriptionsResponse: EntitiesResponse<SubscriptionRuntimeProperties> = Object.defineProperty(\n        subscriptions,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      listSubscriptionsResponse.continuationToken = nextMarker;\n      return listSubscriptionsResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildSubscriptionResponse(\n    response: HttpOperationResponse\n  ): WithResponse<SubscriptionProperties> {\n    try {\n      const subscription = buildSubscription(response.parsedBody);\n      const subscriptionResponse: WithResponse<SubscriptionProperties> = Object.defineProperty(\n        subscription || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      return subscriptionResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildSubscriptionRuntimePropertiesResponse(\n    response: HttpOperationResponse\n  ): WithResponse<SubscriptionRuntimeProperties> {\n    try {\n      const subscription = buildSubscriptionRuntimeProperties(response.parsedBody);\n      const subscriptionResponse: WithResponse<SubscriptionRuntimeProperties> = Object.defineProperty(\n        subscription || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      return subscriptionResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildListRulesResponse(\n    response: HttpOperationResponse\n  ): EntitiesResponse<RuleProperties> {\n    try {\n      const rules: RuleProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawRuleArray: any = response.parsedBody;\n      for (let i = 0; i < rawRuleArray.length; i++) {\n        const rule = buildRule(rawRuleArray[i]);\n        if (rule) {\n          rules.push(rule);\n        }\n      }\n      const listRulesResponse: EntitiesResponse<RuleProperties> = Object.defineProperty(\n        rules,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      listRulesResponse.continuationToken = nextMarker;\n      return listRulesResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of rules using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private buildRuleResponse(response: HttpOperationResponse): WithResponse<RuleProperties> {\n    try {\n      const rule = buildRule(response.parsedBody);\n      const ruleResponse: WithResponse<RuleProperties> = Object.defineProperty(\n        rule || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response)\n        }\n      );\n      return ruleResponse;\n    } catch (err) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a rule object using the response from the service.`,\n        RestError.PARSE_ERROR,\n        response.status,\n        stripRequest(response.request),\n        stripResponse(response)\n      );\n    }\n  }\n\n  private throwIfInvalidContinuationToken(token: string | undefined) {\n    if (!(token === undefined || (typeof token === \"string\" && Number(token) >= 0))) {\n      throw new Error(`Invalid continuationToken ${token} provided`);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { message } from \"rhea-promise\";\nimport isBuffer from \"is-buffer\";\nimport { Buffer } from \"buffer\";\nimport { logErrorStackTrace, logger } from \"./log\";\n\n/**\n * The default data transformer that will be used by the Azure SDK.\n * @internal\n * @hidden\n */\nexport const defaultDataTransformer = {\n  /**\n   * A function that takes the body property from an EventData object\n   * and returns an encoded body (some form of AMQP type).\n   *\n   * @param {*} body The AMQP message body\n   * @return {DataSection} encodedBody - The encoded AMQP message body as an AMQP Data type\n   * (data section in rhea terms). Section object with following properties:\n   * - typecode: 117 (0x75)\n   * - content: The given AMQP message body as a Buffer.\n   * - multiple: true | undefined.\n   */\n  encode(body: any): any {\n    let result: any;\n    if (isBuffer(body)) {\n      result = message.data_section(body);\n    } else {\n      // string, undefined, null, boolean, array, object, number should end up here\n      // coercing undefined to null as that will ensure that null value will be given to the\n      // customer on receive.\n      if (body === undefined) body = null; // tslint:disable-line\n      try {\n        const bodyStr = JSON.stringify(body);\n        result = message.data_section(Buffer.from(bodyStr, \"utf8\"));\n      } catch (err) {\n        const msg =\n          `An error occurred while executing JSON.stringify() on the given body ` +\n          body +\n          `${err ? err.stack : JSON.stringify(err)}`;\n        logger.warning(\"[encode] \" + msg);\n        logErrorStackTrace(logger, err);\n        throw new Error(msg);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * @property {Function} [decode] A function that takes the body property from an AMQP message\n   * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.\n   * If it cannot decode the body then it returns the body\n   * as-is.\n   * @param {DataSection} body The AMQP message body\n   * @return {*} decoded body or the given body as-is.\n   */\n  decode(body: any): any {\n    let processedBody: any = body;\n    try {\n      if (body.content && isBuffer(body.content)) {\n        // This indicates that we are getting the AMQP described type. Let us try decoding it.\n        processedBody = body.content;\n      }\n      try {\n        // Trying to stringify and JSON.parse() anything else will fail flat and we shall return\n        // the original type back\n        const bodyStr: string = processedBody.toString(\"utf8\");\n        processedBody = JSON.parse(bodyStr);\n      } catch (err) {\n        logger.verbose(\n          \"[decode] An error occurred while trying JSON.parse() on the received body. \" +\n            \"The error is %O\",\n          err\n        );\n      }\n    } catch (err) {\n      logger.verbose(\n        \"[decode] An error occurred while decoding the received message body. The error is: %O\",\n        err\n      );\n    }\n    return processedBody;\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AmqpAnnotatedMessage, Constants } from \"@azure/core-amqp\";\nimport { Buffer } from \"buffer\";\nimport Long from \"long\";\nimport {\n  Delivery,\n  DeliveryAnnotations,\n  MessageAnnotations,\n  uuid_to_string,\n  Message as RheaMessage\n} from \"rhea-promise\";\nimport { defaultDataTransformer } from \"./dataTransformer\";\nimport { messageLogger as logger } from \"./log\";\nimport { ReceiveMode } from \"./models\";\nimport { reorderLockToken } from \"./util/utils\";\n\n/**\n * @internal\n * @hidden\n */\nexport enum DispositionType {\n  complete = \"complete\",\n  deadletter = \"deadletter\",\n  abandon = \"abandon\",\n  defer = \"defer\"\n}\n\n/**\n * @internal\n * @hidden\n * Describes the delivery annotations for Service Bus.\n */\nexport interface ServiceBusDeliveryAnnotations extends DeliveryAnnotations {\n  /**\n   * @property {string} [last_enqueued_offset] The offset of the last event.\n   */\n  last_enqueued_offset?: string;\n  /**\n   * @property {number} [last_enqueued_sequence_number] The sequence number of the last event.\n   */\n  last_enqueued_sequence_number?: number;\n  /**\n   * @property {number} [last_enqueued_time_utc] The enqueued time of the last event.\n   */\n  last_enqueued_time_utc?: number;\n  /**\n   * @property {number} [runtime_info_retrieval_time_utc] The retrieval time of the last event.\n   */\n  runtime_info_retrieval_time_utc?: number;\n  /**\n   * @property {string} Any unknown delivery annotations.\n   */\n  [x: string]: any;\n}\n\n/**\n * @internal\n * @hidden\n * Describes the message annotations for Service Bus.\n */\nexport interface ServiceBusMessageAnnotations extends MessageAnnotations {\n  /**\n   * @property {string | null} [x-opt-partition-key] Annotation for the partition key set for the event.\n   */\n  \"x-opt-partition-key\"?: string | null;\n  /**\n   * @property {number} [x-opt-sequence-number] Annontation for the sequence number of the event.\n   */\n  \"x-opt-sequence-number\"?: number;\n  /**\n   * @property {number} [x-opt-enqueued-time] Annotation for the enqueued time of the event.\n   */\n  \"x-opt-enqueued-time\"?: number;\n  /**\n   * @property {string} [x-opt-offset] Annotation for the offset of the event.\n   */\n  \"x-opt-offset\"?: string;\n  /**\n   * @property {string} [x-opt-locked-until] Annotation for the message being locked until.\n   */\n  \"x-opt-locked-until\"?: Date | number;\n}\n\n/**\n * Describes the reason and error description for dead lettering a message using the `deadLetter()`\n * method on the message received from Service Bus.\n */\nexport interface DeadLetterOptions {\n  /**\n   * @property The reason for deadlettering the message.\n   */\n  deadLetterReason: string;\n  /**\n   * @property The error description for deadlettering the message.\n   */\n  deadLetterErrorDescription: string;\n}\n\n/**\n * Describes the message to be sent to Service Bus.\n */\nexport interface ServiceBusMessage {\n  /**\n   * @property The message body that needs to be sent or is received.\n   * If the application receiving the message is not using this SDK,\n   * convert your body payload to a byte array or Buffer for better\n   * cross-language compatibility.\n   */\n  body: any;\n  /**\n   * @property The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * @property The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n  /**\n   * @property The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  correlationId?: string | number | Buffer;\n  /**\n   * @property The partition key for sending a message to a partitioned entity.\n   * Maximum length is 128 characters. For {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning partitioned entities},\n   * setting this value enables assigning related messages to the same internal partition,\n   * so that submission sequence order is correctly recorded. The partition is chosen by a hash\n   * function over this value and cannot be chosen directly.\n   * - For session-aware entities, the `sessionId` property overrides this value.\n   * - For non partitioned entities, partition key will be ignored\n   *\n   */\n  partitionKey?: string;\n  /**\n   * @property The partition key for sending a message into an entity\n   * via a partitioned transfer queue. Maximum length is 128 characters. If a message is sent via a\n   * transfer queue in the scope of a transaction, this value selects the transfer queue partition:\n   * This is functionally equivalent to `partitionKey` property and ensures that messages are kept\n   * together and in order as they are transferred.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via Transfers and Send Via}.\n   */\n\n  // Will be required later for implementing Transactions\n  // viaPartitionKey?: string;\n\n  /**\n   * @property The session identifier for a session-aware entity. Maximum\n   * length is 128 characters. For session-aware entities, this application-defined value specifies\n   * the session affiliation of the message. Messages with the same session identifier are subject\n   * to summary locking and enable exact in-order processing and demultiplexing. For\n   * session-unaware entities, this value is ignored.\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions Message Sessions}.\n   */\n  sessionId?: string;\n  /**\n   * @property The session identifier augmenting the `replyTo` address.\n   * Maximum length is 128 characters. This value augments the ReplyTo information and specifies\n   * which SessionId should be set for the reply when sent to the reply entity.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  replyToSessionId?: string;\n  /**\n   * @property The message’s time to live value. This value is the relative\n   * duration after which the message expires, starting from the instant the message has been\n   * accepted and stored by the broker, as captured in `enqueuedTimeUtc`. When not set explicitly,\n   * the assumed value is the DefaultTimeToLive for the respective queue or topic. A message-level\n   * `timeToLive` value cannot be longer than the entity's DefaultTimeToLive setting and it is\n   * silently adjusted if it does. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-expiration Expiration}.\n   */\n  timeToLive?: number;\n  /**\n   * @property The application specific label. This property enables the\n   * application to indicate the purpose of the message to the receiver in a standardized. fashion,\n   * similar to an email subject line. The mapped AMQP property is \"subject\".\n   */\n  subject?: string;\n  /**\n   * @property The \"to\" address. This property is reserved for future use in routing\n   * scenarios and presently ignored by the broker itself. Applications can use this value in\n   * rule-driven {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-auto-forwarding auto-forward chaining}\n   * scenarios to indicate the intended logical destination of the message.\n   */\n  to?: string;\n  /**\n   * @property The address of an entity to send replies to. This optional and\n   * application-defined value is a standard way to express a reply path to the receiver of the\n   * message. When a sender expects a reply, it sets the value to the absolute or relative path of\n   * the queue or topic it expects the reply to be sent to. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  replyTo?: string;\n  /**\n   * @property The date and time in UTC at which the message will\n   * be enqueued. This property returns the time in UTC; when setting the property, the\n   * supplied DateTime value must also be in UTC. This value is for delayed message sending.\n   * It is utilized to delay messages sending to a specific time in the future. Message enqueuing\n   * time does not mean that the message will be sent at the same time. It will get enqueued,\n   * but the actual sending time depends on the queue's workload and its state.\n   */\n  scheduledEnqueueTimeUtc?: Date;\n  /**\n   * @property The application specific properties which can be\n   * used for custom message metadata.\n   */\n  applicationProperties?: { [key: string]: number | boolean | string | Date };\n}\n\n/**\n * @internal\n * @hidden\n * Gets the error message for when a property on given message is not of expected type\n */\nexport function getMessagePropertyTypeMismatchError(msg: ServiceBusMessage): Error | undefined {\n  if (msg.contentType != null && typeof msg.contentType !== \"string\") {\n    return new TypeError(\"The property 'contentType' on the message must be of type 'string'\");\n  }\n\n  if (msg.subject != null && typeof msg.subject !== \"string\") {\n    return new TypeError(\"The property 'label' on the message must be of type 'string'\");\n  }\n\n  if (msg.to != null && typeof msg.to !== \"string\") {\n    return new TypeError(\"The property 'to' on the message must be of type 'string'\");\n  }\n\n  if (msg.replyTo != null && typeof msg.replyTo !== \"string\") {\n    return new TypeError(\"The property 'replyTo' on the message must be of type 'string'\");\n  }\n\n  if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== \"string\") {\n    return new TypeError(\"The property 'replyToSessionId' on the message must be of type 'string'\");\n  }\n\n  if (msg.timeToLive != null && typeof msg.timeToLive !== \"number\") {\n    return new TypeError(\"The property 'timeToLive' on the message must be of type 'number'\");\n  }\n\n  if (msg.sessionId != null && typeof msg.sessionId !== \"string\") {\n    return new TypeError(\"The property 'sessionId' on the message must be of type 'string'\");\n  }\n\n  if (\n    msg.messageId != null &&\n    typeof msg.messageId !== \"string\" &&\n    typeof msg.messageId !== \"number\" &&\n    !Buffer.isBuffer(msg.messageId)\n  ) {\n    return new TypeError(\n      \"The property 'messageId' on the message must be of type string, number or Buffer\"\n    );\n  }\n\n  if (\n    msg.correlationId != null &&\n    typeof msg.correlationId !== \"string\" &&\n    typeof msg.correlationId !== \"number\" &&\n    !Buffer.isBuffer(msg.correlationId)\n  ) {\n    return new TypeError(\n      \"The property 'correlationId' on the message must be of type string, number or Buffer\"\n    );\n  }\n  return;\n}\n\n/**\n * @internal\n * @hidden\n * Converts given ServiceBusMessage to RheaMessage\n */\nexport function toRheaMessage(msg: ServiceBusMessage): RheaMessage {\n  const amqpMsg: RheaMessage = {\n    body: msg.body,\n    message_annotations: {}\n  };\n  if (msg.applicationProperties != null) {\n    amqpMsg.application_properties = msg.applicationProperties;\n  }\n  if (msg.contentType != null) {\n    amqpMsg.content_type = msg.contentType;\n  }\n  if (msg.sessionId != null) {\n    if (msg.sessionId.length > Constants.maxSessionIdLength) {\n      throw new Error(\n        \"Length of 'sessionId' property on the message cannot be greater than 128 characters.\"\n      );\n    }\n    amqpMsg.group_id = msg.sessionId;\n  }\n  if (msg.replyTo != null) {\n    amqpMsg.reply_to = msg.replyTo;\n  }\n  if (msg.to != null) {\n    amqpMsg.to = msg.to;\n  }\n  if (msg.subject != null) {\n    amqpMsg.subject = msg.subject;\n  }\n  if (msg.messageId != null) {\n    if (typeof msg.messageId === \"string\" && msg.messageId.length > Constants.maxMessageIdLength) {\n      throw new Error(\n        \"Length of 'messageId' property on the message cannot be greater than 128 characters.\"\n      );\n    }\n    amqpMsg.message_id = msg.messageId;\n  }\n  if (msg.correlationId != null) {\n    amqpMsg.correlation_id = msg.correlationId;\n  }\n  if (msg.replyToSessionId != null) {\n    amqpMsg.reply_to_group_id = msg.replyToSessionId;\n  }\n  if (msg.timeToLive != null && msg.timeToLive !== Constants.maxDurationValue) {\n    amqpMsg.ttl = msg.timeToLive;\n    amqpMsg.creation_time = Date.now();\n    if (Constants.maxAbsoluteExpiryTime - amqpMsg.creation_time > amqpMsg.ttl) {\n      amqpMsg.absolute_expiry_time = amqpMsg.creation_time + amqpMsg.ttl;\n    } else {\n      amqpMsg.absolute_expiry_time = Constants.maxAbsoluteExpiryTime;\n    }\n  }\n  if (msg.partitionKey != null) {\n    if (msg.partitionKey.length > Constants.maxPartitionKeyLength) {\n      throw new Error(\n        \"Length of 'partitionKey' property on the message cannot be greater than 128 characters.\"\n      );\n    }\n    amqpMsg.message_annotations![Constants.partitionKey] = msg.partitionKey;\n  }\n\n  // Will be required later for implementing Transactions\n  // if (msg.viaPartitionKey != null) {\n  //   if (msg.viaPartitionKey.length > Constants.maxPartitionKeyLength) {\n  //     throw new Error(\n  //       \"Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters.\"\n  //     );\n  //   }\n  //   amqpMsg.message_annotations![Constants.viaPartitionKey] = msg.viaPartitionKey;\n  // }\n\n  if (msg.scheduledEnqueueTimeUtc != null) {\n    amqpMsg.message_annotations![Constants.scheduledEnqueueTime] = msg.scheduledEnqueueTimeUtc;\n  }\n\n  logger.verbose(\"SBMessage to RheaMessage: %O\", amqpMsg);\n  return amqpMsg;\n}\n\n/**\n * Describes the message received from Service Bus during peek operations and so cannot be settled.\n * @class ServiceBusReceivedMessage\n */\nexport interface ServiceBusReceivedMessage extends ServiceBusMessage {\n  /**\n   * @property The reason for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterReason?: string;\n  /**\n   * @property The error description for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterErrorDescription?: string;\n  /**\n   * @property The lock token is a reference to the lock that is being held by the broker in\n   * `peekLock` receive mode. Locks are used internally settle messages as explained in the\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement product documentation in more detail}\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   * @readonly\n   */\n  readonly lockToken?: string;\n  /**\n   * @property Number of deliveries that have been attempted for this message. The count is\n   * incremented when a message lock expires, or the message is explicitly abandoned using the\n   * `abandon()` method on the message.\n   * @readonly\n   */\n  readonly deliveryCount?: number;\n  /**\n   * @property The UTC instant at which the message has been accepted and stored in Service Bus.\n   * @readonly\n   */\n  readonly enqueuedTimeUtc?: Date;\n  /**\n   * @property The UTC instant at which the message is marked for removal and no longer available for\n   * retrieval from the entity due to expiration. This property is computed from 2 other properties\n   * on the message: `enqueuedTimeUtc` + `timeToLive`.\n   */\n  readonly expiresAtUtc?: Date;\n  /**\n   * @property The UTC instant until which the message is held locked in the queue/subscription.\n   * When the lock expires, the `deliveryCount` is incremented and the message is again available\n   * for retrieval.\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   */\n  lockedUntilUtc?: Date;\n  /**\n   * @property The original sequence number of the message. For\n   * messages that have been auto-forwarded, this property reflects the sequence number that had\n   * first been assigned to the message at its original point of submission.\n   * @readonly\n   */\n  readonly enqueuedSequenceNumber?: number;\n  /**\n   * @property The unique number assigned to a message by Service Bus.\n   * The sequence number is a unique 64-bit integer assigned to a message as it is accepted\n   * and stored by the broker and functions as its true identifier. For partitioned entities,\n   * the topmost 16 bits reflect the partition identifier. Sequence numbers monotonically increase.\n   * They roll over to 0 when the 48-64 bit range is exhausted.\n   *\n   * **Max safe integer** that Javascript currently supports is `2^53 - 1`. The sequence number\n   * is an AMQP `Long` type which can be upto 64 bits long. To represent that we are using a\n   * library named {@link https://github.com/dcodeIO/long.js long.js}. We expect customers\n   * to use the **`Long`** type exported by this library.\n   * @readonly\n   */\n  readonly sequenceNumber?: Long;\n  /**\n   * @property The name of the queue or subscription that this message\n   * was enqueued on, before it was deadlettered. Only set in messages that have been dead-lettered\n   * and subsequently auto-forwarded from the dead-letter sub-queue to another entity. Indicates the\n   * entity in which the message was dead-lettered.\n   * @readonly\n   */\n  readonly deadLetterSource?: string;\n  /**\n   * @property The underlying raw amqp message.\n   * @readonly\n   */\n  readonly _rawAmqpMessage: AmqpAnnotatedMessage;\n}\n\n/**\n * @internal\n * @hidden\n * Converts given RheaMessage to ServiceBusReceivedMessage\n */\nexport function fromRheaMessage(\n  msg: RheaMessage,\n  delivery?: Delivery,\n  shouldReorderLockToken?: boolean\n): ServiceBusReceivedMessage {\n  if (!msg) {\n    msg = {\n      body: undefined\n    };\n  }\n  const sbmsg: ServiceBusMessage = {\n    body: msg.body\n  };\n\n  if (msg.application_properties != null) {\n    sbmsg.applicationProperties = msg.application_properties;\n  }\n  if (msg.content_type != null) {\n    sbmsg.contentType = msg.content_type;\n  }\n  if (msg.group_id != null) {\n    sbmsg.sessionId = msg.group_id;\n  }\n  if (msg.reply_to != null) {\n    sbmsg.replyTo = msg.reply_to;\n  }\n  if (msg.to != null) {\n    sbmsg.to = msg.to;\n  }\n  if (msg.ttl != null) {\n    sbmsg.timeToLive = msg.ttl;\n  }\n  if (msg.subject != null) {\n    sbmsg.subject = msg.subject;\n  }\n  if (msg.message_id != null) {\n    sbmsg.messageId = msg.message_id;\n  }\n  if (msg.correlation_id != null) {\n    sbmsg.correlationId = msg.correlation_id;\n  }\n  if (msg.reply_to_group_id != null) {\n    sbmsg.replyToSessionId = msg.reply_to_group_id;\n  }\n\n  if (msg.message_annotations != null) {\n    if (msg.message_annotations[Constants.partitionKey] != null) {\n      sbmsg.partitionKey = msg.message_annotations[Constants.partitionKey];\n    }\n\n    // Will be required later for implementing Transactions\n    // if (msg.message_annotations[Constants.viaPartitionKey] != null) {\n    //   sbmsg.viaPartitionKey = msg.message_annotations[Constants.viaPartitionKey];\n    // }\n\n    if (msg.message_annotations[Constants.scheduledEnqueueTime] != null) {\n      sbmsg.scheduledEnqueueTimeUtc = msg.message_annotations[Constants.scheduledEnqueueTime];\n    }\n  }\n\n  const props: any = {};\n  if (msg.message_annotations != null) {\n    if (msg.message_annotations[Constants.deadLetterSource] != null) {\n      props.deadLetterSource = msg.message_annotations[Constants.deadLetterSource];\n    }\n    if (msg.message_annotations[Constants.enqueueSequenceNumber] != null) {\n      props.enqueuedSequenceNumber = msg.message_annotations[Constants.enqueueSequenceNumber];\n    }\n    if (msg.message_annotations[Constants.sequenceNumber] != null) {\n      if (Buffer.isBuffer(msg.message_annotations[Constants.sequenceNumber])) {\n        props.sequenceNumber = Long.fromBytesBE(msg.message_annotations[Constants.sequenceNumber]);\n      } else {\n        props.sequenceNumber = Long.fromNumber(msg.message_annotations[Constants.sequenceNumber]);\n      }\n    }\n    if (msg.message_annotations[Constants.enqueuedTime] != null) {\n      props.enqueuedTimeUtc = new Date(msg.message_annotations[Constants.enqueuedTime] as number);\n    }\n    if (msg.message_annotations[Constants.lockedUntil] != null) {\n      props.lockedUntilUtc = new Date(msg.message_annotations[Constants.lockedUntil] as number);\n    }\n  }\n  if (msg.ttl != null && msg.ttl >= Constants.maxDurationValue - props.enqueuedTimeUtc.getTime()) {\n    props.expiresAtUtc = new Date(Constants.maxDurationValue);\n  } else {\n    props.expiresAtUtc = new Date(props.enqueuedTimeUtc.getTime() + msg.ttl!);\n  }\n\n  const rcvdsbmsg: ServiceBusReceivedMessage = {\n    _rawAmqpMessage: AmqpAnnotatedMessage.fromRheaMessage(msg),\n    _delivery: delivery,\n    deliveryCount: msg.delivery_count,\n    lockToken:\n      delivery && delivery.tag && delivery.tag.length !== 0\n        ? uuid_to_string(\n            shouldReorderLockToken === true\n              ? reorderLockToken(\n                  typeof delivery.tag === \"string\" ? Buffer.from(delivery.tag) : delivery.tag\n                )\n              : typeof delivery.tag === \"string\"\n              ? Buffer.from(delivery.tag)\n              : delivery.tag\n          )\n        : undefined,\n    ...sbmsg,\n    ...props,\n    deadLetterReason: sbmsg.applicationProperties?.DeadLetterReason,\n    deadLetterErrorDescription: sbmsg.applicationProperties?.DeadLetterErrorDescription\n  };\n\n  logger.verbose(\"AmqpMessage to ServiceBusReceivedMessage: %O\", rcvdsbmsg);\n  return rcvdsbmsg;\n}\n\n/**\n * @internal\n * @hidden\n */\nexport function isServiceBusMessage(possible: any): possible is ServiceBusMessage {\n  return possible != null && typeof possible === \"object\" && \"body\" in possible;\n}\n\n/**\n * Describes the message received from Service Bus.\n *\n * @internal\n * @hidden\n * @class ServiceBusMessageImpl\n * @implements {ServiceBusReceivedMessage}\n */\nexport class ServiceBusMessageImpl implements ServiceBusReceivedMessage {\n  /**\n   * @property The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * @property The application specific properties.\n   */\n  applicationProperties?: { [key: string]: any };\n  /**\n   * @property The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload. The identifier\n   * is a free-form string and can reflect a GUID or an identifier derived from the application\n   * context. If enabled, the\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection duplicate detection}\n   * identifies and removes second and further submissions of messages with the same MessageId.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * @property The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n  /**\n   * @property The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  correlationId?: string | number | Buffer;\n  /**\n   * @property The partition key for sending a message to a\n   * partitioned entity. Maximum length is 128 characters. For {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning partitioned entities},\n   * setting this value enables assigning related messages to the same internal partition,\n   * so that submission sequence order is correctly recorded. The partition is chosen by a hash\n   * function over this value and cannot be chosen directly. For session-aware entities,\n   * the `sessionId` property overrides this value.\n   */\n  partitionKey?: string;\n  /**\n   * @property The partition key for sending a message into an entity\n   * via a partitioned transfer queue. Maximum length is 128 characters. If a message is sent via a\n   * transfer queue in the scope of a transaction, this value selects the transfer queue partition:\n   * This is functionally equivalent to `partitionKey` property and ensures that messages are kept\n   * together and in order as they are transferred.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via Transfers and Send Via}.\n   */\n  // Will be required later for implementing Transactions\n  // viaPartitionKey?: string;\n  /**\n   * @property The session identifier for a session-aware entity. Maximum\n   * length is 128 characters. For session-aware entities, this application-defined value specifies\n   * the session affiliation of the message. Messages with the same session identifier are subject\n   * to summary locking and enable exact in-order processing and demultiplexing. For\n   * session-unaware entities, this value is ignored.\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions Message Sessions}.\n   */\n  sessionId?: string;\n  /**\n   * @property The session identifier augmenting the `replyTo` address.\n   * Maximum length is 128 characters. This value augments the ReplyTo information and specifies\n   * which SessionId should be set for the reply when sent to the reply entity.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  replyToSessionId?: string;\n  /**\n   * @property The message’s time to live value. This value is the relative\n   * duration after which the message expires, starting from the instant the message has been\n   * accepted and stored by the broker, as captured in `enqueuedTimeUtc`. When not set explicitly,\n   * the assumed value is the DefaultTimeToLive for the respective queue or topic. A message-level\n   * `timeToLive` value cannot be longer than the entity's DefaultTimeToLive setting and it is\n   * silently adjusted if it does. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-expiration Expiration}.\n   */\n  timeToLive?: number;\n  /**\n   * @property The application specific label. This property enables the\n   * application to indicate the purpose of the message to the receiver in a standardized. fashion,\n   * similar to an email subject line. The mapped AMQP property is \"subject\".\n   */\n  subject?: string;\n  /**\n   * @property The \"to\" address. This property is reserved for future use in routing\n   * scenarios and presently ignored by the broker itself. Applications can use this value in\n   * rule-driven {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-auto-forwarding auto-forward chaining}\n   * scenarios to indicate the intended logical destination of the message.\n   */\n  to?: string;\n  /**\n   * @property The address of an entity to send replies to. This optional and\n   * application-defined value is a standard way to express a reply path to the receiver of the\n   * message. When a sender expects a reply, it sets the value to the absolute or relative path of\n   * the queue or topic it expects the reply to be sent to. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  replyTo?: string;\n  /**\n   * @property The date and time in UTC at which the message will\n   * be enqueued. This property returns the time in UTC; when setting the property, the\n   * supplied DateTime value must also be in UTC. This value is for delayed message sending.\n   * It is utilized to delay messages sending to a specific time in the future. Message enqueuing\n   * time does not mean that the message will be sent at the same time. It will get enqueued,\n   * but the actual sending time depends on the queue's workload and its state.\n   */\n  scheduledEnqueueTimeUtc?: Date;\n  /**\n   * @property The lock token is a reference to the lock that is being held by the broker in\n   * `peekLock` receive mode. Locks are used internally settle messages as explained in the\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement product documentation in more detail}\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   * @readonly\n   */\n  readonly lockToken?: string;\n  /**\n   * @property Number of deliveries that have been attempted for this message. The count is\n   * incremented when a message lock expires, or the message is explicitly abandoned using the\n   * `abandon()` method on the message.\n   * @readonly\n   */\n  readonly deliveryCount?: number;\n  /**\n   * @property The UTC instant at which the message has been accepted and stored in Service Bus.\n   * @readonly\n   */\n  readonly enqueuedTimeUtc?: Date;\n  /**\n   * @property The UTC instant at which the message is marked for removal and no longer available for\n   * retrieval from the entity due to expiration. This property is computed from 2 other properties\n   * on the message: `enqueuedTimeUtc` + `timeToLive`.\n   */\n  readonly expiresAtUtc?: Date;\n  /**\n   * @property The UTC instant until which the message is held locked in the queue/subscription.\n   * When the lock expires, the `deliveryCount` is incremented and the message is again available\n   * for retrieval.\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   */\n  lockedUntilUtc?: Date;\n  /**\n   * @property The original sequence number of the message. For\n   * messages that have been auto-forwarded, this property reflects the sequence number that had\n   * first been assigned to the message at its original point of submission.\n   * @readonly\n   */\n  readonly enqueuedSequenceNumber?: number;\n  /**\n   * @property The unique number assigned to a message by Service Bus.\n   * The sequence number is a unique 64-bit integer assigned to a message as it is accepted\n   * and stored by the broker and functions as its true identifier. For partitioned entities,\n   * the topmost 16 bits reflect the partition identifier. Sequence numbers monotonically increase.\n   * They roll over to 0 when the 48-64 bit range is exhausted.\n   * @readonly\n   */\n  readonly sequenceNumber?: Long;\n  /**\n   * @property The name of the queue or subscription that this message\n   * was enqueued on, before it was deadlettered. Only set in messages that have been dead-lettered\n   * and subsequently auto-forwarded from the dead-letter sub-queue to another entity. Indicates the\n   * entity in which the message was dead-lettered.\n   * @readonly\n   */\n  readonly deadLetterSource?: string;\n  /**\n   * The associated delivery of the received message.\n   */\n  readonly delivery: Delivery;\n  /**\n   * @property {AmqpMessage} _rawAmqpMessage The underlying raw amqp annotated message.\n   * @readonly\n   */\n  readonly _rawAmqpMessage: AmqpAnnotatedMessage;\n  /**\n   * @property The reason for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterReason?: string;\n  /**\n   * @property The error description for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterErrorDescription?: string;\n  /**\n   * @internal\n   */\n  constructor(\n    msg: RheaMessage,\n    delivery: Delivery,\n    shouldReorderLockToken: boolean,\n    receiveMode: ReceiveMode\n  ) {\n    Object.assign(this, fromRheaMessage(msg, delivery, shouldReorderLockToken));\n    // Lock on a message is applicable only in peekLock mode, but the service sets\n    // the lock token even in receiveAndDelete mode if the entity in question is partitioned.\n    if (receiveMode === \"receiveAndDelete\") {\n      this.lockToken = undefined;\n    }\n    if (msg.body) {\n      this.body = defaultDataTransformer.decode(msg.body);\n    }\n    // TODO: _rawAmqpMessage is already being populated in fromRheaMessage(), no need to do it twice\n    this._rawAmqpMessage = AmqpAnnotatedMessage.fromRheaMessage(msg);\n    this.delivery = delivery;\n  }\n\n  /**\n   * Creates a clone of the current message to allow it to be re-sent to the queue\n   * @returns ServiceBusMessage\n   */\n  clone(): ServiceBusMessage {\n    // We are returning a ServiceBusMessage object because that object can then be sent to Service Bus\n    const clone: ServiceBusMessage = {\n      body: this.body,\n      contentType: this.contentType,\n      correlationId: this.correlationId,\n      subject: this.subject,\n      messageId: this.messageId,\n      partitionKey: this.partitionKey,\n      replyTo: this.replyTo,\n      replyToSessionId: this.replyToSessionId,\n      scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,\n      sessionId: this.sessionId,\n      timeToLive: this.timeToLive,\n      to: this.to,\n      applicationProperties: this.applicationProperties\n      // Will be required later for implementing Transactions\n      // viaPartitionKey: this.viaPartitionKey\n    };\n\n    return clone;\n  }\n}\n","import { isMessagingError, MessagingError, translate } from \"@azure/core-amqp\";\nimport { AmqpError } from \"rhea-promise\";\n\n/**\n * Service Bus failure codes.\n */\nexport type ServiceBusErrorCode =\n  // note: This list is intended to loosely follow https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/servicebus/Azure.Messaging.ServiceBus/src/Primitives/ServiceBusFailureReason.cs\n  /**\n   * The exception was the result of a general error within the client library.\n   */\n  | \"GeneralError\"\n  /**\n   * A Service Bus resource cannot be found by the Service Bus service.\n   */\n  | \"MessagingEntityNotFound\"\n  /**\n   * The lock on the message is lost. Callers should attempt to receive and process the message again.\n   */\n  | \"MessageLockLost\"\n  /**\n   * The requested message was not found.\n   */\n  | \"MessageNotFound\"\n  /**\n   * A message is larger than the maximum size allowed for its transport.\n   */\n  | \"MessageSizeExceeded\"\n  /**\n   * An entity with the same name exists under the same namespace.\n   */\n  | \"MessagingEntityAlreadyExists\"\n  /**\n   * The Messaging Entity is disabled. Enable the entity again using Portal.\n   */\n  | \"MessagingEntityDisabled\"\n  /**\n   * The quota applied to an Service Bus resource has been exceeded while interacting with the Azure Service Bus service.\n   */\n  | \"QuotaExceeded\"\n  /**\n   * The Azure Service Bus service reports that it is busy in response to a client request to perform an operation.\n   */\n  | \"ServiceBusy\"\n  /**\n   * An operation or other request timed out while interacting with the Azure Service Bus service.\n   */\n  | \"ServiceTimeout\"\n  /**\n   * There was a general communications error encountered when interacting with the Azure Service Bus service.\n   */\n  | \"ServiceCommunicationProblem\"\n  /**\n   * The requested session cannot be locked.\n   */\n  | \"SessionCannotBeLocked\"\n  /**\n   * The lock on the session has expired. Callers should request the session again.\n   */\n  | \"SessionLockLost\"\n  /**\n   * The user doesn't have access to the entity.\n   */\n  | \"UnauthorizedAccess\";\n\n/**\n * Translation between the MessagingErrorCodes into a ServiceBusCode\n *\n * @internal\n * @hidden\n */\nexport const wellKnownMessageCodesToServiceBusCodes: Map<string, ServiceBusErrorCode> = new Map([\n  [\"MessagingEntityNotFoundError\", \"MessagingEntityNotFound\"],\n  [\"MessageLockLostError\", \"MessageLockLost\"],\n  [\"MessageNotFoundError\", \"MessageNotFound\"],\n  [\"MessageTooLargeError\", \"MessageSizeExceeded\"],\n  [\"MessagingEntityAlreadyExistsError\", \"MessagingEntityAlreadyExists\"],\n  [\"MessagingEntityDisabledError\", \"MessagingEntityDisabled\"],\n  [\"QuotaExceededError\", \"QuotaExceeded\"],\n  [\"ServerBusyError\", \"ServiceBusy\"],\n\n  [\"OperationTimeoutError\", \"ServiceTimeout\"],\n  [\"ServiceCommunicationError\", \"ServiceCommunicationProblem\"],\n  [\"SessionCannotBeLockedError\", \"SessionCannotBeLocked\"],\n  [\"SessionLockLostError\", \"SessionLockLost\"],\n  [\"UnauthorizedError\", \"UnauthorizedAccess\"]\n]);\n\n/**\n * Errors that occur within Service Bus.\n */\nexport class ServiceBusError extends MessagingError {\n  /**\n   * The reason for the failure.\n   *\n   * - **GeneralError**: The exception was the result of a general error within the client library.\n   * - **MessagingEntityNotFound**: A Service Bus resource cannot be found by the Service Bus service.\n   * - **MessageLockLost**: The lock on the message is lost. Callers should attempt to receive and process the message again.\n   * - **MessageNotFound**: The requested message was not found.\n   * - **MessageSizeExceeded**: A message is larger than the maximum size allowed for its transport.\n   * - **MessagingEntityAlreadyExists**: An entity with the same name exists under the same namespace.\n   * - **MessagingEntityDisabled**: The Messaging Entity is disabled. Enable the entity again using Portal.\n   * - **QuotaExceeded**: The quota applied to an Service Bus resource has been exceeded while interacting with the Azure Service Bus service.\n   * - **ServiceBusy**: The Azure Service Bus service reports that it is busy in response to a client request to perform an operation.\n   * - **ServiceTimeout**: An operation or other request timed out while interacting with the Azure Service Bus service.\n   * - **ServiceCommunicationProblem**: There was a general communications error encountered when interacting with the Azure Service Bus service.\n   * - **SessionCannotBeLocked**: The requested session cannot be locked.\n   * - **SessionLockLost**: The lock on the session has expired. Callers should request the session again.\n   * - **UnauthorizedAccess\"**: The user doesn't have access to the entity.\n   */\n  // NOTE: make sure this list and the list above are properly kept in sync.\n  code: ServiceBusErrorCode;\n\n  /**\n   * @param message The error message that provides more information about the error.\n   * @param code The reason for the failure.\n   */\n  constructor(message: string, code: ServiceBusErrorCode);\n  /**\n   * @param messagingError An error whose properties will be copied to the ServiceBusError.\n   */\n  constructor(messagingError: MessagingError);\n  constructor(messageOrError: string | MessagingError, code?: ServiceBusErrorCode) {\n    const message = typeof messageOrError === \"string\" ? messageOrError : messageOrError.message;\n    super(message);\n\n    if (typeof messageOrError === \"string\") {\n      this.code = code ?? \"GeneralError\";\n    } else {\n      for (const prop in messageOrError) {\n        (this as any)[prop] = (messageOrError as any)[prop];\n      }\n\n      this.code = ServiceBusError.normalizeMessagingCode(messageOrError.code);\n      // For GeneralErrors, prefix the error message with the MessagingError code to provide\n      // more context to the user.\n      if (this.code === \"GeneralError\" && messageOrError.code) {\n        this.message = `${messageOrError.code}: ${this.message}`;\n      }\n    }\n\n    this.name = \"ServiceBusError\";\n  }\n\n  private static normalizeMessagingCode(oldCode?: string): ServiceBusErrorCode {\n    if (oldCode == null || !wellKnownMessageCodesToServiceBusCodes.has(oldCode)) {\n      return \"GeneralError\";\n    }\n\n    return wellKnownMessageCodesToServiceBusCodes.get(oldCode)!;\n  }\n}\n\n/**\n * Translates an error into either an Error or a ServiceBusError which provides a `reason` code that\n * can be used by clients to programatically react to errors.\n *\n * If you are calling `@azure/core-amqp/translate` you should swap to using this function instead since it provides\n * Service Bus specific handling of the error (falling back to default translate behavior otherwise).\n *\n * @internal\n * @hidden\n */\nexport function translateServiceBusError(err: AmqpError | Error): ServiceBusError | Error {\n  if (isServiceBusError(err)) {\n    return err;\n  }\n\n  const translatedError = translate(err);\n\n  if (isMessagingError(translatedError)) {\n    return new ServiceBusError(translatedError);\n  }\n\n  return translatedError;\n}\n\n/**\n * Determines if an error is of type `ServiceBusError`\n *\n * @param err An error to check to see if it's of type ServiceBusError\n */\nexport function isServiceBusError(err: any): err is ServiceBusError {\n  return err?.name === \"ServiceBusError\";\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants, TokenType, defaultLock, RequestResponseLink } from \"@azure/core-amqp\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport {\n  AwaitableSender,\n  AwaitableSenderOptions,\n  generate_uuid,\n  Receiver,\n  ReceiverOptions,\n  SenderOptions\n} from \"rhea-promise\";\nimport { getUniqueName, StandardAbortMessage } from \"../util/utils\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { ServiceBusLogger } from \"../log\";\nimport { SharedKeyCredential } from \"../servicebusSharedKeyCredential\";\nimport { ServiceBusError } from \"../serviceBusError\";\n\n/**\n * @internal\n * @hidden\n * Options passed to the constructor of LinkEntity\n */\nexport interface LinkEntityOptions {\n  /**\n   * @property {string} address The client entity address in one of the following forms:\n   */\n  address?: string;\n  /**\n   * @property {string} audience The client entity token audience in one of the following forms:\n   */\n  audience?: string;\n}\n\n/**\n * A simple grouping of the sender and receiver options. Only used\n * with the ManagementClient today.\n *\n * @internal\n * @hidden\n */\nexport interface RequestResponseLinkOptions {\n  senderOptions: SenderOptions;\n  receiverOptions: ReceiverOptions;\n  name?: string;\n}\n\n/**\n * @internal\n * @hidden\n */\nexport type ReceiverType =\n  | \"batching\" // batching receiver\n  | \"streaming\" // streaming receiver;\n  | \"session\"; // message session\n\n/**\n * @internal\n * @hidden\n */\ntype LinkOptionsT<\n  LinkT extends Receiver | AwaitableSender | RequestResponseLink\n> = LinkT extends Receiver\n  ? ReceiverOptions\n  : LinkT extends AwaitableSender\n  ? AwaitableSenderOptions\n  : LinkT extends RequestResponseLink\n  ? RequestResponseLinkOptions\n  : never;\n\n/**\n * @internal\n * @hidden\n */\ntype LinkTypeT<\n  LinkT extends Receiver | AwaitableSender | RequestResponseLink\n> = LinkT extends Receiver\n  ? ReceiverType\n  : LinkT extends AwaitableSender\n  ? \"sender\" // sender\n  : LinkT extends RequestResponseLink\n  ? \"mgmt\" // management link\n  : never;\n\n/**\n * @internal\n * @hidden\n * Describes the base class for entities like MessageSender, MessageReceiver and Management client.\n */\nexport abstract class LinkEntity<LinkT extends Receiver | AwaitableSender | RequestResponseLink> {\n  /**\n   * @property {string} id The unique name for the entity in the format:\n   * `${name of the entity}-${guid}`.\n   */\n  name: string;\n  /**\n   * @property {string} address The client entity address in one of the following forms:\n   *\n   * **Sender**\n   * - `\"<queue-name>\"`.\n   * - `\"<topic-name>\"`.\n   *\n   * **Receiver**\n   * - `\"<queue-name>\"`.\n   * - `\"<topic-name>\"`.\n   *\n   * **ManagementClient**\n   * -`\"$management\"`.\n   */\n  address: string;\n  /**\n   * @property {string} audience The client entity token audience in one of the following forms:\n   *\n   * **Sender**\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<queue-name>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<topic-name>\"`\n   *\n   * **Receiver**\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<queue-name>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<topic-name>\"`\n   *\n   * **ManagementClient**\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<queue-name>/$management\"`.\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<topic-name>/$management\"`.\n   */\n  audience: string;\n  /**\n   * @property _context Provides relevant information about the amqp connection,\n   * cbs and $management sessions, token provider, sender and receivers.\n   */\n  protected _context: ConnectionContext;\n  /**\n   * @property {NodeJS.Timer} _tokenRenewalTimer The token renewal timer that keeps track of when\n   * the Client Entity is due for token renewal.\n   */\n  private _tokenRenewalTimer?: NodeJS.Timer;\n  /**\n   * @property _tokenTimeout Indicates token timeout\n   */\n  protected _tokenTimeout?: number;\n\n  /**\n   * The actual rhea link (of type Receiver or AwaitableSender) or RequestResponseLink\n   */\n  private _link?: LinkT;\n\n  /**\n   * The log prefix for any log messages.\n   */\n  private _logPrefix: string;\n\n  public get logPrefix(): string {\n    return this._logPrefix;\n  }\n\n  /**\n   * Indicates that close() has been called on this link and\n   * that it should not be allowed to reopen.\n   */\n  private _wasClosedPermanently: boolean = false;\n\n  /**\n   * A lock that ensures that opening and closing this\n   * link properly cooperate.\n   */\n  private _openLock: string = generate_uuid();\n\n  /**\n   * Creates a new ClientEntity instance.\n   * @constructor\n   * @param baseName The base name to use for the link. A unique ID will be appended to this.\n   * @param entityPath The entity path (ex: 'your-queue')\n   * @param context The connection context.\n   * @param options Options that can be provided while creating the LinkEntity.\n   */\n  constructor(\n    public readonly baseName: string,\n    public readonly entityPath: string,\n    context: ConnectionContext,\n    private _linkType: LinkTypeT<LinkT>,\n    private _logger: ServiceBusLogger,\n    options?: LinkEntityOptions\n  ) {\n    if (!options) options = {};\n    this._context = context;\n    this.address = options.address || \"\";\n    this.audience = options.audience || \"\";\n    this.name = getUniqueName(baseName);\n    this._logPrefix = `[${context.connectionId}|${this._linkType}:${this.name}]`;\n  }\n\n  /**\n   * Determines whether the AMQP link is open. If open then returns true else returns false.\n   * @return {boolean} boolean\n   */\n  isOpen(): boolean {\n    const result: boolean = this._link ? this._link.isOpen() : false;\n    this._logger.verbose(`${this._logPrefix} is open? ${result}`);\n    return result;\n  }\n\n  /**\n   * Initializes this LinkEntity, setting this._link with the result of  `createRheaLink`, which\n   * is implemented by child classes.\n   *\n   * @returns A Promise that resolves when the link has been properly initialized\n   * @throws {AbortError} if the link has been closed via 'close'\n   */\n  async initLink(options: LinkOptionsT<LinkT>, abortSignal?: AbortSignalLike): Promise<void> {\n    // we'll check that the connection isn't in the process of recycling (and if so, wait for it to complete)\n    await this._context.readyToOpenLink();\n\n    this._logger.verbose(\n      `${this._logPrefix} Attempting to acquire lock token ${this._openLock} for initializing link`\n    );\n    return defaultLock.acquire(this._openLock, () => {\n      this._logger.verbose(\n        `${this._logPrefix} Lock ${this._openLock} acquired for initializing link`\n      );\n      return this._initLinkImpl(options, abortSignal);\n    });\n  }\n\n  private async _initLinkImpl(\n    options: LinkOptionsT<LinkT>,\n    abortSignal?: AbortSignalLike\n  ): Promise<void> {\n    const checkAborted = (): void => {\n      if (abortSignal?.aborted) {\n        throw new AbortError(StandardAbortMessage);\n      }\n    };\n\n    const connectionId = this._context.connectionId;\n    checkAborted();\n\n    if (options.name) {\n      this.name = options.name;\n      this._logPrefix = `[${connectionId}|${this._linkType}:${this.name}]`;\n    }\n\n    if (this._wasClosedPermanently) {\n      this._logger.verbose(`${this._logPrefix} Link has been permanently closed. Not reopening.`);\n      throw new AbortError(`Link has been permanently closed. Not reopening.`);\n    }\n\n    if (this.isOpen()) {\n      this._logger.verbose(`${this._logPrefix} Link is already open. Returning.`);\n      return;\n    }\n\n    this._logger.verbose(\n      `${this._logPrefix} Is not open and is not currently connecting. Opening.`\n    );\n\n    try {\n      await this._negotiateClaim();\n\n      checkAborted();\n      this.checkIfConnectionReady();\n\n      this._logger.verbose(`${this._logPrefix} Creating with options %O`, options);\n      this._link = await this.createRheaLink(options);\n      checkAborted();\n\n      this._ensureTokenRenewal();\n\n      this._logger.verbose(`${this._logPrefix} Link has been created.`);\n    } catch (err) {\n      this._logger.logError(err, `${this._logPrefix} Error thrown when creating the link`);\n      await this.closeLinkImpl();\n      throw err;\n    }\n  }\n\n  /**\n   * Clears token renewal for current link, removes current LinkEntity instance from cache,\n   * and closes the underlying AMQP link.\n   * Once closed, this instance of LinkEntity is not meant to be re-used.\n   */\n  async close(): Promise<void> {\n    // Set the flag to indicate that this instance of LinkEntity is not meant to be re-used.\n    this._wasClosedPermanently = true;\n\n    this._logger.verbose(`${this.logPrefix} permanently closing this link.`);\n\n    // Remove the underlying AMQP link from the cache\n    switch (this._linkType) {\n      case \"s\": {\n        delete this._context.senders[this.name];\n        break;\n      }\n      case \"br\":\n      case \"sr\": {\n        delete this._context.messageReceivers[this.name];\n        break;\n      }\n      case \"ms\": {\n        delete this._context.messageSessions[this.name];\n        break;\n      }\n    }\n\n    await this.closeLink();\n    this._logger.verbose(`${this.logPrefix} permanently closed this link.`);\n  }\n\n  /**\n   * NOTE: This method should be implemented by any child classes to actually create the underlying\n   * Rhea link (AwaitableSender or Receiver or RequestResponseLink)\n   *\n   * @param _options\n   */\n  protected abstract createRheaLink(_options: LinkOptionsT<LinkT>): Promise<LinkT>;\n\n  /**\n   * Closes the internally held rhea link, stops the token renewal timer and sets\n   * the this._link field to undefined.\n   */\n  protected closeLink(): Promise<void> {\n    this._logger.verbose(\n      `${this._logPrefix} Attempting to acquire lock token ${this._openLock} for closing link`\n    );\n    return defaultLock.acquire(this._openLock, () => {\n      this._logger.verbose(`${this._logPrefix} Lock ${this._openLock} acquired for closing link`);\n      return this.closeLinkImpl();\n    });\n  }\n\n  private async closeLinkImpl(): Promise<void> {\n    this._logger.verbose(`${this._logPrefix} closeLinkImpl() called`);\n\n    clearTimeout(this._tokenRenewalTimer as NodeJS.Timer);\n    this._tokenRenewalTimer = undefined;\n\n    if (this._link) {\n      try {\n        const link = this._link;\n        this._link = undefined;\n\n        // This should take care of closing the link and it's underlying session. This should also\n        // remove them from the internal map.\n        await link.close();\n        this._logger.verbose(`${this._logPrefix} closed.`);\n      } catch (err) {\n        this._logger.logError(err, `${this._logPrefix} An error occurred while closing the link`);\n      }\n    }\n  }\n\n  /**\n   * Provides the current type of the ClientEntity.\n   * @return {string} The entity type.\n   */\n  private get _type(): string {\n    let result = \"LinkEntity\";\n    if ((this as any).constructor && (this as any).constructor.name) {\n      result = (this as any).constructor.name;\n    }\n    return result;\n  }\n\n  protected get wasClosedPermanently(): boolean {\n    return this._wasClosedPermanently;\n  }\n\n  protected get link(): LinkT | undefined {\n    return this._link;\n  }\n\n  /**\n   * Negotiates the cbs claim for the ClientEntity.\n   * @param {boolean} [setTokenRenewal] Set the token renewal timer. Default false.\n   * @return {Promise<void>} Promise<void>\n   */\n  private async _negotiateClaim(setTokenRenewal?: boolean): Promise<void> {\n    this._logger.verbose(`${this._logPrefix} negotiateclaim() has been called`);\n\n    // Wait for the connectionContext to be ready to open the link.\n    this.checkIfConnectionReady();\n\n    // Acquire the lock and establish a cbs session if it does not exist on the connection.\n    // Although node.js is single threaded, we need a locking mechanism to ensure that a\n    // race condition does not happen while creating a shared resource (in this case the\n    // cbs session, since we want to have exactly 1 cbs session per connection).\n    this._logger.verbose(\n      \"%s Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: \" +\n        \"'%s' with address: '%s'.\",\n      this.logPrefix,\n      this._context.cbsSession.cbsLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    await defaultLock.acquire(this._context.cbsSession.cbsLock, async () => {\n      this.checkIfConnectionReady();\n      return this._context.cbsSession.init();\n    });\n    let tokenObject: AccessToken;\n    let tokenType: TokenType;\n    if (this._context.tokenCredential instanceof SharedKeyCredential) {\n      tokenObject = this._context.tokenCredential.getToken(this.audience);\n      tokenType = TokenType.CbsTokenTypeSas;\n\n      // expiresOnTimestamp can be 0 if the token is not meant to be renewed\n      // (ie, SharedAccessSignatureCredential)\n      if (tokenObject.expiresOnTimestamp > 0) {\n        // renew sas token in every 45 minutes\n        this._tokenTimeout = (3600 - 900) * 1000;\n      }\n    } else {\n      const aadToken = await this._context.tokenCredential.getToken(Constants.aadServiceBusScope);\n      if (!aadToken) {\n        throw new Error(`Failed to get token from the provided \"TokenCredential\" object`);\n      }\n      tokenObject = aadToken;\n      tokenType = TokenType.CbsTokenTypeJwt;\n      this._tokenTimeout = tokenObject.expiresOnTimestamp - Date.now() - 2 * 60 * 1000;\n    }\n    this._logger.verbose(\n      \"%s %s: calling negotiateClaim for audience '%s'.\",\n      this.logPrefix,\n      this._type,\n      this.audience\n    );\n    // Acquire the lock to negotiate the CBS claim.\n    this._logger.verbose(\n      \"%s Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.\",\n      this.logPrefix,\n      this._context.negotiateClaimLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    if (!tokenObject) {\n      throw new Error(\"Token cannot be null\");\n    }\n    await defaultLock.acquire(this._context.negotiateClaimLock, () => {\n      this.checkIfConnectionReady();\n      return this._context.cbsSession.negotiateClaim(this.audience, tokenObject.token, tokenType);\n    });\n    this._logger.verbose(\n      \"%s Negotiated claim for %s '%s' with with address: %s\",\n      this.logPrefix,\n      this._type,\n      this.name,\n      this.address\n    );\n    if (setTokenRenewal) {\n      this._ensureTokenRenewal();\n    }\n  }\n\n  /**\n   * Checks to see if the connection is in a \"reopening\" state. If it is\n   * we need to _not_ use it otherwise we'll trigger some race conditions\n   * within rhea (for instance, errors about _process not being defined).\n   */\n  private checkIfConnectionReady() {\n    if (!this._context.isConnectionClosing()) {\n      return;\n    }\n\n    this._logger.verbose(\n      `${this._logPrefix} Connection is reopening, aborting link initialization.`\n    );\n    const err = new ServiceBusError(\n      \"Connection is reopening, aborting link initialization.\",\n      \"GeneralError\"\n    );\n    err.retryable = true;\n    throw err;\n  }\n\n  /**\n   * Ensures that the token is renewed within the predefined renewal margin.\n   * @returns {void}\n   */\n  private _ensureTokenRenewal(): void {\n    if (!this._tokenTimeout) {\n      return;\n    }\n    // Clear the existing token renewal timer.\n    // This scenario can happen if the connection goes down and is brought back up\n    // before the `nextRenewalTimeout` was reached.\n    if (this._tokenRenewalTimer) {\n      clearTimeout(this._tokenRenewalTimer);\n    }\n    this._tokenRenewalTimer = setTimeout(async () => {\n      try {\n        await this._negotiateClaim(true);\n      } catch (err) {\n        this._logger.logError(\n          err,\n          \"%s %s '%s' with address %s, an error occurred while renewing the token\",\n          this.logPrefix,\n          this._type,\n          this.name,\n          this.address\n        );\n      }\n    }, this._tokenTimeout);\n    this._logger.verbose(\n      \"%s %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).\",\n      this.logPrefix,\n      this._type,\n      this.name,\n      this.address,\n      this._tokenTimeout,\n      new Date(Date.now() + this._tokenTimeout).toString()\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logger, receiverLogger } from \"../log\";\nimport Long from \"long\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { isServiceBusMessage, ServiceBusReceivedMessage } from \"../serviceBusMessage\";\nimport { ReceiveMode } from \"../models\";\n\n/**\n * Error message to use when EntityPath in connection string does not match the\n * queue or topic name passed to the methods in the ServiceBusClient that create\n * senders and receivers.\n *\n * @internal\n * @hidden\n */\nexport const entityPathMisMatchError =\n  \"The queue or topic name provided does not match the EntityPath in the connection string passed to the ServiceBusClient constructor.\";\n\n/**\n * Error message for when maxMessageCount provided is invalid.\n *\n * @internal\n * @hidden\n */\nexport const InvalidMaxMessageCountError = \"'maxMessageCount' must be a number greater than 0.\";\n\n/**\n * @internal\n * @hidden\n * Logs and throws Error if the current AMQP connection is closed.\n * @param context The ConnectionContext associated with the current AMQP connection.\n */\nexport function throwErrorIfConnectionClosed(context: ConnectionContext): void {\n  if (context && context.wasConnectionCloseCalled) {\n    const errorMessage = \"The underlying AMQP connection is closed.\";\n    const error = new Error(errorMessage);\n    logger.warning(`[${context.connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * @hidden\n * Gets the error message when a sender is used when its already closed\n * @param entityPath Value of the `entityPath` property on the client which denotes its name\n */\nexport function getSenderClosedErrorMsg(entityPath: string): string {\n  return (\n    `The sender for \"${entityPath}\" has been closed and can no longer be used. ` +\n    `Please create a new sender using the \"createSender\" method on the ServiceBusClient.`\n  );\n}\n\n/**\n * @internal\n * @hidden\n * Gets the error message when a receiver is used when its already closed\n * @param entityPath Value of the `entityPath` property on the client which denotes its name\n * @param sessionId If using session receiver, then the id of the session\n */\nexport function getReceiverClosedErrorMsg(entityPath: string, sessionId?: string): string {\n  if (sessionId == undefined) {\n    return (\n      `The receiver for \"${entityPath}\" has been closed and can no longer be used. ` +\n      `Please create a new receiver using the \"createReceiver\" method on the ServiceBusClient.`\n    );\n  }\n  return (\n    `The receiver for session \"${sessionId}\" in \"${entityPath}\" has been closed and can no ` +\n    `longer be used. Please create a new receiver using the \"acceptSession\" or \"acceptNextSession\" method on the ServiceBusClient.`\n  );\n}\n\n/**\n * @internal\n * @hidden\n * @param entityPath Value of the `entityPath` property on the client which denotes its name\n * @param sessionId If using session receiver, then the id of the session\n */\nexport function getAlreadyReceivingErrorMsg(entityPath: string, sessionId?: string): string {\n  if (sessionId == undefined) {\n    return `The receiver for \"${entityPath}\" is already receiving messages.`;\n  }\n  return `The receiver for session \"${sessionId}\" for \"${entityPath}\" is already receiving messages.`;\n}\n\n/**\n * @internal\n * @hidden\n * Logs and Throws TypeError if given parameter is undefined or null\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to check\n * @param parameterValue Value of the parameter to check\n */\nexport function throwTypeErrorIfParameterMissing(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any\n): void {\n  if (parameterValue === undefined || parameterValue === null) {\n    const error = new TypeError(`Missing parameter \"${parameterName}\"`);\n    logger.warning(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * @hidden\n * Logs and Throws TypeError if given parameter is not of expected type\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n * @param expectedType Expected type of the parameter\n */\n\nexport function throwTypeErrorIfParameterTypeMismatch(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any,\n  expectedType: string\n): void {\n  if (typeof parameterValue !== expectedType) {\n    const error = new TypeError(\n      `The parameter \"${parameterName}\" should be of type \"${expectedType}\"`\n    );\n    logger.warning(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * @hidden\n * Logs and Throws TypeError if given parameter is not of type `Long` or an array of type `Long`\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterNotLong(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any\n): TypeError | undefined {\n  if (Array.isArray(parameterValue)) {\n    return throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue);\n  }\n  if (Long.isLong(parameterValue)) {\n    return;\n  }\n  const error = new TypeError(`The parameter \"${parameterName}\" should be of type \"Long\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * @hidden\n * Logs and Throws TypeError if given parameter is not an array of type `Long`\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterNotLongArray(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any[]\n): TypeError | undefined {\n  if (parameterValue.every((item) => Long.isLong(item))) {\n    return;\n  }\n  const error = new TypeError(`The parameter \"${parameterName}\" should be an array of type \"Long\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * @hidden\n * Logs and Throws TypeError if given parameter is an empty string\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterIsEmptyString(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: string\n): TypeError | undefined {\n  if (parameterValue !== \"\") {\n    return;\n  }\n  const error = new TypeError(`Empty string not allowed in parameter \"${parameterName}\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * @hidden\n * The error message for operations on the receiver that are invalid for a message received in receiveAndDelete mode.\n */\nexport const InvalidOperationInReceiveAndDeleteMode =\n  \"The operation is not supported in 'receiveAndDelete' receive mode.\";\n\n/**\n * @internal\n * @hidden\n * The error message for operations on the receiver that are invalid for a peeked message.\n */\nexport const InvalidOperationForPeekedMessage =\n  \"This operation is not supported for peeked messages. Only messages received using 'receiveMessages()', 'subscribe()' and 'getMessageIterator()' methods on the receiver in 'peekLock' receive mode can be settled.\";\n\n/**\n * @internal\n * @hidden\n * The error message for when one attempts to settle an already settled message.\n */\nexport const MessageAlreadySettled = \"The message has either been deleted or already settled\";\n\n/**\n * Throws error if the ServiceBusReceivedMessage cannot be settled.\n * @internal\n * @hidden\n */\nexport function throwErrorIfInvalidOperationOnMessage(\n  message: ServiceBusReceivedMessage,\n  receiveMode: ReceiveMode,\n  connectionId: string\n) {\n  let error: Error | undefined;\n\n  if (receiveMode === \"receiveAndDelete\") {\n    error = new Error(InvalidOperationInReceiveAndDeleteMode);\n  } else if (!message.lockToken) {\n    error = new Error(InvalidOperationForPeekedMessage);\n  }\n\n  if (error) {\n    receiverLogger.logError(\n      error,\n      \"[%s] An error occurred for message with id '%s'\",\n      connectionId,\n      message.messageId\n    );\n    throw error;\n  }\n}\n\n/**\n * Error message for when the ServiceBusMessage provided by the user has different values\n * for partitionKey and sessionId.\n * @internal\n * @hidden\n * @throw\n */\nexport const PartitionKeySessionIdMismatchError =\n  \"The fields 'partitionKey' and 'sessionId' cannot have different values.\";\n/**\n * Throws error if the given object is not a valid ServiceBusMessage\n * @internal\n * @hidden\n * @param msg The object that needs to be validated as a ServiceBusMessage\n * @param errorMessageForWrongType The error message to use when given object is not a ServiceBusMessage\n */\nexport function throwIfNotValidServiceBusMessage(msg: any, errorMessageForWrongType: string): void {\n  if (!isServiceBusMessage(msg)) {\n    throw new TypeError(errorMessageForWrongType);\n  }\n  if (msg.partitionKey && msg.sessionId && msg.partitionKey !== msg.sessionId) {\n    throw new TypeError(PartitionKeySessionIdMismatchError);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport Long from \"long\";\nimport {\n  EventContext,\n  ReceiverOptions,\n  message as RheaMessageUtil,\n  SenderOptions,\n  generate_uuid,\n  string_to_uuid,\n  types,\n  Typed,\n  ReceiverEvents,\n  Message as RheaMessage\n} from \"rhea-promise\";\nimport {\n  ConditionErrorNameMapper,\n  Constants,\n  MessagingError,\n  RequestResponseLink,\n  SendRequestOptions\n} from \"@azure/core-amqp\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport {\n  DispositionType,\n  ServiceBusReceivedMessage,\n  ServiceBusMessage,\n  ServiceBusMessageImpl,\n  getMessagePropertyTypeMismatchError,\n  toRheaMessage,\n  fromRheaMessage\n} from \"../serviceBusMessage\";\nimport { LinkEntity, RequestResponseLinkOptions } from \"./linkEntity\";\nimport { managementClientLogger, receiverLogger, senderLogger, ServiceBusLogger } from \"../log\";\nimport { toBuffer } from \"../util/utils\";\nimport {\n  InvalidMaxMessageCountError,\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterIsEmptyString,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n  throwTypeErrorIfParameterTypeMismatch\n} from \"../util/errors\";\nimport { max32BitNumber } from \"../util/constants\";\nimport { Buffer } from \"buffer\";\nimport { OperationOptionsBase } from \"./../modelsToBeSharedWithEventHubs\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { ReceiveMode } from \"../models\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { defaultDataTransformer } from \"../dataTransformer\";\n\n/**\n * @internal\n * @hidden\n */\nexport interface SendManagementRequestOptions extends SendRequestOptions {\n  /**\n   * The name of the sender or receiver link associated with the managmenet operations.\n   * This is used for service side optimization.\n   */\n  associatedLinkName?: string;\n}\n\n/**\n * Represents a Rule on a Subscription that is used to filter the incoming message from the\n * Subscription.\n */\nexport interface RuleDescription {\n  /**\n   * Filter expression used to match messages. Supports 2 types:\n   * - `string`: SQL-like condition expression that is evaluated against the messages'\n   * user-defined properties and system properties. All system properties will be prefixed with\n   * `sys.` in the condition expression.\n   * - `CorrelationRuleFilter`: Properties of the filter will be used to match with the message properties.\n   */\n  filter?: string | CorrelationRuleFilter;\n  /**\n   * Action to perform if the message satisfies the filtering expression.\n   */\n  action?: string;\n  /**\n   * Represents the name of the rule.\n   */\n  name: string;\n}\n\n/**\n * Represents the correlation filter expression.\n * A CorrelationRuleFilter holds a set of conditions that are matched against user and system properties\n * of incoming messages from a Subscription.\n */\nexport interface CorrelationRuleFilter {\n  /**\n   * Value to be matched with the `correlationId` property of the incoming message.\n   */\n  correlationId?: string;\n  /**\n   * Value to be matched with the `messageId` property of the incoming message.\n   */\n  messageId?: string;\n  /**\n   * Value to be matched with the `to` property of the incoming message.\n   */\n  to?: string;\n  /**\n   * Value to be matched with the `replyTo` property of the incoming message.\n   */\n  replyTo?: string;\n  /**\n   * Value to be matched with the `subject` property of the incoming message.\n   */\n  subject?: string;\n  /**\n   * Value to be matched with the `sessionId` property of the incoming message.\n   */\n  sessionId?: string;\n  /**\n   * Value to be matched with the `replyToSessionId` property of the incoming message.\n   */\n  replyToSessionId?: string;\n  /**\n   * Value to be matched with the `contentType` property of the incoming message.\n   */\n  contentType?: string;\n  /**\n   * Value to be matched with the user properties of the incoming message.\n   */\n  applicationProperties?: { [key: string]: string | number | boolean | Date };\n}\n\n/**\n * @internal\n * @hidden\n */\nconst correlationProperties = [\n  \"correlationId\",\n  \"messageId\",\n  \"to\",\n  \"replyTo\",\n  \"subject\",\n  \"sessionId\",\n  \"replyToSessionId\",\n  \"contentType\",\n  \"applicationProperties\"\n];\n\n/**\n * @internal\n * @hidden\n * Options to set when updating the disposition status\n */\nexport interface DispositionStatusOptions extends OperationOptionsBase {\n  /**\n   * @property [propertiesToModify] A map of Service Bus brokered message properties\n   * to modify.\n   */\n  propertiesToModify?: { [key: string]: any };\n  /**\n   * @property [deadLetterReason] The deadletter reason. May be set if disposition status\n   * is set to suspended.\n   */\n  deadLetterReason?: string;\n  /**\n   * @property [deadLetterDescription] The deadletter description. May be set if disposition status\n   * is set to suspended.\n   */\n  deadLetterDescription?: string;\n  /**\n   * This should only be provided if `session` is enabled for a Queue or Topic.\n   */\n  sessionId?: string;\n}\n\n/**\n * @internal\n * @hidden\n * Options passed to the constructor of ManagementClient\n */\nexport interface ManagementClientOptions {\n  address?: string;\n  audience?: string;\n}\n\n/**\n * @internal\n * @hidden\n * @class ManagementClient\n * Describes the ServiceBus Management Client that talks\n * to the $management endpoint over AMQP connection.\n */\nexport class ManagementClient extends LinkEntity<RequestResponseLink> {\n  /**\n   * @property {string} replyTo The reply to Guid for the management client.\n   */\n  replyTo: string = generate_uuid();\n  /**\n   * @property _lastPeekedSequenceNumber Provides the sequence number of the last peeked message.\n   */\n  private _lastPeekedSequenceNumber: Long = Long.ZERO;\n\n  /**\n   * @constructor\n   * Instantiates the management client.\n   * @param context The connection context\n   * @param entityPath - The name/path of the entity (queue/topic/subscription name)\n   * for which the management request needs to be made.\n   * @param {ManagementClientOptions} [options] Options to be provided for creating the\n   * \"$management\" client.\n   */\n  constructor(context: ConnectionContext, entityPath: string, options?: ManagementClientOptions) {\n    super(`${entityPath}/$management`, entityPath, context, \"mgmt\", managementClientLogger, {\n      address: options && options.address ? options.address : Constants.management,\n      audience:\n        options && options.audience\n          ? options.audience\n          : `${context.config.endpoint}${entityPath}/$management`\n    });\n    this._context = context;\n  }\n\n  private async _init(abortSignal?: AbortSignalLike): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const rxopt: ReceiverOptions = {\n        source: { address: this.address },\n        name: this.replyTo,\n        target: { address: this.replyTo },\n        onSessionError: (context: EventContext) => {\n          const sbError = translateServiceBusError(context.session!.error!);\n          managementClientLogger.logError(\n            sbError,\n            `${this.logPrefix} An error occurred on the session for request/response links for $management`\n          );\n        }\n      };\n      const sropt: SenderOptions = {\n        target: { address: this.address },\n        onError: (context: EventContext) => {\n          const ehError = translateServiceBusError(context.sender!.error!);\n          managementClientLogger.logError(\n            ehError,\n            `${this.logPrefix} An error occurred on the $management sender link`\n          );\n        }\n      };\n\n      // Even if multiple parallel requests reach here, the initLink secures a lock\n      // to ensure there won't be multiple initializations\n      await this.initLink(\n        {\n          senderOptions: sropt,\n          receiverOptions: rxopt\n        },\n        abortSignal\n      );\n    } catch (err) {\n      err = translateServiceBusError(err);\n      managementClientLogger.logError(\n        err,\n        `${this.logPrefix} An error occurred while establishing the $management links`\n      );\n      throw err;\n    }\n  }\n\n  protected async createRheaLink(\n    options: RequestResponseLinkOptions\n  ): Promise<RequestResponseLink> {\n    const rheaLink = await RequestResponseLink.create(\n      this._context.connection,\n      options.senderOptions,\n      options.receiverOptions\n    );\n    // Attach listener for the `receiver_error` events to log the errors.\n\n    // \"message\" event listener is added in core-amqp.\n    // \"rhea\" doesn't allow setting only the \"onError\" handler in the options if it is not accompanied by an \"onMessage\" handler.\n    // Hence, not passing onError handler in the receiver options, adding a handler below.\n    rheaLink.receiver.on(ReceiverEvents.receiverError, (context: EventContext) => {\n      const ehError = translateServiceBusError(context.receiver!.error!);\n      managementClientLogger.logError(\n        ehError,\n        `${this.logPrefix} An error occurred on the $management receiver link`\n      );\n    });\n    return rheaLink;\n  }\n\n  /**\n   * Given array of typed values, returns the element in given index\n   */\n  private _safelyGetTypedValueFromArray(data: Typed[], index: number): any {\n    return Array.isArray(data) && data.length > index && data[index]\n      ? data[index].value\n      : undefined;\n  }\n\n  private async _makeManagementRequest(\n    request: RheaMessage,\n    internalLogger: ServiceBusLogger,\n    sendRequestOptions: SendManagementRequestOptions = {}\n  ): Promise<RheaMessage> {\n    if (request.message_id == undefined) {\n      request.message_id = generate_uuid();\n    }\n    const retryTimeoutInMs =\n      sendRequestOptions.timeoutInMs ?? Constants.defaultOperationTimeoutInMs;\n    const initOperationStartTime = Date.now();\n    const actionAfterTimeout = (reject: (reason?: any) => void) => {\n      const desc: string = `The request with message_id \"${request.message_id}\" timed out. Please try again later.`;\n      const e: Error = {\n        name: \"OperationTimeoutError\",\n        message: desc\n      };\n\n      reject(e);\n    };\n\n    let waitTimer: ReturnType<typeof setTimeout>;\n    const operationTimeout = new Promise<void>((_, reject) => {\n      waitTimer = setTimeout(() => actionAfterTimeout(reject), retryTimeoutInMs);\n    });\n    internalLogger.verbose(`${this.logPrefix} Acquiring lock to get the management req res link.`);\n\n    try {\n      if (!this.isOpen()) {\n        await Promise.race([this._init(sendRequestOptions?.abortSignal), operationTimeout]);\n      }\n    } finally {\n      clearTimeout(waitTimer!);\n    }\n\n    // time taken by the init operation\n    const timeTakenByInit = Date.now() - initOperationStartTime;\n    // Left over time\n    sendRequestOptions.timeoutInMs = retryTimeoutInMs - timeTakenByInit;\n\n    try {\n      if (!request.message_id) request.message_id = generate_uuid();\n      return await this.link!.sendRequest(request, sendRequestOptions);\n    } catch (err) {\n      err = translateServiceBusError(err);\n      internalLogger.logError(\n        err,\n        \"%s An error occurred during send on management request-response link with address \" +\n          \"'%s': %O\",\n        this.logPrefix,\n        this.address,\n        err\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Closes the AMQP management session to the ServiceBus namespace for this client,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @return Promise<void>\n   */\n  async close(): Promise<void> {\n    try {\n      // Always clear the timeout, as the isOpen check may report\n      // false without ever having cleared the timeout otherwise.\n\n      // NOTE: management link currently doesn't have a separate concept of \"detaching\" like\n      // the other links do. When we add handling of this (via the onDetached call, like other links)\n      // we can change this back to closeLink(\"permanent\").\n      await this.closeLink();\n      managementClientLogger.verbose(\"Successfully closed the management session.\");\n    } catch (err) {\n      managementClientLogger.logError(\n        err,\n        `${this.logPrefix} An error occurred while closing the management session`\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Fetches the next batch of active messages. The first call to `peek()` fetches the first\n   * active message for this client. Each subsequent call fetches the subsequent message in the\n   * entity.\n   *\n   * Unlike a `received` message, `peeked` message will not have lock token associated with it,\n   * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. This method will\n   * also fetch even Deferred messages (but not Deadlettered message).\n   *\n   * @param messageCount The number of messages to retrieve. Default value `1`.\n   * @returns Promise<ReceivedSBMessage[]>\n   */\n  async peek(\n    messageCount: number,\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<ServiceBusReceivedMessage[]> {\n    throwErrorIfConnectionClosed(this._context);\n    return this.peekBySequenceNumber(\n      this._lastPeekedSequenceNumber.add(1),\n      messageCount,\n      undefined,\n      options\n    );\n  }\n\n  /**\n   * Fetches the next batch of active messages in the current MessageSession. The first call to\n   * `peek()` fetches the first active message for this client. Each subsequent call fetches the\n   * subsequent message in the entity.\n   *\n   * Unlike a `received` message, `peeked` message will not have lock token associated with it,\n   * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`.  This method will\n   * also fetch even Deferred messages (but not Deadlettered message).\n   *\n   * @param sessionId The sessionId from which messages need to be peeked.\n   * @param messageCount The number of messages to retrieve. Default value `1`.\n   * @returns Promise<ReceivedMessageInfo[]>\n   */\n  async peekMessagesBySession(\n    sessionId: string,\n    messageCount: number,\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<ServiceBusReceivedMessage[]> {\n    throwErrorIfConnectionClosed(this._context);\n    return this.peekBySequenceNumber(\n      this._lastPeekedSequenceNumber.add(1),\n      messageCount,\n      sessionId,\n      options\n    );\n  }\n\n  /**\n   * Peeks the desired number of messages from the specified sequence number.\n   *\n   * @param fromSequenceNumber The sequence number from where to read the message.\n   * @param messageCount The number of messages to retrieve. Default value `1`.\n   * @param sessionId The sessionId from which messages need to be peeked.\n   * @returns Promise<ReceivedMessageInfo[]>\n   */\n  async peekBySequenceNumber(\n    fromSequenceNumber: Long,\n    maxMessageCount: number,\n    sessionId?: string,\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<ServiceBusReceivedMessage[]> {\n    throwErrorIfConnectionClosed(this._context);\n    const connId = this._context.connectionId;\n\n    // Checks for fromSequenceNumber\n    throwTypeErrorIfParameterMissing(connId, \"fromSequenceNumber\", fromSequenceNumber);\n    throwTypeErrorIfParameterNotLong(connId, \"fromSequenceNumber\", fromSequenceNumber);\n\n    // Checks for maxMessageCount\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount\n    );\n    throwTypeErrorIfParameterTypeMismatch(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n      \"number\"\n    );\n\n    if (isNaN(maxMessageCount) || maxMessageCount < 1) {\n      throw new TypeError(InvalidMaxMessageCountError);\n    }\n\n    const messageList: ServiceBusReceivedMessage[] = [];\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.fromSequenceNumber] = types.wrap_long(\n        Buffer.from(fromSequenceNumber.toBytesBE())\n      );\n      messageBody[Constants.messageCount] = types.wrap_int(maxMessageCount!);\n      if (sessionId != undefined) {\n        messageBody[Constants.sessionIdMapKey] = sessionId;\n      }\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.peekMessage\n        }\n      };\n      if (options?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = options?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n\n      // TODO: it'd be nice to attribute this peek request to the actual receiver that made it. So have them pass in a\n      // log prefix rather than just falling back to the management links.\n      receiverLogger.verbose(\n        \"%s Peek by sequence number request body: %O.\",\n        this.logPrefix,\n        request.body\n      );\n\n      const result = await this._makeManagementRequest(request, receiverLogger, options);\n      if (result.application_properties!.statusCode !== 204) {\n        const messages = result.body.messages as { message: Buffer }[];\n        for (const msg of messages) {\n          const decodedMessage = RheaMessageUtil.decode(msg.message);\n          const message = fromRheaMessage(decodedMessage as any);\n          message.body = defaultDataTransformer.decode(message.body);\n          messageList.push(message);\n          this._lastPeekedSequenceNumber = message.sequenceNumber!;\n        }\n      }\n    } catch (err) {\n      const error = translateServiceBusError(err) as MessagingError;\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the request to peek messages to $management endpoint`\n      );\n      // statusCode == 404 then do not throw\n      if (error.code !== ConditionErrorNameMapper[\"com.microsoft:message-not-found\"]) {\n        throw error;\n      }\n    }\n    return messageList;\n  }\n\n  /**\n   * Renews the lock on the message. The lock will be renewed based on the setting specified on\n   * the queue.\n   *\n   * When a message is received in `PeekLock` mode, the message is locked on the server for this\n   * receiver instance for a duration as specified during the Queue/Subscription creation\n   * (LockDuration). If processing of the message requires longer than this duration, the\n   * lock needs to be renewed. For each renewal, it resets the time the message is locked by the\n   * LockDuration set on the Entity.\n   *\n   * @param lockToken Lock token of the message\n   * @param options Options that can be set while sending the request.\n   * @returns Promise<Date> New lock token expiry date and time in UTC format.\n   */\n  async renewLock(lockToken: string, options?: SendManagementRequestOptions): Promise<Date> {\n    throwErrorIfConnectionClosed(this._context);\n    if (!options) options = {};\n    if (options.timeoutInMs == null) options.timeoutInMs = 5000;\n\n    try {\n      const messageBody: any = {};\n\n      messageBody[Constants.lockTokens] = types.wrap_array(\n        [string_to_uuid(lockToken)],\n        0x98,\n        undefined\n      );\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.renewLock\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      if (options.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = options.associatedLinkName;\n      }\n      receiverLogger.verbose(\n        \"[%s] Renew message Lock request: %O.\",\n        this._context.connectionId,\n        request\n      );\n      const result = await this._makeManagementRequest(request, receiverLogger, {\n        abortSignal: options?.abortSignal,\n        requestName: \"renewLock\"\n      });\n      const lockedUntilUtc = new Date(result.body.expirations[0]);\n      return lockedUntilUtc;\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Schedules an array of messages to appear on Service Bus at a later time.\n   *\n   * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.\n   * @param messages - An array of messages that needs to be scheduled.\n   * @returns Promise<number> The sequence numbers of messages that were scheduled.\n   */\n  async scheduleMessages(\n    scheduledEnqueueTimeUtc: Date,\n    messages: ServiceBusMessage[],\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<Long[]> {\n    throwErrorIfConnectionClosed(this._context);\n    if (!messages.length) {\n      return [];\n    }\n    const messageBody: any[] = [];\n    for (let i = 0; i < messages.length; i++) {\n      const item = messages[i];\n      if (!item.messageId) item.messageId = generate_uuid();\n      item.scheduledEnqueueTimeUtc = scheduledEnqueueTimeUtc;\n      const amqpMessage = toRheaMessage(item);\n      amqpMessage.body = defaultDataTransformer.encode(amqpMessage.body);\n\n      try {\n        const entry: any = {\n          message: RheaMessageUtil.encode(amqpMessage),\n          \"message-id\": item.messageId\n        };\n        if (item.sessionId) {\n          entry[Constants.sessionIdMapKey] = item.sessionId;\n        }\n        if (item.partitionKey) {\n          entry[\"partition-key\"] = item.partitionKey;\n        }\n\n        // Will be required later for implementing Transactions\n        // if (item.viaPartitionKey) {\n        //   entry[\"via-partition-key\"] = item.viaPartitionKey;\n        // }\n\n        const wrappedEntry = types.wrap_map(entry);\n        messageBody.push(wrappedEntry);\n      } catch (err) {\n        let error: Error;\n        if (err instanceof TypeError || err.name === \"TypeError\") {\n          // `RheaMessageUtil.encode` can fail if message properties are of invalid type\n          // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too\n          // Errors in such cases do not have user-friendly message or call stack\n          // So use `getMessagePropertyTypeMismatchError` to get a better error message\n          error = translateServiceBusError(getMessagePropertyTypeMismatchError(item) || err);\n        } else {\n          error = translateServiceBusError(err);\n        }\n        senderLogger.logError(\n          error,\n          `${this.logPrefix} An error occurred while encoding the item at position ${i} in the messages array`\n        );\n        throw error;\n      }\n    }\n    try {\n      const request: RheaMessage = {\n        body: { messages: messageBody },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.scheduleMessage\n        }\n      };\n      if (options?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = options?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      senderLogger.verbose(\"%s Schedule messages request body: %O.\", this.logPrefix, request.body);\n      const result = await this._makeManagementRequest(request, senderLogger, options);\n      const sequenceNumbers = result.body[Constants.sequenceNumbers];\n      const sequenceNumbersAsLong = [];\n      for (let i = 0; i < sequenceNumbers.length; i++) {\n        if (typeof sequenceNumbers[i] === \"number\") {\n          sequenceNumbersAsLong.push(Long.fromNumber(sequenceNumbers[i]));\n        } else {\n          sequenceNumbersAsLong.push(Long.fromBytesBE(sequenceNumbers[i]));\n        }\n      }\n      return sequenceNumbersAsLong;\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      senderLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the request to schedule messages to $management endpoint`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Cancels an array of messages that were scheduled.\n   * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.\n   * @returns Promise<void>\n   */\n  async cancelScheduledMessages(\n    sequenceNumbers: Long[],\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    if (!sequenceNumbers.length) {\n      return;\n    }\n    const messageBody: any = {};\n    messageBody[Constants.sequenceNumbers] = [];\n    for (let i = 0; i < sequenceNumbers.length; i++) {\n      const sequenceNumber = sequenceNumbers[i];\n      try {\n        messageBody[Constants.sequenceNumbers].push(Buffer.from(sequenceNumber.toBytesBE()));\n      } catch (err) {\n        const error = translateServiceBusError(err);\n        senderLogger.logError(\n          error,\n          `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`\n        );\n        throw error;\n      }\n    }\n\n    try {\n      messageBody[Constants.sequenceNumbers] = types.wrap_array(\n        messageBody[Constants.sequenceNumbers],\n        0x81,\n        undefined\n      );\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.cancelScheduledMessage\n        }\n      };\n\n      if (options?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = options?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      senderLogger.verbose(\n        \"%s Cancel scheduled messages request body: %O.\",\n        this.logPrefix,\n        request.body\n      );\n\n      await this._makeManagementRequest(request, senderLogger, options);\n      return;\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      senderLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the request to cancel the scheduled message to $management endpoint`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Receives a list of deferred messages identified by `sequenceNumbers`.\n   *\n   * @param sequenceNumbers A list containing the sequence numbers to receive.\n   * @param receiveMode The mode in which the receiver was created.\n   * @returns Promise<ServiceBusMessage[]>\n   * - Returns a list of messages identified by the given sequenceNumbers.\n   * - Returns an empty list if no messages are found.\n   * - Throws an error if the messages have not been deferred.\n   */\n  async receiveDeferredMessages(\n    sequenceNumbers: Long[],\n    receiveMode: ReceiveMode,\n    sessionId?: string,\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<ServiceBusMessageImpl[]> {\n    throwErrorIfConnectionClosed(this._context);\n\n    if (!sequenceNumbers.length) {\n      return [];\n    }\n\n    const messageList: ServiceBusMessageImpl[] = [];\n    const messageBody: any = {};\n    messageBody[Constants.sequenceNumbers] = [];\n    for (let i = 0; i < sequenceNumbers.length; i++) {\n      const sequenceNumber = sequenceNumbers[i];\n      try {\n        messageBody[Constants.sequenceNumbers].push(Buffer.from(sequenceNumber.toBytesBE()));\n      } catch (err) {\n        const error = translateServiceBusError(err);\n        receiverLogger.logError(\n          error,\n          `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`\n        );\n        throw error;\n      }\n    }\n\n    try {\n      messageBody[Constants.sequenceNumbers] = types.wrap_array(\n        messageBody[Constants.sequenceNumbers],\n        0x81,\n        undefined\n      );\n      const receiverSettleMode: number = receiveMode === \"receiveAndDelete\" ? 0 : 1;\n      messageBody[Constants.receiverSettleMode] = types.wrap_uint(receiverSettleMode);\n      if (sessionId != null) {\n        messageBody[Constants.sessionIdMapKey] = sessionId;\n      }\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.receiveBySequenceNumber\n        }\n      };\n      if (options?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = options?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      receiverLogger.verbose(\n        \"%s Receive deferred messages request body: %O.\",\n        this.logPrefix,\n        request.body\n      );\n\n      const result = await this._makeManagementRequest(request, receiverLogger, options);\n      const messages = result.body.messages as {\n        message: Buffer;\n        \"lock-token\": Buffer;\n      }[];\n      for (const msg of messages) {\n        const decodedMessage = RheaMessageUtil.decode(msg.message);\n        const message = new ServiceBusMessageImpl(\n          decodedMessage as any,\n          { tag: msg[\"lock-token\"] } as any,\n          false,\n          receiveMode\n        );\n        messageList.push(message);\n      }\n      return messageList;\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the request to receive deferred messages to $management endpoint`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Updates the disposition status of deferred messages.\n   *\n   * @param lockTokens Message lock tokens to update disposition status.\n   * @param dispositionStatus The disposition status to be set\n   * @param options Optional parameters that can be provided while updating the disposition status.\n   *\n   * @returns Promise<void>\n   */\n  async updateDispositionStatus(\n    lockToken: string,\n    dispositionType: DispositionType,\n    options?: DispositionStatusOptions & SendManagementRequestOptions\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    if (!options) options = {};\n    try {\n      let dispositionStatus: \"completed\" | \"defered\" | \"suspended\" | \"abandoned\";\n\n      if (dispositionType === DispositionType.abandon) dispositionStatus = \"abandoned\";\n      else if (dispositionType === DispositionType.complete) dispositionStatus = \"completed\";\n      else if (dispositionType === DispositionType.defer) dispositionStatus = \"defered\";\n      else if (dispositionType === DispositionType.deadletter) dispositionStatus = \"suspended\";\n      else throw new Error(`Provided \"dispositionType\" - ${dispositionType} is invalid`);\n\n      const messageBody: any = {};\n      const lockTokenBuffer: Buffer[] = [];\n      lockTokenBuffer.push(string_to_uuid(lockToken));\n      messageBody[Constants.lockTokens] = types.wrap_array(lockTokenBuffer, 0x98, undefined);\n      messageBody[Constants.dispositionStatus] = dispositionStatus;\n      if (options.deadLetterDescription != null) {\n        messageBody[Constants.deadLetterDescription] = options.deadLetterDescription;\n      }\n      if (options.deadLetterReason != null) {\n        messageBody[Constants.deadLetterReason] = options.deadLetterReason;\n      }\n      if (options.propertiesToModify != null) {\n        messageBody[Constants.propertiesToModify] = options.propertiesToModify;\n      }\n      if (options.sessionId != null) {\n        messageBody[Constants.sessionIdMapKey] = options.sessionId;\n      }\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.updateDisposition\n        }\n      };\n      if (options.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = options.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      receiverLogger.verbose(\n        \"%s Update disposition status request body: %O.\",\n        this.logPrefix,\n        request.body\n      );\n      await this._makeManagementRequest(request, receiverLogger, options);\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the request to update disposition status to $management endpoint`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Renews the lock for the specified session.\n   *\n   * @param sessionId Id of the session for which the lock needs to be renewed\n   * @param options Options that can be set while sending the request.\n   * @returns Promise<Date> New lock token expiry date and time in UTC format.\n   */\n  async renewSessionLock(\n    sessionId: string,\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<Date> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.sessionIdMapKey] = sessionId;\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.renewSessionLock\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      if (options?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = options?.associatedLinkName;\n      }\n      receiverLogger.verbose(\n        \"%s Renew Session Lock request body: %O.\",\n        this.logPrefix,\n        request.body\n      );\n      const result = await this._makeManagementRequest(request, receiverLogger, options);\n      const lockedUntilUtc = new Date(result.body.expiration);\n      receiverLogger.verbose(\n        \"%s Lock for session '%s' will expire at %s.\",\n        this.logPrefix,\n        sessionId,\n        lockedUntilUtc.toString()\n      );\n      return lockedUntilUtc;\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Sets the state of the specified session.\n   *\n   * @param sessionId The session for which the state needs to be set\n   * @param state The state that needs to be set.\n   * @returns Promise<void>\n   */\n  async setSessionState(\n    sessionId: string,\n    state: any,\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.sessionIdMapKey] = sessionId;\n      messageBody[\"session-state\"] = toBuffer(state);\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.setSessionState\n        }\n      };\n      if (options?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = options?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      receiverLogger.verbose(\n        \"%s Set Session state request body: %O.\",\n        this.logPrefix,\n        request.body\n      );\n      await this._makeManagementRequest(request, receiverLogger, options);\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the state of the specified session.\n   *\n   * @param sessionId The session for which the state needs to be retrieved.\n   * @returns Promise<any> The state of that session\n   */\n  async getSessionState(\n    sessionId: string,\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<any> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.sessionIdMapKey] = sessionId;\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.getSessionState\n        }\n      };\n      if (options?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = options?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      receiverLogger.verbose(\n        \"%s Get session state request body: %O.\",\n        this.logPrefix,\n        request.body\n      );\n      const result = await this._makeManagementRequest(request, receiverLogger, options);\n      return result.body[\"session-state\"]\n        ? defaultDataTransformer.decode(result.body[\"session-state\"])\n        : result.body[\"session-state\"];\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Lists the sessions on the ServiceBus Queue/Topic.\n   * @param lastUpdateTime Filter to include only sessions updated after a given time.\n   * @param skip The number of sessions to skip\n   * @param top Maximum numer of sessions.\n   * @returns Promise<string[]> A list of session ids.\n   */\n  async listMessageSessions(\n    skip: number,\n    top: number,\n    lastUpdatedTime?: Date,\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<string[]> {\n    throwErrorIfConnectionClosed(this._context);\n    const defaultLastUpdatedTimeForListingSessions: number = 259200000; // 3 * 24 * 3600 * 1000\n    if (typeof skip !== \"number\") {\n      throw new Error(\"'skip' is a required parameter and must be of type 'number'.\");\n    }\n    if (typeof top !== \"number\") {\n      throw new Error(\"'top' is a required parameter and must be of type 'number'.\");\n    }\n    if (lastUpdatedTime && !(lastUpdatedTime instanceof Date)) {\n      throw new Error(\"'lastUpdatedTime' must be of type 'Date'.\");\n    }\n    if (!lastUpdatedTime) {\n      lastUpdatedTime = new Date(Date.now() - defaultLastUpdatedTimeForListingSessions);\n    }\n    try {\n      const messageBody: any = {};\n      messageBody[\"last-updated-time\"] = lastUpdatedTime;\n      messageBody[\"skip\"] = types.wrap_int(skip);\n      messageBody[\"top\"] = types.wrap_int(top);\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.enumerateSessions\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      managementClientLogger.verbose(\n        \"%s List sessions request body: %O.\",\n        this.logPrefix,\n        request.body\n      );\n      const response = await this._makeManagementRequest(request, managementClientLogger, options);\n\n      return (response && response.body && response.body[\"sessions-ids\"]) || [];\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      managementClientLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get all the rules on the Subscription.\n   * @returns Promise<RuleDescription[]> A list of rules.\n   */\n  async getRules(\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<RuleDescription[]> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const request: RheaMessage = {\n        body: {\n          top: types.wrap_int(max32BitNumber),\n          skip: types.wrap_int(0)\n        },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.enumerateRules\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n\n      managementClientLogger.verbose(\n        \"%s Get rules request body: %O.\",\n        this.logPrefix,\n        request.body\n      );\n      const response = await this._makeManagementRequest(request, managementClientLogger, options);\n      if (\n        response.application_properties!.statusCode === 204 ||\n        !response.body ||\n        !Array.isArray(response.body.rules)\n      ) {\n        return [];\n      }\n\n      // Reference: https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-request-response#response-11\n      const result: { \"rule-description\": Typed }[] = response.body.rules || [];\n      const rules: RuleDescription[] = [];\n      result.forEach((x) => {\n        const ruleDescriptor = x[\"rule-description\"];\n\n        // We use the first three elements of the `ruleDescriptor.value` to get filter, action, name\n        if (\n          !ruleDescriptor ||\n          !ruleDescriptor.descriptor ||\n          ruleDescriptor.descriptor.value !== Constants.descriptorCodes.ruleDescriptionList ||\n          !Array.isArray(ruleDescriptor.value) ||\n          ruleDescriptor.value.length < 3\n        ) {\n          return;\n        }\n\n        const filtersRawData: Typed = ruleDescriptor.value[0];\n        const actionsRawData: Typed = ruleDescriptor.value[1];\n        const rule: RuleDescription = {\n          name: ruleDescriptor.value[2].value\n        };\n\n        switch (filtersRawData.descriptor.value) {\n          case Constants.descriptorCodes.trueFilterList:\n            rule.filter = \"1=1\";\n            break;\n          case Constants.descriptorCodes.falseFilterList:\n            rule.filter = \"1=0\";\n            break;\n          case Constants.descriptorCodes.sqlFilterList:\n            rule.filter = this._safelyGetTypedValueFromArray(filtersRawData.value, 0);\n            break;\n          case Constants.descriptorCodes.correlationFilterList:\n            rule.filter = {\n              correlationId: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),\n              messageId: this._safelyGetTypedValueFromArray(filtersRawData.value, 1),\n              to: this._safelyGetTypedValueFromArray(filtersRawData.value, 2),\n              replyTo: this._safelyGetTypedValueFromArray(filtersRawData.value, 3),\n              subject: this._safelyGetTypedValueFromArray(filtersRawData.value, 4),\n              sessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 5),\n              replyToSessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 6),\n              contentType: this._safelyGetTypedValueFromArray(filtersRawData.value, 7),\n              applicationProperties: this._safelyGetTypedValueFromArray(filtersRawData.value, 8)\n            };\n            break;\n          default:\n            managementClientLogger.warning(\n              `${this.logPrefix} Found unexpected descriptor code for the filter: ${filtersRawData.descriptor.value}`\n            );\n            break;\n        }\n\n        if (\n          actionsRawData.descriptor.value === Constants.descriptorCodes.sqlRuleActionList &&\n          Array.isArray(actionsRawData.value) &&\n          actionsRawData.value.length\n        ) {\n          rule.action = this._safelyGetTypedValueFromArray(actionsRawData.value, 0);\n        }\n\n        rules.push(rule);\n      });\n\n      return rules;\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      managementClientLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the get rules request to $management endpoint`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Removes the rule on the Subscription identified by the given rule name.\n   * @param ruleName\n   */\n  async removeRule(\n    ruleName: string,\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"ruleName\", ruleName);\n    ruleName = String(ruleName);\n    throwTypeErrorIfParameterIsEmptyString(this._context.connectionId, \"ruleName\", ruleName);\n\n    try {\n      const request: RheaMessage = {\n        body: {\n          \"rule-name\": types.wrap_string(ruleName)\n        },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.removeRule\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n\n      managementClientLogger.verbose(\n        \"%s Remove Rule request body: %O.\",\n        this.logPrefix,\n        request.body\n      );\n      await this._makeManagementRequest(request, managementClientLogger, options);\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      managementClientLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the remove rule request to $management endpoint`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Adds a rule on the subscription as defined by the given rule name, filter and action\n   * @param ruleName Name of the rule\n   * @param filter A Boolean, SQL expression or a Correlation filter\n   * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression\n   */\n  async addRule(\n    ruleName: string,\n    filter: boolean | string | CorrelationRuleFilter,\n    sqlRuleActionExpression?: string,\n    options?: OperationOptionsBase & SendManagementRequestOptions\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"ruleName\", ruleName);\n    ruleName = String(ruleName);\n    throwTypeErrorIfParameterIsEmptyString(this._context.connectionId, \"ruleName\", ruleName);\n\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"filter\", filter);\n    if (\n      typeof filter !== \"boolean\" &&\n      typeof filter !== \"string\" &&\n      !correlationProperties.some((validProperty) => filter.hasOwnProperty(validProperty))\n    ) {\n      throw new TypeError(\n        `The parameter \"filter\" should be either a boolean, string or implement the CorrelationRuleFilter interface.`\n      );\n    }\n\n    try {\n      const ruleDescription: any = {};\n      switch (typeof filter) {\n        case \"boolean\":\n          ruleDescription[\"sql-filter\"] = {\n            expression: filter ? \"1=1\" : \"1=0\"\n          };\n          break;\n        case \"string\":\n          ruleDescription[\"sql-filter\"] = {\n            expression: filter\n          };\n          break;\n        default:\n          ruleDescription[\"correlation-filter\"] = {\n            \"correlation-id\": filter.correlationId,\n            \"message-id\": filter.messageId,\n            to: filter.to,\n            \"reply-to\": filter.replyTo,\n            subject: filter.subject,\n            \"session-id\": filter.sessionId,\n            \"reply-to-session-id\": filter.replyToSessionId,\n            \"content-type\": filter.contentType,\n            applicationProperties: filter.applicationProperties\n          };\n          break;\n      }\n\n      if (sqlRuleActionExpression !== undefined) {\n        ruleDescription[\"sql-rule-action\"] = {\n          expression: String(sqlRuleActionExpression)\n        };\n      }\n      const request: RheaMessage = {\n        body: {\n          \"rule-name\": types.wrap_string(ruleName),\n          \"rule-description\": types.wrap_map(ruleDescription)\n        },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.addRule\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n\n      managementClientLogger.verbose(\"%s Add Rule request body: %O.\", this.logPrefix, request.body);\n      await this._makeManagementRequest(request, managementClientLogger, options);\n    } catch (err) {\n      const error = translateServiceBusError(err);\n      managementClientLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the Add rule request to $management endpoint`\n      );\n      throw error;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as os from \"os\";\n\n/**\n * Returns information about the platform this function is being run on.\n * @hidden\n * @internal\n */\nexport function getRuntimeInfo(): string {\n  const runtimeInfo = {\n    key: \"Node\",\n    value: process.version\n  };\n\n  const osInfo = {\n    key: \"OS\",\n    value: `(${os.arch()}-${os.type()}-${os.release()})`\n  };\n\n  return `${runtimeInfo.key}/${runtimeInfo.value} ${osInfo.key}/${osInfo.value}`;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { connectionLogger as logger } from \"./log\";\nimport { packageJsonInfo } from \"./util/constants\";\nimport {\n  ConnectionConfig,\n  ConnectionContextBase,\n  CreateConnectionContextBaseParameters\n} from \"@azure/core-amqp\";\nimport { TokenCredential } from \"@azure/core-auth\";\nimport { ServiceBusClientOptions } from \"./constructorHelpers\";\nimport {\n  AmqpError,\n  Connection,\n  ConnectionError,\n  ConnectionEvents,\n  EventContext,\n  OnAmqpEvent\n} from \"rhea-promise\";\nimport { MessageSender } from \"./core/messageSender\";\nimport { MessageSession } from \"./session/messageSession\";\nimport { MessageReceiver } from \"./core/messageReceiver\";\nimport { ManagementClient } from \"./core/managementClient\";\nimport { formatUserAgentPrefix } from \"./util/utils\";\nimport { getRuntimeInfo } from \"./util/runtimeInfo\";\nimport { SharedKeyCredential } from \"./servicebusSharedKeyCredential\";\nimport { ReceiverType } from \"./core/linkEntity\";\n\n/**\n * @internal\n * @hidden\n * Provides contextual information like the underlying amqp connection, cbs session, management session,\n * tokenCredential, senders, receivers, etc. about the ServiceBus client.\n */\nexport interface ConnectionContext extends ConnectionContextBase {\n  /**\n   * @property {SharedKeyCredential | TokenCredential} [tokenCredential] The credential to be used for Authentication.\n   * Default value: SharedKeyCredentials.\n   */\n  tokenCredential: SharedKeyCredential | TokenCredential;\n  /**\n   * @property A map of active Service Bus Senders with sender name as key.\n   */\n  senders: { [name: string]: MessageSender };\n  /**\n   * @property A map of active Service Bus receivers for non session enabled queues/subscriptions\n   * with receiver name as key.\n   */\n  messageReceivers: { [name: string]: MessageReceiver };\n  /**\n   * @property A map of active Service Bus receivers for session enabled queues/subscriptions\n   * with receiver name as key.\n   */\n  messageSessions: { [name: string]: MessageSession };\n  /**\n   * @property A map of ManagementClient instances for operations over the $management link\n   * with key as the entity path.\n   */\n  managementClients: { [name: string]: ManagementClient };\n  /**\n   * Function returning a promise that resolves once the connectionContext is ready to open an AMQP link.\n   * ConnectionContext will be ready to open an AMQP link when:\n   * - The AMQP connection is already open on both sides.\n   * - The AMQP connection has been closed or disconnected. In this case, a new AMQP connection is expected\n   * to be created first.\n   * An AMQP link cannot be opened if the AMQP connection\n   * is in the process of closing or disconnecting.\n   */\n  readyToOpenLink(): Promise<void>;\n  /**\n   * Fetches the receiver from the cache in ConnectionContext based on the receiverName given.\n   * Useful for when a message needs to be settled or have its lock renewed.\n   *\n   * TODO: Track the right receiver on the message instead of the ConnectionContext to remove\n   * the need for this helper.\n   */\n  getReceiverFromCache(\n    receiverName: string,\n    sessionId?: string\n  ): MessageReceiver | MessageSession | undefined;\n  /**\n   * Gets the management client for given entity path from the cache\n   * Creates one if none exists in the cache\n   */\n  getManagementClient(entityPath: string): ManagementClient;\n  /**\n   * Indicates whether the connection is in the process of closing.\n   * When this returns `true`, a `disconnected` event will be received\n   * after the connection is closed.\n   */\n  isConnectionClosing(): boolean;\n}\n\n/**\n * Describes the members on the ConnectionContext that are only\n * used by it internally.\n * @hidden\n * @internal\n */\nexport interface ConnectionContextInternalMembers extends ConnectionContext {\n  /**\n   * Resolves once the context's connection emits a `disconnected` event.\n   */\n  waitForDisconnectedEvent(): Promise<void>;\n  /**\n   * Resolves once the connection has finished being reset.\n   * Connections are reset as part of reacting to a `disconnected` event.\n   */\n  waitForConnectionReset(): Promise<void>;\n}\n\n/**\n * @internal\n * @hidden\n * Helper type to get the names of all the functions on an object.\n */\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\n/**\n * @internal\n * @hidden\n * Helper type to get the types of all the functions on an object.\n */\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n/**\n * @internal\n * @hidden\n * Helper type to get the types of all the functions on ConnectionContext\n * and the internal methods from ConnectionContextInternalMembers.\n * Note that this excludes the functions that ConnectionContext inherits.\n * Each function also has its `this` type set as `ConnectionContext`.\n */\ntype ConnectionContextMethods = Omit<\n  FunctionProperties<ConnectionContextInternalMembers>,\n  FunctionPropertyNames<ConnectionContextBase>\n> &\n  ThisType<ConnectionContextInternalMembers>;\n\n/**\n * @internal\n * @hidden\n * Helper method to call onDetached on the receivers from the connection context upon seeing an error.\n */\nasync function callOnDetachedOnReceivers(\n  connectionContext: ConnectionContext,\n  contextOrConnectionError: Error | ConnectionError | AmqpError | undefined,\n  receiverType: ReceiverType\n) {\n  const detachCalls: Promise<void>[] = [];\n\n  for (const receiverName of Object.keys(connectionContext.messageReceivers)) {\n    const receiver = connectionContext.messageReceivers[receiverName];\n    if (receiver && receiver.receiverType === receiverType) {\n      logger.verbose(\n        \"[%s] calling detached on %s receiver '%s'.\",\n        connectionContext.connection.id,\n        receiver.receiverType,\n        receiver.name\n      );\n      detachCalls.push(\n        receiver.onDetached(contextOrConnectionError).catch((err) => {\n          logger.logError(\n            err,\n            \"[%s] An error occurred while calling onDetached() on the %s receiver '%s'\",\n            connectionContext.connection.id,\n            receiver.receiverType,\n            receiver.name\n          );\n        })\n      );\n    }\n  }\n\n  return Promise.all(detachCalls);\n}\n\n/**\n * @internal\n * @hidden\n * Helper method to get the number of receivers of specified type from the connectionContext.\n */\nasync function getNumberOfReceivers(\n  connectionContext: Pick<ConnectionContext, \"messageReceivers\" | \"messageSessions\">,\n  receiverType: ReceiverType\n) {\n  if (receiverType === \"session\") {\n    const receivers = connectionContext.messageSessions;\n    return Object.keys(receivers).length;\n  }\n  const receivers = connectionContext.messageReceivers;\n  const receiverNames = Object.keys(receivers);\n  const count = receiverNames.reduce(\n    (acc, name) => (receivers[name].receiverType === receiverType ? ++acc : acc),\n    0\n  );\n  return count;\n}\n\n/**\n * @internal\n * @hidden\n */\nexport namespace ConnectionContext {\n  export function create(\n    config: ConnectionConfig,\n    tokenCredential: SharedKeyCredential | TokenCredential,\n    options?: ServiceBusClientOptions\n  ): ConnectionContext {\n    if (!options) options = {};\n    const userAgent = `${formatUserAgentPrefix(\n      options.userAgentOptions?.userAgentPrefix\n    )} ${getRuntimeInfo()}`;\n    const parameters: CreateConnectionContextBaseParameters = {\n      config: config,\n      // re-enabling this will be a post-GA discussion similar to event-hubs.\n      // dataTransformer: options.dataTransformer,\n      isEntityPathRequired: false,\n      connectionProperties: {\n        product: \"MSJSClient\",\n        userAgent,\n        version: packageJsonInfo.version\n      }\n    };\n    // Let us create the base context and then add ServiceBus specific ConnectionContext properties.\n    const connectionContext = ConnectionContextBase.create(parameters) as ConnectionContext;\n    connectionContext.tokenCredential = tokenCredential;\n    connectionContext.senders = {};\n    connectionContext.messageReceivers = {};\n    connectionContext.messageSessions = {};\n    connectionContext.managementClients = {};\n\n    let waitForConnectionRefreshResolve: () => void;\n    let waitForConnectionRefreshPromise: Promise<void> | undefined;\n    Object.assign<ConnectionContext, ConnectionContextMethods>(connectionContext, {\n      isConnectionClosing() {\n        // When the connection is not open, but the remote end is open,\n        // then the rhea connection is in the process of terminating.\n        return Boolean(!this.connection.isOpen() && this.connection.isRemoteOpen());\n      },\n      async readyToOpenLink() {\n        logger.verbose(\n          `[${this.connectionId}] Waiting until the connection is ready to open link.`\n        );\n        // Check that the connection isn't in the process of closing.\n        // This can happen when the idle timeout has been reached but\n        // the underlying socket is waiting to be destroyed.\n        if (this.isConnectionClosing()) {\n          logger.verbose(\n            `[${this.connectionId}] Connection is closing, waiting for disconnected event`\n          );\n          // Wait for the disconnected event that indicates the underlying socket has closed.\n          await this.waitForDisconnectedEvent();\n        }\n\n        // Wait for the connection to be reset.\n        await this.waitForConnectionReset();\n        logger.verbose(`[${this.connectionId}] Connection is ready to open link.`);\n      },\n      waitForDisconnectedEvent() {\n        return new Promise((resolve) => {\n          logger.verbose(\n            `[${this.connectionId}] Attempting to reinitialize connection` +\n              ` but the connection is in the process of closing.` +\n              ` Waiting for the disconnect event before continuing.`\n          );\n          this.connection.once(ConnectionEvents.disconnected, resolve);\n        });\n      },\n      waitForConnectionReset() {\n        // Check if the connection is currently in the process of disconnecting.\n        if (waitForConnectionRefreshPromise) {\n          logger.verbose(`[${this.connectionId}] Waiting for connection reset`);\n          return waitForConnectionRefreshPromise;\n        }\n\n        logger.verbose(\n          `[${this.connectionId}] Connection not waiting to be reset. Resolving immediately.`\n        );\n        return Promise.resolve();\n      },\n      getReceiverFromCache(\n        receiverName: string,\n        sessionId?: string\n      ): MessageReceiver | MessageSession | undefined {\n        if (sessionId != null && this.messageSessions[receiverName]) {\n          return this.messageSessions[receiverName];\n        }\n\n        if (this.messageReceivers[receiverName]) {\n          return this.messageReceivers[receiverName];\n        }\n\n        let existingReceivers = \"\";\n        if (sessionId != null) {\n          for (const messageSessionName of Object.keys(this.messageSessions)) {\n            if (this.messageSessions[messageSessionName].sessionId === sessionId) {\n              existingReceivers = this.messageSessions[messageSessionName].name;\n              break;\n            }\n          }\n        } else {\n          existingReceivers +=\n            (existingReceivers ? \", \" : \"\") + Object.keys(this.messageReceivers).join(\",\");\n        }\n\n        logger.verbose(\n          \"[%s] Failed to find receiver '%s' among existing receivers: %s\",\n          this.connectionId,\n          receiverName,\n          existingReceivers\n        );\n        return;\n      },\n      getManagementClient(entityPath: string): ManagementClient {\n        if (!this.managementClients[entityPath]) {\n          this.managementClients[entityPath] = new ManagementClient(this, entityPath, {\n            address: `${entityPath}/$management`\n          });\n        }\n        return this.managementClients[entityPath];\n      }\n    });\n\n    // Define listeners to be added to the connection object for\n    // \"connection_open\" and \"connection_error\" events.\n    const onConnectionOpen: OnAmqpEvent = () => {\n      connectionContext.wasConnectionCloseCalled = false;\n      logger.verbose(\n        \"[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.\",\n        connectionContext.connection.id,\n        connectionContext.wasConnectionCloseCalled\n      );\n    };\n\n    const disconnected: OnAmqpEvent = async (context: EventContext) => {\n      if (waitForConnectionRefreshPromise) {\n        return;\n      }\n\n      waitForConnectionRefreshPromise = new Promise((resolve) => {\n        waitForConnectionRefreshResolve = resolve;\n      });\n\n      const connectionError =\n        context.connection && context.connection.error ? context.connection.error : undefined;\n      if (connectionError) {\n        logger.logError(\n          connectionError,\n          \"[%s] Error (context.connection.error) occurred on the amqp connection\",\n          connectionContext.connection.id\n        );\n      }\n      const contextError = context.error;\n      if (contextError) {\n        logger.logError(\n          contextError,\n          \"[%s] Error (context.error) occurred on the amqp connection\",\n          connectionContext.connection.id\n        );\n      }\n      const state: Readonly<{\n        wasConnectionCloseCalled: boolean;\n        numSenders: number;\n        numReceivers: number;\n      }> = {\n        wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,\n        numSenders: Object.keys(connectionContext.senders).length,\n        numReceivers:\n          Object.keys(connectionContext.messageReceivers).length +\n          Object.keys(connectionContext.messageSessions).length\n      };\n\n      // Clear internal map maintained by rhea to avoid reconnecting of old links once the\n      // connection is back up.\n      connectionContext.connection.removeAllSessions();\n\n      // Close the cbs session to ensure all the event handlers are released.\n      await connectionContext.cbsSession.close();\n\n      // Close the management sessions to ensure all the event handlers are released.\n      for (const entityPath of Object.keys(connectionContext.managementClients)) {\n        await connectionContext.managementClients[entityPath].close();\n      }\n\n      // Calling onDetached on sender\n      if (!state.wasConnectionCloseCalled && state.numSenders) {\n        // We don't do recovery for the sender:\n        //   Because we don't want to keep the sender active all the time\n        //   and the \"next\" send call would bear the burden of creating the link.\n        // Call onDetached() on sender so that it can gracefully shutdown\n        //   by cleaning up the timers and closing the links.\n        // We don't call onDetached for sender after `refreshConnection()`\n        //   because any new send calls that potentially initialize links would also get affected if called later.\n        logger.verbose(\n          `[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${state.numSenders} ` +\n            `senders. We should not reconnect.`\n        );\n        const detachCalls: Promise<void>[] = [];\n        for (const senderName of Object.keys(connectionContext.senders)) {\n          const sender = connectionContext.senders[senderName];\n          if (sender) {\n            logger.verbose(\n              \"[%s] calling detached on sender '%s'.\",\n              connectionContext.connection.id,\n              sender.name\n            );\n            detachCalls.push(\n              sender.onDetached().catch((err) => {\n                logger.logError(\n                  err,\n                  \"[%s] An error occurred while calling onDetached() the sender '%s'\",\n                  connectionContext.connection.id,\n                  sender.name\n                );\n              })\n            );\n          }\n        }\n        await Promise.all(detachCalls);\n      }\n\n      // Calling onDetached on batching receivers for the same reasons as sender\n      const numBatchingReceivers = getNumberOfReceivers(connectionContext, \"batching\");\n      if (!state.wasConnectionCloseCalled && numBatchingReceivers) {\n        logger.verbose(\n          `[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numBatchingReceivers} ` +\n            `batching receivers. We should reconnect.`\n        );\n\n        // Call onDetached() on receivers so that batching receivers it can gracefully close any ongoing batch operation\n        await callOnDetachedOnReceivers(\n          connectionContext,\n          connectionError || contextError,\n          \"batching\"\n        );\n\n        // TODO:\n        //  `callOnDetachedOnReceivers` handles \"connectionContext.messageReceivers\".\n        //  ...What to do for sessions (connectionContext.messageSessions) ??\n      }\n\n      await refreshConnection(connectionContext);\n      waitForConnectionRefreshResolve();\n      waitForConnectionRefreshPromise = undefined;\n      // The connection should always be brought back up if the sdk did not call connection.close()\n      // and there was at least one receiver link on the connection before it went down.\n      logger.verbose(\"[%s] state: %O\", connectionContext.connectionId, state);\n\n      // Calling onDetached on streaming receivers\n      const numStreamingReceivers = getNumberOfReceivers(connectionContext, \"streaming\");\n      if (!state.wasConnectionCloseCalled && numStreamingReceivers) {\n        logger.verbose(\n          `[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numStreamingReceivers} ` +\n            `streaming receivers. We should reconnect.`\n        );\n\n        // Calling `onDetached()` on streaming receivers after the refreshConnection() since `onDetached()` would\n        // recover the streaming receivers and that would only be possible after the connection is refreshed.\n        //\n        // This is different from the batching receiver since `onDetached()` for the batching receiver would\n        // return the outstanding messages and close the receive link.\n        await callOnDetachedOnReceivers(\n          connectionContext,\n          connectionError || contextError,\n          \"streaming\"\n        );\n      }\n    };\n\n    const protocolError: OnAmqpEvent = async (context: EventContext) => {\n      if (context.connection && context.connection.error) {\n        logger.logError(\n          context.connection.error,\n          \"[%s] Error (context.connection.error) occurred on the amqp connection\",\n          connectionContext.connection.id\n        );\n      }\n      if (context.error) {\n        logger.logError(\n          context.error,\n          \"[%s] Error (context.error) occurred on the amqp connection\",\n          connectionContext.connection.id\n        );\n      }\n    };\n\n    const error: OnAmqpEvent = async (context: EventContext) => {\n      if (context.connection && context.connection.error) {\n        logger.logError(\n          context.connection.error,\n          \"[%s] Error (context.connection.error) occurred on the amqp connection\",\n          connectionContext.connection.id\n        );\n      }\n      if (context.error) {\n        logger.logError(\n          context.error,\n          \"[%s] Error (context.error) occurred on the amqp connection\",\n          connectionContext.connection.id\n        );\n      }\n    };\n\n    async function refreshConnection(connectionContext: ConnectionContext) {\n      const originalConnectionId = connectionContext.connectionId;\n      try {\n        await cleanConnectionContext(connectionContext);\n      } catch (err) {\n        logger.logError(\n          err,\n          `[${connectionContext.connectionId}] There was an error closing the connection before reconnecting`\n        );\n      }\n      // Create a new connection, id, locks, and cbs client.\n      connectionContext.refreshConnection();\n      addConnectionListeners(connectionContext.connection);\n      logger.verbose(\n        `The connection \"${originalConnectionId}\" has been updated to \"${connectionContext.connectionId}\".`\n      );\n    }\n\n    function addConnectionListeners(connection: Connection) {\n      // Add listeners on the connection object.\n      connection.on(ConnectionEvents.connectionOpen, onConnectionOpen);\n      connection.on(ConnectionEvents.disconnected, disconnected);\n      connection.on(ConnectionEvents.protocolError, protocolError);\n      connection.on(ConnectionEvents.error, error);\n    }\n\n    async function cleanConnectionContext(connectionContext: ConnectionContext) {\n      // Remove listeners from the connection object.\n      connectionContext.connection.removeListener(\n        ConnectionEvents.connectionOpen,\n        onConnectionOpen\n      );\n      connectionContext.connection.removeListener(ConnectionEvents.disconnected, disconnected);\n      connectionContext.connection.removeListener(ConnectionEvents.protocolError, protocolError);\n      connectionContext.connection.removeListener(ConnectionEvents.error, error);\n      // Close the connection\n      await connectionContext.connection.close();\n    }\n\n    addConnectionListeners(connectionContext.connection);\n\n    logger.verbose(\"[%s] Created connection context successfully.\", connectionContext.connectionId);\n\n    return connectionContext;\n  }\n\n  /**\n   * Closes the AMQP connection created by this ServiceBusClient along with AMQP links for\n   * sender/receivers created by the queue/topic/subscription clients created by this\n   * ServiceBusClient.\n   * Once closed,\n   * - the clients created by this ServiceBusClient cannot be used to send/receive messages anymore.\n   * - this ServiceBusClient cannot be used to create any new queues/topics/subscriptions clients.\n   * @returns {Promise<any>}\n   */\n  export async function close(context: ConnectionContext): Promise<void> {\n    const logPrefix = `[${context.connectionId}]`;\n\n    try {\n      logger.verbose(`${logPrefix} Permanently closing the amqp connection on the client.`);\n\n      // Close all the senders.\n      const senderNames = Object.keys(context.senders);\n      logger.verbose(`${logPrefix} Permanently closing ${senderNames.length} senders.`);\n      for (const senderName of senderNames) {\n        await context.senders[senderName].close();\n      }\n\n      // Close all MessageReceiver instances\n      const messageReceiverNames = Object.keys(context.messageReceivers);\n      logger.verbose(`${logPrefix} Permanently closing ${messageReceiverNames.length} receivers.`);\n      for (const receiverName of messageReceiverNames) {\n        await context.messageReceivers[receiverName].close();\n      }\n\n      // Close all MessageSession instances\n      const messageSessionNames = Object.keys(context.messageSessions);\n      logger.verbose(\n        `${logPrefix} Permanently closing ${messageSessionNames.length} session receivers.`\n      );\n      for (const messageSessionName of messageSessionNames) {\n        await context.messageSessions[messageSessionName].close();\n      }\n\n      // Close all the ManagementClients.\n      const managementClientsEntityPaths = Object.keys(context.managementClients);\n      logger.verbose(\n        `${logPrefix} Permanently closing ${managementClientsEntityPaths.length} session receivers.`\n      );\n      for (const entityPath of managementClientsEntityPaths) {\n        await context.managementClients[entityPath].close();\n      }\n\n      logger.verbose(`${logPrefix} Permanently closing cbsSession`);\n      await context.cbsSession.close();\n\n      logger.verbose(`${logPrefix} Permanently closing internal connection`);\n      await context.connection.close();\n      context.wasConnectionCloseCalled = true;\n      logger.verbose(`[${logPrefix} Permanently closed the amqp connection on the client.`);\n    } catch (err) {\n      const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));\n      logger.logError(err, `${logPrefix} An error occurred while closing the connection`);\n      throw errObj;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionConfig, RetryOptions, WebSocketOptions } from \"@azure/core-amqp\";\nimport { TokenCredential } from \"@azure/core-auth\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { UserAgentOptions } from \"@azure/core-http\";\nimport { SharedKeyCredential } from \"./servicebusSharedKeyCredential\";\n\n/**\n * Describes the options that can be provided while creating the ServiceBusClient.\n */\nexport interface ServiceBusClientOptions {\n  /**\n   * Retry policy options that determine the mode, number of retries, retry interval etc.\n   */\n  retryOptions?: RetryOptions;\n  /**\n   * @property\n   * Options to configure the channelling of the AMQP connection over Web Sockets.\n   */\n  webSocketOptions?: WebSocketOptions;\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentOptions;\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {string} connectionString\n * @param {(SharedKeyCredential | TokenCredential)} credential\n * @param {ServiceBusClientOptions} options\n */\nexport function createConnectionContext(\n  connectionString: string,\n  credential: SharedKeyCredential | TokenCredential,\n  options: ServiceBusClientOptions\n): ConnectionContext {\n  const config = ConnectionConfig.create(connectionString);\n\n  config.webSocket = options?.webSocketOptions?.webSocket;\n  config.webSocketEndpointPath = \"$servicebus/websocket\";\n  config.webSocketConstructorOptions = options?.webSocketOptions?.webSocketConstructorOptions;\n\n  return ConnectionContext.create(config, credential, options);\n}\n\n/**\n * @param connectionString\n * @param options\n * @internal\n * @hidden\n */\nexport function createConnectionContextForConnectionString(\n  connectionString: string,\n  options: ServiceBusClientOptions = {}\n): ConnectionContext {\n  const credential = SharedKeyCredential.fromConnectionString(connectionString);\n  return createConnectionContext(connectionString, credential, options);\n}\n\n/**\n *\n * @param credential\n * @param host\n * @param options\n * @internal\n * @hidden\n */\nexport function createConnectionContextForTokenCredential(\n  credential: TokenCredential,\n  host: string,\n  options: ServiceBusClientOptions = {}\n): ConnectionContext {\n  if (typeof host !== \"string\") {\n    throw new TypeError(\"`host` parameter is not a string\");\n  }\n\n  // host, credential and options based constructor was invoked\n  if (!host.endsWith(\"/\")) {\n    host += \"/\";\n  }\n  const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;`;\n  return createConnectionContext(connectionString, credential, options);\n}\n\n/**\n * Parses a connection string and extracts the EntityPath named entity out.\n * @param connectionString An entity specific Service Bus connection string.\n * @internal\n * @hidden\n */\nexport function getEntityNameFromConnectionString(connectionString: string): string {\n  const entityPathMatch = connectionString.match(/^.+EntityPath=(.+?);{0,1}$/);\n\n  if (entityPathMatch != null && entityPathMatch.length === 2) {\n    return entityPathMatch[1];\n  } else {\n    throw new Error(\"No entity name present in the connection string\");\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// TODO: this code is a straight-copy from EventHubs. Need to merge.\n\nimport { CanonicalCode, Link, Span, SpanContext, SpanKind } from \"@opentelemetry/api\";\nimport { OperationOptions } from \"@azure/core-http\";\nimport { getTracer, OperationTracingOptions } from \"@azure/core-tracing\";\n\n/**\n * NOTE: This type is intended to mirror the relevant fields and structure from @azure/core-http OperationOptions\n *\n * Options for configuring tracing and the abortSignal.\n */\nexport type OperationOptionsBase = Pick<OperationOptions, \"abortSignal\" | \"tracingOptions\">;\n\n/**\n * @internal\n * @hidden\n */\nexport function getParentSpan(\n  options?: OperationTracingOptions\n): Span | SpanContext | null | undefined {\n  return options?.spanOptions?.parent;\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {(Span | SpanContext | null)} [parentSpan]\n * @param {SpanContext[]} [spanContextsToLink=[]]\n * @param {string} [entityPath]\n * @param {string} [host]\n */\nexport function createSendSpan(\n  parentSpan?: Span | SpanContext | null,\n  spanContextsToLink: SpanContext[] = [],\n  entityPath?: string,\n  host?: string\n): Span {\n  const links: Link[] = spanContextsToLink.map((context) => {\n    return {\n      context\n    };\n  });\n  const tracer = getTracer();\n  const span = tracer.startSpan(\"Azure.ServiceBus.send\", {\n    kind: SpanKind.CLIENT,\n    parent: parentSpan,\n    links\n  });\n\n  span.setAttribute(\"az.namespace\", \"Microsoft.ServiceBus\");\n  span.setAttribute(\"message_bus.destination\", entityPath);\n  span.setAttribute(\"peer.address\", host);\n\n  return span;\n}\n/**\n * The set of options to manually propagate `Span` context for distributed tracing.\n */\nexport interface TryAddOptions {\n  /**\n   * The `Span` or `SpanContext` to use as the `parent` of any spans created while calling operations that make a request to the service.\n   */\n  parentSpan?: Span | SpanContext | null;\n}\n\n/**\n * Runs the `fn` passed in and marks the span as completed with an error (and the\n * corresponding message) or as OK.\n *\n * @hidden\n * @internal\n */\nexport async function trace<T>(fn: () => Promise<T>, span: Span): Promise<T> {\n  try {\n    const ret = await fn();\n    span.setStatus({ code: CanonicalCode.OK });\n    return ret;\n  } catch (err) {\n    span.setStatus({\n      code: CanonicalCode.UNKNOWN,\n      message: err.message\n    });\n    throw err;\n  } finally {\n    span.end();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Delivery, ReceiverOptions, Source } from \"rhea-promise\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { receiverLogger } from \"../log\";\nimport { ReceiveMode } from \"../models\";\n\n/**\n * @internal\n * @hidden\n */\nexport type ReceiverHandlers = Pick<\n  ReceiverOptions,\n  \"onMessage\" | \"onError\" | \"onClose\" | \"onSessionError\" | \"onSessionClose\" | \"onSettled\"\n>;\n\n/**\n * @internal\n */\nexport interface DeferredPromiseAndTimer {\n  resolve: (value?: any) => void;\n  reject: (reason?: any) => void;\n  timer: NodeJS.Timer;\n}\n\n/**\n * This is the shared onSettled handler for all of the receiver implementations.\n *\n * The sequence is basically:\n * 1. User calls `await <ServiceBusMessage instance>.complete()`     (or other settlement methods)\n * 2. This creates a `Promise` that gets stored in the _deliveryDispositionMap\n * 3. When the service acknowledges the settlement this method gets called for that message.\n * 4. We resolve() the promise from the _deliveryDispositionMap.\n * 5. User's code after the settlement continues.\n *\n * @internal\n * @hidden\n */\nexport function onMessageSettled(\n  logPrefix: string,\n  delivery: Delivery | undefined,\n  deliveryDispositionMap: Map<number, DeferredPromiseAndTimer>\n): void {\n  if (delivery) {\n    const id = delivery.id;\n    const state = delivery.remote_state;\n    const settled = delivery.remote_settled;\n    receiverLogger.verbose(\n      \"%s Delivery with id %d, remote_settled: %s, remote_state: %o has been \" + \"received.\",\n      logPrefix,\n      id,\n      settled,\n      state && state.error ? state.error : state\n    );\n    if (settled && deliveryDispositionMap.has(id)) {\n      const promise = deliveryDispositionMap.get(id) as DeferredPromiseAndTimer;\n      clearTimeout(promise.timer);\n      receiverLogger.verbose(\n        \"%s Found the delivery with id %d in the map and cleared the timer.\",\n        logPrefix,\n        id\n      );\n      const deleteResult = deliveryDispositionMap.delete(id);\n      receiverLogger.verbose(\n        \"%s Successfully deleted the delivery with id %d from the map.\",\n        logPrefix,\n        id,\n        deleteResult\n      );\n      if (state && state.error && (state.error.condition || state.error.description)) {\n        const error = translateServiceBusError(state.error);\n        return promise.reject(error);\n      }\n\n      return promise.resolve();\n    }\n  }\n}\n\n/**\n * Creates the options that need to be specified while creating an AMQP receiver link.\n *\n * @internal\n * @hidden\n * @param {string} name\n * @param {ReceiveMode} receiveMode\n * @param {Source} source\n * @param {ReceiverHandlers} handlers\n */\nexport function createReceiverOptions(\n  name: string,\n  receiveMode: ReceiveMode,\n  source: Source,\n  handlers: ReceiverHandlers\n): ReceiverOptions {\n  const rcvrOptions: ReceiverOptions = {\n    name,\n    // \"autoaccept\" being true in the \"receiveAndDelete\" mode sets the \"settled\" flag to true on the deliveries\n    // which helps in clearing the circular buffer(size=2048) as it is needed to receive messages after 2048 of them are received.\n    autoaccept: receiveMode === \"receiveAndDelete\" ? true : false,\n    // receiveAndDelete -> first(0), peekLock -> second (1)\n    rcv_settle_mode: receiveMode === \"receiveAndDelete\" ? 0 : 1,\n    // receiveAndDelete -> settled (1), peekLock -> unsettled (0)\n    snd_settle_mode: receiveMode === \"receiveAndDelete\" ? 1 : 0,\n    source,\n    credit_window: 0,\n    ...handlers\n  };\n\n  return rcvrOptions;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  Constants,\n  ErrorNameConditionMapper,\n  MessagingError,\n  RetryOptions\n} from \"@azure/core-amqp\";\nimport { AmqpError, EventContext, OnAmqpEvent, Receiver, ReceiverOptions } from \"rhea-promise\";\nimport { receiverLogger as logger } from \"../log\";\nimport { LinkEntity, ReceiverType } from \"./linkEntity\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { DispositionType, ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { getUniqueName } from \"../util/utils\";\nimport { ProcessErrorArgs, ReceiveMode, SubscribeOptions } from \"../models\";\nimport { DispositionStatusOptions } from \"./managementClient\";\nimport { AbortSignalLike } from \"@azure/core-http\";\nimport {\n  onMessageSettled,\n  DeferredPromiseAndTimer,\n  ReceiverHandlers,\n  createReceiverOptions\n} from \"./shared\";\nimport { LockRenewer } from \"./autoLockRenewer\";\nimport { translateServiceBusError } from \"../serviceBusError\";\n\n/**\n * @internal\n * @hidden\n */\nexport interface OnAmqpEventAsPromise extends OnAmqpEvent {\n  (context: EventContext): Promise<void>;\n}\n\n/**\n * @internal\n * @hidden\n */\nexport interface ReceiveOptions extends SubscribeOptions {\n  /**\n   * @property {number} [receiveMode] The mode in which messages should be received.\n   */\n  receiveMode: ReceiveMode;\n  /**\n   * Retry policy options that determine the mode, number of retries, retry interval etc.\n   */\n  retryOptions?: RetryOptions;\n\n  /**\n   * A LockAutoRenewer that will automatically renew locks based on user specified interval.\n   * This will be set if the user has chosen peekLock mode _and_ they've set a positive\n   * maxAutoRenewLockDurationInMs value when they created their receiver.\n   */\n  lockRenewer: LockRenewer | undefined;\n}\n\n/**\n * Describes the signature of the message handler passed to `registerMessageHandler` method.\n * @internal\n * @hidden\n */\nexport interface OnMessage {\n  /**\n   * Handler for processing each incoming message.\n   */\n  (message: ServiceBusMessageImpl): Promise<void>;\n}\n\n/**\n * Describes the signature of the error handler passed to `registerMessageHandler` method.\n *\n * @internal\n * @hidden\n */\nexport interface OnError {\n  /**\n   * Handler for any error that occurs while receiving or processing messages.\n   *\n   * NOTE: if this signature changes make sure you reflect those same changes in the\n   * `OnErrorNoContext` definition below.\n   */\n  (args: ProcessErrorArgs): void;\n}\n\n/**\n * An onError method but without the context property. Used when wrapping OnError\n * with an implicit ProcessErrorContext. Used by LockRenewer.\n *\n * @internal\n * @hidden\n */\nexport interface OnErrorNoContext {\n  (error: MessagingError | Error): void;\n}\n\n/**\n * @internal\n * @hidden\n * Describes the MessageReceiver that will receive messages from ServiceBus.\n * @class MessageReceiver\n */\nexport abstract class MessageReceiver extends LinkEntity<Receiver> {\n  /**\n   * @property {string} receiverType The type of receiver: \"batching\" or \"streaming\".\n   */\n  receiverType: ReceiverType;\n  /**\n   * @property {number} [receiveMode] The mode in which messages should be received.\n   * Default: ReceiveMode.peekLock\n   */\n  receiveMode: ReceiveMode;\n  /**\n   * @property {boolean} autoComplete Indicates whether `Message.complete()` should be called\n   * automatically after the message processing is complete while receiving messages with handlers.\n   * Default: false.\n   */\n  autoComplete: boolean;\n  /**\n   * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that\n   * are being actively disposed. It acts as a store for correlating the responses received for\n   * active dispositions.\n   */\n  protected _deliveryDispositionMap: Map<number, DeferredPromiseAndTimer> = new Map<\n    number,\n    DeferredPromiseAndTimer\n  >();\n  /**\n   * @property {OnMessage} _onMessage The message handler provided by the user that will be wrapped\n   * inside _onAmqpMessage.\n   */\n  protected _onMessage!: OnMessage;\n  /**\n   * @property {OnMessage} _onError The error handler provided by the user that will be wrapped\n   * inside _onAmqpError.\n   */\n  protected _onError?: OnError;\n\n  /**\n   * A lock renewer that handles message lock auto-renewal. This is undefined unless the user\n   * has activated autolock renewal via ReceiveOptions. A single auto lock renewer is shared\n   * for all links for a `ServiceBusReceiver` instance.\n   */\n  protected _lockRenewer: LockRenewer | undefined;\n\n  constructor(\n    context: ConnectionContext,\n    entityPath: string,\n    receiverType: ReceiverType,\n    options: Omit<ReceiveOptions, \"maxConcurrentCalls\">\n  ) {\n    super(entityPath, entityPath, context, receiverType, logger, {\n      address: entityPath,\n      audience: `${context.config.endpoint}${entityPath}`\n    });\n\n    this.receiverType = receiverType;\n    this.receiveMode = options.receiveMode || \"peekLock\";\n\n    // If explicitly set to false then autoComplete is false else true (default).\n    this.autoComplete =\n      options.autoCompleteMessages === false ? options.autoCompleteMessages : true;\n    this._lockRenewer = options.lockRenewer;\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   */\n  protected _createReceiverOptions(\n    useNewName: boolean,\n    handlers: ReceiverHandlers\n  ): ReceiverOptions {\n    const rcvrOptions: ReceiverOptions = createReceiverOptions(\n      useNewName ? getUniqueName(this.baseName) : this.name,\n      this.receiveMode,\n      {\n        address: this.address\n      },\n      {\n        onSettled: (context: EventContext) => {\n          return onMessageSettled(this.logPrefix, context.delivery, this._deliveryDispositionMap);\n        },\n        ...handlers\n      }\n    );\n\n    return rcvrOptions;\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   *\n   * @returns {Promise<void>} Promise<void>.\n   */\n  protected async _init(options: ReceiverOptions, abortSignal?: AbortSignalLike): Promise<void> {\n    try {\n      await this.initLink(options, abortSignal);\n\n      // It is possible for someone to close the receiver and then start it again.\n      // Thus make sure that the receiver is present in the client cache.\n      this._context.messageReceivers[this.name] = this as any;\n    } catch (err) {\n      err = translateServiceBusError(err);\n      logger.logError(err, \"%s An error occured while creating the receiver\", this.logPrefix);\n\n      // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.\n      if ((err as MessagingError).code === \"OperationTimeoutError\") {\n        err.message = \"Failed to create a receiver within allocated time and retry attempts.\";\n      }\n\n      throw err;\n    }\n  }\n\n  protected createRheaLink(\n    options: ReceiverOptions,\n    _abortSignal?: AbortSignalLike\n  ): Promise<Receiver> {\n    return this._context.connection.createReceiver(options);\n  }\n\n  /**\n   * React to receiver being detached due to given error.\n   * You may want to set up retries to recover the broken link and/or report error to user.\n   * @param error The error accompanying the receiver/session error or connection disconnected events\n   */\n  abstract onDetached(error?: AmqpError | Error): Promise<void>;\n\n  /**\n   * Clears lock renewal timers on all active messages, clears token remewal for current receiver,\n   * removes current MessageReceiver instance from cache, and closes the underlying AMQP receiver.\n   * @return {Promise<void>} Promise<void>.\n   */\n  async close(): Promise<void> {\n    this._lockRenewer?.stopAll(this);\n    await super.close();\n  }\n\n  /**\n   * Settles the message with the specified disposition.\n   * @param message The ServiceBus Message that needs to be settled.\n   * @param operation The disposition type.\n   * @param options Optional parameters that can be provided while disposing the message.\n   */\n  async settleMessage(\n    message: ServiceBusMessageImpl,\n    operation: DispositionType,\n    options?: DispositionStatusOptions\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      if (!options) options = {};\n      if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {\n        return reject(new Error(`operation: '${operation}' is not a valid operation.`));\n      }\n      this._lockRenewer?.stop(this, message);\n      const delivery = message.delivery;\n      const timer = setTimeout(() => {\n        this._deliveryDispositionMap.delete(delivery.id);\n\n        logger.verbose(\n          \"%s Disposition for delivery id: %d, did not complete in %d milliseconds. \" +\n            \"Hence rejecting the promise with timeout error.\",\n          this.logPrefix,\n          delivery.id,\n          Constants.defaultOperationTimeoutInMs\n        );\n\n        const e: AmqpError = {\n          condition: ErrorNameConditionMapper.ServiceUnavailableError,\n          description:\n            \"Operation to settle the message has timed out. The disposition of the \" +\n            \"message may or may not be successful\"\n        };\n        return reject(translateServiceBusError(e));\n      }, Constants.defaultOperationTimeoutInMs);\n      this._deliveryDispositionMap.set(delivery.id, {\n        resolve: resolve,\n        reject: reject,\n        timer: timer\n      });\n      if (operation === DispositionType.complete) {\n        delivery.accept();\n      } else if (operation === DispositionType.abandon) {\n        const params: any = {\n          undeliverable_here: false\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.defer) {\n        const params: any = {\n          undeliverable_here: true\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.deadletter) {\n        const error: AmqpError = {\n          condition: Constants.deadLetterName,\n          info: {\n            ...options.propertiesToModify,\n            DeadLetterReason: options.deadLetterReason,\n            DeadLetterErrorDescription: options.deadLetterDescription\n          }\n        };\n        delivery.reject(error);\n      }\n    });\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Receiver, ReceiverEvents } from \"rhea-promise\";\nimport { receiverLogger as logger } from \"../log\";\n\n/**\n * Wraps the receiver with some higher level operations for managing state\n * like credits, draining, etc...\n *\n * @internal\n * @hidden\n */\nexport class ReceiverHelper {\n  private _isSuspended: boolean = false;\n\n  constructor(\n    private _getCurrentReceiver: () => { receiver: Receiver | undefined; logPrefix: string }\n  ) {}\n\n  /**\n   * Adds credits to the receiver, respecting any state that\n   * indicates the receiver is closed or should not continue\n   * to receive more messages.\n   *\n   * @param credits Number of credits to add.\n   * @returns true if credits were added, false if there is no current receiver instance\n   * or `stopReceivingMessages` has been called.\n   */\n  addCredit(credits: number): boolean {\n    const { receiver, logPrefix } = this._getCurrentReceiver();\n\n    if (!this.canReceiveMessages()) {\n      logger.verbose(\n        `${logPrefix} Asked to add ${credits} credits but the receiver is not able to receive messages`\n      );\n      return false;\n    }\n\n    if (receiver != null) {\n      logger.verbose(`${logPrefix} Adding ${credits} credits`);\n      receiver.addCredit(credits);\n    }\n\n    return true;\n  }\n\n  /**\n   * Drains the credits for the receiver and prevents the `receiverHelper.addCredit()` method from adding credits.\n   * Call `resume()` to enable the `addCredit()` method.\n   */\n  async suspend(): Promise<void> {\n    const { receiver, logPrefix } = this._getCurrentReceiver();\n\n    this._isSuspended = true;\n\n    if (!this._isValidReceiver(receiver)) {\n      return;\n    }\n\n    logger.verbose(\n      `${logPrefix} User has requested to stop receiving new messages, attempting to drain.`\n    );\n    return this.drain();\n  }\n\n  /**\n   * Resets tracking so `addCredit` works again.\n   */\n  resume(): void {\n    this._isSuspended = false;\n  }\n\n  /**\n   * Whether the receiver can receive messages.\n   *\n   * This checks if the the caller has decided to disable adding\n   * credits via 'suspend' as well as whether the receiver itself is\n   * still open.\n   */\n  canReceiveMessages(): boolean {\n    const { receiver } = this._getCurrentReceiver();\n    return !this._isSuspended && this._isValidReceiver(receiver);\n  }\n\n  /**\n   * Initiates a drain for the current receiver and resolves when\n   * the drain has completed.\n   */\n  async drain(): Promise<void> {\n    const { receiver, logPrefix } = this._getCurrentReceiver();\n\n    if (!this._isValidReceiver(receiver)) {\n      return;\n    }\n\n    logger.verbose(\n      `${logPrefix} Receiver is starting drain. Remaining credits; ${receiver.credit}`\n    );\n\n    const drainPromise = new Promise<void>((resolve) => {\n      receiver.once(ReceiverEvents.receiverDrained, () => {\n        logger.verbose(`${logPrefix} Receiver has been drained.`);\n        receiver.drain = false;\n        resolve();\n      });\n\n      receiver.drain = true;\n      // this is not actually adding another credit - it'll just\n      // cause the drain call to start.\n      receiver.addCredit(1);\n    });\n\n    return drainPromise;\n  }\n\n  private _isValidReceiver(receiver: Receiver | undefined): receiver is Receiver {\n    return receiver != null && receiver.isOpen();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { MessageHandlers, ProcessErrorArgs } from \"../models\";\nimport { ServiceBusReceiver } from \"./receiver\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { receiverLogger, ServiceBusLogger } from \"../log\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport {\n  DeadLetterOptions,\n  DispositionType,\n  ServiceBusMessageImpl,\n  ServiceBusReceivedMessage\n} from \"../serviceBusMessage\";\nimport { DispositionStatusOptions } from \"../core/managementClient\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { ErrorNameConditionMapper } from \"@azure/core-amqp\";\nimport { MessageAlreadySettled } from \"../util/errors\";\n\n/**\n * @internal\n * @hidden\n */\nexport function assertValidMessageHandlers(handlers: any) {\n  if (\n    handlers &&\n    handlers.processMessage instanceof Function &&\n    handlers.processError instanceof Function\n  ) {\n    return;\n  }\n\n  throw new TypeError('Invalid \"MessageHandlers\" provided.');\n}\n\n/**\n * @internal\n * @hidden\n */\nexport async function* getMessageIterator(\n  receiver: Pick<ServiceBusReceiver, \"receiveMessages\">,\n  options?: OperationOptionsBase\n): AsyncIterableIterator<ServiceBusReceivedMessage> {\n  while (true) {\n    const messages = await receiver.receiveMessages(1, options);\n\n    if (messages.length === 0) {\n      continue;\n    }\n\n    yield messages[0];\n  }\n}\n\n/**\n * @internal\n * @hidden\n */\nexport function wrapProcessErrorHandler(\n  handlers: Pick<MessageHandlers, \"processError\">,\n  logger: ServiceBusLogger = receiverLogger\n): MessageHandlers[\"processError\"] {\n  return async (args: ProcessErrorArgs) => {\n    try {\n      args.error = translateServiceBusError(args.error);\n      await handlers.processError(args);\n    } catch (err) {\n      logger.logError(err, `An error was thrown from the user's processError handler`);\n    }\n  };\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {ServiceBusMessageImpl} message\n * @param {ConnectionContext} context\n * @param {string} entityPath\n */\nexport function completeMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Completing the message with id '%s'.\",\n    context.connectionId,\n    message.messageId\n  );\n  return settleMessage(message, DispositionType.complete, context, entityPath);\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {ServiceBusMessageImpl} message\n * @param {ConnectionContext} context\n * @param {string} entityPath\n * @param {{ [key: string]: any }} [propertiesToModify]\n */\nexport function abandonMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string,\n  propertiesToModify?: { [key: string]: any }\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Abandoning the message with id '%s'.\",\n    context.connectionId,\n    message.messageId\n  );\n  return settleMessage(message, DispositionType.abandon, context, entityPath, {\n    propertiesToModify\n  });\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {ServiceBusMessageImpl} message\n * @param {ConnectionContext} context\n * @param {string} entityPath\n * @param {{ [key: string]: any }} [propertiesToModify]\n */\nexport function deferMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string,\n  propertiesToModify?: { [key: string]: any }\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Deferring the message with id '%s'.\",\n    context.connectionId,\n    message.messageId\n  );\n  return settleMessage(message, DispositionType.defer, context, entityPath, {\n    propertiesToModify\n  });\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {ServiceBusMessageImpl} message\n * @param {ConnectionContext} context\n * @param {string} entityPath\n * @param {(DeadLetterOptions & { [key: string]: any })} [propertiesToModify]\n */\nexport function deadLetterMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string,\n  propertiesToModify?: DeadLetterOptions & { [key: string]: any }\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Deadlettering the message with id '%s'.\",\n    context.connectionId,\n    message.messageId\n  );\n\n  const actualPropertiesToModify: Partial<DeadLetterOptions> = {\n    ...propertiesToModify\n  };\n\n  // these two fields are handled specially and don't need to be in here.\n  delete actualPropertiesToModify.deadLetterErrorDescription;\n  delete actualPropertiesToModify.deadLetterReason;\n\n  const dispositionStatusOptions: DispositionStatusOptions = {\n    propertiesToModify: actualPropertiesToModify,\n    deadLetterReason: propertiesToModify?.deadLetterReason,\n    deadLetterDescription: propertiesToModify?.deadLetterErrorDescription\n  };\n\n  return settleMessage(\n    message,\n    DispositionType.deadletter,\n    context,\n    entityPath,\n    dispositionStatusOptions\n  );\n}\n\n/**\n * @internal\n * @hidden\n *\n * @param {ServiceBusMessageImpl} message\n * @param {DispositionType} operation\n * @param {ConnectionContext} context\n * @param {string} entityPath\n * @param {DispositionStatusOptions} [options]\n */\nfunction settleMessage(\n  message: ServiceBusMessageImpl,\n  operation: DispositionType,\n  context: ConnectionContext,\n  entityPath: string,\n  options?: DispositionStatusOptions\n): Promise<void> {\n  const isDeferredMessage = !message.delivery.link;\n  const receiver = isDeferredMessage\n    ? undefined\n    : context.getReceiverFromCache(message.delivery.link.name, message.sessionId);\n  const associatedLinkName = receiver?.name;\n\n  let error: Error | undefined;\n  if (message.delivery.remote_settled) {\n    error = new Error(MessageAlreadySettled);\n  } else if (\n    !isDeferredMessage &&\n    (!receiver || !receiver.isOpen()) &&\n    message.sessionId != undefined\n  ) {\n    error = translateServiceBusError({\n      description:\n        `Failed to ${operation} the message as the AMQP link with which the message was ` +\n        `received is no longer alive.`,\n      condition: ErrorNameConditionMapper.SessionLockLostError\n    });\n  }\n\n  if (error) {\n    receiverLogger.logError(\n      error,\n      \"[%s] An error occurred when settling a message with id '%s'\",\n      context.connectionId,\n      message.messageId\n    );\n    throw error;\n  }\n\n  // Message Settlement with managementLink\n  // 1. If the received message is deferred as such messages can only be settled using managementLink\n  // 2. If the associated receiver link is not available. This does not apply to messages from sessions as we need a lock on the session to do so.\n  if (isDeferredMessage || ((!receiver || !receiver.isOpen()) && message.sessionId == undefined)) {\n    return context\n      .getManagementClient(entityPath)\n      .updateDispositionStatus(message.lockToken!, operation, {\n        ...options,\n        associatedLinkName,\n        sessionId: message.sessionId\n      })\n      .catch((err) => {\n        throw translateServiceBusError(err);\n      });\n  }\n\n  return receiver!.settleMessage(message, operation, options).catch((err) => {\n    throw translateServiceBusError(err);\n  });\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  MessageReceiver,\n  OnAmqpEventAsPromise,\n  OnError,\n  OnMessage,\n  ReceiveOptions\n} from \"./messageReceiver\";\nimport { ConnectionContext } from \"../connectionContext\";\n\nimport { ReceiverHelper } from \"./receiverHelper\";\n\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport {\n  RetryOperationType,\n  RetryConfig,\n  retry,\n  MessagingError,\n  RetryOptions,\n  ConditionErrorNameMapper\n} from \"@azure/core-amqp\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { receiverLogger as logger } from \"../log\";\nimport { AmqpError, EventContext, OnAmqpEvent } from \"rhea-promise\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { abandonMessage, completeMessage } from \"../receivers/shared\";\nimport { ReceiverHandlers } from \"./shared\";\n\n/**\n * @internal\n * @hidden\n */\nexport interface StreamingReceiverInitArgs\n  extends ReceiveOptions,\n    Pick<OperationOptionsBase, \"abortSignal\"> {\n  onError: OnError;\n}\n\n/**\n * @internal\n * @hidden\n * Describes the streaming receiver where the user can receive the message\n * by providing handler functions.\n * @class StreamingReceiver\n * @extends MessageReceiver\n */\nexport class StreamingReceiver extends MessageReceiver {\n  /**\n   * @property {number} [maxConcurrentCalls] The maximum number of messages that should be\n   * processed concurrently while in streaming mode. Once this limit has been reached, more\n   * messages will not be received until the user's message handler has completed processing current message.\n   * Default: 1\n   */\n  maxConcurrentCalls: number = 1;\n\n  /**\n   * Indicates whether the receiver is already actively\n   * running `onDetached`.\n   * This is expected to be true while the receiver attempts\n   * to bring its link back up due to a retryable issue.\n   */\n  private _isDetaching: boolean = false;\n  /**\n   *Retry policy options that determine the mode, number of retries, retry interval etc.\n   */\n  private _retryOptions: RetryOptions;\n\n  private _receiverHelper: ReceiverHelper;\n\n  /**\n   * Used so we can stub out retry in tests.\n   */\n  private _retry: typeof retry;\n\n  /**\n   * @property {OnAmqpEventAsPromise} _onAmqpClose The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_close\" event.\n   */\n  private _onAmqpClose: OnAmqpEventAsPromise;\n\n  /**\n   * @property {OnAmqpEventAsPromise} _onSessionClose The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEventAsPromise;\n\n  /**\n   * @property {OnAmqpEvent} _onSessionError The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onAmqpError The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_error\" event.\n   */\n  private _onAmqpError: OnAmqpEvent;\n\n  /**\n   * @property {OnAmqpEventAsPromise} _onAmqpMessage The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"message\" event.\n   */\n  protected _onAmqpMessage: OnAmqpEventAsPromise;\n\n  /**\n   * Whether we are currently registered for receiving messages.\n   */\n  public get isReceivingMessages(): boolean {\n    // for the streaming receiver so long as we can receive messages then we\n    // _are_ receiving messages - there's no in-between state like there is\n    // with BatchingReceiver.\n    return this._receiverHelper.canReceiveMessages();\n  }\n\n  /**\n   * Instantiate a new Streaming receiver for receiving messages with handlers.\n   *\n   * @constructor\n   * @param {ClientEntityContext} context                      The client entity context.\n   * @param {ReceiveOptions} [options]                         Options for how you'd like to connect.\n   */\n  constructor(context: ConnectionContext, entityPath: string, options: ReceiveOptions) {\n    super(context, entityPath, \"streaming\", options);\n\n    if (typeof options?.maxConcurrentCalls === \"number\" && options?.maxConcurrentCalls > 0) {\n      this.maxConcurrentCalls = options.maxConcurrentCalls;\n    }\n\n    this._retryOptions = options?.retryOptions || {};\n    this._retry = retry;\n\n    this._receiverHelper = new ReceiverHelper(() => ({\n      receiver: this.link,\n      logPrefix: this.logPrefix\n    }));\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      const receiver = this.link || context.receiver!;\n\n      logger.logError(\n        receiverError,\n        `${this.logPrefix} 'receiver_close' event occurred. The associated error is`\n      );\n\n      this._lockRenewer?.stopAll(this);\n\n      if (receiver && !receiver.isItselfClosed()) {\n        await this.onDetached(receiverError);\n      } else {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver '%s' with address '%s' \" +\n            \"because the sdk initiated it. Hence not calling detached from the _onAmqpClose\" +\n            \"() handler.\",\n          this.logPrefix,\n          this.name,\n          this.address\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const receiver = this.link || context.receiver!;\n      const sessionError = context.session && context.session.error;\n\n      logger.logError(\n        sessionError,\n        `${this.logPrefix} 'session_close' event occurred. The associated error is`\n      );\n\n      this._lockRenewer?.stopAll(this);\n\n      if (receiver && !receiver.isSessionItselfClosed()) {\n        await this.onDetached(sessionError);\n      } else {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the session of receiver '%s' with address \" +\n            \"'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose\" +\n            \"() handler.\",\n          this.logPrefix,\n          this.name,\n          this.address\n        );\n      }\n    };\n\n    this._onAmqpError = (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        logger.logError(\n          sbError,\n          `${this.logPrefix} 'receiver_error' event occurred. The associated error is`\n        );\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError) as MessagingError;\n        logger.logError(\n          sbError,\n          `${this.logPrefix} 'session_error' event occurred. The associated error is`\n        );\n      }\n    };\n\n    this._onAmqpMessage = async (context: EventContext) => {\n      // If the receiver got closed in PeekLock mode, avoid processing the message as we\n      // cannot settle the message.\n      if (this.receiveMode === \"peekLock\" && (!this.link || !this.link.isOpen())) {\n        logger.verbose(\n          \"%s Not calling the user's message handler for the current message \" +\n            \"as the receiver is closed\",\n          this.logPrefix\n        );\n        return;\n      }\n\n      const bMessage: ServiceBusMessageImpl = new ServiceBusMessageImpl(\n        context.message!,\n        context.delivery!,\n        true,\n        this.receiveMode\n      );\n\n      this._lockRenewer?.start(this, bMessage, (err) => {\n        if (this._onError) {\n          this._onError({\n            error: err,\n            errorSource: \"renewLock\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host\n          });\n        }\n      });\n\n      try {\n        await this._onMessage(bMessage);\n      } catch (err) {\n        logger.logError(\n          err,\n          \"%s An error occurred while running user's message handler for the message \" +\n            \"with id '%s' on the receiver '%s'\",\n          this.logPrefix,\n          bMessage.messageId,\n          this.name\n        );\n        this._onError!({\n          error: err,\n          errorSource: \"processMessageCallback\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host\n        });\n\n        // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,\n        // doing this here. Otherwise, this should be done in finally.\n        this._lockRenewer?.stop(this, bMessage);\n        const error = translateServiceBusError(err) as MessagingError;\n        // Nothing much to do if user's message handler throws. Let us try abandoning the message.\n        if (\n          !bMessage.delivery.remote_settled &&\n          error.code !== ConditionErrorNameMapper[\"com.microsoft:message-lock-lost\"] &&\n          this.receiveMode === \"peekLock\" &&\n          this.isOpen() // only try to abandon the messages if the connection is still open\n        ) {\n          try {\n            logger.logError(\n              error,\n              \"%s Abandoning the message with id '%s' on the receiver '%s' since \" +\n                \"an error occured: %O.\",\n              this.logPrefix,\n              bMessage.messageId,\n              this.name,\n              error\n            );\n            await abandonMessage(bMessage, this._context, entityPath);\n          } catch (abandonError) {\n            const translatedError = translateServiceBusError(abandonError);\n            logger.logError(\n              translatedError,\n              \"%s An error occurred while abandoning the message with id '%s' on the \" +\n                \"receiver '%s'\",\n              this.logPrefix,\n              bMessage.messageId,\n              this.name\n            );\n            this._onError!({\n              error: translatedError,\n              errorSource: \"abandon\",\n              entityPath: this.entityPath,\n              fullyQualifiedNamespace: this._context.config.host\n            });\n          }\n        }\n        return;\n      } finally {\n        this._receiverHelper.addCredit(1);\n      }\n\n      // If we've made it this far, then user's message handler completed fine. Let us try\n      // completing the message.\n      if (\n        this.autoComplete &&\n        this.receiveMode === \"peekLock\" &&\n        !bMessage.delivery.remote_settled\n      ) {\n        try {\n          logger.verbose(\n            \"%s Auto completing the message with id '%s' on \" + \"the receiver.\",\n            this.logPrefix,\n            bMessage.messageId\n          );\n          await completeMessage(bMessage, this._context, entityPath);\n        } catch (completeError) {\n          const translatedError = translateServiceBusError(completeError);\n          logger.logError(\n            translatedError,\n            \"%s An error occurred while completing the message with id '%s' on the \" +\n              \"receiver '%s'\",\n            this.logPrefix,\n            bMessage.messageId,\n            this.name\n          );\n          this._onError!({\n            error: translatedError,\n            errorSource: \"complete\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host\n          });\n        }\n      }\n    };\n  }\n\n  private _getHandlers(): ReceiverHandlers {\n    return {\n      onMessage: (context: EventContext) =>\n        this._onAmqpMessage(context).catch(() => {\n          /* */\n        }),\n      onClose: (context: EventContext) =>\n        this._onAmqpClose(context).catch(() => {\n          /* */\n        }),\n      onSessionClose: (context: EventContext) =>\n        this._onSessionClose(context).catch(() => {\n          /* */\n        }),\n      onError: this._onAmqpError,\n      onSessionError: this._onSessionError\n    };\n  }\n\n  async stopReceivingMessages(): Promise<void> {\n    await this._receiverHelper.suspend();\n  }\n\n  /**\n   * Initializes the link. This method will retry infinitely until a connection is established.\n   *\n   * The retries are broken up into cycles. For each cycle we do a set of retries, using the user's\n   * configured retryOptions. If that retry call fails we will report the error and then go into a\n   * new cycle, repeating the retries the same as before.\n   *\n   * It is completely up to the user to break out of this retry cycle in their error handler by either:\n   * 1. closing the receiver\n   * 2. Calling `close` on the subscription instance they received when they initially called subscribe().\n   * 3. aborting the abortSignal they passed in when calling subscribe (this does not apply in onDetached, however)\n   */\n  async init(\n    args: { useNewName: boolean; connectionId: string; onError: OnError } & Pick<\n      OperationOptionsBase,\n      \"abortSignal\"\n    >\n  ) {\n    let numRetryCycles = 0;\n\n    while (true) {\n      ++numRetryCycles;\n\n      const config: RetryConfig<void> = {\n        operation: () => this._initOnce(args),\n        connectionId: args.connectionId,\n        operationType: RetryOperationType.receiverLink,\n        // even though we're going to loop infinitely we allow them to control the pattern we use on each\n        // retry run. This lets them toggle things like exponential retries, etc..\n        retryOptions: this._retryOptions,\n        abortSignal: args.abortSignal\n      };\n\n      try {\n        await this._retry<void>(config);\n        break;\n      } catch (err) {\n        // we only report the error here - this avoids spamming the user with too many\n        // redundant reports of errors while still providing them incremental status on failures.\n        args.onError({\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n          error: err\n        });\n\n        // if the user aborts the operation we're immediately done.\n        if (err.name === \"AbortError\") {\n          throw err;\n        }\n\n        logger.logError(\n          err,\n          `${this.logPrefix} Error thrown in retry cycle ${numRetryCycles}, restarting retry cycle with retry options`,\n          this._retryOptions\n        );\n\n        continue;\n      }\n    }\n  }\n\n  private async _initOnce(args: {\n    useNewName: boolean;\n    abortSignal?: AbortSignalLike;\n  }): Promise<void> {\n    const options = this._createReceiverOptions(args.useNewName, this._getHandlers());\n    await this._init(options, args.abortSignal);\n\n    // this might seem odd but in reality this entire class is like one big function call that\n    // results in a receive(). Once we're being initialized we should consider ourselves the\n    // \"owner\" of the receiver and that it's now being locked into being the actual receiver.\n    this._receiverHelper.resume();\n  }\n\n  /**\n   * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.\n   *\n   * @param {OnMessage} onMessage The message handler to receive servicebus messages.\n   * @param {OnError} onError The error handler to receive an error that occurs while receivin messages.\n   */\n  subscribe(onMessage: OnMessage, onError: OnError): void {\n    throwErrorIfConnectionClosed(this._context);\n\n    this._onMessage = onMessage;\n    this._onError = onError;\n\n    this._receiverHelper.addCredit(this.maxConcurrentCalls);\n  }\n\n  /**\n   * Will reconnect the receiver link if necessary.\n   * @param receiverError The receiver error or connection error, if any.\n   * @returns {Promise<void>} Promise<void>.\n   */\n  async onDetached(receiverError?: AmqpError | Error): Promise<void> {\n    logger.verbose(`${this.logPrefix} onDetached: reinitializing link.`);\n\n    // User explicitly called `close` on the receiver, so link is already closed\n    // and we can exit early.\n    if (this.wasClosedPermanently) {\n      logger.verbose(\n        `${this.logPrefix} onDetached: link has been closed permanently, not reinitializing. `\n      );\n      return;\n    }\n\n    // Prevent multiple onDetached invocations from running concurrently.\n    if (this._isDetaching) {\n      // This can happen when the network connection goes down for some amount of time.\n      // The first connection `disconnect` will trigger `onDetached` and attempt to retry\n      // creating the connection/receiver link.\n      // While those retry attempts fail (until the network connection comes back up),\n      // we'll continue to see connection `disconnect` errors.\n      // These should be ignored until the already running `onDetached` completes\n      // its retry attempts or errors.\n      logger.verbose(\n        `${this.logPrefix} onDetached: Call to detached on streaming receiver '${this.name}' is already in progress.`\n      );\n      return;\n    }\n\n    this._isDetaching = true;\n\n    const translatedError = receiverError ? translateServiceBusError(receiverError) : receiverError;\n    logger.logError(\n      translatedError,\n      `${this.logPrefix} onDetached: Reinitializing receiver because of error`\n    );\n\n    try {\n      // Clears the token renewal timer. Closes the link and its session if they are open.\n      // Removes the link and its session if they are present in rhea's cache.\n      await this.closeLink();\n    } catch (err) {\n      logger.verbose(\n        `${this.logPrefix} onDetached: Encountered an error when closing the previous link: `,\n        err\n      );\n    }\n\n    try {\n      await this.init({\n        // provide a new name to the link while re-connecting it. This ensures that\n        // the service does not send an error stating that the link is still open.\n        useNewName: true,\n        connectionId: this._context.connectionId,\n        onError: (args) => this._onError && this._onError(args)\n      });\n\n      this._receiverHelper.addCredit(this.maxConcurrentCalls);\n      logger.verbose(\n        `${this.logPrefix} onDetached: link has been reestablished, added ${this.maxConcurrentCalls} credits.`\n      );\n    } finally {\n      this._isDetaching = false;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  extractSpanContextFromTraceParentHeader,\n  getTraceParentHeader,\n  getTracer\n} from \"@azure/core-tracing\";\nimport { CanonicalCode, Link, Span, SpanContext, SpanKind } from \"@opentelemetry/api\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { getParentSpan, OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { ServiceBusReceiver } from \"../receivers/receiver\";\nimport { ServiceBusMessage, ServiceBusReceivedMessage } from \"../serviceBusMessage\";\n\n/**\n * @hidden\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * Populates the `ServiceBusMessage` with `SpanContext` info to support trace propagation.\n * Creates and returns a copy of the passed in `ServiceBusMessage` unless the `ServiceBusMessage`\n * has already been instrumented.\n * @param message The `ServiceBusMessage` to instrument.\n * @param span The `Span` containing the context to propagate tracing information.\n * @hidden\n * @internal\n */\nexport function instrumentServiceBusMessage(\n  message: ServiceBusMessage,\n  span: Span\n): ServiceBusMessage {\n  if (message.applicationProperties && message.applicationProperties[TRACEPARENT_PROPERTY]) {\n    return message;\n  }\n\n  // create a copy so the original isn't modified\n  message = { ...message, applicationProperties: { ...message.applicationProperties } };\n\n  const traceParent = getTraceParentHeader(span.context());\n  if (traceParent) {\n    message.applicationProperties![TRACEPARENT_PROPERTY] = traceParent;\n  }\n\n  return message;\n}\n\n/**\n * Extracts the `SpanContext` from an `ServiceBusMessage` if the context exists.\n * @param message An individual `ServiceBusMessage` object.\n * @internal\n * @hidden\n */\nexport function extractSpanContextFromServiceBusMessage(\n  message: ServiceBusMessage\n): SpanContext | undefined {\n  if (!message.applicationProperties || !message.applicationProperties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = message.applicationProperties[TRACEPARENT_PROPERTY] as string;\n  return extractSpanContextFromTraceParentHeader(diagnosticId);\n}\n\n/**\n * Provides an iterable over messages, whether it is a single message or multiple\n * messages.\n *\n * @param receivedMessages A single message or a set of messages\n * @internal\n * @hidden\n */\nfunction* getReceivedMessages(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[]\n): Iterable<ServiceBusReceivedMessage> {\n  if (!Array.isArray(receivedMessages)) {\n    yield receivedMessages;\n  } else {\n    for (const message of receivedMessages) {\n      yield message;\n    }\n  }\n}\n\n/**\n * A span that encompasses the period when the message has been received and\n * is being processed.\n *\n * NOTE: The amount of time the user would be considered processing the message is\n * not always clear - in that case the span will have a very short lifetime\n * since we'll start the span when we receive the message and end it when we\n * give the message to the user.\n *\n * @internal\n * @hidden\n */\nexport function createProcessingSpan(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[],\n  // NOTE: the connectionConfig also has an entityPath property but that only\n  // represents the optional entityPath in their connection string which is NOT\n  // what we want for tracing.\n  receiver: Pick<ServiceBusReceiver, \"entityPath\">,\n  connectionConfig: Pick<ConnectionContext[\"config\"], \"host\">,\n  options?: OperationOptionsBase\n): Span {\n  const links: Link[] = [];\n\n  for (const receivedMessage of getReceivedMessages(receivedMessages)) {\n    const spanContext = extractSpanContextFromServiceBusMessage(receivedMessage);\n\n    if (spanContext == null) {\n      continue;\n    }\n\n    links.push({\n      context: spanContext,\n      attributes: {\n        enqueuedTime: receivedMessage.enqueuedTimeUtc?.getTime()\n      }\n    });\n  }\n\n  const span = getTracer().startSpan(\"Azure.ServiceBus.process\", {\n    kind: SpanKind.CONSUMER,\n    links,\n    parent: getParentSpan(options?.tracingOptions)\n  });\n\n  span.setAttributes({\n    \"az.namespace\": \"Microsoft.ServiceBus\",\n    \"message_bus.destination\": receiver.entityPath,\n    \"peer.address\": connectionConfig.host\n  });\n\n  return span;\n}\n\n/**\n * Creates and immediately ends a processing span. Used when\n * the 'processing' occurs outside of our control so we don't\n * know the scope.\n *\n * @internal\n * @hidden\n */\nexport function createAndEndProcessingSpan(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[],\n  receiver: Pick<ServiceBusReceiver, \"entityPath\">,\n  connectionConfig: Pick<ConnectionContext[\"config\"], \"host\">,\n  options?: OperationOptionsBase\n): void {\n  const span = createProcessingSpan(receivedMessages, receiver, connectionConfig, options);\n  span.setStatus({ code: CanonicalCode.OK });\n  span.end();\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { receiverLogger as logger } from \"../log\";\nimport {\n  AmqpError,\n  EventContext,\n  OnAmqpEvent,\n  ReceiverEvents,\n  SessionEvents,\n  Receiver,\n  Session\n} from \"rhea-promise\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { MessageReceiver, OnAmqpEventAsPromise, ReceiveOptions } from \"./messageReceiver\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { checkAndRegisterWithAbortSignal } from \"../util/utils\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { createAndEndProcessingSpan } from \"../diagnostics/instrumentServiceBusMessage\";\nimport { ReceiveMode } from \"../models\";\nimport { ServiceBusError, translateServiceBusError } from \"../serviceBusError\";\n\n/**\n * Describes the batching receiver where the user can receive a specified number of messages for\n * a predefined time.\n * @internal\n * @hidden\n * @class BatchingReceiver\n * @extends MessageReceiver\n */\nexport class BatchingReceiver extends MessageReceiver {\n  /**\n   * Instantiate a new BatchingReceiver.\n   *\n   * @constructor\n   * @param {ClientEntityContext} context The client entity context.\n   * @param {ReceiveOptions} [options]  Options for how you'd like to connect.\n   */\n  constructor(context: ConnectionContext, entityPath: string, options: ReceiveOptions) {\n    super(context, entityPath, \"batching\", options);\n\n    this._batchingReceiverLite = new BatchingReceiverLite(\n      context,\n      entityPath,\n      async (abortSignal?: AbortSignalLike): Promise<MinimalReceiver | undefined> => {\n        let lastError: Error | AmqpError | undefined;\n\n        const rcvrOptions = this._createReceiverOptions(false, {\n          onError: (context) => {\n            lastError = context?.receiver?.error;\n          },\n          onSessionError: (context) => {\n            lastError = context?.session?.error;\n          },\n          // ignored for now - the next call will just fail so they'll get an appropriate error from somewhere else.\n          onClose: async () => {},\n          onSessionClose: async () => {},\n          // we don't add credits initially so we don't need to worry about handling any messages.\n          onMessage: async () => {}\n        });\n\n        await this._init(rcvrOptions, abortSignal);\n\n        if (lastError != null) {\n          throw lastError;\n        }\n\n        return this.link;\n      },\n      this.receiveMode\n    );\n  }\n\n  private _batchingReceiverLite: BatchingReceiverLite;\n\n  get isReceivingMessages(): boolean {\n    return this._batchingReceiverLite.isReceivingMessages;\n  }\n\n  /**\n   * To be called when connection is disconnected to gracefully close ongoing receive request.\n   * @param {AmqpError | Error} [connectionError] The connection error if any.\n   * @returns {Promise<void>} Promise<void>.\n   */\n  async onDetached(connectionError?: AmqpError | Error): Promise<void> {\n    await this.closeLink();\n\n    if (connectionError == null) {\n      connectionError = new Error(\n        \"Unknown error occurred on the AMQP connection while receiving messages.\"\n      );\n    }\n\n    this._batchingReceiverLite.close(connectionError);\n  }\n\n  /**\n   * Receives a batch of messages from a ServiceBus Queue/Topic.\n   * @param maxMessageCount The maximum number of messages to receive.\n   * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.\n   * @param maxWaitTimeInMs The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.\n   * @param maxTimeAfterFirstMessageInMs The total amount of time to wait after the first message\n   * has been received. Defaults to 1 second.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * @returns {Promise<ServiceBusMessageImpl[]>} A promise that resolves with an array of Message objects.\n   */\n  async receive(\n    maxMessageCount: number,\n    maxWaitTimeInMs: number,\n    maxTimeAfterFirstMessageInMs: number,\n    options: OperationOptionsBase\n  ): Promise<ServiceBusMessageImpl[]> {\n    throwErrorIfConnectionClosed(this._context);\n\n    try {\n      logger.verbose(\n        \"[%s] Receiver '%s', setting max concurrent calls to 0.\",\n        this.logPrefix,\n        this.name\n      );\n\n      const messages = await this._batchingReceiverLite.receiveMessages({\n        maxMessageCount,\n        maxWaitTimeInMs,\n        maxTimeAfterFirstMessageInMs,\n        ...options\n      });\n\n      if (this._lockRenewer) {\n        for (const message of messages) {\n          this._lockRenewer.start(this, message, (_error) => {\n            // the auto lock renewer already logs this in a detailed way. So this hook is mainly here\n            // to potentially forward the error to the user (which we're not doing yet)\n          });\n        }\n      }\n\n      return messages;\n    } catch (error) {\n      logger.logError(error, \"[%s] Rejecting receiveMessages()\", this.logPrefix);\n      throw error;\n    }\n  }\n\n  static create(\n    context: ConnectionContext,\n    entityPath: string,\n    options: ReceiveOptions\n  ): BatchingReceiver {\n    throwErrorIfConnectionClosed(context);\n    const bReceiver = new BatchingReceiver(context, entityPath, options);\n    context.messageReceivers[bReceiver.name] = bReceiver;\n    return bReceiver;\n  }\n}\n\n/**\n * Gets a function that returns the smaller of the two timeouts,\n * taking into account elapsed time from when getRemainingWaitTimeInMsFn\n * was called.\n *\n * @param maxWaitTimeInMs Maximum time to wait for the first message\n * @param maxTimeAfterFirstMessageInMs Maximum time to wait after the first message before completing the receive.\n *\n * @internal\n * @hidden\n */\nexport function getRemainingWaitTimeInMsFn(\n  maxWaitTimeInMs: number,\n  maxTimeAfterFirstMessageInMs: number\n): () => number {\n  const startTimeMs = Date.now();\n\n  return () => {\n    const remainingTimeMs = maxWaitTimeInMs - (Date.now() - startTimeMs);\n\n    if (remainingTimeMs < 0) {\n      return 0;\n    }\n\n    return Math.min(remainingTimeMs, maxTimeAfterFirstMessageInMs);\n  };\n}\n\n/**\n * Useful interface that mimics EventEmitter without requiring us to actually\n * import the events definition (which is annoying with browsers).\n *\n * @internal\n * @hidden\n */\ntype EventEmitterLike<T extends Receiver | Session> = Pick<T, \"once\" | \"removeListener\" | \"on\">;\n\n/**\n * The bare minimum needed to receive messages for batched\n * message receiving.\n *\n * @internal\n * @hidden\n */\nexport type MinimalReceiver = Pick<Receiver, \"name\" | \"isOpen\" | \"credit\" | \"addCredit\" | \"drain\"> &\n  EventEmitterLike<Receiver> & {\n    session: EventEmitterLike<Session>;\n  } & {\n    connection: {\n      id: string;\n    };\n  };\n\n/**\n * @internal\n * @hidden\n */\ntype MessageAndDelivery = Pick<EventContext, \"message\" | \"delivery\">;\n\n/**\n * @internal\n * @hidden\n */\ninterface ReceiveMessageArgs extends OperationOptionsBase {\n  maxMessageCount: number;\n  maxWaitTimeInMs: number;\n  maxTimeAfterFirstMessageInMs: number;\n}\n\n/**\n * The internals of a batching receiver minus anything that would require us to hold onto a client entity context\n * or a receiver on a permanent basis.\n *\n * Usable with both session and non-session receivers.\n *\n * @internal\n * @hidden\n */\nexport class BatchingReceiverLite {\n  /**\n   * NOTE: exists only to make unit testing possible.\n   */\n  private _createAndEndProcessingSpan: typeof createAndEndProcessingSpan;\n\n  constructor(\n    private _connectionContext: ConnectionContext,\n    public entityPath: string,\n    private _getCurrentReceiver: (\n      abortSignal?: AbortSignalLike\n    ) => Promise<MinimalReceiver | undefined>,\n    private _receiveMode: ReceiveMode\n  ) {\n    this._createAndEndProcessingSpan = createAndEndProcessingSpan;\n\n    this._createServiceBusMessage = (context: MessageAndDelivery) => {\n      return new ServiceBusMessageImpl(\n        context.message!,\n        context.delivery!,\n        true,\n        this._receiveMode\n      );\n    };\n\n    this._getRemainingWaitTimeInMsFn = (\n      maxWaitTimeInMs: number,\n      maxTimeAfterFirstMessageInMs: number\n    ) => getRemainingWaitTimeInMsFn(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs);\n\n    this.isReceivingMessages = false;\n  }\n\n  private _createServiceBusMessage: (\n    context: Pick<EventContext, \"message\" | \"delivery\">\n  ) => ServiceBusMessageImpl;\n\n  private _getRemainingWaitTimeInMsFn: typeof getRemainingWaitTimeInMsFn;\n  private _closeHandler: ((connectionError?: AmqpError | Error) => void) | undefined;\n\n  isReceivingMessages: boolean;\n\n  /**\n   * Receives a set of messages,\n   *\n   * @internal\n   * @hidden\n   */\n  public async receiveMessages(args: ReceiveMessageArgs): Promise<ServiceBusMessageImpl[]> {\n    try {\n      this.isReceivingMessages = true;\n      const receiver = await this._getCurrentReceiver(args.abortSignal);\n\n      if (receiver == null) {\n        // (was somehow closed in between the init() and the return)\n        return [];\n      }\n\n      const messages = await new Promise<ServiceBusMessageImpl[]>((resolve, reject) =>\n        this._receiveMessagesImpl(receiver, args, resolve, reject)\n      );\n      this._createAndEndProcessingSpan(messages, this, this._connectionContext.config, args);\n      return messages;\n    } finally {\n      this._closeHandler = undefined;\n      this.isReceivingMessages = false;\n    }\n  }\n\n  /**\n   * Closes the receiver (optionally with an error), cancelling any current operations.\n   *\n   * @param connectionError An optional error (rhea doesn't always deliver one for certain disconnection events)\n   */\n  close(connectionError?: Error | AmqpError) {\n    if (this._closeHandler) {\n      this._closeHandler(connectionError);\n      this._closeHandler = undefined;\n    }\n  }\n\n  private _receiveMessagesImpl(\n    receiver: MinimalReceiver,\n    args: ReceiveMessageArgs,\n    origResolve: (messages: ServiceBusMessageImpl[]) => void,\n    origReject: (err: Error | AmqpError) => void\n  ): void {\n    const getRemainingWaitTimeInMs = this._getRemainingWaitTimeInMsFn(\n      args.maxWaitTimeInMs,\n      args.maxTimeAfterFirstMessageInMs\n    );\n\n    const brokeredMessages: ServiceBusMessageImpl[] = [];\n    const loggingPrefix = `[${receiver.connection.id}|r:${receiver.name}]`;\n\n    let totalWaitTimer: NodeJS.Timer | undefined;\n\n    // eslint-disable-next-line prefer-const\n    let cleanupBeforeResolveOrReject: () => void;\n\n    const reject = (err: Error | AmqpError) => {\n      cleanupBeforeResolveOrReject();\n      origReject(err);\n    };\n\n    const resolveImmediately = (result: ServiceBusMessageImpl[]) => {\n      cleanupBeforeResolveOrReject();\n      origResolve(result);\n    };\n\n    const resolveAfterPendingMessageCallbacks = (result: ServiceBusMessageImpl[]) => {\n      // NOTE: through rhea-promise, most of our event handlers are made asynchronous by calling setTimeout(emit).\n      // However, a small set (*error and drain) execute immediately. This can lead to a situation where the logical\n      // ordering of events is correct but the execution order is incorrect because the events are not all getting\n      // put into the task queue the same way.\n      // setTimeout() ensures that we resolve _after_ any already-queued onMessage handlers that may\n      // be waiting in the task queue.\n      setTimeout(() => {\n        cleanupBeforeResolveOrReject();\n        origResolve(result);\n      });\n    };\n\n    const onError: OnAmqpEvent = (context: EventContext) => {\n      const eventType = context.session?.error != null ? \"session_error\" : \"receiver_error\";\n      let error = context.session?.error || context.receiver?.error;\n\n      if (error) {\n        error = translateServiceBusError(error);\n        logger.logError(error, `${loggingPrefix} '${eventType}' event occurred. Received an error`);\n      } else {\n        error = new ServiceBusError(\"An error occurred while receiving messages.\", \"GeneralError\");\n      }\n      reject(error);\n    };\n\n    this._closeHandler = (error?: AmqpError | Error): void => {\n      if (\n        // no error, just closing. Go ahead and return what we have.\n        error == null ||\n        // Return the collected messages if in ReceiveAndDelete mode because otherwise they are lost forever\n        (this._receiveMode === \"receiveAndDelete\" && brokeredMessages.length)\n      ) {\n        logger.verbose(\n          `${loggingPrefix} Closing. Resolving with ${brokeredMessages.length} messages.`\n        );\n\n        return resolveAfterPendingMessageCallbacks(brokeredMessages);\n      }\n\n      reject(translateServiceBusError(error));\n    };\n\n    let abortSignalCleanupFunction: (() => void) | undefined = undefined;\n\n    // Final action to be performed after\n    // - maxMessageCount is reached or\n    // - maxWaitTime is passed or\n    // - newMessageWaitTimeoutInSeconds is passed since the last message was received\n    const finalAction = (): void => {\n      // Drain any pending credits.\n      if (receiver.isOpen() && receiver.credit > 0) {\n        logger.verbose(`${loggingPrefix} Draining leftover credits(${receiver.credit}).`);\n\n        // setting .drain and combining it with .addCredit results in (eventually) sending\n        // a drain request to Service Bus. When the drain completes rhea will call `onReceiveDrain`\n        // at which point we'll wrap everything up and resolve the promise.\n        receiver.drain = true;\n        receiver.addCredit(1);\n      } else {\n        logger.verbose(\n          `${loggingPrefix} Resolving receiveMessages() with ${brokeredMessages.length} messages.`\n        );\n\n        // we can resolve immediately (ie, no setTimeout call) because we have no\n        // remaining messages (thus nothing to wait for)\n        resolveImmediately(brokeredMessages);\n      }\n    };\n\n    // Action to be performed on the \"message\" event.\n    const onReceiveMessage: OnAmqpEventAsPromise = async (context: EventContext) => {\n      // TODO: this appears to be aggravating a bug that we need to look into more deeply.\n      // The same timeout+drain sequence should work fine for receiveAndDelete but it appears\n      // to cause problems.\n      if (this._receiveMode === \"peekLock\") {\n        if (brokeredMessages.length === 0) {\n          // We'll now remove the old timer (which was the overall `maxWaitTimeMs` timer)\n          // and replace it with another timer that is a (probably) much shorter interval.\n          //\n          // This allows the user to get access to received messages earlier and also gives us\n          // a chance to have fewer messages internally that could get lost if the user's\n          // app crashes.\n          if (totalWaitTimer) clearTimeout(totalWaitTimer);\n          const remainingWaitTimeInMs = getRemainingWaitTimeInMs();\n          totalWaitTimer = setTimeout(() => {\n            logger.verbose(\n              `${loggingPrefix} Batching, waited for ${remainingWaitTimeInMs} milliseconds after receiving the first message.`\n            );\n            finalAction();\n          }, remainingWaitTimeInMs);\n        }\n      }\n\n      try {\n        const data: ServiceBusMessageImpl = this._createServiceBusMessage(context);\n        if (brokeredMessages.length < args.maxMessageCount) {\n          brokeredMessages.push(data);\n        }\n      } catch (err) {\n        const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));\n        logger.logError(\n          err,\n          `${loggingPrefix} Received an error while converting AmqpMessage to ServiceBusMessage`\n        );\n        reject(errObj);\n      }\n      if (brokeredMessages.length === args.maxMessageCount) {\n        finalAction();\n      }\n    };\n\n    const onClose: OnAmqpEventAsPromise = async (context: EventContext) => {\n      const type = context.session?.error != null ? \"session_closed\" : \"receiver_closed\";\n      const error = context.session?.error || context.receiver?.error;\n\n      if (error) {\n        logger.logError(error, `${loggingPrefix} '${type}' event occurred. The associated error`);\n      }\n    };\n\n    // Action to be performed on the \"receiver_drained\" event.\n    const onReceiveDrain: OnAmqpEvent = () => {\n      receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n      receiver.drain = false;\n\n      logger.verbose(\n        `${loggingPrefix} Drained, resolving receiveMessages() with ${brokeredMessages.length} messages.`\n      );\n\n      resolveAfterPendingMessageCallbacks(brokeredMessages);\n    };\n\n    cleanupBeforeResolveOrReject = (): void => {\n      if (receiver != null) {\n        receiver.removeListener(ReceiverEvents.receiverError, onError);\n        receiver.removeListener(ReceiverEvents.message, onReceiveMessage);\n        receiver.session.removeListener(SessionEvents.sessionError, onError);\n        receiver.removeListener(ReceiverEvents.receiverClose, onClose);\n        receiver.session.removeListener(SessionEvents.sessionClose, onClose);\n        receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n      }\n\n      if (totalWaitTimer) {\n        clearTimeout(totalWaitTimer);\n      }\n\n      if (abortSignalCleanupFunction) {\n        abortSignalCleanupFunction();\n      }\n      abortSignalCleanupFunction = undefined;\n    };\n\n    abortSignalCleanupFunction = checkAndRegisterWithAbortSignal((err) => {\n      reject(err);\n    }, args.abortSignal);\n\n    logger.verbose(\n      `${loggingPrefix} Adding credit for receiving ${args.maxMessageCount} messages.`\n    );\n\n    // By adding credit here, we let the service know that at max we can handle `maxMessageCount`\n    // number of messages concurrently. We will return the user an array of messages that can\n    // be of size upto maxMessageCount. Then the user needs to accordingly dispose\n    // (complete/abandon/defer/deadletter) the messages from the array.\n    receiver.addCredit(args.maxMessageCount);\n\n    logger.verbose(\n      `${loggingPrefix} Setting the wait timer for ${args.maxWaitTimeInMs} milliseconds.`\n    );\n\n    totalWaitTimer = setTimeout(() => {\n      logger.verbose(\n        `${loggingPrefix} Batching, waited for max wait time ${args.maxWaitTimeInMs} milliseconds.`\n      );\n      finalAction();\n    }, args.maxWaitTimeInMs);\n\n    receiver.on(ReceiverEvents.message, onReceiveMessage);\n    receiver.on(ReceiverEvents.receiverError, onError);\n    receiver.on(ReceiverEvents.receiverClose, onClose);\n    receiver.on(ReceiverEvents.receiverDrained, onReceiveDrain);\n\n    receiver.session.on(SessionEvents.sessionError, onError);\n    receiver.session.on(SessionEvents.sessionClose, onClose);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionContext } from \"../connectionContext\";\nimport { receiverLogger as logger } from \"../log\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { calculateRenewAfterDuration } from \"../util/utils\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { OnErrorNoContext } from \"./messageReceiver\";\n\n/**\n * @internal\n * @hidden\n */\nexport type RenewableMessageProperties = Readonly<\n  Pick<ServiceBusMessageImpl, \"lockToken\" | \"messageId\">\n> &\n  // updated when we renew the lock\n  Pick<ServiceBusMessageImpl, \"lockedUntilUtc\">;\n\n/**\n * @internal\n * @hidden\n */\ntype MinimalLink = Pick<LinkEntity<any>, \"name\" | \"logPrefix\" | \"entityPath\">;\n\n/**\n * Tracks locks for messages, renewing until a configurable duration.\n *\n * @internal\n * @hidden\n */\nexport class LockRenewer {\n  /**\n   * @property _messageRenewLockTimers A map of link names to individual maps for each\n   * link that map a message ID to its auto-renewal timer.\n   */\n  private _messageRenewLockTimers: Map<string, Map<string, NodeJS.Timer | undefined>> = new Map<\n    string,\n    Map<string, NodeJS.Timer | undefined>\n  >();\n\n  // just here for make unit testing a bit easier.\n  private _calculateRenewAfterDuration: typeof calculateRenewAfterDuration;\n\n  constructor(\n    private _context: Pick<ConnectionContext, \"getManagementClient\">,\n    private _maxAutoRenewDurationInMs: number\n  ) {\n    this._calculateRenewAfterDuration = calculateRenewAfterDuration;\n  }\n\n  /**\n   * Creates an AutoLockRenewer.\n   *\n   * @param linkEntity Your link entity instance (probably 'this')\n   * @param context The connection context for your link entity (probably 'this._context')\n   * @param options The ReceiveOptions passed through to your message receiver.\n   * @returns if the lock mode is peek lock (or if is unspecified, thus defaulting to peekLock)\n   * and the options.maxAutoLockRenewalDurationInMs is > 0..Otherwise, returns undefined.\n   */\n  static create(\n    context: Pick<ConnectionContext, \"getManagementClient\">,\n    maxAutoRenewLockDurationInMs: number,\n    receiveMode: \"peekLock\" | \"receiveAndDelete\"\n  ) {\n    if (receiveMode !== \"peekLock\") {\n      return undefined;\n    }\n\n    if (maxAutoRenewLockDurationInMs <= 0) {\n      return undefined;\n    }\n\n    return new LockRenewer(context, maxAutoRenewLockDurationInMs);\n  }\n\n  /**\n   * Cancels all pending lock renewals for messages on given link and removes all entries from our internal cache.\n   */\n  stopAll(linkEntity: MinimalLink) {\n    logger.verbose(\n      `${linkEntity.logPrefix} Clearing message renew lock timers for all the active messages.`\n    );\n\n    const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);\n\n    if (messagesForLink == null) {\n      return;\n    }\n\n    for (const messageId of messagesForLink.keys()) {\n      this._stopAndRemoveById(linkEntity, messagesForLink, messageId);\n    }\n\n    this._messageRenewLockTimers.delete(linkEntity.name);\n  }\n\n  /**\n   * Stops lock renewal for a single message.\n   *\n   * @param bMessage The message whose lock renewal we will stop.\n   */\n  stop(linkEntity: MinimalLink, bMessage: RenewableMessageProperties) {\n    const messageId = bMessage.messageId as string;\n\n    const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);\n\n    if (messagesForLink == null) {\n      return;\n    }\n\n    this._stopAndRemoveById(linkEntity, messagesForLink, messageId);\n  }\n\n  /**\n   * Starts lock renewal for a single message.\n   *\n   * @param bMessage The message whose lock renewal we will start.\n   */\n  start(linkEntity: MinimalLink, bMessage: RenewableMessageProperties, onError: OnErrorNoContext) {\n    try {\n      const logPrefix = linkEntity.logPrefix;\n\n      if (bMessage.lockToken == null) {\n        throw new Error(\n          `Can't start auto lock renewal for message with message id '${bMessage.messageId}' since it does not have a lock token.`\n        );\n      }\n\n      const lockToken = bMessage.lockToken;\n      const linkMessageMap = this._getOrCreateMapForLink(linkEntity);\n      // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.\n      // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInMs\n      // - We should be able to clear the renewal timer when the user's message handler\n      // is done (whether it succeeds or fails).\n      // Setting the messageId with undefined value in the linkMessageMap because we\n      // track state by checking the presence of messageId in the map. It is removed from the map\n      // when an attempt is made to settle the message (either by the user or by the sdk) OR\n      // when the execution of user's message handler completes.\n      linkMessageMap.set(bMessage.messageId as string, undefined);\n\n      logger.verbose(\n        `${logPrefix} message with id '${\n          bMessage.messageId\n        }' is locked until ${bMessage.lockedUntilUtc!.toString()}.`\n      );\n      const totalAutoLockRenewDuration = Date.now() + this._maxAutoRenewDurationInMs;\n      logger.verbose(\n        `${logPrefix} Total autolockrenew duration for message with id '${\n          bMessage.messageId\n        }' is: ${new Date(totalAutoLockRenewDuration).toString()}`\n      );\n\n      const autoRenewLockTask = (): void => {\n        const renewalNeededToMaintainLock =\n          // if the lock expires _after_ our max auto-renew duration there's no reason to\n          // spin up an auto-renewer - it's already held for the duration.\n          new Date(totalAutoLockRenewDuration) > bMessage.lockedUntilUtc!;\n\n        // once we've exceeded the max amount of time we'll renew we can stop.\n        const haventExceededMaxLockRenewalTime = Date.now() < totalAutoLockRenewDuration;\n\n        if (renewalNeededToMaintainLock && haventExceededMaxLockRenewalTime) {\n          if (linkMessageMap.has(bMessage.messageId as string)) {\n            // TODO: We can run into problems with clock skew between the client and the server.\n            // It would be better to calculate the duration based on the \"lockDuration\" property\n            // of the queue. However, we do not have the management plane of the client ready for\n            // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.\n            const amount = this._calculateRenewAfterDuration(bMessage.lockedUntilUtc!);\n\n            logger.verbose(\n              `${logPrefix} Sleeping for ${amount} milliseconds while renewing the lock for message with id '${bMessage.messageId}'`\n            );\n            // Setting the value of the messageId to the actual timer. This will be cleared when\n            // an attempt is made to settle the message (either by the user or by the sdk) OR\n            // when the execution of user's message handler completes.\n            const autoRenewTimer = setTimeout(async () => {\n              try {\n                logger.verbose(\n                  `${logPrefix} Attempting to renew the lock for message with id '${bMessage.messageId}'.`\n                );\n\n                bMessage.lockedUntilUtc = await this._context\n                  .getManagementClient(linkEntity.entityPath)\n                  .renewLock(lockToken, {\n                    associatedLinkName: linkEntity.name\n                  });\n                logger.verbose(\n                  `${logPrefix} Successfully renewed the lock for message with id '${bMessage.messageId}'. Starting next auto-lock-renew cycle for message.`\n                );\n\n                autoRenewLockTask();\n              } catch (err) {\n                logger.logError(\n                  err,\n                  `${logPrefix} An error occurred while auto renewing the message lock '${bMessage.lockToken}' for message with id '${bMessage.messageId}'`\n                );\n                onError(err);\n              }\n            }, amount);\n\n            // Prevent the active Timer from keeping the Node.js event loop active.\n            if (typeof autoRenewTimer.unref === \"function\") {\n              autoRenewTimer.unref();\n            }\n\n            linkMessageMap.set(bMessage.messageId as string, autoRenewTimer);\n          } else {\n            logger.verbose(\n              `${logPrefix} Looks like the message lock renew timer has already been cleared for message with id '${bMessage.messageId}'.`\n            );\n          }\n        } else {\n          logger.verbose(\n            `${logPrefix} Current time ${new Date()} exceeds the total autolockrenew duration ${new Date(\n              totalAutoLockRenewDuration\n            )} for message with messageId '${\n              bMessage.messageId\n            }'. Hence we will stop the autoLockRenewTask.`\n          );\n\n          this.stop(linkEntity, bMessage);\n        }\n      };\n\n      // start\n      autoRenewLockTask();\n    } catch (err) {\n      onError(err);\n    }\n  }\n\n  private _getOrCreateMapForLink(linkEntity: MinimalLink): Map<string, NodeJS.Timer | undefined> {\n    if (!this._messageRenewLockTimers.has(linkEntity.name)) {\n      this._messageRenewLockTimers.set(\n        linkEntity.name,\n        new Map<string, NodeJS.Timer | undefined>()\n      );\n    }\n\n    return this._messageRenewLockTimers.get(linkEntity.name)!;\n  }\n\n  private _stopAndRemoveById(\n    linkEntity: MinimalLink,\n    linkMessageMap: Map<string, NodeJS.Timer | undefined>,\n    messageId: string | undefined\n  ): void {\n    if (messageId == null) {\n      throw new Error(\"Failed to stop auto lock renewal - no message ID\");\n    }\n\n    // TODO: messageId doesn't actually need to be unique. Perhaps we should use lockToken\n    // instead?\n    if (linkMessageMap.has(messageId)) {\n      clearTimeout(linkMessageMap.get(messageId) as NodeJS.Timer);\n      logger.verbose(\n        `${linkEntity.logPrefix} Cleared the message renew lock timer for message with id '${messageId}'.`\n      );\n      linkMessageMap.delete(messageId);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  PeekMessagesOptions,\n  GetMessageIteratorOptions,\n  MessageHandlers,\n  ReceiveMessagesOptions,\n  SubscribeOptions,\n  InternalMessageHandlers\n} from \"../models\";\nimport { OperationOptionsBase, trace } from \"../modelsToBeSharedWithEventHubs\";\nimport { ServiceBusReceivedMessage } from \"../serviceBusMessage\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport {\n  getAlreadyReceivingErrorMsg,\n  getReceiverClosedErrorMsg,\n  InvalidMaxMessageCountError,\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n  throwErrorIfInvalidOperationOnMessage,\n  throwTypeErrorIfParameterTypeMismatch\n} from \"../util/errors\";\nimport { OnError, OnMessage, ReceiveOptions } from \"../core/messageReceiver\";\nimport { StreamingReceiverInitArgs, StreamingReceiver } from \"../core/streamingReceiver\";\nimport { BatchingReceiver } from \"../core/batchingReceiver\";\nimport {\n  abandonMessage,\n  assertValidMessageHandlers,\n  completeMessage,\n  deadLetterMessage,\n  deferMessage,\n  getMessageIterator,\n  wrapProcessErrorHandler\n} from \"./shared\";\nimport Long from \"long\";\nimport { ServiceBusMessageImpl, DeadLetterOptions } from \"../serviceBusMessage\";\nimport { Constants, RetryConfig, RetryOperationType, RetryOptions, retry } from \"@azure/core-amqp\";\nimport \"@azure/core-asynciterator-polyfill\";\nimport { LockRenewer } from \"../core/autoLockRenewer\";\nimport { createProcessingSpan } from \"../diagnostics/instrumentServiceBusMessage\";\nimport { receiverLogger as logger } from \"../log\";\nimport { translateServiceBusError } from \"../serviceBusError\";\n\n/**\n * A receiver that does not handle sessions.\n */\nexport interface ServiceBusReceiver {\n  /**\n   * Streams messages to message handlers.\n   * @param handlers A handler that gets called for messages and errors.\n   * @param options Options for subscribe.\n   * @returns An object that can be closed, sending any remaining messages to `handlers` and\n   * stopping new messages from arriving.\n   */\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions\n  ): {\n    /**\n     * Causes the subscriber to stop receiving new messages.\n     */\n    close(): Promise<void>;\n  };\n\n  /**\n   * Returns an iterator that can be used to receive messages from Service Bus.\n   * If the iterator is not able to fetch a new message in over a minute, `undefined` will be returned.\n   *\n   * @param options A set of options to control the receive operation.\n   * - `maxWaitTimeInMs`: The time to wait to receive the message in each iteration.\n   * - `abortSignal`: The signal to use to abort the ongoing operation.\n   *\n   * @throws Error if the underlying connection, client or receiver is closed.\n   * @throws Error if current receiver is already in state of receiving messages.\n   * @throws `ServiceBusError` if the service returns an error while receiving messages.\n   */\n  getMessageIterator(\n    options?: GetMessageIteratorOptions\n  ): AsyncIterableIterator<ServiceBusReceivedMessage>;\n\n  /**\n   * Returns a promise that resolves to an array of messages received from Service Bus.\n   *\n   * @param maxMessageCount The maximum number of messages to receive.\n   * @param options A set of options to control the receive operation.\n   * - `maxWaitTimeInMs`: The maximum time to wait for the first message before returning an empty array if no messages are available.\n   * - `abortSignal`: The signal to use to abort the ongoing operation.\n   * @returns Promise<ServiceBusReceivedMessage[]> A promise that resolves with an array of messages.\n   * @throws Error if the underlying connection, client or receiver is closed.\n   * @throws Error if current receiver is already in state of receiving messages.\n   * @throws `ServiceBusError` if the service returns an error while receiving messages.\n   */\n  receiveMessages(\n    maxMessageCount: number,\n    options?: ReceiveMessagesOptions\n  ): Promise<ServiceBusReceivedMessage[]>;\n\n  /**\n   * Returns a promise that resolves to an array of deferred messages identified by given `sequenceNumbers`.\n   * @param sequenceNumbers The sequence number or an array of sequence numbers for the messages that need to be received.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns {Promise<ServiceBusMessage[]>}\n   * - Returns a list of messages identified by the given sequenceNumbers.\n   * - Returns an empty list if no messages are found.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while receiving deferred messages.\n   */\n  receiveDeferredMessages(\n    sequenceNumbers: Long | Long[],\n    options?: OperationOptionsBase\n  ): Promise<ServiceBusReceivedMessage[]>;\n\n  /**\n   * Peek the next batch of active messages (including deferred but not deadlettered messages) on the\n   * queue or subscription without modifying them.\n   * - The first call to `peekMessages()` fetches the first active message. Each subsequent call fetches the\n   * subsequent message.\n   * - Unlike a \"received\" message, \"peeked\" message is a read-only version of the message.\n   * It cannot be `Completed/Abandoned/Deferred/Deadlettered`.\n   * @param maxMessageCount The maximum number of messages to peek.\n   * @param options Options that allow to specify the maximum number of messages to peek,\n   * the sequenceNumber to start peeking from or an abortSignal to abort the operation.\n   */\n  peekMessages(\n    maxMessageCount: number,\n    options?: PeekMessagesOptions\n  ): Promise<ServiceBusReceivedMessage[]>;\n  /**\n   * Path of the entity for which the receiver has been created.\n   */\n  entityPath: string;\n  /**\n   * The receive mode used to create the receiver.\n   */\n  receiveMode: \"peekLock\" | \"receiveAndDelete\";\n  /**\n   * @property Returns `true` if either the receiver or the client that created it has been closed.\n   * @readonly\n   */\n  isClosed: boolean;\n  /**\n   * Closes the receiver.\n   * Once closed, the receiver cannot be used for any further operations.\n   * Use the `createReceiver()` method on the ServiceBusClient to create a new Receiver.\n   */\n  close(): Promise<void>;\n  /**\n   * Removes the message from Service Bus.\n   *\n   * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link is closed by the library due to network loss or service error.\n   * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled.\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   *\n   * @returns Promise<void>.\n   */\n  completeMessage(message: ServiceBusReceivedMessage): Promise<void>;\n  /**\n   * The lock held on the message by the receiver is let go, making the message available again in\n   * Service Bus for another receive operation.\n   *\n   * @throws `ServiceBusError` with the code `SessionLockLost` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link is closed by the library due to network loss or service error.\n   * @throws `ServiceBusError` with the code `MessageLockLost` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled.\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws `ServiceBusError` with the code `ServiceTimeout` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   *\n   * @param propertiesToModify The properties of the message to modify while abandoning the message.\n   *\n   * @return Promise<void>.\n   */\n  abandonMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: any }\n  ): Promise<void>;\n  /**\n   * Defers the processing of the message. Save the `sequenceNumber` of the message, in order to\n   * receive it message again in the future using the `receiveDeferredMessage` method.\n   *\n   * @throws `ServiceBusError` with the code `SessionLockLost` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link is closed by the library due to network loss or service error.\n   * @throws `ServiceBusError` with the code `MessageLockLost` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled.\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws `ServiceBusError` with the code `ServiceTimeout` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   *\n   * @param propertiesToModify The properties of the message to modify while deferring the message\n   *\n   * @returns Promise<void>\n   */\n  deferMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: any }\n  ): Promise<void>;\n  /**\n   * Moves the message to the deadletter sub-queue. To receive a deadletted message, create a new\n   * QueueClient/SubscriptionClient using the path for the deadletter sub-queue.\n   *\n   * @throws `ServiceBusError` with the code `SessionLockLost` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link is closed by the library due to network loss or service error.\n   * @throws `ServiceBusError` with the code `MessageLockLost` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled.\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws `ServiceBusError` with the code `ServiceTimeout` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   *\n   * @param options The DeadLetter options that can be provided while\n   * rejecting the message.\n   *\n   * @returns Promise<void>\n   */\n  deadLetterMessage(\n    message: ServiceBusReceivedMessage,\n    options?: DeadLetterOptions & { [key: string]: any }\n  ): Promise<void>;\n  /**\n   * Renews the lock on the message for the duration as specified during the Queue/Subscription\n   * creation.\n   * - Check the `lockedUntilUtc` property on the message for the time when the lock expires.\n   * - If a message is not settled (using either `complete()`, `defer()` or `deadletter()`,\n   * before its lock expires, then the message lands back in the Queue/Subscription for the next\n   * receive operation.\n   *\n   * @returns Promise<Date> - New lock token expiry date and time in UTC format.\n   * @throws Error if the underlying connection, client or receiver is closed.\n   * @throws ServiceBusError if the service returns an error while renewing message lock.\n   */\n  renewMessageLock(message: ServiceBusReceivedMessage): Promise<Date>;\n}\n\n/**\n * @internal\n * @hidden\n */\nexport class ServiceBusReceiverImpl implements ServiceBusReceiver {\n  private _retryOptions: RetryOptions;\n  /**\n   * @property {boolean} [_isClosed] Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n\n  /**\n   * Instance of the BatchingReceiver class to use to receive messages in pull mode.\n   */\n  private _batchingReceiver?: BatchingReceiver;\n\n  /**\n   * Instance of the StreamingReceiver class to use to receive messages in push mode.\n   */\n  private _streamingReceiver?: StreamingReceiver;\n  private _lockRenewer: LockRenewer | undefined;\n\n  private _createProcessingSpan: typeof createProcessingSpan;\n\n  private get logPrefix() {\n    return `[${this._context.connectionId}|receiver:${this.entityPath}]`;\n  }\n\n  /**\n   * @throws Error if the underlying connection is closed.\n   */\n  constructor(\n    private _context: ConnectionContext,\n    public entityPath: string,\n    public receiveMode: \"peekLock\" | \"receiveAndDelete\",\n    maxAutoRenewLockDurationInMs: number,\n    retryOptions: RetryOptions = {}\n  ) {\n    throwErrorIfConnectionClosed(_context);\n    this._retryOptions = retryOptions;\n    this._lockRenewer = LockRenewer.create(\n      this._context,\n      maxAutoRenewLockDurationInMs,\n      receiveMode\n    );\n    this._createProcessingSpan = createProcessingSpan;\n  }\n\n  private _throwIfAlreadyReceiving(): void {\n    if (this._isReceivingMessages()) {\n      const errorMessage = getAlreadyReceivingErrorMsg(this.entityPath);\n      const error = new Error(errorMessage);\n      logger.logError(error, `${this.logPrefix} is already receiving`);\n      throw error;\n    }\n  }\n\n  private _throwIfReceiverOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (this.isClosed) {\n      const errorMessage = getReceiverClosedErrorMsg(this.entityPath);\n      const error = new Error(errorMessage);\n      logger.logError(error, `${this.logPrefix} is closed`);\n      throw error;\n    }\n  }\n\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.wasConnectionCloseCalled;\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the Receiver.\n   *\n   * Throws an error if there is another receive operation in progress on the same receiver. If you\n   * are not sure whether there is another receive operation running, check the `isReceivingMessages`\n   * property on the receiver.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control if messages should be automatically completed, and/or have\n   * their locks automatically renewed. You can control the maximum number of messages that should\n   * be concurrently processed. You can also provide a timeout in milliseconds to denote the\n   * amount of time to wait for a new message before closing the receiver.\n   *\n   * @returns void\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws Error if current receiver is already in state of receiving messages.\n   * @throws ServiceBusError if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.\n   */\n  private _registerMessageHandler(\n    onInitialize: () => Promise<void>,\n    onMessage: OnMessage,\n    onError: OnError,\n    options: SubscribeOptions\n  ): void {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    const connId = this._context.connectionId;\n    throwTypeErrorIfParameterMissing(connId, \"onMessage\", onMessage);\n    throwTypeErrorIfParameterMissing(connId, \"onError\", onError);\n    if (typeof onMessage !== \"function\") {\n      throw new TypeError(\"The parameter 'onMessage' must be of type 'function'.\");\n    }\n    if (typeof onError !== \"function\") {\n      throw new TypeError(\"The parameter 'onError' must be of type 'function'.\");\n    }\n\n    this._createStreamingReceiver({\n      ...options,\n      receiveMode: this.receiveMode,\n      retryOptions: this._retryOptions,\n      lockRenewer: this._lockRenewer,\n      onError\n    })\n      .then(async (sReceiver) => {\n        if (!sReceiver) {\n          return;\n        }\n        this._streamingReceiver = sReceiver;\n\n        try {\n          await onInitialize();\n        } catch (err) {\n          onError({\n            error: err,\n            errorSource: \"receive\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host\n          });\n        }\n\n        if (!this.isClosed) {\n          sReceiver.subscribe(onMessage, onError);\n        } else {\n          await sReceiver.close();\n        }\n        return;\n      })\n      .catch((err) => {\n        // TODO: being a bit broad here but the only errors that should filter out this\n        // far are going to be bootstrapping the subscription.\n        onError({\n          error: err,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host\n        });\n      });\n  }\n\n  private async _createStreamingReceiver(\n    options: StreamingReceiverInitArgs\n  ): Promise<StreamingReceiver> {\n    throwErrorIfConnectionClosed(this._context);\n    if (options.autoCompleteMessages == null) options.autoCompleteMessages = true;\n\n    // When the user \"stops\" a streaming receiver (via the returned instance from 'subscribe' we just suspend\n    // it, leaving the link open). This allows users to stop the flow of messages but still be able to settle messages\n    // since the link itself hasn't been shut down.\n    //\n    // Users can, if they want, restart their subscription (since we've got a link already established).\n    // So you'll have an instance here if the user has done:\n    // 1. const subscription = receiver.subscribe()\n    // 2. subscription.stop()\n    // 3. receiver.subscribe()\n    this._streamingReceiver =\n      this._streamingReceiver ?? new StreamingReceiver(this._context, this.entityPath, options);\n\n    // this ensures that if the outer service bus client is closed that  this receiver is cleaned up.\n    // this mostly affects us if we're in the middle of init() - the connection (and receiver) are not yet\n    // open but we do need to close the receiver to exit the init() loop.\n    this._context.messageReceivers[this._streamingReceiver.name] = this._streamingReceiver;\n\n    await this._streamingReceiver.init({\n      connectionId: this._context.connectionId,\n      useNewName: false,\n      ...options\n    });\n\n    return this._streamingReceiver;\n  }\n\n  async receiveMessages(\n    maxMessageCount: number,\n    options?: ReceiveMessagesOptions\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount\n    );\n    throwTypeErrorIfParameterTypeMismatch(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n      \"number\"\n    );\n\n    if (isNaN(maxMessageCount) || maxMessageCount < 1) {\n      throw new TypeError(InvalidMaxMessageCountError);\n    }\n\n    const receiveMessages = async () => {\n      if (!this._batchingReceiver || !this._context.messageReceivers[this._batchingReceiver.name]) {\n        const options: ReceiveOptions = {\n          maxConcurrentCalls: 0,\n          receiveMode: this.receiveMode,\n          lockRenewer: this._lockRenewer\n        };\n        this._batchingReceiver = this._createBatchingReceiver(\n          this._context,\n          this.entityPath,\n          options\n        );\n      }\n\n      const receivedMessages = await this._batchingReceiver.receive(\n        maxMessageCount,\n        options?.maxWaitTimeInMs ?? Constants.defaultOperationTimeoutInMs,\n        defaultMaxTimeAfterFirstMessageForBatchingMs,\n        options ?? {}\n      );\n\n      return receivedMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      connectionHost: this._context.config.host,\n      connectionId: this._context.connectionId,\n      operation: receiveMessages,\n      operationType: RetryOperationType.receiveMessage,\n      abortSignal: options?.abortSignal,\n      retryOptions: this._retryOptions\n    };\n    return retry<ServiceBusReceivedMessage[]>(config).catch((err) => {\n      throw translateServiceBusError(err);\n    });\n  }\n\n  getMessageIterator(\n    options?: GetMessageIteratorOptions\n  ): AsyncIterableIterator<ServiceBusReceivedMessage> {\n    return getMessageIterator(this, options);\n  }\n\n  async receiveDeferredMessages(\n    sequenceNumbers: Long | Long[],\n    options: OperationOptionsBase = {}\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n    throwTypeErrorIfParameterNotLong(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n\n    const deferredSequenceNumbers = Array.isArray(sequenceNumbers)\n      ? sequenceNumbers\n      : [sequenceNumbers];\n    const receiveDeferredMessagesOperationPromise = async () => {\n      const deferredMessages = await this._context\n        .getManagementClient(this.entityPath)\n        .receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, undefined, {\n          ...options,\n          associatedLinkName: this._getAssociatedReceiverName(),\n          requestName: \"receiveDeferredMessages\",\n          timeoutInMs: this._retryOptions.timeoutInMs\n        });\n      return deferredMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: receiveDeferredMessagesOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  // ManagementClient methods # Begin\n\n  async peekMessages(\n    maxMessageCount: number,\n    options: PeekMessagesOptions = {}\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    const managementRequestOptions = {\n      ...options,\n      associatedLinkName: this._getAssociatedReceiverName(),\n      requestName: \"peekMessages\",\n      timeoutInMs: this._retryOptions?.timeoutInMs\n    };\n    const peekOperationPromise = async () => {\n      if (options.fromSequenceNumber) {\n        return await this._context\n          .getManagementClient(this.entityPath)\n          .peekBySequenceNumber(\n            options.fromSequenceNumber,\n            maxMessageCount,\n            undefined,\n            managementRequestOptions\n          );\n      } else {\n        return await this._context\n          .getManagementClient(this.entityPath)\n          .peek(maxMessageCount, managementRequestOptions);\n      }\n    };\n\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: peekOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions\n  ): {\n    close(): Promise<void>;\n  } {\n    assertValidMessageHandlers(handlers);\n    options = options ?? {};\n\n    const processError = wrapProcessErrorHandler(handlers);\n\n    const internalMessageHandlers = handlers as InternalMessageHandlers;\n\n    this._registerMessageHandler(\n      async () => {\n        if (internalMessageHandlers?.processInitialize) {\n          await internalMessageHandlers.processInitialize();\n        }\n      },\n      async (message: ServiceBusMessageImpl) => {\n        const span = this._createProcessingSpan(message, this, this._context.config, options);\n        return trace(() => handlers.processMessage(message), span);\n      },\n      processError,\n      options\n    );\n\n    return {\n      close: async (): Promise<void> => {\n        return this._streamingReceiver?.stopReceivingMessages();\n      }\n    };\n  }\n\n  async completeMessage(message: ServiceBusReceivedMessage): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return completeMessage(msgImpl, this._context, this.entityPath);\n  }\n\n  async abandonMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: any }\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return abandonMessage(msgImpl, this._context, this.entityPath, propertiesToModify);\n  }\n\n  async deferMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: any }\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deferMessage(msgImpl, this._context, this.entityPath, propertiesToModify);\n  }\n\n  async deadLetterMessage(\n    message: ServiceBusReceivedMessage,\n    options?: DeadLetterOptions & { [key: string]: any }\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deadLetterMessage(msgImpl, this._context, this.entityPath, options);\n  }\n\n  async renewMessageLock(message: ServiceBusReceivedMessage): Promise<Date> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n\n    const msgImpl = message as ServiceBusMessageImpl;\n\n    let associatedLinkName: string | undefined;\n    if (msgImpl.delivery.link) {\n      const associatedReceiver = this._context.getReceiverFromCache(msgImpl.delivery.link.name);\n      associatedLinkName = associatedReceiver?.name;\n    }\n    return this._context\n      .getManagementClient(this.entityPath)\n      .renewLock(message.lockToken!, { associatedLinkName })\n      .then((lockedUntil) => {\n        message.lockedUntilUtc = lockedUntil;\n        return lockedUntil;\n      });\n  }\n\n  async close(): Promise<void> {\n    try {\n      this._isClosed = true;\n      if (this._context.connection && this._context.connection.isOpen()) {\n        // Close the streaming receiver.\n        if (this._streamingReceiver) {\n          await this._streamingReceiver.close();\n        }\n\n        // Close the batching receiver.\n        if (this._batchingReceiver) {\n          await this._batchingReceiver.close();\n        }\n      }\n    } catch (err) {\n      logger.logError(err, `${this.logPrefix} An error occurred while closing the Receiver`);\n      throw err;\n    }\n  }\n\n  /**\n   * Indicates whether the receiver is currently receiving messages or not.\n   * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.\n   */\n  private _isReceivingMessages(): boolean {\n    if (\n      this._streamingReceiver &&\n      this._streamingReceiver.isOpen() &&\n      this._streamingReceiver.isReceivingMessages\n    ) {\n      return true;\n    }\n    if (\n      this._batchingReceiver &&\n      this._batchingReceiver.isOpen() &&\n      this._batchingReceiver.isReceivingMessages\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  private _createBatchingReceiver(\n    context: ConnectionContext,\n    entityPath: string,\n    options: ReceiveOptions\n  ): BatchingReceiver {\n    return BatchingReceiver.create(context, entityPath, options);\n  }\n\n  /**\n   * Helper function to retrieve any active receiver name, regardless of streaming or\n   * batching if it exists. This is used for optimization on the service side\n   */\n  private _getAssociatedReceiverName(): string | undefined {\n    if (this._streamingReceiver && this._streamingReceiver.isOpen()) {\n      return this._streamingReceiver.name;\n    }\n    if (\n      this._batchingReceiver &&\n      this._batchingReceiver.isOpen() &&\n      this._batchingReceiver.isReceivingMessages\n    ) {\n      return this._batchingReceiver.name;\n    }\n    return;\n  }\n}\n\n/**\n * The default time to wait for messages _after_ the first message\n * has been received.\n *\n * This timeout only applies to receiveMessages()\n *\n * @internal\n * @hidden\n */\nexport const defaultMaxTimeAfterFirstMessageForBatchingMs = 1000;\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionContext } from \"../connectionContext\";\nimport { MessageHandlers, ReceiveMessagesOptions, ServiceBusReceivedMessage } from \"..\";\nimport { PeekMessagesOptions, GetMessageIteratorOptions, SubscribeOptions } from \"../models\";\nimport { MessageSession } from \"../session/messageSession\";\nimport {\n  getAlreadyReceivingErrorMsg,\n  getReceiverClosedErrorMsg,\n  InvalidMaxMessageCountError,\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n  throwErrorIfInvalidOperationOnMessage,\n  throwTypeErrorIfParameterTypeMismatch\n} from \"../util/errors\";\nimport { OnError, OnMessage } from \"../core/messageReceiver\";\nimport {\n  abandonMessage,\n  assertValidMessageHandlers,\n  completeMessage,\n  deadLetterMessage,\n  deferMessage,\n  getMessageIterator,\n  wrapProcessErrorHandler\n} from \"./shared\";\nimport { defaultMaxTimeAfterFirstMessageForBatchingMs, ServiceBusReceiver } from \"./receiver\";\nimport Long from \"long\";\nimport { ServiceBusMessageImpl, DeadLetterOptions } from \"../serviceBusMessage\";\nimport {\n  Constants,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  retry,\n  ErrorNameConditionMapper\n} from \"@azure/core-amqp\";\nimport { OperationOptionsBase, trace } from \"../modelsToBeSharedWithEventHubs\";\nimport \"@azure/core-asynciterator-polyfill\";\nimport { AmqpError } from \"rhea-promise\";\nimport { createProcessingSpan } from \"../diagnostics/instrumentServiceBusMessage\";\nimport { receiverLogger as logger } from \"../log\";\nimport { translateServiceBusError } from \"../serviceBusError\";\n\n/**\n *A receiver that handles sessions, including renewing the session lock.\n */\nexport interface ServiceBusSessionReceiver extends ServiceBusReceiver {\n  /**\n   * The session ID.\n   */\n  readonly sessionId: string;\n\n  /**\n   * @property The time in UTC until which the session is locked.\n   * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock\n   * duration as specified during the Queue/Subscription creation.\n   *\n   * Will return undefined until a AMQP receiver link has been successfully set up for the session.\n   *\n   * @readonly\n   */\n  readonly sessionLockedUntilUtc: Date;\n\n  /**\n   * Streams messages to message handlers.\n   * @param handlers A handler that gets called for messages and errors.\n   * @param options Options for subscribe.\n   * @returns An object that can be closed, sending any remaining messages to `handlers` and\n   * stopping new messages from arriving.\n   */\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions\n  ): {\n    /**\n     * Causes the subscriber to stop receiving new messages.\n     */\n    close(): Promise<void>;\n  };\n\n  /**\n   * Renews the lock on the session.\n   */\n  renewSessionLock(options?: OperationOptionsBase): Promise<Date>;\n\n  /**\n   * Gets the state of the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state Session State}\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns {Promise<any>} The state of that session\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while retrieving session state.\n   */\n  getSessionState(options?: OperationOptionsBase): Promise<any>;\n\n  /**\n   * Sets the state on the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state Session State}\n   * @param state The state that needs to be set.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while setting the session state.\n   *\n   * @param {*} state\n   * @returns {Promise<void>}\n   */\n  setSessionState(state: any, options?: OperationOptionsBase): Promise<void>;\n}\n\n/**\n * @internal\n * @hidden\n */\nexport class ServiceBusSessionReceiverImpl implements ServiceBusSessionReceiver {\n  public sessionId: string;\n\n  /**\n   * @property {boolean} [_isClosed] Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n\n  private _createProcessingSpan: typeof createProcessingSpan;\n\n  private get logPrefix() {\n    return `[${this._context.connectionId}|session:${this.entityPath}]`;\n  }\n\n  /**\n   * @internal\n   * @throws Error if the underlying connection is closed.\n   * @throws Error if an open receiver is already existing for given sessionId.\n   */\n  constructor(\n    private _messageSession: MessageSession,\n    private _context: ConnectionContext,\n    public entityPath: string,\n    public receiveMode: \"peekLock\" | \"receiveAndDelete\",\n    private _retryOptions: RetryOptions = {}\n  ) {\n    throwErrorIfConnectionClosed(_context);\n    this.sessionId = _messageSession.sessionId;\n    this._createProcessingSpan = createProcessingSpan;\n  }\n\n  private _throwIfReceiverOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (this.isClosed) {\n      if (this._isClosed) {\n        const errorMessage = getReceiverClosedErrorMsg(this.entityPath, this.sessionId);\n        const error = new Error(errorMessage);\n        logger.logError(error, `${this.logPrefix} already closed`);\n        throw error;\n      }\n      const amqpError: AmqpError = {\n        condition: ErrorNameConditionMapper.SessionLockLostError,\n        description: `The session lock has expired on the session with id ${this.sessionId}`\n      };\n      throw translateServiceBusError(amqpError);\n    }\n  }\n\n  private _throwIfAlreadyReceiving(): void {\n    if (this._isReceivingMessages()) {\n      const errorMessage = getAlreadyReceivingErrorMsg(this.entityPath, this.sessionId);\n      const error = new Error(errorMessage);\n      logger.logError(error, `${this.logPrefix} is already receiving.`);\n      throw error;\n    }\n  }\n\n  public get isClosed(): boolean {\n    return (\n      this._isClosed ||\n      !this._context.messageSessions[this._messageSession.name] ||\n      !this._messageSession.isOpen()\n    );\n  }\n\n  /**\n   * @property The time in UTC until which the session is locked.\n   * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock\n   * duration as specified during the Queue/Subscription creation.\n   *\n   * When the lock on the session expires\n   * - The current receiver can no longer be used to receive more messages.\n   * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.\n   * - Messages that were received in `peekLock` mode with this receiver but not yet settled\n   * will land back in the Queue/Subscription with their delivery count incremented.\n   *\n   * @readonly\n   */\n  public get sessionLockedUntilUtc(): Date {\n    return this._messageSession.sessionLockedUntilUtc;\n  }\n\n  /**\n   * Renews the lock on the session for the duration as specified during the Queue/Subscription\n   * creation. You can check the `sessionLockedUntilUtc` property for the time when the lock expires.\n   *\n   * When the lock on the session expires\n   * - The current receiver can no longer be used to receive mode messages.\n   * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.\n   * - Messages that were received in `peekLock` mode with this receiver but not yet settled\n   * will land back in the Queue/Subscription with their delivery count incremented.\n   *\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns Promise<Date> - New lock token expiry date and time in UTC format.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while renewing session lock.\n   */\n  async renewSessionLock(options?: OperationOptionsBase): Promise<Date> {\n    this._throwIfReceiverOrConnectionClosed();\n    const renewSessionLockOperationPromise = async () => {\n      this._messageSession!.sessionLockedUntilUtc = await this._context\n        .getManagementClient(this.entityPath)\n        .renewSessionLock(this.sessionId, {\n          ...options,\n          associatedLinkName: this._messageSession.name,\n          requestName: \"renewSessionLock\",\n          timeoutInMs: this._retryOptions.timeoutInMs\n        });\n      return this._messageSession!.sessionLockedUntilUtc!;\n    };\n    const config: RetryConfig<Date> = {\n      operation: renewSessionLockOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    };\n    return retry<Date>(config);\n  }\n\n  /**\n   * Sets the state on the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state Session State}\n   * @param state The state that needs to be set.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while setting the session state.\n   */\n  async setSessionState(state: any, options: OperationOptionsBase = {}): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    const setSessionStateOperationPromise = async () => {\n      await this._context\n        .getManagementClient(this.entityPath)\n        .setSessionState(this.sessionId!, state, {\n          ...options,\n          associatedLinkName: this._messageSession.name,\n          requestName: \"setState\",\n          timeoutInMs: this._retryOptions.timeoutInMs\n        });\n      return;\n    };\n    const config: RetryConfig<void> = {\n      operation: setSessionStateOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    };\n    return retry<void>(config);\n  }\n\n  /**\n   * Gets the state of the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state Session State}\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns Promise<any> The state of that session\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while retrieving session state.\n   */\n  async getSessionState(options: OperationOptionsBase = {}): Promise<any> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    const getSessionStateOperationPromise = async () => {\n      return this._context.getManagementClient(this.entityPath).getSessionState(this.sessionId, {\n        ...options,\n        associatedLinkName: this._messageSession.name,\n        requestName: \"getState\",\n        timeoutInMs: this._retryOptions.timeoutInMs\n      });\n    };\n    const config: RetryConfig<any> = {\n      operation: getSessionStateOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    };\n    return retry<any>(config);\n  }\n\n  async peekMessages(\n    maxMessageCount: number,\n    options: PeekMessagesOptions = {}\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    const managementRequestOptions = {\n      ...options,\n      associatedLinkName: this._messageSession.name,\n      requestName: \"peekMessages\",\n      timeoutInMs: this._retryOptions?.timeoutInMs\n    };\n    const peekOperationPromise = async () => {\n      if (options.fromSequenceNumber) {\n        return await this._context\n          .getManagementClient(this.entityPath)\n          .peekBySequenceNumber(\n            options.fromSequenceNumber,\n            maxMessageCount,\n            this.sessionId,\n            managementRequestOptions\n          );\n      } else {\n        return await this._context\n          .getManagementClient(this.entityPath)\n          .peekMessagesBySession(this.sessionId, maxMessageCount, managementRequestOptions);\n      }\n    };\n\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: peekOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  async receiveDeferredMessages(\n    sequenceNumbers: Long | Long[],\n    options: OperationOptionsBase = {}\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n    throwTypeErrorIfParameterNotLong(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n\n    const deferredSequenceNumbers = Array.isArray(sequenceNumbers)\n      ? sequenceNumbers\n      : [sequenceNumbers];\n    const receiveDeferredMessagesOperationPromise = async () => {\n      const deferredMessages = await this._context\n        .getManagementClient(this.entityPath)\n        .receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, this.sessionId, {\n          ...options,\n          associatedLinkName: this._messageSession.name,\n          requestName: \"receiveDeferredMessages\",\n          timeoutInMs: this._retryOptions.timeoutInMs\n        });\n      return deferredMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: receiveDeferredMessagesOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  async receiveMessages(\n    maxMessageCount: number,\n    options?: ReceiveMessagesOptions\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount\n    );\n    throwTypeErrorIfParameterTypeMismatch(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n      \"number\"\n    );\n\n    if (isNaN(maxMessageCount) || maxMessageCount < 1) {\n      throw new TypeError(InvalidMaxMessageCountError);\n    }\n\n    const receiveBatchOperationPromise = async () => {\n      const receivedMessages = await this._messageSession!.receiveMessages(\n        maxMessageCount,\n        options?.maxWaitTimeInMs ?? Constants.defaultOperationTimeoutInMs,\n        defaultMaxTimeAfterFirstMessageForBatchingMs,\n        options ?? {}\n      );\n\n      return receivedMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: receiveBatchOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.receiveMessage,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    };\n    return retry<ServiceBusReceivedMessage[]>(config).catch((err) => {\n      throw translateServiceBusError(err);\n    });\n  }\n\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions\n  ): {\n    close(): Promise<void>;\n  } {\n    // TODO - receiverOptions for subscribe??\n    assertValidMessageHandlers(handlers);\n\n    options = options ?? {};\n\n    const processError = wrapProcessErrorHandler(handlers);\n\n    this._registerMessageHandler(\n      async (message: ServiceBusMessageImpl) => {\n        const span = this._createProcessingSpan(message, this, this._context.config, options);\n        return trace(() => handlers.processMessage(message), span);\n      },\n      processError,\n      options\n    );\n\n    return {\n      close: async (): Promise<void> => {\n        return this._messageSession?.receiverHelper.suspend();\n      }\n    };\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the SessionReceiver.\n   *\n   * Throws an error if there is another receive operation in progress on the same receiver. If you\n   * are not sure whether there is another receive operation running, check the `isReceivingMessages`\n   * property on the receiver.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control whether messages should be automatically completed\n   * or if the lock on the session should be automatically renewed. You can control the\n   * maximum number of messages that should be concurrently processed. You can\n   * also provide a timeout in milliseconds to denote the amount of time to wait for a new message\n   * before closing the receiver.\n   *\n   * @returns void\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws Error if the receiver is already in state of receiving messages.\n   * @throws `ServiceBusError` if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.\n   */\n  private _registerMessageHandler(\n    onMessage: OnMessage,\n    onError: OnError,\n    options: SubscribeOptions\n  ): void {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    const connId = this._context.connectionId;\n    throwTypeErrorIfParameterMissing(connId, \"onMessage\", onMessage);\n    throwTypeErrorIfParameterMissing(connId, \"onError\", onError);\n    if (typeof onMessage !== \"function\") {\n      throw new TypeError(\"The parameter 'onMessage' must be of type 'function'.\");\n    }\n    if (typeof onError !== \"function\") {\n      throw new TypeError(\"The parameter 'onError' must be of type 'function'.\");\n    }\n\n    try {\n      this._messageSession.subscribe(onMessage, onError, options);\n    } catch (err) {\n      onError({\n        error: err,\n        errorSource: \"receive\",\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host\n      });\n    }\n  }\n\n  getMessageIterator(\n    options?: GetMessageIteratorOptions\n  ): AsyncIterableIterator<ServiceBusReceivedMessage> {\n    return getMessageIterator(this, options);\n  }\n\n  async completeMessage(message: ServiceBusReceivedMessage): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return completeMessage(msgImpl, this._context, this.entityPath);\n  }\n\n  async abandonMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: any }\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return abandonMessage(msgImpl, this._context, this.entityPath, propertiesToModify);\n  }\n\n  async deferMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: any }\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deferMessage(msgImpl, this._context, this.entityPath, propertiesToModify);\n  }\n\n  async deadLetterMessage(\n    message: ServiceBusReceivedMessage,\n    options?: DeadLetterOptions & { [key: string]: any }\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deadLetterMessage(msgImpl, this._context, this.entityPath, options);\n  }\n\n  async renewMessageLock(): Promise<Date> {\n    throw new Error(\"Renewing message lock is an invalid operation when working with sessions.\");\n  }\n\n  async close(): Promise<void> {\n    try {\n      await this._messageSession.close();\n    } catch (err) {\n      logger.logError(\n        err,\n        \"%s An error occurred while closing the SessionReceiver for session %s\",\n        this.logPrefix,\n        this.sessionId\n      );\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  /**\n   * Indicates whether the receiver is currently receiving messages or not.\n   * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.\n   */\n  private _isReceivingMessages(): boolean {\n    return this._messageSession ? this._messageSession.isReceivingMessages : false;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionConfig } from \"@azure/core-amqp\";\nimport { getTracer } from \"@azure/core-tracing\";\nimport { Span, SpanContext, SpanKind } from \"@opentelemetry/api\";\n\n/**\n * @internal\n * @hidden\n */\nexport function createMessageSpan(\n  parentSpan?: Span | SpanContext | null,\n  config?: Pick<ConnectionConfig, \"entityPath\" | \"host\">\n): Span {\n  const tracer = getTracer();\n  const span = tracer.startSpan(\"Azure.ServiceBus.message\", {\n    kind: SpanKind.PRODUCER,\n    parent: parentSpan\n  });\n  span.setAttribute(\"az.namespace\", \"Microsoft.ServiceBus\");\n  if (config) {\n    span.setAttribute(\"message_bus.destination\", config.entityPath);\n    span.setAttribute(\"peer.address\", config.host);\n  }\n  return span;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  ServiceBusMessage,\n  toRheaMessage,\n  getMessagePropertyTypeMismatchError\n} from \"./serviceBusMessage\";\nimport { throwIfNotValidServiceBusMessage, throwTypeErrorIfParameterMissing } from \"./util/errors\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport {\n  MessageAnnotations,\n  messageProperties as RheaMessagePropertiesList,\n  message as RheaMessageUtil,\n  Message as RheaMessage\n} from \"rhea-promise\";\nimport { SpanContext } from \"@opentelemetry/api\";\nimport {\n  instrumentServiceBusMessage,\n  TRACEPARENT_PROPERTY\n} from \"./diagnostics/instrumentServiceBusMessage\";\nimport { createMessageSpan } from \"./diagnostics/messageSpan\";\nimport { TryAddOptions } from \"./modelsToBeSharedWithEventHubs\";\nimport { defaultDataTransformer } from \"./dataTransformer\";\n\n/**\n * @internal\n * @hidden\n * The amount of bytes to reserve as overhead for a small message.\n */\nconst smallMessageOverhead = 5;\n/**\n * @internal\n * @hidden\n * The amount of bytes to reserve as overhead for a large message.\n */\nconst largeMessageOverhead = 8;\n/**\n * @internal\n * @hidden\n * The maximum number of bytes that a message may be to be considered small.\n */\nconst smallMessageMaxBytes = 255;\n\n/**\n * A batch of messages that you can create using the {@link createBatch} method.\n *\n * @export\n */\nexport interface ServiceBusMessageBatch {\n  /**\n   * Size of the batch in bytes after the events added to it have been encoded into a single AMQP\n   * message.\n   * @readonly\n   */\n  readonly sizeInBytes: number;\n\n  /**\n   * Number of messages added to the batch.\n   * @readonly\n   */\n  readonly count: number;\n\n  /**\n   * The maximum size of the batch, in bytes. The `tryAddMessage` function on the batch will return `false`\n   * if the message being added causes the size of the batch to exceed this limit. Use the `createMessageBatch()` method on\n   * the `Sender` to set the maxSizeInBytes.\n   * @readonly.\n   */\n  readonly maxSizeInBytes: number;\n\n  /**\n   * Adds a message to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param message  An individual service bus message.\n   * @returns A boolean value indicating if the message has been added to the batch or not.\n   */\n  tryAddMessage(message: ServiceBusMessage, options?: TryAddOptions): boolean;\n\n  /**\n   * The AMQP message containing encoded events that were added to the batch.\n   * Used internally by the `sendBatch()` method on the `Sender`.\n   * This is not meant for the user to use directly.\n   *\n   * @readonly\n   * @internal\n   * @hidden\n   */\n  _generateMessage(): Buffer;\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * Used internally by the `sendBatch()` method to set up the right spans in traces if tracing is enabled.\n   * @internal\n   * @hidden\n   */\n  readonly _messageSpanContexts: SpanContext[];\n}\n\n/**\n * An internal class representing a batch of messages which can be used to send messages to Service Bus.\n *\n * @class\n * @internal\n * @hidden\n */\nexport class ServiceBusMessageBatchImpl implements ServiceBusMessageBatch {\n  /**\n   * @property Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * @property Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: SpanContext[] = [];\n  /**\n   * ServiceBusMessageBatch should not be constructed using `new ServiceBusMessageBatch()`\n   * Use the `createBatch()` method on your `Sender` instead.\n   * @constructor\n   * @internal\n   * @hidden\n   */\n  constructor(private _context: ConnectionContext, private _maxSizeInBytes: number) {\n    this._sizeInBytes = 0;\n    this._batchMessageProperties = {};\n  }\n\n  /**\n   * @property The maximum size of the batch, in bytes.\n   * @readonly\n   */\n  get maxSizeInBytes(): number {\n    return this._maxSizeInBytes;\n  }\n\n  /**\n   * @property Size of the `ServiceBusMessageBatch` instance after the messages added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * @property Number of messages in the `ServiceBusMessageBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._encodedMessages.length;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding messages to the batch.\n   * @internal\n   * @hidden\n   */\n  get _messageSpanContexts(): SpanContext[] {\n    return this._spanContexts;\n  }\n\n  /**\n   * Generates an AMQP message that contains the provided encoded messages and annotations.\n   *\n   * @private\n   * @param {Buffer[]} encodedMessages The already encoded messages to include in the AMQP batch.\n   * @param {MessageAnnotations} [annotations] The message annotations to set on the batch.\n   * @param {{ [key: string]: any }} [applicationProperties] The application properties to set on the batch.\n   * @param {{ [key: string]: string }} [messageProperties] The message properties to set on the batch.\n   * @returns {Buffer}\n   * @memberof ServiceBusMessageBatchImpl\n   */\n  private _generateBatch(\n    encodedMessages: Buffer[],\n    annotations?: MessageAnnotations,\n    applicationProperties?: { [key: string]: any },\n    messageProperties?: { [key: string]: string }\n  ): Buffer {\n    const batchEnvelope: RheaMessage = {\n      body: RheaMessageUtil.data_sections(encodedMessages),\n      message_annotations: annotations,\n      application_properties: applicationProperties\n    };\n    if (messageProperties) {\n      for (const prop of RheaMessagePropertiesList) {\n        if ((messageProperties as any)[prop]) {\n          (batchEnvelope as any)[prop] = (messageProperties as any)[prop];\n        }\n      }\n    }\n    return RheaMessageUtil.encode(batchEnvelope);\n  }\n\n  /**\n   * @property Represents the single AMQP message which is the result of encoding all the events\n   * added into the `ServiceBusMessageBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `ServiceBusMessageBatch` instance is passed to the `sendBatch()` method on the `Sender`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  _generateMessage(): Buffer {\n    return this._generateBatch(\n      this._encodedMessages,\n      this._batchAnnotations,\n      this._batchApplicationProperties,\n      this._batchMessageProperties\n    );\n  }\n\n  /**\n   * The message annotations to apply on the batch envelope.\n   * This will reflect the message annotations on the first message\n   * that was added to the batch.\n   */\n  private _batchAnnotations?: MessageAnnotations;\n  /**\n   * The message properties to apply on the batch envelope.\n   * This will reflect the message properties on the first message\n   * that was added to the batch.\n   */\n  private _batchMessageProperties?: { [key: string]: string };\n  /**\n   * The application properties to apply on the batch envelope.\n   * This will reflect the application properties on the first message\n   * that was added to the batch.\n   */\n  private _batchApplicationProperties?: { [key: string]: any };\n\n  /**\n   * Tries to add a message to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next message.\n   *\n   * @param message  An individual service bus message.\n   * @returns A boolean value indicating if the message has been added to the batch or not.\n   */\n  public tryAddMessage(message: ServiceBusMessage, options: TryAddOptions = {}): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"message\", message);\n    throwIfNotValidServiceBusMessage(\n      message,\n      \"Provided value for 'message' must be of type ServiceBusMessage.\"\n    );\n\n    // check if the event has already been instrumented\n    const previouslyInstrumented = Boolean(\n      message.applicationProperties && message.applicationProperties[TRACEPARENT_PROPERTY]\n    );\n    let spanContext: SpanContext | undefined;\n    if (!previouslyInstrumented) {\n      const messageSpan = createMessageSpan(options?.parentSpan, this._context.config);\n      message = instrumentServiceBusMessage(message, messageSpan);\n      spanContext = messageSpan.context();\n      messageSpan.end();\n    }\n\n    // Convert ServiceBusMessage to AmqpMessage.\n    const amqpMessage = toRheaMessage(message);\n    amqpMessage.body = defaultDataTransformer.encode(message.body);\n\n    let encodedMessage: Buffer;\n    try {\n      encodedMessage = RheaMessageUtil.encode(amqpMessage);\n    } catch (error) {\n      if (error instanceof TypeError || error.name === \"TypeError\") {\n        throw getMessagePropertyTypeMismatchError(message) || error;\n      }\n      throw error;\n    }\n\n    let currentSize = this._sizeInBytes;\n\n    // The first time an event is added, we need to calculate\n    // the overhead of creating an AMQP batch, including the\n    // message_annotations, application_properties and message_properties\n    // that are taken from the 1st message.\n    if (this.count === 0) {\n      if (amqpMessage.message_annotations) {\n        this._batchAnnotations = amqpMessage.message_annotations;\n      }\n      if (amqpMessage.application_properties) {\n        this._batchApplicationProperties = amqpMessage.application_properties;\n      }\n      for (const prop of RheaMessagePropertiesList) {\n        if ((amqpMessage as any)[prop]) {\n          (this._batchMessageProperties as any)[prop] = (amqpMessage as any)[prop];\n        }\n      }\n      // Figure out the overhead of creating a batch by generating an empty batch\n      // with the expected batch annotations.\n      currentSize += this._generateBatch(\n        [],\n        this._batchAnnotations,\n        this._batchApplicationProperties,\n        this._batchMessageProperties\n      ).length;\n    }\n\n    const messageSize = encodedMessage.length;\n    const messageOverhead =\n      messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;\n    currentSize += messageSize + messageOverhead;\n    // Check if the size of the batch exceeds the maximum allowed size\n    // once we add the new event to it.\n    if (currentSize > this._maxSizeInBytes) {\n      return false;\n    }\n\n    // The message will fit in the batch, so it is now safe to store it.\n    this._encodedMessages.push(encodedMessage);\n    if (spanContext) {\n      this._spanContexts.push(spanContext);\n    }\n\n    this._sizeInBytes = currentSize;\n    return true;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { senderLogger as logger } from \"../log\";\nimport {\n  AmqpError,\n  AwaitableSender,\n  AwaitableSenderOptions,\n  EventContext,\n  OnAmqpEvent,\n  message as RheaMessageUtil,\n  messageProperties,\n  Message as RheaMessage\n} from \"rhea-promise\";\nimport {\n  Constants,\n  ErrorNameConditionMapper,\n  MessagingError,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  delay,\n  retry\n} from \"@azure/core-amqp\";\nimport {\n  ServiceBusMessage,\n  getMessagePropertyTypeMismatchError,\n  toRheaMessage\n} from \"../serviceBusMessage\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { getUniqueName, waitForTimeoutOrAbortOrResolve } from \"../util/utils\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport { ServiceBusMessageBatch, ServiceBusMessageBatchImpl } from \"../serviceBusMessageBatch\";\nimport { CreateMessageBatchOptions } from \"../models\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { defaultDataTransformer } from \"../dataTransformer\";\n\n/**\n * @internal\n * @hidden\n * Describes the MessageSender that will send messages to ServiceBus.\n * @class MessageSender\n */\nexport class MessageSender extends LinkEntity<AwaitableSender> {\n  /**\n   * @property {OnAmqpEvent} _onAmqpError The handler function to handle errors that happen on the\n   * underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onAmqpClose The handler function to handle \"sender_close\" event\n   * that happens on the underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpClose: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onSessionError The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onSessionClose The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEvent;\n  private _retryOptions: RetryOptions;\n\n  constructor(context: ConnectionContext, entityPath: string, retryOptions: RetryOptions) {\n    super(entityPath, entityPath, context, \"sender\", logger, {\n      address: entityPath,\n      audience: `${context.config.endpoint}${entityPath}`\n    });\n    this._retryOptions = retryOptions;\n    this._onAmqpError = (context: EventContext) => {\n      const senderError = context.sender && context.sender.error;\n      logger.logError(\n        senderError,\n        \"%s 'sender_error' event occurred on the sender '%s' with address '%s'. \" +\n          \"The associated error\",\n        this.logPrefix,\n        this.name,\n        this.address\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n      logger.logError(\n        sessionError,\n        \"%s 'session_error' event occurred on the session of sender '%s' with address '%s'. \" +\n          \"The associated error\",\n        this.logPrefix,\n        this.name,\n        this.address\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const senderError = context.sender && context.sender.error;\n\n      logger.logError(\n        senderError,\n        `${this.logPrefix} 'sender_close' event occurred. The associated error is`\n      );\n\n      await this.onDetached().catch((err) => {\n        logger.logError(\n          err,\n          `${this.logPrefix} error when closing sender after 'sender_close' event`\n        );\n      });\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n\n      logger.logError(\n        sessionError,\n        `${this.logPrefix} 'session_close' event occurred. The associated error is`\n      );\n\n      await this.onDetached().catch((err) => {\n        logger.logError(\n          err,\n          `${this.logPrefix} error when closing sender after 'session_close' event`\n        );\n      });\n    };\n  }\n\n  private _createSenderOptions(timeoutInMs: number, newName?: boolean): AwaitableSenderOptions {\n    if (newName) this.name = getUniqueName(this.baseName);\n    const srOptions: AwaitableSenderOptions = {\n      name: this.name,\n      target: {\n        address: this.address\n      },\n      onError: this._onAmqpError,\n      onClose: this._onAmqpClose,\n      onSessionError: this._onSessionError,\n      onSessionClose: this._onSessionClose,\n      sendTimeoutInSeconds: timeoutInMs / 1000\n    };\n    logger.verbose(`${this.logPrefix} Creating sender with options: %O`, srOptions);\n    return srOptions;\n  }\n\n  /**\n   * Tries to send the message to ServiceBus if there is enough credit to send them\n   * and the circular buffer has available space to settle the message after sending them.\n   *\n   * We have implemented a synchronous send over here in the sense that we shall be waiting\n   * for the message to be accepted or rejected and accordingly resolve or reject the promise.\n   *\n   * @param encodedMessage The encoded message to be sent to ServiceBus.\n   * @param sendBatch Boolean indicating whether the encoded message represents a batch of messages or not\n   * @return {Promise<Delivery>} Promise<Delivery>\n   */\n  private _trySend(\n    encodedMessage: Buffer,\n    sendBatch: boolean,\n    options: OperationOptionsBase | undefined\n  ): Promise<void> {\n    const abortSignal = options?.abortSignal;\n    const timeoutInMs =\n      this._retryOptions.timeoutInMs == undefined\n        ? Constants.defaultOperationTimeoutInMs\n        : this._retryOptions.timeoutInMs;\n\n    const sendEventPromise = () =>\n      new Promise<void>(async (resolve, reject) => {\n        const initStartTime = Date.now();\n        if (!this.isOpen()) {\n          try {\n            await waitForTimeoutOrAbortOrResolve({\n              actionFn: () => this.open(undefined, options?.abortSignal),\n              abortSignal: options?.abortSignal,\n              timeoutMs: timeoutInMs,\n              timeoutMessage:\n                `[${this._context.connectionId}] Sender \"${this.name}\" ` +\n                `with address \"${this.address}\", was not able to send the message right now, due ` +\n                `to operation timeout.`\n            });\n          } catch (err) {\n            err = translateServiceBusError(err);\n            logger.logError(\n              err,\n              \"%s An error occurred while creating the sender\",\n              this.logPrefix,\n              this.name\n            );\n            return reject(err);\n          }\n        }\n\n        try {\n          const timeTakenByInit = Date.now() - initStartTime;\n\n          logger.verbose(\n            \"%s Sender '%s', credit: %d available: %d\",\n            this.logPrefix,\n            this.name,\n            this.link?.credit,\n            this.link?.session?.outgoing?.available()\n          );\n\n          if (!this.link?.sendable()) {\n            logger.verbose(\n              \"%s Sender '%s', waiting for 1 second for sender to become sendable\",\n              this.logPrefix,\n              this.name\n            );\n\n            await delay(1000);\n\n            logger.verbose(\n              \"%s Sender '%s' after waiting for a second, credit: %d available: %d\",\n              this.logPrefix,\n              this.name,\n              this.link?.credit,\n              this.link?.session?.outgoing?.available()\n            );\n          }\n          if (this.link?.sendable()) {\n            if (timeoutInMs <= timeTakenByInit) {\n              const desc: string =\n                `${this.logPrefix} Sender \"${this.name}\" ` +\n                `with address \"${this.address}\", was not able to send the message right now, due ` +\n                `to operation timeout.`;\n              logger.warning(desc);\n              const e: AmqpError = {\n                condition: ErrorNameConditionMapper.ServiceUnavailableError,\n                description: desc\n              };\n              return reject(translateServiceBusError(e));\n            }\n            try {\n              this.link.sendTimeoutInSeconds = (timeoutInMs - timeTakenByInit) / 1000;\n              const delivery = await this.link!.send(\n                encodedMessage,\n                undefined,\n                sendBatch ? 0x80013700 : 0\n              );\n              logger.verbose(\n                \"%s Sender '%s', sent message with delivery id: %d\",\n                this.logPrefix,\n                this.name,\n                delivery.id\n              );\n              return resolve();\n            } catch (error) {\n              error = translateServiceBusError(error.innerError || error);\n              logger.logError(\n                error,\n                `${this.logPrefix} An error occurred while sending the message`\n              );\n              return reject(error);\n            }\n          } else {\n            // let us retry to send the message after some time.\n            const msg =\n              `[${this.logPrefix}] Sender \"${this.name}\", ` +\n              `cannot send the message right now. Please try later.`;\n            logger.warning(msg);\n            const amqpError: AmqpError = {\n              condition: ErrorNameConditionMapper.SenderBusyError,\n              description: msg\n            };\n            reject(translateServiceBusError(amqpError));\n          }\n        } catch (err) {\n          reject(err);\n        }\n      });\n\n    const config: RetryConfig<void> = {\n      operation: sendEventPromise,\n      connectionId: this._context.connectionId!,\n      operationType: RetryOperationType.sendMessage,\n      retryOptions: this._retryOptions,\n      abortSignal: abortSignal\n    };\n\n    return retry<void>(config);\n  }\n\n  protected async createRheaLink(options: AwaitableSenderOptions): Promise<AwaitableSender> {\n    const sender = await this._context.connection.createAwaitableSender(options);\n    sender.setMaxListeners(1000);\n    return sender;\n  }\n\n  /**\n   * Initializes the sender session on the connection.\n   */\n  public async open(\n    options?: AwaitableSenderOptions,\n    abortSignal?: AbortSignalLike\n  ): Promise<void> {\n    try {\n      if (!options) {\n        options = this._createSenderOptions(Constants.defaultOperationTimeoutInMs);\n      }\n      await this.initLink(options, abortSignal);\n    } catch (err) {\n      err = translateServiceBusError(err);\n      logger.logError(err, `${this.logPrefix} An error occurred while creating the sender`);\n      // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.\n      if ((err as MessagingError).code === \"OperationTimeoutError\") {\n        err.message = \"Failed to create a sender within allocated time and retry attempts.\";\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Closes the rhea link.\n   * To be called when connection is disconnected, onAmqpClose and onSessionClose events.\n   * @returns {Promise<void>} Promise<void>.\n   */\n  async onDetached(): Promise<void> {\n    // Clears the token renewal timer. Closes the link and its session if they are open.\n    // Removes the link and its session if they are present in rhea's cache.\n    await this.closeLink();\n  }\n\n  /**\n   * Determines whether the AMQP sender link is open. If open then returns true else returns false.\n   * @return {boolean} boolean\n   */\n  isOpen(): boolean {\n    const result: boolean = this.link == null ? false : this.link.isOpen();\n    logger.verbose(\n      \"%s Sender '%s' with address '%s' is open? -> %s\",\n      this.logPrefix,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Sends the given message, with the given options on this link\n   *\n   * @param {ServiceBusMessage} data Message to send.  Will be sent as UTF8-encoded JSON string.\n   * @returns {Promise<void>}\n   */\n  async send(data: ServiceBusMessage, options?: OperationOptionsBase): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const amqpMessage = toRheaMessage(data);\n      amqpMessage.body = defaultDataTransformer.encode(data.body);\n\n      // TODO: this body of logic is really similar to what's in sendMessages. Unify what we can.\n      let encodedMessage;\n      try {\n        encodedMessage = RheaMessageUtil.encode(amqpMessage);\n      } catch (error) {\n        if (error instanceof TypeError || error.name === \"TypeError\") {\n          // `RheaMessageUtil.encode` can fail if message properties are of invalid type\n          // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too\n          // Errors in such cases do not have user-friendly message or call stack\n          // So use `getMessagePropertyTypeMismatchError` to get a better error message\n          throw getMessagePropertyTypeMismatchError(data) || error;\n        }\n        throw error;\n      }\n      logger.verbose(\"%s Sender '%s', trying to send message: %O\", this.logPrefix, this.name, data);\n      return await this._trySend(encodedMessage, false, options);\n    } catch (err) {\n      logger.logError(\n        err,\n        \"%s An error occurred while sending the message: %O\\nError\",\n        this.logPrefix,\n        data\n      );\n      throw err;\n    }\n  }\n\n  // Not exposed to the users\n  /**\n   * Send a batch of Message to the ServiceBus in a single AMQP message. The \"message_annotations\",\n   * \"application_properties\" and \"properties\" of the first message will be set as that\n   * of the envelope (batch message).\n   * @param {Array<Message>} inputMessages  An array of Message objects to be sent in a\n   * Batch message.\n   * @return {Promise<void>}\n   */\n  async sendMessages(\n    inputMessages: ServiceBusMessage[],\n    options?: OperationOptionsBase\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      if (!Array.isArray(inputMessages)) {\n        inputMessages = [inputMessages];\n      }\n      logger.verbose(\n        \"%s Sender '%s', trying to send Message[]: %O\",\n        this.logPrefix,\n        this.name,\n        inputMessages\n      );\n      const amqpMessages: RheaMessage[] = [];\n      const encodedMessages = [];\n      // Convert Message to AmqpMessage.\n      for (let i = 0; i < inputMessages.length; i++) {\n        const amqpMessage = toRheaMessage(inputMessages[i]);\n        amqpMessage.body = defaultDataTransformer.encode(inputMessages[i].body);\n        amqpMessages[i] = amqpMessage;\n        try {\n          encodedMessages[i] = RheaMessageUtil.encode(amqpMessage);\n        } catch (error) {\n          if (error instanceof TypeError || error.name === \"TypeError\") {\n            throw getMessagePropertyTypeMismatchError(inputMessages[i]) || error;\n          }\n          throw error;\n        }\n      }\n\n      // Convert every encoded message to amqp data section\n      const batchMessage: RheaMessage = {\n        body: RheaMessageUtil.data_sections(encodedMessages)\n      };\n      // Set message_annotations, application_properties and properties of the first message as\n      // that of the envelope (batch message).\n      if (amqpMessages[0].message_annotations) {\n        batchMessage.message_annotations = amqpMessages[0].message_annotations;\n      }\n      if (amqpMessages[0].application_properties) {\n        batchMessage.application_properties = amqpMessages[0].application_properties;\n      }\n      for (const prop of messageProperties) {\n        if ((amqpMessages[0] as any)[prop]) {\n          (batchMessage as any)[prop] = (amqpMessages[0] as any)[prop];\n        }\n      }\n\n      // Finally encode the envelope (batch message).\n      const encodedBatchMessage = RheaMessageUtil.encode(batchMessage);\n\n      logger.verbose(\n        \"%s Sender '%s', sending encoded batch message.\",\n        this.logPrefix,\n        this.name,\n        encodedBatchMessage\n      );\n      return await this._trySend(encodedBatchMessage, true, options);\n    } catch (err) {\n      logger.logError(\n        err,\n        \"%s Sender '%s': An error occurred while sending the messages: %O\\nError\",\n        this.logPrefix,\n        this.name,\n        inputMessages\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Returns maximum message size on the AMQP sender link.\n   *\n   * Options to configure the `createBatch` method on the `Sender`.\n   * - `maxSizeInBytes`: The upper limit for the size of batch.\n   *\n   * Example usage:\n   * ```js\n   * {\n   *     retryOptions: { maxRetries: 5; timeoutInMs: 10 }\n   * }\n   * ```\n   * @param {{retryOptions?: RetryOptions}} [options={}]\n   * @returns {Promise<number>}\n   */\n  async getMaxMessageSize(\n    options: {\n      retryOptions?: RetryOptions;\n    } & Pick<OperationOptionsBase, \"abortSignal\"> = {}\n  ): Promise<number> {\n    const retryOptions = options.retryOptions || {};\n    if (this.isOpen()) {\n      return this.link!.maxMessageSize;\n    }\n    return new Promise<number>(async (resolve, reject) => {\n      try {\n        const config: RetryConfig<void> = {\n          operation: () => this.open(undefined, options?.abortSignal),\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.senderLink,\n          retryOptions: retryOptions,\n          abortSignal: options?.abortSignal\n        };\n\n        await retry<void>(config);\n\n        return resolve(this.link!.maxMessageSize);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }\n\n  async createBatch(options?: CreateMessageBatchOptions): Promise<ServiceBusMessageBatch> {\n    throwErrorIfConnectionClosed(this._context);\n    let maxMessageSize = await this.getMaxMessageSize({\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    });\n    if (options?.maxSizeInBytes) {\n      if (options.maxSizeInBytes > maxMessageSize!) {\n        const error = new Error(\n          `Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`\n        );\n        throw error;\n      }\n      maxMessageSize = options.maxSizeInBytes;\n    }\n    return new ServiceBusMessageBatchImpl(this._context, maxMessageSize!);\n  }\n\n  async sendBatch(\n    batchMessage: ServiceBusMessageBatch,\n    options?: OperationOptionsBase\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      logger.verbose(\n        \"%s Sender '%s', sending encoded batch message.\",\n        this.logPrefix,\n        this.name,\n        batchMessage\n      );\n      return await this._trySend(batchMessage._generateMessage(), true, options);\n    } catch (err) {\n      logger.logError(\n        err,\n        \"%s Sender '%s': An error occurred while sending the messages: %O\\nError\",\n        this.logPrefix,\n        this.name,\n        batchMessage\n      );\n      throw err;\n    }\n  }\n\n  static create(\n    context: ConnectionContext,\n    entityPath: string,\n    retryOptions: RetryOptions\n  ): MessageSender {\n    throwErrorIfConnectionClosed(context);\n\n    const sbSender = new MessageSender(context, entityPath, retryOptions);\n    context.senders[sbSender.name] = sbSender;\n    return sbSender;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport Long from \"long\";\nimport { MessageSender } from \"./core/messageSender\";\nimport { ServiceBusMessage } from \"./serviceBusMessage\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport {\n  getSenderClosedErrorMsg,\n  throwErrorIfConnectionClosed,\n  throwIfNotValidServiceBusMessage,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong\n} from \"./util/errors\";\nimport { ServiceBusMessageBatch } from \"./serviceBusMessageBatch\";\nimport { CreateMessageBatchOptions } from \"./models\";\nimport { RetryConfig, RetryOperationType, RetryOptions, retry } from \"@azure/core-amqp\";\nimport {\n  createSendSpan,\n  getParentSpan,\n  OperationOptionsBase\n} from \"./modelsToBeSharedWithEventHubs\";\nimport { CanonicalCode } from \"@opentelemetry/api\";\nimport { senderLogger as logger } from \"./log\";\nimport { ServiceBusError } from \"./serviceBusError\";\n\n/**\n * A Sender can be used to send messages, schedule messages to be sent at a later time\n * and cancel such scheduled messages.\n * Use the `createSender` function on the ServiceBusClient to instantiate a Sender.\n * The Sender class is an abstraction over the underlying AMQP sender link.\n */\nexport interface ServiceBusSender {\n  /**\n   * Sends the given messages after creating an AMQP Sender link if it doesn't already exist.\n   *\n   * - To send messages to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`\n   * and/or `partitionKey` properties respectively on the messages.\n   * - All messages passed to the same sendMessages() call should have the same `sessionId` (if using\n   *  sessions) and the same `partitionKey` (if using partitions).\n   *\n   * @param messages - A single message or an array of messages or a batch of messages created via the createBatch()\n   * method to send.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @return Promise<void>\n   * @throws `ServiceBusError` with the code `MessageSizeExceeded` if the provided messages do not fit in a single `ServiceBusMessageBatch`.\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws `ServiceBusError` if the service returns an error while sending messages to the service.\n   */\n  sendMessages(\n    messages: ServiceBusMessage | ServiceBusMessage[] | ServiceBusMessageBatch,\n    options?: OperationOptionsBase\n  ): Promise<void>;\n\n  /**\n   * Creates an instance of `ServiceBusMessageBatch` to which one can add messages until the maximum supported size is reached.\n   * The batch can be passed to the {@link send} method to send the messages to Azure Service Bus.\n   * @param options  Configures the behavior of the batch.\n   * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   *\n   * @param {CreateMessageBatchOptions} [options]\n   * @returns {Promise<ServiceBusMessageBatch>}\n   * @throws `ServiceBusError` if an error is encountered while sending a message.\n   * @throws Error if the underlying connection or sender has been closed.\n   */\n  createMessageBatch(options?: CreateMessageBatchOptions): Promise<ServiceBusMessageBatch>;\n\n  // TODO: Commented out to come up with an alternative name\n  // /**\n  //  * Opens the AMQP link to Azure Service Bus from the sender.\n  //  *\n  //  * It is not necessary to call this method in order to use the sender. It is\n  //  * recommended to call this before your first sendMessages() call if you\n  //  * want to front load the work of setting up the AMQP link to the service.\n  //  *\n  //  * @param options - Options to configure tracing and the abortSignal.\n  //  */\n  // open(options?: OperationOptionsBase): Promise<void>;\n\n  /**\n   * @property Returns `true` if either the sender or the client that created it has been closed.\n   * @readonly\n   */\n  isClosed: boolean;\n\n  /**\n   * Schedules given messages to appear on Service Bus Queue/Subscription at a later time.\n   *\n   * @param messages - Message or an array of messages that need to be scheduled.\n   * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns Promise<Long[]> - The sequence numbers of messages that were scheduled.\n   * You will need the sequence number if you intend to cancel the scheduling of the messages.\n   * Save the `Long` type as-is in your application without converting to number. Since JavaScript\n   * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws `ServiceBusError` if the service returns an error while scheduling messages.\n   */\n  scheduleMessages(\n    messages: ServiceBusMessage | ServiceBusMessage[],\n    scheduledEnqueueTimeUtc: Date,\n    options?: OperationOptionsBase\n  ): Promise<Long[]>;\n\n  /**\n   * Cancels multiple messages that were scheduled to appear on a ServiceBus Queue/Subscription.\n   * @param sequenceNumbers - Sequence number or an array of sequence numbers of the messages to be cancelled.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws `ServiceBusError` if the service returns an error while canceling scheduled messages.\n   */\n  cancelScheduledMessages(\n    sequenceNumbers: Long | Long[],\n    options?: OperationOptionsBase\n  ): Promise<void>;\n  /**\n   * Path of the entity for which the sender has been created.\n   */\n  entityPath: string;\n  /**\n   * Closes the underlying AMQP sender link.\n   * Once closed, the sender cannot be used for any further operations.\n   * Use the `createSender` function on the QueueClient or TopicClient to instantiate a new Sender\n   *\n   * @returns {Promise<void>}\n   */\n  close(): Promise<void>;\n}\n\n/**\n * @internal\n * @hidden\n * @class ServiceBusSenderImpl\n * @implements {ServiceBusSender}\n */\nexport class ServiceBusSenderImpl implements ServiceBusSender {\n  private _retryOptions: RetryOptions;\n  /**\n   * @property Denotes if close() was called on this sender\n   */\n  private _isClosed: boolean = false;\n  private _sender: MessageSender;\n  public entityPath: string;\n\n  private get logPrefix() {\n    return `[${this._context.connectionId}|sender:${this.entityPath}]`;\n  }\n\n  /**\n   * @internal\n   * @throws Error if the underlying connection is closed.\n   */\n  constructor(\n    private _context: ConnectionContext,\n    private _entityPath: string,\n    retryOptions: RetryOptions = {}\n  ) {\n    throwErrorIfConnectionClosed(_context);\n    this.entityPath = _entityPath;\n    this._sender = MessageSender.create(this._context, _entityPath, retryOptions);\n    this._retryOptions = retryOptions;\n  }\n\n  private _throwIfSenderOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (this.isClosed) {\n      const errorMessage = getSenderClosedErrorMsg(this._entityPath);\n      const error = new Error(errorMessage);\n      logger.logError(error, `[${this._context.connectionId}] is closed`);\n      throw error;\n    }\n  }\n\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.wasConnectionCloseCalled;\n  }\n\n  async sendMessages(\n    messages: ServiceBusMessage | ServiceBusMessage[] | ServiceBusMessageBatch,\n    options?: OperationOptionsBase\n  ): Promise<void> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"messages\", messages);\n    const invalidTypeErrMsg =\n      \"Provided value for 'messages' must be of type ServiceBusMessage, ServiceBusMessageBatch or an array of type ServiceBusMessage.\";\n\n    let batch: ServiceBusMessageBatch;\n    if (isServiceBusMessageBatch(messages)) {\n      batch = messages;\n    } else {\n      if (!Array.isArray(messages)) {\n        messages = [messages];\n      }\n      batch = await this.createMessageBatch(options);\n      for (const message of messages) {\n        throwIfNotValidServiceBusMessage(message, invalidTypeErrMsg);\n        if (!batch.tryAddMessage(message, { parentSpan: getParentSpan(options?.tracingOptions) })) {\n          // this is too big - throw an error\n          throw new ServiceBusError(\n            \"Messages were too big to fit in a single batch. Remove some messages and try again or create your own batch using createBatch(), which gives more fine-grained control.\",\n            \"MessageSizeExceeded\"\n          );\n        }\n      }\n    }\n\n    const sendSpan = createSendSpan(\n      getParentSpan(options?.tracingOptions),\n      batch._messageSpanContexts,\n      this.entityPath,\n      this._context.config.host\n    );\n\n    try {\n      const result = await this._sender.sendBatch(batch, options);\n      sendSpan.setStatus({ code: CanonicalCode.OK });\n      return result;\n    } catch (error) {\n      sendSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: error.message\n      });\n      throw error;\n    } finally {\n      sendSpan.end();\n    }\n  }\n\n  async createMessageBatch(options?: CreateMessageBatchOptions): Promise<ServiceBusMessageBatch> {\n    this._throwIfSenderOrConnectionClosed();\n    return this._sender.createBatch(options);\n  }\n\n  async scheduleMessages(\n    messages: ServiceBusMessage | ServiceBusMessage[],\n    scheduledEnqueueTimeUtc: Date,\n    options: OperationOptionsBase = {}\n  ): Promise<Long[]> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"scheduledEnqueueTimeUtc\",\n      scheduledEnqueueTimeUtc\n    );\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"messages\", messages);\n    const messagesToSchedule = Array.isArray(messages) ? messages : [messages];\n\n    for (const message of messagesToSchedule) {\n      throwIfNotValidServiceBusMessage(\n        message,\n        \"Provided value for 'messages' must be of type ServiceBusMessage or an array of type ServiceBusMessage.\"\n      );\n    }\n\n    const scheduleMessageOperationPromise = async () => {\n      return this._context\n        .getManagementClient(this._entityPath)\n        .scheduleMessages(scheduledEnqueueTimeUtc, messagesToSchedule, {\n          ...options,\n          associatedLinkName: this._sender.name,\n          requestName: \"scheduleMessages\",\n          timeoutInMs: this._retryOptions.timeoutInMs\n        });\n    };\n    const config: RetryConfig<Long[]> = {\n      operation: scheduleMessageOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    };\n    return retry<Long[]>(config);\n  }\n\n  async cancelScheduledMessages(\n    sequenceNumbers: Long | Long[],\n    options: OperationOptionsBase = {}\n  ): Promise<void> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n    throwTypeErrorIfParameterNotLong(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n\n    const sequenceNumbersToCancel = Array.isArray(sequenceNumbers)\n      ? sequenceNumbers\n      : [sequenceNumbers];\n    const cancelSchedulesMessagesOperationPromise = async () => {\n      return this._context.getManagementClient(this._entityPath).cancelScheduledMessages(\n        sequenceNumbersToCancel,\n\n        {\n          ...options,\n          associatedLinkName: this._sender.name,\n          requestName: \"cancelScheduledMessages\",\n          timeoutInMs: this._retryOptions.timeoutInMs\n        }\n      );\n    };\n    const config: RetryConfig<void> = {\n      operation: cancelSchedulesMessagesOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal\n    };\n    return retry<void>(config);\n  }\n\n  // async open(options?: OperationOptionsBase): Promise<void> {\n  //   this._throwIfSenderOrConnectionClosed();\n\n  //   const config: RetryConfig<void> = {\n  //     // TODO: Pass tracing options too\n  //     operation: () => this._sender.open(undefined, options?.abortSignal),\n  //     connectionId: this._context.connectionId,\n  //     operationType: RetryOperationType.senderLink,\n  //     retryOptions: this._retryOptions,\n  //     abortSignal: options?.abortSignal\n  //   };\n\n  //   return retry<void>(config);\n  // }\n\n  async close(): Promise<void> {\n    try {\n      this._isClosed = true;\n      await this._sender.close();\n    } catch (err) {\n      logger.logError(err, `${this.logPrefix} An error occurred while closing the Sender`);\n      throw err;\n    }\n  }\n}\n\n/**\n * @internal\n * @hidden\n */\nexport function isServiceBusMessageBatch(\n  messageBatchOrAnything: any\n): messageBatchOrAnything is ServiceBusMessageBatch {\n  if (messageBatchOrAnything == null) {\n    return false;\n  }\n\n  const possibleBatch = messageBatchOrAnything as ServiceBusMessageBatch;\n\n  return (\n    typeof possibleBatch.tryAddMessage === \"function\" &&\n    typeof possibleBatch.maxSizeInBytes === \"number\" &&\n    typeof possibleBatch.sizeInBytes === \"number\"\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants, ErrorNameConditionMapper, MessagingError } from \"@azure/core-amqp\";\nimport {\n  AmqpError,\n  EventContext,\n  OnAmqpEvent,\n  Receiver,\n  ReceiverEvents,\n  ReceiverOptions\n} from \"rhea-promise\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { LinkEntity } from \"../core/linkEntity\";\nimport { DispositionStatusOptions } from \"../core/managementClient\";\nimport { OnAmqpEventAsPromise, OnError, OnMessage } from \"../core/messageReceiver\";\nimport { receiverLogger as logger } from \"../log\";\nimport { DispositionType, ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport {\n  calculateRenewAfterDuration,\n  convertTicksToDate,\n  StandardAbortMessage\n} from \"../util/utils\";\nimport { BatchingReceiverLite, MinimalReceiver } from \"../core/batchingReceiver\";\nimport { onMessageSettled, DeferredPromiseAndTimer, createReceiverOptions } from \"../core/shared\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { ReceiverHelper } from \"../core/receiverHelper\";\nimport {\n  ServiceBusSessionReceiverOptions,\n  ProcessErrorArgs,\n  ReceiveMode,\n  SubscribeOptions\n} from \"../models\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { abandonMessage, completeMessage } from \"../receivers/shared\";\n\n/**\n * Describes the options that need to be provided while creating a message session receiver link.\n * @internal\n * @hidden\n */\nexport interface CreateMessageSessionReceiverLinkOptions {\n  onClose: OnAmqpEventAsPromise;\n  onSessionClose: OnAmqpEventAsPromise;\n  onError: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSettled: OnAmqpEvent;\n  sessionId?: string;\n}\n\n/**\n * @internal\n * @hidden\n * Describes all the options that can be set while instantiating a MessageSession object.\n */\nexport type MessageSessionOptions = Pick<\n  ServiceBusSessionReceiverOptions,\n  \"maxAutoLockRenewalDurationInMs\" | \"abortSignal\"\n> & {\n  receiveMode?: ReceiveMode;\n};\n\n/**\n * @internal\n * @hidden\n * Describes the receiver for a Message Session.\n */\nexport class MessageSession extends LinkEntity<Receiver> {\n  /**\n   * @property {Date} [sessionLockedUntilUtc] Provides the duration until which the session is locked.\n   */\n  sessionLockedUntilUtc!: Date;\n  /**\n   * @property {string} [sessionId] The sessionId for the message session. Empty string is valid sessionId.\n   */\n  sessionId!: string;\n  /**\n   * @property {number} [maxConcurrentSessions] The maximum number of concurrent sessions that the\n   * client should initiate.\n   * - **Default**: `1`.\n   */\n  maxConcurrentSessions?: number;\n  /**\n   * @property {number} [maxConcurrentCalls] The maximum number of messages that should be\n   * processed concurrently in a session while in streaming mode. Once this limit has been reached,\n   * more messages will not be received until the user's message handler has completed processing current message.\n   * - **Default**: `1` (message in a session at a time).\n   */\n  maxConcurrentCalls: number = 1;\n  /**\n   * @property {number} [receiveMode] The mode in which messages should be received.\n   * Default: ReceiveMode.peekLock\n   */\n  receiveMode: ReceiveMode;\n  /**\n   * @property {boolean} autoComplete Indicates whether `Message.complete()` should be called\n   * automatically after the message processing is complete while receiving messages with handlers.\n   * Default: false.\n   */\n  autoComplete: boolean;\n  /**\n   * @property {number} maxAutoRenewDurationInMs The maximum duration within which the\n   * lock will be renewed automatically. This value should be greater than the longest message\n   * lock duration; for example, the `lockDuration` property on the received message.\n   *\n   * Default: `300 * 1000` (5 minutes);\n   */\n  maxAutoRenewDurationInMs: number;\n  /**\n   * @property {boolean} autoRenewLock Should lock renewal happen automatically.\n   */\n  autoRenewLock: boolean;\n  /**\n   * Denotes if we are currently receiving messages\n   */\n  get isReceivingMessages(): boolean {\n    return this._batchingReceiverLite.isReceivingMessages || this._isReceivingMessagesForSubscriber;\n  }\n\n  private _batchingReceiverLite: BatchingReceiverLite;\n  private _isReceivingMessagesForSubscriber: boolean;\n\n  /**\n   * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that\n   * are being actively disposed. It acts as a store for correlating the responses received for\n   * active dispositions.\n   */\n  private _deliveryDispositionMap: Map<number, DeferredPromiseAndTimer> = new Map<\n    number,\n    DeferredPromiseAndTimer\n  >();\n  /**\n   * @property {OnMessage} _onMessage The message handler provided by the user that will\n   * be wrapped inside _onAmqpMessage.\n   */\n  private _onMessage!: OnMessage;\n  /**\n   * @property {OnError} _onError The error handler provided by the user that will be wrapped\n   * inside _onAmqpError.\n   */\n  private _onError?: OnError;\n  /**\n   * @property {OnError} _notifyError If the user provided error handler is present then it will\n   * notify the user's error handler about the error.\n   */\n  private _notifyError: OnError;\n  /**\n   * @property {OnAmqpEventAsPromise} _onAmqpClose The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_close\" event.\n   */\n  private _onAmqpClose: OnAmqpEventAsPromise;\n  /**\n   * @property {OnAmqpEvent} _onSessionError The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEventAsPromise} _onSessionClose The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEventAsPromise;\n  /**\n   * @property {OnAmqpEvent} _onAmqpError The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_error\" event.\n   */\n  private _onAmqpError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onSettled The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"settled\" event.\n   */\n  private _onSettled: OnAmqpEvent;\n  /**\n   * @property {NodeJS.Timer} _sessionLockRenewalTimer The session lock renewal timer that keeps\n   * track of when the MessageSession is due for session lock renewal.\n   */\n  private _sessionLockRenewalTimer?: NodeJS.Timer;\n\n  private _totalAutoLockRenewDuration: number;\n\n  public get receiverHelper(): ReceiverHelper {\n    return this._receiverHelper;\n  }\n  private _receiverHelper: ReceiverHelper;\n\n  /**\n   * Ensures that the session lock is renewed before it expires. The lock will not be renewed for\n   * more than the configured totalAutoLockRenewDuration.\n   */\n  private _ensureSessionLockRenewal(): void {\n    if (\n      this.autoRenewLock &&\n      new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc! &&\n      Date.now() < this._totalAutoLockRenewDuration &&\n      this.isOpen()\n    ) {\n      const nextRenewalTimeout = calculateRenewAfterDuration(this.sessionLockedUntilUtc!);\n      this._sessionLockRenewalTimer = setTimeout(async () => {\n        try {\n          logger.verbose(\n            \"%s Attempting to renew the session lock for MessageSession '%s' \" + \"with name '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n            this.name\n          );\n          this.sessionLockedUntilUtc = await this._context\n            .getManagementClient(this.entityPath)\n            .renewSessionLock(this.sessionId, {\n              associatedLinkName: this.name,\n              timeoutInMs: 10000\n            });\n          logger.verbose(\n            \"%s Successfully renewed the session lock for MessageSession '%s' \" + \"with name '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n            this.name\n          );\n          logger.verbose(\n            \"%s Calling _ensureSessionLockRenewal() again for MessageSession '%s'.\",\n            this.logPrefix,\n            this.sessionId\n          );\n          this._ensureSessionLockRenewal();\n        } catch (err) {\n          logger.logError(\n            err,\n            \"%s An error occurred while renewing the session lock for MessageSession '%s'\",\n            this.logPrefix,\n            this.sessionId\n          );\n        }\n      }, nextRenewalTimeout);\n      logger.verbose(\n        \"%s MessageSession '%s' has next session lock renewal in %d milliseconds @(%s).\",\n        this.logPrefix,\n        this.sessionId,\n        nextRenewalTimeout,\n        new Date(Date.now() + nextRenewalTimeout).toString()\n      );\n    }\n  }\n\n  protected createRheaLink(\n    options: ReceiverOptions,\n    _abortSignal?: AbortSignalLike\n  ): Promise<Receiver> {\n    return this._context.connection.createReceiver(options);\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   */\n  private async _init(abortSignal?: AbortSignalLike): Promise<void> {\n    try {\n      const options = this._createMessageSessionOptions();\n      await this.initLink(options, abortSignal);\n\n      if (this.link == null) {\n        throw new Error(\"INTERNAL ERROR: failed to create receiver but without an error.\");\n      }\n\n      const receivedSessionId =\n        this.link.source &&\n        this.link.source.filter &&\n        this.link.source.filter[Constants.sessionFilterName];\n\n      let errorMessage: string = \"\";\n\n      if (this._providedSessionId == null && receivedSessionId == null) {\n        // Ideally this code path should never be reached as `MessageSession.createReceiver()` should fail instead\n        // TODO: https://github.com/Azure/azure-sdk-for-js/issues/9775 to figure out why this code path indeed gets hit.\n        errorMessage = `Failed to create a receiver. No unlocked sessions available.`;\n      } else if (this._providedSessionId != null && receivedSessionId !== this._providedSessionId) {\n        // This code path is reached if the session is already locked by another receiver.\n        // TODO: Check why the service would not throw an error or just timeout instead of giving a misleading successful receiver\n        errorMessage = `Failed to create a receiver for the requested session '${this._providedSessionId}'. It may be locked by another receiver.`;\n      }\n\n      if (errorMessage) {\n        const error = translateServiceBusError({\n          description: errorMessage,\n          condition: ErrorNameConditionMapper.SessionCannotBeLockedError\n        });\n        logger.logError(error, this.logPrefix);\n        throw error;\n      }\n      if (this._providedSessionId == null) this.sessionId = receivedSessionId;\n      this.sessionLockedUntilUtc = convertTicksToDate(\n        this.link.properties[\"com.microsoft:locked-until-utc\"]\n      );\n      logger.verbose(\n        \"%s Session with id '%s' is locked until: '%s'.\",\n        this.logPrefix,\n        this.sessionId,\n        this.sessionLockedUntilUtc.toISOString()\n      );\n      logger.verbose(\"%s Receiver created with receiver options: %O\", this.logPrefix, options);\n      if (!this._context.messageSessions[this.name]) {\n        this._context.messageSessions[this.name] = this;\n      }\n      this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;\n      this._ensureSessionLockRenewal();\n    } catch (err) {\n      const errObj = translateServiceBusError(err);\n      logger.logError(errObj, \"%s An error occured while creating the receiver\", this.logPrefix);\n\n      // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.\n      if ((errObj as MessagingError).code === \"OperationTimeoutError\") {\n        if (this._providedSessionId) {\n          errObj.message = `Failed to create a receiver for the requested session '${this._providedSessionId}' within allocated time and retry attempts.`;\n        } else {\n          errObj.message = \"Failed to create a receiver within allocated time and retry attempts.\";\n        }\n      }\n      throw errObj;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   */\n  private _createMessageSessionOptions(): ReceiverOptions {\n    const rcvrOptions: ReceiverOptions = createReceiverOptions(\n      this.name,\n      this.receiveMode,\n      {\n        address: this.address,\n        filter: { [Constants.sessionFilterName]: this.sessionId }\n      },\n      {\n        onClose: (context) =>\n          this._onAmqpClose(context).catch(() => {\n            /* */\n          }),\n        onSessionClose: (context) =>\n          this._onSessionClose(context).catch(() => {\n            /* */\n          }),\n        onError: this._onAmqpError,\n        onSessionError: this._onSessionError,\n        onSettled: this._onSettled\n      }\n    );\n\n    return rcvrOptions;\n  }\n\n  /**\n   * Constructs a MessageSession instance which lets you receive messages as batches\n   * or via callbacks using subscribe.\n   *\n   * @param _providedSessionId The sessionId provided by the user. This can be the\n   * name of a session ID to open (empty string is also valid) or it can be undefined,\n   * to indicate we want the next unlocked non-empty session.\n   */\n  constructor(\n    context: ConnectionContext,\n    entityPath: string,\n    private _providedSessionId: string | undefined,\n    options?: MessageSessionOptions\n  ) {\n    super(entityPath, entityPath, context, \"session\", logger, {\n      address: entityPath,\n      audience: `${context.config.endpoint}${entityPath}`\n    });\n    this._receiverHelper = new ReceiverHelper(() => ({\n      receiver: this.link,\n      logPrefix: this.logPrefix\n    }));\n    if (!options) options = {};\n    this.autoComplete = false;\n    if (this._providedSessionId != undefined) this.sessionId = this._providedSessionId;\n    this.receiveMode = options.receiveMode || \"peekLock\";\n    this.maxAutoRenewDurationInMs =\n      options.maxAutoLockRenewalDurationInMs != null\n        ? options.maxAutoLockRenewalDurationInMs\n        : 300 * 1000;\n    this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;\n    this.autoRenewLock = this.maxAutoRenewDurationInMs > 0 && this.receiveMode === \"peekLock\";\n\n    this._isReceivingMessagesForSubscriber = false;\n    this._batchingReceiverLite = new BatchingReceiverLite(\n      context,\n      entityPath,\n      async (_abortSignal?: AbortSignalLike): Promise<MinimalReceiver> => {\n        return this.link!;\n      },\n      this.receiveMode\n    );\n\n    // setting all the handlers\n    this._onSettled = (context: EventContext) => {\n      const delivery = context.delivery;\n\n      onMessageSettled(this.logPrefix, delivery, this._deliveryDispositionMap);\n    };\n\n    this._notifyError = (args: ProcessErrorArgs) => {\n      if (this._onError) {\n        this._onError(args);\n        logger.verbose(\n          \"%s Notified the user's error handler about the error received by the Receiver\",\n          this.logPrefix\n        );\n      }\n    };\n\n    this._onAmqpError = (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        if (sbError.code === \"SessionLockLostError\") {\n          sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;\n        }\n        logger.logError(sbError, \"%s An error occurred for Receiver\", this.logPrefix);\n        this._notifyError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host\n        });\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const connectionId = this._context.connectionId;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError);\n        logger.logError(\n          sbError,\n          \"[%s] An error occurred on the session for Receiver '%s': %O.\",\n          connectionId,\n          this.name,\n          sbError\n        );\n        this._notifyError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host\n        });\n      }\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const connectionId = this._context.connectionId;\n      const receiverError = context.receiver && context.receiver.error;\n      const receiver = this.link || context.receiver!;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        logger.logError(\n          sbError,\n          \"[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. \" +\n            \"The associated error is: %O\",\n          connectionId,\n          this.name,\n          this.sessionId,\n          sbError\n        );\n        // no need to notify the user's error handler since rhea guarantees that receiver_error\n        // will always be emitted before receiver_close.\n      }\n      if (receiver && !receiver.isItselfClosed()) {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver for sessionId '%s' \" +\n            \"and the sdk did not initiate this. Hence, let's gracefully close the receiver.\",\n          this.logPrefix,\n          this.sessionId\n        );\n        try {\n          await this.close();\n        } catch (err) {\n          logger.logError(\n            err,\n            \"%s An error occurred while closing the receiver for sessionId '%s'.\",\n            this.logPrefix,\n            this.sessionId\n          );\n        }\n      } else {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver for sessionId '%s' \" +\n            \"because the sdk initiated it. Hence no need to gracefully close the receiver\",\n          this.logPrefix,\n          this.sessionId\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const receiver = this.link || context.receiver!;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError);\n        logger.logError(\n          sbError,\n          \"%s 'session_close' event occurred for receiver for sessionId '%s'. \" +\n            \"The associated error is\",\n          this.logPrefix,\n          this.sessionId\n        );\n        // no need to notify the user's error handler since rhea guarantees that session_error\n        // will always be emitted before session_close.\n      }\n\n      if (receiver && !receiver.isSessionItselfClosed()) {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the receiver for sessionId '%s' \" +\n            \"and the sdk did not initiate this. Hence, let's gracefully close the receiver.\",\n          this.logPrefix,\n          this.sessionId\n        );\n        try {\n          await this.close();\n        } catch (err) {\n          logger.logError(\n            err,\n            \"%s An error occurred while closing the receiver for sessionId '%s'\",\n            this.logPrefix,\n            this.sessionId\n          );\n        }\n      } else {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the receiver for sessionId'%s' \" +\n            \"because the sdk initiated it. Hence no need to gracefully close the receiver\",\n          this.logPrefix,\n          this.sessionId\n        );\n      }\n    };\n  }\n\n  /**\n   * Closes the underlying AMQP receiver link.\n   */\n  async close(): Promise<void> {\n    try {\n      this._isReceivingMessagesForSubscriber = false;\n      if (this._sessionLockRenewalTimer) clearTimeout(this._sessionLockRenewalTimer);\n      logger.verbose(\n        \"%s Cleared the timers for 'no new message received' task and \" +\n          \"'session lock renewal' task.\",\n        this.logPrefix\n      );\n\n      await super.close();\n\n      await this._batchingReceiverLite.close();\n    } catch (err) {\n      logger.logError(\n        err,\n        \"%s An error occurred while closing the message session with id '%s'\",\n        this.logPrefix,\n        this.sessionId\n      );\n    }\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   */\n  isOpen(): boolean {\n    const result: boolean = this.link! && this.link!.isOpen();\n    logger.verbose(\n      \"%s Receiver for sessionId '%s' is open? -> %s\",\n      this.logPrefix,\n      this.sessionId,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the SessionReceiver or set the property\n   * `newMessageWaitTimeoutInMs` in the options to provide a timeout.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control whether messages should be automatically completed. You can\n   * also provide a timeout in milliseconds to denote the amount of time to wait for a new message\n   * before closing the receiver.\n   *\n   * @returns void\n   */\n  subscribe(onMessage: OnMessage, onError: OnError, options: SubscribeOptions): void {\n    if (!options) options = {};\n\n    if (options.abortSignal?.aborted) {\n      throw new AbortError(StandardAbortMessage);\n    }\n\n    this._isReceivingMessagesForSubscriber = true;\n    if (typeof options.maxConcurrentCalls === \"number\" && options.maxConcurrentCalls > 0) {\n      this.maxConcurrentCalls = options.maxConcurrentCalls;\n    }\n\n    // If explicitly set to false then autoComplete is false else true (default).\n    this.autoComplete =\n      options.autoCompleteMessages === false ? options.autoCompleteMessages : true;\n    this._onMessage = onMessage;\n    this._onError = onError;\n\n    if (this.link && this.link.isOpen()) {\n      const onSessionMessage = async (context: EventContext): Promise<void> => {\n        // If the receiver got closed in PeekLock mode, avoid processing the message as we\n        // cannot settle the message.\n        if (this.receiveMode === \"peekLock\" && (!this.link || !this.link.isOpen())) {\n          logger.verbose(\n            \"%s Not calling the user's message handler for the current message \" +\n              \"as the receiver is closed\",\n            this.logPrefix\n          );\n          return;\n        }\n\n        const bMessage = new ServiceBusMessageImpl(\n          context.message!,\n          context.delivery!,\n          true,\n          this.receiveMode\n        );\n\n        try {\n          await this._onMessage(bMessage);\n        } catch (err) {\n          logger.logError(\n            err,\n            \"%s An error occurred while running user's message handler for the message \" +\n              \"with id '%s' on the receiver\",\n            this.logPrefix,\n            bMessage.messageId\n          );\n          this._onError!({\n            error: err,\n            errorSource: \"processMessageCallback\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host\n          });\n\n          const error = translateServiceBusError(err);\n          // Nothing much to do if user's message handler throws. Let us try abandoning the message.\n          if (\n            !bMessage.delivery.remote_settled &&\n            this.receiveMode === \"peekLock\" &&\n            this.isOpen() // only try to abandon the messages if the connection is still open\n          ) {\n            try {\n              logger.logError(\n                error,\n                \"%s Abandoning the message with id '%s' on the receiver since an error occured\",\n                this.logPrefix,\n                bMessage.messageId\n              );\n              await abandonMessage(bMessage, this._context, this.entityPath);\n            } catch (abandonError) {\n              const translatedError = translateServiceBusError(abandonError);\n              logger.logError(\n                translatedError,\n                \"%s An error occurred while abandoning the message with id '%s' on the \" +\n                  \"receiver\",\n                this.logPrefix,\n                bMessage.messageId,\n                translatedError\n              );\n              this._notifyError({\n                error: translatedError,\n                errorSource: \"abandon\",\n                entityPath: this.entityPath,\n                fullyQualifiedNamespace: this._context.config.host\n              });\n            }\n          }\n          return;\n        } finally {\n          this.receiverHelper.addCredit(1);\n        }\n\n        // If we've made it this far, then user's message handler completed fine. Let us try\n        // completing the message.\n        if (\n          this.autoComplete &&\n          this.receiveMode === \"peekLock\" &&\n          !bMessage.delivery.remote_settled\n        ) {\n          try {\n            logger.verbose(\n              \"%s Auto completing the message with id '%s' on the receiver.\",\n              this.logPrefix,\n              bMessage.messageId\n            );\n            await completeMessage(bMessage, this._context, this.entityPath);\n          } catch (completeError) {\n            const translatedError = translateServiceBusError(completeError);\n            logger.logError(\n              translatedError,\n              \"%s An error occurred while completing the message with id '%s' on the \" + \"receiver\",\n              this.logPrefix,\n              bMessage.messageId\n            );\n            this._notifyError({\n              error: translatedError,\n              errorSource: \"complete\",\n              entityPath: this.entityPath,\n              fullyQualifiedNamespace: this._context.config.host\n            });\n          }\n        }\n      };\n      // setting the \"message\" event listener.\n      this.link.on(ReceiverEvents.message, onSessionMessage);\n      // adding credit\n      this.receiverHelper.addCredit(this.maxConcurrentCalls);\n    } else {\n      this._isReceivingMessagesForSubscriber = false;\n      const msg =\n        `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` +\n        `has either not been created or is not open.`;\n      logger.verbose(\"[%s] %s\", this._context.connectionId, msg);\n      this._notifyError({\n        error: new Error(msg),\n        // This is _probably_ the right error code since we require that\n        // the message session is created before we even give back the receiver. So it not\n        // being open at this point is either:\n        //\n        // 1. we didn't acquire the lock\n        // 2. the connection was broken (we don't reconnect)\n        //\n        // If any of these becomes untrue you'll probably want to re-evaluate this classification.\n        errorSource: \"receive\",\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host\n      });\n    }\n  }\n\n  /**\n   * Returns a batch of messages based on given count and timeout over an AMQP receiver link\n   * from a Queue/Subscription.\n   *\n   * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.\n   * @param maxWaitTimeInMs The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.\n   */\n  async receiveMessages(\n    maxMessageCount: number,\n    maxWaitTimeInMs: number,\n    maxTimeAfterFirstMessageInMs: number,\n    options: OperationOptionsBase\n  ): Promise<ServiceBusMessageImpl[]> {\n    try {\n      return await this._batchingReceiverLite.receiveMessages({\n        maxMessageCount,\n        maxWaitTimeInMs,\n        maxTimeAfterFirstMessageInMs,\n        ...options\n      });\n    } catch (error) {\n      logger.logError(error, `${this.logPrefix} Rejecting receiveMessages() with error`);\n      throw error;\n    }\n  }\n\n  /**\n   * Settles the message with the specified disposition.\n   * @param message The ServiceBus Message that needs to be settled.\n   * @param operation The disposition type.\n   * @param options Optional parameters that can be provided while disposing the message.\n   */\n  async settleMessage(\n    message: ServiceBusMessageImpl,\n    operation: DispositionType,\n    options?: DispositionStatusOptions\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      if (!options) options = {};\n      if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {\n        return reject(new Error(`operation: '${operation}' is not a valid operation.`));\n      }\n      const delivery = message.delivery;\n      const timer = setTimeout(() => {\n        this._deliveryDispositionMap.delete(delivery.id);\n        logger.verbose(\n          \"[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. \" +\n            \"Hence rejecting the promise with timeout error\",\n          this._context.connectionId,\n          delivery.id,\n          Constants.defaultOperationTimeoutInMs\n        );\n\n        const e: AmqpError = {\n          condition: ErrorNameConditionMapper.ServiceUnavailableError,\n          description:\n            \"Operation to settle the message has timed out. The disposition of the \" +\n            \"message may or may not be successful\"\n        };\n        return reject(translateServiceBusError(e));\n      }, Constants.defaultOperationTimeoutInMs);\n      this._deliveryDispositionMap.set(delivery.id, {\n        resolve: resolve,\n        reject: reject,\n        timer: timer\n      });\n      if (operation === DispositionType.complete) {\n        delivery.accept();\n      } else if (operation === DispositionType.abandon) {\n        const params: any = {\n          undeliverable_here: false\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.defer) {\n        const params: any = {\n          undeliverable_here: true\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.deadletter) {\n        const error: AmqpError = {\n          condition: Constants.deadLetterName,\n          info: {\n            ...options.propertiesToModify,\n            DeadLetterReason: options.deadLetterReason,\n            DeadLetterErrorDescription: options.deadLetterDescription\n          }\n        };\n        delivery.reject(error);\n      }\n    });\n  }\n\n  /**\n   * Creates a new instance of the MessageSession based on the provided parameters.\n   * @param context The client entity context\n   * @param options Options that can be provided while creating the MessageSession.\n   */\n  static async create(\n    context: ConnectionContext,\n    entityPath: string,\n    sessionId: string | undefined,\n    options?: MessageSessionOptions\n  ): Promise<MessageSession> {\n    throwErrorIfConnectionClosed(context);\n    const messageSession = new MessageSession(context, entityPath, sessionId, options);\n    await messageSession._init(options?.abortSignal);\n    return messageSession;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionConfig } from \"@azure/core-amqp\";\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport {\n  ServiceBusClientOptions,\n  createConnectionContextForConnectionString,\n  createConnectionContextForTokenCredential\n} from \"./constructorHelpers\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { ServiceBusReceiverOptions, ServiceBusSessionReceiverOptions, ReceiveMode } from \"./models\";\nimport { ServiceBusReceiver, ServiceBusReceiverImpl } from \"./receivers/receiver\";\nimport {\n  ServiceBusSessionReceiver,\n  ServiceBusSessionReceiverImpl\n} from \"./receivers/sessionReceiver\";\nimport { ServiceBusSender, ServiceBusSenderImpl } from \"./sender\";\nimport { entityPathMisMatchError } from \"./util/errors\";\nimport { MessageSession } from \"./session/messageSession\";\n\n/**\n * A client that can create Sender instances for sending messages to queues and\n * topics as well as Receiver instances to receive messages from queues and subscriptions.\n */\nexport class ServiceBusClient {\n  private _connectionContext: ConnectionContext;\n  private _clientOptions: ServiceBusClientOptions;\n  /**\n   * The fully qualified namespace of the Service Bus instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  public fullyQualifiedNamespace: string;\n  /**\n   * Creates an instance of the ServiceBusClient class which can be used to create senders and receivers to\n   * the Azure Service Bus namespace provided in the connection string. No connection is made to the service\n   * until the senders/receivers created with the client are used to send/receive messages.\n   * @param connectionString A connection string for Azure Service Bus namespace.\n   * NOTE: this connection string can contain an EntityPath, which is ignored.\n   * @param options Options for the service bus client.\n   */\n  constructor(connectionString: string, options?: ServiceBusClientOptions);\n  /**\n   * Creates an instance of the ServiceBusClient class which can be used to create senders and receivers to\n   * the Azure Service Bus namespace provided. No connection is made to the service until\n   * the senders/receivers created with the client are used to send/receive messages.\n   * @param fullyQualifiedNamespace The full namespace of your Service Bus instance which is\n   * likely to be similar to <yournamespace>.servicebus.windows.net.\n   * @param credential A credential object used by the client to get the token to authenticate the connection\n   * with the Azure Service Bus. See &commat;azure/identity for creating the credentials.\n   * If you're using an own implementation of the `TokenCredential` interface against AAD, then set the \"scopes\" for service-bus\n   * to be `[\"https://servicebus.azure.net//user_impersonation\"]` to get the appropriate token.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    credential: TokenCredential,\n    options?: ServiceBusClientOptions\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    credentialOrOptions2?: TokenCredential | ServiceBusClientOptions,\n    options3?: ServiceBusClientOptions\n  ) {\n    if (isTokenCredential(credentialOrOptions2)) {\n      const fullyQualifiedNamespace: string = fullyQualifiedNamespaceOrConnectionString1;\n      const credential: TokenCredential = credentialOrOptions2;\n      this._clientOptions = options3 || {};\n\n      this._connectionContext = createConnectionContextForTokenCredential(\n        credential,\n        fullyQualifiedNamespace,\n        this._clientOptions\n      );\n    } else {\n      const connectionString: string = fullyQualifiedNamespaceOrConnectionString1;\n      this._clientOptions = credentialOrOptions2 || {};\n\n      this._connectionContext = createConnectionContextForConnectionString(\n        connectionString,\n        this._clientOptions\n      );\n    }\n    this.fullyQualifiedNamespace = this._connectionContext.config.host;\n    this._clientOptions.retryOptions = this._clientOptions.retryOptions || {};\n\n    const timeoutInMs = this._clientOptions.retryOptions.timeoutInMs;\n    if (\n      timeoutInMs != undefined &&\n      (typeof timeoutInMs !== \"number\" || !isFinite(timeoutInMs) || timeoutInMs <= 0)\n    ) {\n      throw new Error(`${timeoutInMs} is an invalid value for retryOptions.timeoutInMs`);\n    }\n  }\n\n  /**\n   * Creates a receiver for an Azure Service Bus queue. No connection is made\n   * to the service until one of the methods on the receiver is called.\n   *\n   * To target sub queues like the dead letter queue or the transfer dead letter queue, provide the\n   * `subQueue` in the options. To learn more about dead letter queues, see\n   * https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * Messages that are not settled within the lock duration will be redelivered as many times as\n   * the max delivery count set on the queue, after which they get sent to a separate dead letter\n   * queue.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param queueName The name of the queue to receive from.\n   * @param options Options to pass the receiveMode, defaulted to peekLock.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  createReceiver(queueName: string, options?: ServiceBusReceiverOptions): ServiceBusReceiver;\n  /**\n   * Creates a receiver for an Azure Service Bus subscription. No connection is made\n   * to the service until one of the methods on the receiver is called.\n   *\n   * To target sub queues like the dead letter queue or the transfer dead letter queue, provide the\n   * `subQueue` in the options. To learn more about dead letter queues, see\n   * https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * Messages that are not settled within the lock duration will be redelivered as many times as\n   * the max delivery count set on the subscription, after which they get sent to a separate dead letter\n   * queue.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param topicName Name of the topic for the subscription we want to receive from.\n   * @param subscriptionName Name of the subscription (under the `topic`) that we want to receive from.\n   * @param options Options to pass the receiveMode, defaulted to peekLock.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  createReceiver(\n    topicName: string,\n    subscriptionName: string,\n    options?: ServiceBusReceiverOptions\n  ): ServiceBusReceiver;\n  createReceiver(\n    queueOrTopicName1: string,\n    optionsOrSubscriptionName2?: ServiceBusReceiverOptions | string,\n    options3?: ServiceBusReceiverOptions\n  ): ServiceBusReceiver {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName1);\n\n    // NOTE: we don't currently have any options for this kind of receiver but\n    // when we do make sure you pass them in and extract them.\n    const { entityPath, receiveMode, options } = extractReceiverArguments(\n      queueOrTopicName1,\n      optionsOrSubscriptionName2,\n      options3\n    );\n\n    let entityPathWithSubQueue = entityPath;\n    if (options?.subQueueType) {\n      switch (options?.subQueueType) {\n        case \"deadLetter\":\n          entityPathWithSubQueue += \"/$DeadLetterQueue\";\n          break;\n        case \"transferDeadLetter\":\n          entityPathWithSubQueue += \"/$Transfer/$DeadLetterQueue\";\n          break;\n        default:\n          throw new Error(\n            `Invalid subQueueType '${options?.subQueueType}' provided. Valid values are 'deadLetter' and 'transferDeadLetter'`\n          );\n      }\n    }\n\n    const maxLockAutoRenewDurationInMs =\n      options?.maxAutoLockRenewalDurationInMs != null\n        ? options.maxAutoLockRenewalDurationInMs\n        : 5 * 60 * 1000;\n\n    return new ServiceBusReceiverImpl(\n      this._connectionContext,\n      entityPathWithSubQueue,\n      receiveMode,\n      maxLockAutoRenewDurationInMs,\n      this._clientOptions.retryOptions\n    );\n  }\n\n  /**\n   * Creates a receiver for a session enabled Azure Service Bus queue.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param queueName The name of the queue to receive from.\n   * @param sessionId The id of the session from which messages need to be received\n   * @param options Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptSession(\n    queueName: string,\n    sessionId: string,\n    options?: ServiceBusSessionReceiverOptions\n  ): Promise<ServiceBusSessionReceiver>;\n  /**\n   * Creates a receiver for a session enabled Azure Service Bus subscription.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param topicName Name of the topic for the subscription we want to receive from.\n   * @param subscriptionName Name of the subscription (under the `topic`) that we want to receive from.\n   * @param sessionId The id of the session from which messages need to be received\n   * @param options Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptSession(\n    topicName: string,\n    subscriptionName: string,\n    sessionId: string,\n    options?: ServiceBusSessionReceiverOptions\n  ): Promise<ServiceBusSessionReceiver>;\n  async acceptSession(\n    queueOrTopicName1: string,\n    optionsOrSubscriptionNameOrSessionId2?: ServiceBusSessionReceiverOptions | string,\n    optionsOrSessionId3?: ServiceBusSessionReceiverOptions | string,\n    options4?: ServiceBusSessionReceiverOptions\n  ): Promise<ServiceBusSessionReceiver> {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName1);\n\n    let sessionId: string;\n    let entityPath: string;\n    let receiveMode: \"peekLock\" | \"receiveAndDelete\";\n    let options: ServiceBusSessionReceiverOptions | undefined;\n\n    if (\n      typeof queueOrTopicName1 === \"string\" &&\n      typeof optionsOrSubscriptionNameOrSessionId2 === \"string\" &&\n      typeof optionsOrSessionId3 === \"string\"\n    ) {\n      // subscription constructor\n      sessionId = optionsOrSessionId3;\n\n      ({ entityPath, receiveMode, options } = extractReceiverArguments(\n        queueOrTopicName1,\n        optionsOrSubscriptionNameOrSessionId2,\n        // skip the session ID parameter (3)\n        options4\n      ));\n    } else if (\n      typeof queueOrTopicName1 === \"string\" &&\n      typeof optionsOrSubscriptionNameOrSessionId2 === \"string\" &&\n      typeof optionsOrSessionId3 !== \"string\"\n    ) {\n      // queue constructor (but only because we know we're not a subscription constructor)\n      sessionId = optionsOrSubscriptionNameOrSessionId2;\n\n      ({ entityPath, receiveMode, options } = extractReceiverArguments(\n        queueOrTopicName1,\n        // skip the session ID parameter (2)\n        optionsOrSessionId3,\n        undefined\n      ));\n    } else {\n      throw new Error(\"Unhandled set of parameters\");\n    }\n\n    const messageSession = await MessageSession.create(\n      this._connectionContext,\n      entityPath,\n      sessionId,\n      {\n        maxAutoLockRenewalDurationInMs: options?.maxAutoLockRenewalDurationInMs,\n        receiveMode,\n        abortSignal: options?.abortSignal\n      }\n    );\n\n    const sessionReceiver = new ServiceBusSessionReceiverImpl(\n      messageSession,\n      this._connectionContext,\n      entityPath,\n      receiveMode,\n      this._clientOptions.retryOptions\n    );\n\n    return sessionReceiver;\n  }\n\n  /**\n   * Creates a receiver for the next available session in a session-enabled Azure Service Bus queue.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param queueName The name of the queue to receive from.\n   * @param options Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptNextSession(\n    queueName: string,\n    options?: ServiceBusSessionReceiverOptions\n  ): Promise<ServiceBusSessionReceiver>;\n  /**\n   * Creates a receiver for the next available session in a session-enabled Azure Service Bus subscription.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param topicName Name of the topic for the subscription we want to receive from.\n   * @param subscriptionName Name of the subscription (under the `topic`) that we want to receive from.\n   * @param options Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptNextSession(\n    topicName: string,\n    subscriptionName: string,\n    options?: ServiceBusSessionReceiverOptions\n  ): Promise<ServiceBusSessionReceiver>;\n  async acceptNextSession(\n    queueOrTopicName1: string,\n    optionsOrSubscriptionName2?: ServiceBusSessionReceiverOptions | string,\n    options3?: ServiceBusSessionReceiverOptions\n  ): Promise<ServiceBusSessionReceiver> {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName1);\n\n    const { entityPath, receiveMode, options } = extractReceiverArguments(\n      queueOrTopicName1,\n      optionsOrSubscriptionName2,\n      options3\n    );\n\n    const messageSession = await MessageSession.create(\n      this._connectionContext,\n      entityPath,\n      undefined,\n      {\n        maxAutoLockRenewalDurationInMs: options?.maxAutoLockRenewalDurationInMs,\n        receiveMode,\n        abortSignal: options?.abortSignal\n      }\n    );\n\n    const sessionReceiver = new ServiceBusSessionReceiverImpl(\n      messageSession,\n      this._connectionContext,\n      entityPath,\n      receiveMode,\n      this._clientOptions.retryOptions\n    );\n\n    return sessionReceiver;\n  }\n\n  /**\n   * Creates a Sender which can be used to send messages, schedule messages to be\n   * sent at a later time and cancel such scheduled messages. No connection is made\n   * to the service until one of the methods on the sender is called.\n   * @param queueOrTopicName The name of a queue or topic to send messages to.\n   */\n  createSender(queueOrTopicName: string): ServiceBusSender {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName);\n\n    return new ServiceBusSenderImpl(\n      this._connectionContext,\n      queueOrTopicName,\n      this._clientOptions.retryOptions\n    );\n  }\n\n  /**\n   * Closes the underlying AMQP connection.\n   * NOTE: this will also disconnect any Receiver or Sender instances created from this\n   * instance.\n   */\n  close(): Promise<void> {\n    return ConnectionContext.close(this._connectionContext);\n  }\n}\n\n/**\n * Helper to validate and extract the common arguments from both the create*Receiver() overloads that\n * have this pattern:\n *\n * queue, options\n * topic, subscription, options\n *\n * @internal\n * @hidden\n */\nexport function extractReceiverArguments<OptionsT extends { receiveMode?: ReceiveMode }>(\n  queueOrTopicName1: string,\n  optionsOrSubscriptionName2: string | OptionsT | undefined,\n  definitelyOptions3?: OptionsT\n): {\n  entityPath: string;\n  receiveMode: ReceiveMode;\n  options?: Omit<OptionsT, \"receiveMode\">;\n} {\n  let entityPath: string;\n  let options: OptionsT | undefined;\n  if (typeof optionsOrSubscriptionName2 === \"string\") {\n    const topic = queueOrTopicName1;\n    const subscription = optionsOrSubscriptionName2;\n    entityPath = `${topic}/Subscriptions/${subscription}`;\n    options = definitelyOptions3;\n  } else {\n    entityPath = queueOrTopicName1;\n    options = optionsOrSubscriptionName2;\n  }\n  let receiveMode: ReceiveMode;\n  if (options?.receiveMode == undefined || options.receiveMode === \"peekLock\") {\n    receiveMode = \"peekLock\";\n  } else if (options.receiveMode === \"receiveAndDelete\") {\n    receiveMode = \"receiveAndDelete\";\n  } else {\n    throw new TypeError(\n      `Invalid receiveMode '${options?.receiveMode}' provided. Valid values are 'peekLock' and 'receiveAndDelete'`\n    );\n  }\n  delete options?.receiveMode;\n  return {\n    entityPath,\n    receiveMode,\n    options\n  };\n}\n\n/**\n * Validates that the EntityPath in the connection string (if any) matches with the\n * queue or topic name passed to the methods that create senders and receivers.\n *\n * @internal\n * @hidden\n */\nfunction validateEntityPath(connectionConfig: ConnectionConfig, queueOrTopicName: string): void {\n  if (connectionConfig.entityPath && connectionConfig.entityPath !== queueOrTopicName) {\n    throw new Error(entityPathMisMatchError);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { parseConnectionString } from \"@azure/core-amqp\";\n\n/**\n * The set of properties that comprise a Service Bus connection string.\n */\nexport interface ServiceBusConnectionStringProperties {\n  /**\n   * The fully qualified Service Bus namespace extracted from the \"Endpoint\" in the\n   * connection string. This is likely to be similar to \"{yournamespace}.servicebus.windows.net\".\n   * This is typically used to construct the ServiceBusClient.\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The value for \"Endpoint\" in the connection string.\n   */\n  endpoint: string;\n  /**\n   * The value for \"EntityPath\" in the connection string which would be the name of the queue or\n   * topic associated with the connection string.\n   * Connection string from a Shared Access Policy created at the namespace level\n   * will not have the EntityPath in it.\n   */\n  entityPath?: string;\n  /**\n   * The value for \"SharedAccessKey\" in the connection string. This along with the \"SharedAccessKeyName\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKey?: string;\n  /**\n   * The value for \"SharedAccessKeyName\" in the connection string. This along with the \"SharedAccessKey\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKeyName?: string;\n  /**\n   * The value for \"SharedAccessSignature\" in the connection string. This is typically not present in the\n   * connection string generated for a Shared Access Policy. It is instead generated by the\n   * user and appended to the connection string for ease of use.\n   */\n  sharedAccessSignature?: string;\n}\n\n/**\n * Parses given connection string into the different properties applicable to Azure Service Bus.\n * The properties are useful to then construct a ServiceBusClient.\n * @param connectionString The connection string associated with the Shared Access Policy created\n * for the Service Bus namespace, queue or topic.\n */\nexport function parseServiceBusConnectionString(\n  connectionString: string\n): ServiceBusConnectionStringProperties {\n  const parsedResult = parseConnectionString<{\n    Endpoint: string;\n    EntityPath?: string;\n    SharedAccessSignature?: string;\n    SharedAccessKey?: string;\n    SharedAccessKeyName?: string;\n  }>(connectionString);\n  if (!parsedResult.Endpoint) {\n    throw new Error(\"Connection string should have an Endpoint key.\");\n  }\n\n  if (parsedResult.SharedAccessSignature) {\n    if (parsedResult.SharedAccessKey || parsedResult.SharedAccessKeyName) {\n      throw new Error(\n        \"Connection string cannot have both SharedAccessSignature and SharedAccessKey keys.\"\n      );\n    }\n  } else if (parsedResult.SharedAccessKey && !parsedResult.SharedAccessKeyName) {\n    throw new Error(\"Connection string with SharedAccessKey should have SharedAccessKeyName.\");\n  } else if (!parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {\n    throw new Error(\n      \"Connection string with SharedAccessKeyName should have SharedAccessKey as well.\"\n    );\n  }\n\n  const output: ServiceBusConnectionStringProperties = {\n    fullyQualifiedNamespace: (parsedResult.Endpoint.match(\".*://([^/]*)\") || [])[1],\n    endpoint: parsedResult.Endpoint\n  };\n  if (parsedResult.EntityPath) {\n    output.entityPath = parsedResult.EntityPath;\n  }\n  if (parsedResult.SharedAccessSignature) {\n    output.sharedAccessSignature = parsedResult.SharedAccessSignature;\n  }\n  if (parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {\n    output.sharedAccessKey = parsedResult.SharedAccessKey;\n    output.sharedAccessKeyName = parsedResult.SharedAccessKeyName;\n  }\n  return output;\n}\n"],"names":["createClientLogger","generate_uuid","Buffer","Constants.XML_METADATA_MARKER","AbortError","OperationTimeoutError","Constants.packageJsonInfo","stringifyXML","logger","parseXML","RestError","stripRequest","stripResponse","Constants.ATOM_METADATA_MARKER","Constants.HttpResponseCodes","Constants.QUEUE_NAME","Constants.FORWARD_TO","Constants.USER_METADATA","Constants.LOCK_DURATION","Constants.MAX_SIZE_IN_MEGABYTES","Constants.MAX_DELIVERY_COUNT","Constants.ENABLE_PARTITIONING","Constants.REQUIRES_SESSION","Constants.ENABLE_BATCHED_OPERATIONS","Constants.DEFAULT_MESSAGE_TIME_TO_LIVE","Constants.AUTO_DELETE_ON_IDLE","Constants.REQUIRES_DUPLICATE_DETECTION","Constants.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW","Constants.DEAD_LETTERING_ON_MESSAGE_EXPIRATION","Constants.FORWARD_DEADLETTERED_MESSAGES_TO","Constants.AUTHORIZATION_RULES","Constants.STATUS","Constants.ENABLE_EXPRESS","Constants.ENTITY_AVAILABILITY_STATUS","Constants.COUNT_DETAILS","Constants.SIZE_IN_BYTES","Constants.MESSAGE_COUNT","Constants.CREATED_AT","Constants.UPDATED_AT","Constants.ACCESSED_AT","Constants.XML_VALUE_MARKER","Constants.SUBSCRIPTION_NAME","Constants.TOPIC_NAME","Constants.DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS","Constants.SUPPORT_ORDERING","Constants.SUBSCRIPTION_COUNT","parseConnectionString","HttpHeaders","getTracer","SpanKind","CanonicalCode","ServiceClient","isTokenCredential","bearerTokenAuthenticationPolicy","AMQPConstants","signingPolicy","createPipelineFromOptions","__asyncValues","__asyncDelegator","WebResource","URLBuilder","Constants.API_VERSION_QUERY_KEY","Constants.CURRENT_API_VERSION","message","Constants","AmqpAnnotatedMessage","uuid_to_string","MessagingError","translate","isMessagingError","defaultLock","TokenType","RequestResponseLink","ReceiverEvents","types","RheaMessageUtil","ConditionErrorNameMapper","string_to_uuid","os.arch","os.type","os.release","ConnectionContextBase","ConnectionEvents","ConnectionConfig","ErrorNameConditionMapper","retry","RetryOperationType","getTraceParentHeader","extractSpanContextFromTraceParentHeader","SessionEvents","RheaMessagePropertiesList","delay","messageProperties"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAMA;;;;;;AAMO,MAAM,MAAM,GAAG,sBAAsB,CAAC,aAAa,CAAC,CAAC;AAE5D;;;;;AAKO,MAAM,cAAc,GAAG,sBAAsB,CAAC,sBAAsB,CAAC,CAAC;AAE7E;;;;;AAKO,MAAM,YAAY,GAAG,sBAAsB,CAAC,oBAAoB,CAAC,CAAC;AAEzE;;;;;AAKO,MAAM,gBAAgB,GAAG,sBAAsB,CAAC,wBAAwB,CAAC,CAAC;AAEjF;;;;;AAKO,MAAM,oBAAoB,GAAG,sBAAsB,CAAC,4BAA4B,CAAC,CAAC;AAEzF;;;;;AAKO,MAAM,aAAa,GAAG,sBAAsB,CAAC,sBAAsB,CAAC,CAAC;AAE5E;;;;;AAKO,MAAM,sBAAsB,GAAG,sBAAsB,CAAC,wBAAwB,CAAC,CAAC;AAEvF;;;;;;SAMgB,kBAAkB,CAAC,OAAoB,EAAE,KAAU;IACjE,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,EAAE;QACxB,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;KAC9B;AACH,CAAC;AAqBD;;;;;SAKgB,sBAAsB,CAAC,SAAiB;IACtD,MAAM,OAAO,GAAGA,2BAAkB,CAAC,SAAS,CAAqB,CAAC;IAElE,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,GAAkC,EAAE,GAAG,IAAW;QACvE,IAAI,CAAqB,CAAC;;;QAI1B,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,IAAI,KAAK,YAAY,EAAE;YAC7C,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC;SAClB;aAAM;YACL,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC;SACrB;;QAGD,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;;QAGpB,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;;QAGX,IAAI,GAAG,IAAK,GAAW,CAAC,KAAK,EAAE;YAC7B,OAAO,CAAC,OAAO,CAAE,GAAW,CAAC,KAAK,CAAC,CAAC;SACrC;KACF,CAAC;IAEF,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;;AAIA,SAAS,OAAO,CAAC,GAAkC;IACjD,OAAO,GAAG,IAAI,IAAI,IAAK,GAAW,CAAC,IAAI,IAAI,IAAI,CAAC;AAClD;;AC/HA;AACA;AAEA;;;;AAIA,AAAO,MAAM,eAAe,GAAG;IAC7B,IAAI,EAAE,oBAAoB;IAC1B,OAAO,EAAE,OAAO;CACjB,CAAC;AAEF,AAMA;;;;AAIA,AAAO,MAAM,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC;AAElD;;;;;AAKA,AAAO,MAAM,UAAU,GAAG,WAAW,CAAC;AAEtC;;;;;AAKA,AAAO,MAAM,UAAU,GAAG,WAAW,CAAC;AAEtC;;;;;AAKA,AAAO,MAAM,iBAAiB,GAAG,kBAAkB,CAAC;AAEpD,AAOA;;;;;AAKA,AAAO,MAAM,WAAW,GAAG,YAAY,CAAC;AAExC;;;;;AAKA,AAAO,MAAM,UAAU,GAAG,WAAW,CAAC;AAEtC;;;;;AAKA,AAAO,MAAM,UAAU,GAAG,WAAW,CAAC;AAEtC;;;;;AAKA,AAAO,MAAM,mBAAmB,GAAG,oBAAoB,CAAC;AAExD,AAOA;;;;;AAKA,AAAO,MAAM,0BAA0B,GAAG,0BAA0B,CAAC;AAErE;;;;;AAKA,AAAO,MAAM,cAAc,GAAG,eAAe,CAAC;AAE9C,AAqBA;;;;;;AAMA,AAAO,MAAM,aAAa,GAAG,aAAa,CAAC;AAE3C;;;;;;AAMA,AAAO,MAAM,aAAa,GAAG,cAAc,CAAC;AAE5C;;;;;;AAMA,AAAO,MAAM,kBAAkB,GAAG,mBAAmB,CAAC;AAEtD;;;;;;AAMA,AAAO,MAAM,aAAa,GAAG,cAAc,CAAC;AAE5C,AAQA;;;;;;AAMA,AAAO,MAAM,mBAAmB,GAAG,kBAAkB,CAAC;AAEtD;;;;;;AAMA,AAAO,MAAM,MAAM,GAAG,QAAQ,CAAC;AAE/B;;;;;;AAMA,AAAO,MAAM,UAAU,GAAG,WAAW,CAAC;AAEtC;;;;;;AAMA,AAAO,MAAM,aAAa,GAAG,cAAc,CAAC;AAE5C;;;;;;AAMA,AAAO,MAAM,qBAAqB,GAAG,oBAAoB,CAAC;AAE1D;;;;;;AAMA,AAAO,MAAM,4BAA4B,GAAG,0BAA0B,CAAC;AAEvE;;;;;;AAMA,AAAO,MAAM,aAAa,GAAG,cAAc,CAAC;AAE5C;;;;;;AAMA,AAAO,MAAM,gBAAgB,GAAG,iBAAiB,CAAC;AAElD;;;;;;AAMA,AAAO,MAAM,4BAA4B,GAAG,4BAA4B,CAAC;AAEzE;;;;;;;;;AASA,AAAO,MAAM,oCAAoC,GAAG,kCAAkC,CAAC;AAEvF;;;;;;AAMA,AAAO,MAAM,8CAA8C,GACzD,2CAA2C,CAAC;AAE9C;;;;;;AAMA,AAAO,MAAM,uCAAuC,GAAG,qCAAqC,CAAC;AAE7F;;;;;;AAMA,AAAO,MAAM,kBAAkB,GAAG,kBAAkB,CAAC;AAErD;;;;;;AAMA,AAAO,MAAM,yBAAyB,GAAG,yBAAyB,CAAC;AAEnE;;;;;;AAMA,AAAO,MAAM,gBAAgB,GAAG,iBAAiB,CAAC;AAElD;;;;;;AAMA,AAAO,MAAM,mBAAmB,GAAG,oBAAoB,CAAC;AAExD;;;;;;AAMA,AAAO,MAAM,gCAAgC,GAAG,+BAA+B,CAAC;AAEhF;;;;;;AAMA,AAAO,MAAM,qBAAqB,GAAG,aAAa,CAAC;AAEnD;;;;;;AAMA,AAAO,MAAM,mBAAmB,GAAG,SAAS,CAAC;AAE7C,AAeA;;;;;;AAMA,AAAO,MAAM,mBAAmB,GAAG,GAAG,CAAC;AAEvC;;;;;;AAMA,AAAO,MAAM,gBAAgB,GAAG,GAAG,CAAC;AAEpC;;;;;;AAMA,AAAO,MAAM,oBAAoB,GAAG,GAAG,CAAC;AAExC;;;;;;AAMA,AAAO,MAAM,iBAAiB,GAAG;IAC/B,GAAG,EAAE,UAAU;IACf,GAAG,EAAE,oBAAoB;IACzB,GAAG,EAAE,IAAI;IACT,GAAG,EAAE,SAAS;IACd,GAAG,EAAE,UAAU;IACf,GAAG,EAAE,6BAA6B;IAClC,GAAG,EAAE,WAAW;IAChB,GAAG,EAAE,cAAc;IACnB,GAAG,EAAE,gBAAgB;IACrB,GAAG,EAAE,iBAAiB;IACtB,GAAG,EAAE,OAAO;IACZ,GAAG,EAAE,UAAU;IACf,GAAG,EAAE,gBAAgB;IACrB,GAAG,EAAE,aAAa;IAClB,GAAG,EAAE,UAAU;IACf,GAAG,EAAE,QAAQ;IACb,GAAG,EAAE,YAAY;IACjB,GAAG,EAAE,cAAc;IACnB,GAAG,EAAE,iBAAiB;IACtB,GAAG,EAAE,WAAW;IAChB,GAAG,EAAE,UAAU;IACf,GAAG,EAAE,kBAAkB;IACvB,GAAG,EAAE,eAAe;IACpB,GAAG,EAAE,6BAA6B;IAClC,GAAG,EAAE,UAAU;IACf,GAAG,EAAE,MAAM;IACX,GAAG,EAAE,gBAAgB;IACrB,GAAG,EAAE,oBAAoB;IACzB,GAAG,EAAE,uBAAuB;IAC5B,GAAG,EAAE,mBAAmB;IACxB,GAAG,EAAE,sBAAsB;IAC3B,GAAG,EAAE,4BAA4B;IACjC,GAAG,EAAE,mBAAmB;IACxB,GAAG,EAAE,iBAAiB;IACtB,GAAG,EAAE,qBAAqB;IAC1B,GAAG,EAAE,gBAAgB;IACrB,GAAG,EAAE,YAAY;IACjB,GAAG,EAAE,oBAAoB;IACzB,GAAG,EAAE,gBAAgB;IACrB,GAAG,EAAE,yBAAyB;CAC/B,CAAC;;ACpZF;AACA;AAEA;AACA;AAEA;;;;AAIA,MAAM,GAAG,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;AAE3B;;;;;AAKA,AAAO,MAAM,QAAQ,GAAG,CAAC,MAAc;IACrC,OAAO,IAAI,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AAC7B,CAAC,CAAC;;ACnBF;AACA,AA0BA;;;;;;;AAOA,SAAgB,aAAa,CAAC,IAAY;IACxC,OAAO,GAAG,IAAI,IAAIC,yBAAa,EAAE,EAAE,CAAC;AACtC,CAAC;AAED;;;;;;;;;;AAUA,SAAgB,gBAAgB,CAAC,cAAsB;IACrD,IAAI,CAAC,cAAc,IAAI,CAACC,aAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE;QACvD,OAAO,cAAc,CAAC;KACvB;IAED,OAAOA,aAAM,CAAC,IAAI,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QAEjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QAEjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QAEjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QAEjB,cAAc,CAAC,EAAE,CAAC;QAClB,cAAc,CAAC,EAAE,CAAC;QAClB,cAAc,CAAC,EAAE,CAAC;QAClB,cAAc,CAAC,EAAE,CAAC;QAClB,cAAc,CAAC,EAAE,CAAC;QAClB,cAAc,CAAC,EAAE,CAAC;KACnB,CAAC,CAAC;AACL,CAAC;AAED;;;;;;AAMA,SAAgB,2BAA2B,CAAC,cAAoB;IAC9D,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IACvB,MAAM,WAAW,GAAG,cAAc,CAAC,OAAO,EAAE,CAAC;IAC7C,MAAM,aAAa,GAAG,WAAW,GAAG,GAAG,CAAC;IACxC,cAAc,CAAC,OAAO,CAAC,wBAAwB,EAAE,WAAW,CAAC,CAAC;IAC9D,cAAc,CAAC,OAAO,CAAC,wBAAwB,EAAE,GAAG,CAAC,CAAC;IACtD,cAAc,CAAC,OAAO,CAAC,wBAAwB,EAAE,aAAa,CAAC,CAAC;IAChE,IAAI,aAAa,GAAG,IAAI,EAAE;QACxB,OAAO,CAAC,CAAC;KACV;IACD,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,aAAa,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;IAClD,MAAM,UAAU,GAAG,aAAa,GAAG,MAAM,CAAC;IAC1C,cAAc,CAAC,OAAO,CAAC,wBAAwB,EAAE,UAAU,CAAC,CAAC;IAC7D,OAAO,UAAU,CAAC;AACpB,CAAC;AAED;;;;;;;;;;;;;;;AAeA,SAAgB,kBAAkB,CAAC,GAAa;IAC9C,MAAM,cAAc,GAAW,kBAAkB,CAAC;IAClD,MAAM,SAAS,GAAS,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;IAC9C,MAAM,QAAQ,GAAG,SAAS;SACvB,GAAG,CAAC,cAAc,CAAC;SACnB,GAAG,CAAC,KAAK,CAAC;SACV,QAAQ,EAAE,CAAC;IACd,MAAM,MAAM,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;IAClC,MAAM,CAAC,OAAO,CAAC,2BAA2B,EAAE,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC/D,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,AAcA;;;;;;AAMA,SAAgB,QAAQ,CAAC,KAAU;IACjC,IAAI,MAAW,CAAC;IAChB,aAAa,CAAC,OAAO,CACnB,mFAAmF,EACnF,KAAK,CACN,CAAC;IACF,IAAI,QAAQ,CAAC,KAAK,CAAC,EAAE;QACnB,MAAM,GAAG,KAAK,CAAC;KAChB;SAAM;;;;QAIL,IAAI,KAAK,KAAK,SAAS;YAAE,KAAK,GAAG,IAAI,CAAC;QACtC,IAAI;YACF,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YACvC,MAAM,GAAGA,aAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;SACxC;QAAC,OAAO,GAAG,EAAE;YACZ,MAAM,GAAG,GACP,wEAAwE;gBACxE,KAAK;gBACL,GAAG,GAAG,YAAY,KAAK,GAAG,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC;YAC9D,aAAa,CAAC,OAAO,CAAC,mBAAmB,GAAG,GAAG,CAAC,CAAC;YACjD,MAAM,GAAG,YAAY,KAAK,GAAG,GAAG,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC;SACnD;KACF;IACD,aAAa,CAAC,OAAO,CAAC,+CAA+C,EAAE,MAAM,CAAC,CAAC;IAC/E,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;;;AAOA,SAAgB,SAAS,CAAC,KAAU,EAAE,cAAsB;IAC1D,MAAM,MAAM,GAAG,oBAAoB,CAAC,KAAK,CAAC,CAAC;IAC3C,IAAI,MAAM,IAAI,SAAS,EAAE;QACvB,MAAM,IAAI,KAAK,CACb,IAAI,cAAc,0EAA0E,CAC7F,CAAC;KACH;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;;;AAOA,SAAgB,oBAAoB,CAAC,KAAU;IAC7C,IAAI,KAAK,IAAI,SAAS,EAAE;QACtB,OAAO,SAAS,CAAC;KAClB;IACD,OAAO,KAAK,CAAC,QAAQ,EAAE,CAAC;AAC1B,CAAC;AAED;;;;;;;AAOA,SAAgB,UAAU,CAAC,KAAU,EAAE,cAAsB;IAC3D,MAAM,MAAM,GAAG,qBAAqB,CAAC,KAAK,CAAC,CAAC;IAC5C,IAAI,MAAM,IAAI,SAAS,EAAE;QACvB,MAAM,IAAI,KAAK,CACb,IAAI,cAAc,0EAA0E,CAC7F,CAAC;KACH;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;;;AAOA,SAAgB,qBAAqB,CAAC,KAAU;IAC9C,IAAI,KAAK,IAAI,SAAS,EAAE;QACtB,OAAO,SAAS,CAAC;KAClB;IACD,MAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC1C,OAAO,MAAM,IAAI,GAAG,GAAG,SAAS,GAAG,MAAM,CAAC;AAC5C,CAAC;AAED;;;;;;AAMA,SAAgB,OAAO,CAAC,KAAa,EAAE,cAAsB;IAC3D,OAAO,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC,CAAC;AACpD,CAAC;AAED;;;;;;;AAOA,SAAgB,UAAU,CAAC,KAAU,EAAE,cAAsB;IAC3D,MAAM,MAAM,GAAG,qBAAqB,CAAC,KAAK,CAAC,CAAC;IAC5C,IAAI,MAAM,IAAI,SAAS,EAAE;QACvB,MAAM,IAAI,KAAK,CACb,IAAI,cAAc,2EAA2E,CAC9F,CAAC;KACH;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;;;AAOA,SAAgB,qBAAqB,CAAC,KAAU;IAC9C,IAAI,KAAK,IAAI,SAAS,EAAE;QACtB,OAAO,SAAS,CAAC;KAClB;IACD,QACE,KAAK;SACF,QAAQ,EAAE;SACV,IAAI,EAAE;SACN,WAAW,EAAE,KAAK,MAAM,EAC3B;AACJ,CAAC;AAED;;;;;AAKA,MAAM,6BAA6B,GAAG,EAAE,CAAC,WAAW,CAAC;AAErD;;;;;;AAMA,SAAgB,gBAAgB,CAAC,KAAU;;;;;;;;;;;;IAazC,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,WAAW,KAAK,6BAA6B,CAAC;AAC1F,CAAC;AAED;;;;;;AAMA,SAAgB,sBAAsB,CAAC,KAAU;IAC/C,MAAM,WAAW,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;IAC1C,IAAI,KAAK,IAAI,SAAS,EAAE;QACtB,KAAK,GAAG,EAAE,CAAC;KACZ;IACD,OAAO;QACL,kBAAkB,EAAE,QAAQ,CAAC,KAAK,CAAC,GAAG,WAAW,qBAAqB,CAAC,CAAC,IAAI,CAAC;QAC7E,sBAAsB,EAAE,QAAQ,CAAC,KAAK,CAAC,GAAG,WAAW,yBAAyB,CAAC,CAAC,IAAI,CAAC;QACrF,qBAAqB,EAAE,QAAQ,CAAC,KAAK,CAAC,GAAG,WAAW,wBAAwB,CAAC,CAAC,IAAI,CAAC;QACnF,oBAAoB,EAAE,QAAQ,CAAC,KAAK,CAAC,GAAG,WAAW,uBAAuB,CAAC,CAAC,IAAI,CAAC;QACjF,8BAA8B,EAC5B,QAAQ,CAAC,KAAK,CAAC,GAAG,WAAW,iCAAiC,CAAC,CAAC,IAAI,CAAC;KACxE,CAAC;AACJ,CAAC;AAED;;;;;AAKA,SAAgB,cAAc,CAAC,KAAU;IACvC,IAAI,CAAC,KAAK,CAACC,mBAA6B,CAAC,EAAE;QACzC,MAAM,IAAI,KAAK,CACb,0GAA0G,IAAI,CAAC,SAAS,CACtH,KAAK,CACN,EAAE,CACJ,CAAC;KACH;IACD,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAACA,mBAA6B,CAAC,CAAC,CAAC;IAC/D,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;QACrB,MAAM,IAAI,KAAK,CACb,oGAAoG,IAAI,CAAC,SAAS,CAChH,KAAK,CAACA,mBAA6B,CAAC,CACrC,EAAE,CACJ,CAAC;KACH;IACD,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;QACjC,MAAM,IAAI,KAAK,CACb,sEAAsE,IAAI,CAAC,SAAS,CAClF,KAAK,CAACA,mBAA6B,CAAC,CACrC,EAAE,CACJ,CAAC;KACH;;IAED,MAAM,WAAW,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IACzC,IAAI,CAAC,WAAW,EAAE;QAChB,MAAM,IAAI,KAAK,CACb,+EAA+E,IAAI,CAAC,SAAS,CAC3F,KAAK,CAACA,mBAA6B,CAAC,CACrC,EAAE,CACJ,CAAC;KACH;IACD,OAAO,WAAW,CAAC;AACrB,CAAC;AAyCD;;;;;;;AAOA,SAAgB,gCAAgC,CAAC,KAAU;IACzD,MAAM,kBAAkB,GAAwB,EAAE,CAAC;;IAGnD,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QACpD,OAAO,SAAS,CAAC;KAClB;IAED,IAAI,KAAK,IAAI,SAAS,EAAE;QACtB,OAAO,SAAS,CAAC;KAClB;IAED,MAAM,qBAAqB,GAAG,KAAK,CAAC,iBAAiB,CAAC;IACtD,IAAI,KAAK,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE;QACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,qBAAqB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrD,kBAAkB,CAAC,IAAI,CAAC,sBAAsB,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SAC3E;KACF;SAAM;QACL,kBAAkB,CAAC,IAAI,CAAC,sBAAsB,CAAC,qBAAqB,CAAC,CAAC,CAAC;KACxE;IACD,OAAO,kBAAkB,CAAC;AAC5B,CAAC;AAED;;;;;;AAMA,SAAS,sBAAsB,CAAC,KAAU;IACxC,IAAI,YAAY,CAAC;IACjB,IAAI,KAAK,CAAC,QAAQ,CAAC,IAAI,SAAS,EAAE;QAChC,YAAY,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC,cAAc,CAAC,CAAC;KAChD;IAED,MAAM,iBAAiB,GAAsB;QAC3C,SAAS,EAAE,KAAK,CAAC,WAAW,CAAC;QAC7B,YAAY;QACZ,OAAO,EAAE,KAAK,CAAC,SAAS,CAAC;QACzB,UAAU,EAAE,KAAK,CAAC,YAAY,CAAC;QAC/B,YAAY,EAAE,KAAK,CAAC,cAAc,CAAC;KACpC,CAAC;IAEF,IAAI,iBAAiB,CAAC,YAAY,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,iBAAiB,CAAC,YAAY,CAAC,EAAE;QACpF,iBAAiB,CAAC,YAAY,GAAG,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;KACnE;IACD,OAAO,iBAAiB,CAAC;AAC3B,CAAC;AAED;;;;;;;AAOA,SAAgB,wBAAwB,CAAC,kBAAmD;IAC1F,IAAI,kBAAkB,IAAI,SAAS,EAAE;QACnC,OAAO,SAAS,CAAC;KAClB;IAED,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,kBAAkB,CAAC,EAAE;QACtC,MAAM,IAAI,SAAS,CACjB,+FAA+F,IAAI,CAAC,SAAS,CAC3G,kBAAkB,EAClB,SAAS,EACT,CAAC,CACF,EAAE,CACJ,CAAC;KACH;IAED,MAAM,qBAAqB,GAAU,EAAE,CAAC;IACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,kBAAkB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAClD,qBAAqB,CAAC,IAAI,CAAC,yBAAyB,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KAC9E;IACD,OAAO,EAAE,iBAAiB,EAAE,qBAAqB,EAAE,CAAC;AACtD,CAAC;AAED;;;;;;AAMA,SAAS,yBAAyB,CAAC,iBAAoC;IACrE,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,IAAI,iBAAiB,KAAK,IAAI,EAAE;QACtE,MAAM,IAAI,SAAS,CACjB,0EAA0E,IAAI,CAAC,SAAS,CACtF,iBAAiB,EACjB,SAAS,EACT,CAAC,CACF,EAAE,CACJ,CAAC;KACH;IAED,MAAM,oBAAoB,GAAQ;QAChC,SAAS,EAAE,iBAAiB,CAAC,SAAS;;QAEtC,UAAU,EAAE,MAAM;QAClB,MAAM,EAAE;YACN,YAAY,EAAE,iBAAiB,CAAC,YAAY;SAC7C;QACD,OAAO,EAAE,iBAAiB,CAAC,OAAO;QAClC,UAAU,EAAE,iBAAiB,CAAC,UAAU;QACxC,YAAY,EAAE,iBAAiB,CAAC,YAAY;KAC7C,CAAC;IACF,oBAAoB,CAACA,mBAA6B,CAAC,GAAG;QACpD,SAAS,EAAE,+BAA+B;QAC1C,UAAU,EAAE,2CAA2C;KACxD,CAAC;IACF,OAAO,oBAAoB,CAAC;AAC9B,CAAC;AAED;;;;;;AAMA,SAAgB,aAAa,CAAC,GAAW;IACvC,MAAM,IAAI,GAAG,GAAG,CAAC,WAAW,EAAE,CAAC;IAC/B,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;AAC/F,CAAC;AA0BD;;;;AAIA,AAAO,MAAM,oBAAoB,GAAG,4BAA4B,CAAC;AAEjE;;;;;;;;;;;;;AAaA,SAAsB,8BAA8B,CAAI,IAUvD;;QACC,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE;YAChD,MAAM,IAAIC,0BAAU,CAAC,oBAAoB,CAAC,CAAC;SAC5C;QAED,IAAI,KAAK,GAAoB,SAAS,CAAC;QACvC,IAAI,gBAAgB,GAA6B,SAAS,CAAC;QAE3D,MAAM,wBAAwB,GAAG;;YAC/B,aAAC,IAAI,CAAC,gBAAgB,0CAAE,cAAc,mCAAI,YAAY,EAAE,KAAK,CAAC,CAAC;YAE/D,IAAI,gBAAgB,EAAE;gBACpB,gBAAgB,EAAE,CAAC;aACpB;SACF,CAAC;;QAGF,MAAM,qBAAqB,GAAG,IAAI,OAAO,CAAI,CAAC,QAAQ,EAAE,MAAM;;YAC5D,gBAAgB,GAAG,+BAA+B,CAAC,MAAM,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;YAE7E,KAAK,GAAG,aAAC,IAAI,CAAC,gBAAgB,0CAAE,YAAY,mCAAI,UAAU,EAAE;gBAC1D,MAAM,CAAC,IAAIC,iCAAqB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;aACxD,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;SACpB,CAAC,CAAC;QAEH,IAAI;YACF,OAAO,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,qBAAqB,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;SACrE;gBAAS;YACR,wBAAwB,EAAE,CAAC;SAC5B;KACF;CAAA;AAED;;;;;;;;;;;;AAYA,SAAgB,+BAA+B,CAC7C,SAA2C,EAC3C,WAA6B;IAE7B,IAAI,WAAW,IAAI,IAAI,EAAE;QACvB,OAAO,SAAQ,CAAC;KACjB;IAED,IAAI,WAAW,CAAC,OAAO,EAAE;QACvB,MAAM,IAAID,0BAAU,CAAC,oBAAoB,CAAC,CAAC;KAC5C;IAED,MAAM,OAAO,GAAG;QACd,WAAW,CAAC,mBAAmB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAClD,SAAS,CAAC,IAAIA,0BAAU,CAAC,oBAAoB,CAAC,CAAC,CAAC;KACjD,CAAC;IAEF,WAAW,CAAC,gBAAgB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IAE/C,OAAO,MAAM,WAAW,CAAC,mBAAmB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AACjE,CAAC;AAED;;;;;;AAMA,AAAO,MAAM,OAAO,GAAW,4BAA4BE,eAAyB,CAAC,OAAO,EAAE,CAAC;AAE/F;;;;;;;;AAQA,SAAgB,qBAAqB,CAAC,MAAe;IACnD,IAAI,eAAe,GAAG,GAAG,CAAC,MAAM,IAAI,EAAE,EAAE,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC;IAC3D,eAAe,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,GAAG,eAAe,GAAG,GAAG,GAAG,EAAE,CAAC;IAC1E,OAAO,GAAG,eAAe,GAAG,OAAO,EAAE,CAAC;AACxC,CAAC;AAED;;;;;;AAMA,AAAO,MAAM,mBAAmB,GAAG,CAAC,EAClC,OAAO,EACP,MAAM,EACN,OAAO,EACe,MAAoB;IAC1C,OAAO;IACP,MAAM;IACN,OAAO;CACR,CAAC,CAAC;;AC3rBH;AACA,AAiCA;;;;;;;AAOA,SAAsB,uBAAuB,CAC3C,8BAA6C,EAC7C,WAAwB,EACxB,UAA6B,EAC7B,gBAAkC;;;QAElC,IAAI,WAAW,CAAC,IAAI,EAAE;YACpB,MAAM,OAAO,GAAW,UAAU,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;YAC/D,WAAW,CAAC,IAAI,GAAGC,qBAAY,CAAC,OAAO,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAC;SACjE;QAED,IAAI,WAAW,CAAC,MAAM,IAAI,KAAK,EAAE;YAC/B,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,EAAEL,aAAM,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;SAChF;QAEDM,oBAAM,CAAC,OAAO,CAAC,sCAAsC,WAAW,CAAC,IAAI,EAAE,CAAC,CAAC;QAEzE,MAAM,iBAAiB,mCAClB,WAAW,KACd,OAAO,QAAE,gBAAgB,CAAC,cAAc,0CAAE,aAAa,EACvD,gBAAgB,QAAE,gBAAgB,CAAC,cAAc,0CAAE,gBAAgB,EACnE,kBAAkB,QAAE,gBAAgB,CAAC,cAAc,0CAAE,kBAAkB,EACvE,WAAW,EAAE,gBAAgB,CAAC,WAAW,EACzC,WAAW,QAAE,gBAAgB,CAAC,cAAc,0CAAE,WAAW,EACzD,0BAA0B,EAAE,IAAI,GACjC,CAAC;QACF,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;QACrD,WAAW,CAAC,OAAO,GAAG,OAAA,gBAAgB,CAAC,cAAc,0CAAE,OAAO,KAAI,CAAC,CAAC;QACpE,MAAM,QAAQ,GAA0B,MAAM,8BAA8B,CAAC,WAAW,CACtF,WAAW,CACZ,CAAC;QAEFA,oBAAM,CAAC,OAAO,CAAC,sCAAsC,QAAQ,CAAC,UAAU,EAAE,CAAC,CAAC;QAE5E,IAAI;YACF,IAAI,QAAQ,CAAC,UAAU,EAAE;gBACvB,QAAQ,CAAC,UAAU,GAAG,MAAMC,iBAAQ,CAAC,QAAQ,CAAC,UAAU,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,CAAC;aAClF;SACF;QAAC,OAAO,GAAG,EAAE;YACZ,MAAM,KAAK,GAAG,IAAIC,kBAAS,CACzB,oGAAoG,EACpGA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;YACFJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,0CAA0C,CAAC,CAAC;YACjE,MAAM,KAAK,CAAC;SACb;QAED,OAAO,UAAU,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;;CACzC;AAED;;;;;;;;;;;;AAYA,SAAgB,0BAA0B,CAAC,QAAgC;IACzE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,UAAS,QAAQ;QAC7C,IAAI,QAAQ,CAAC,QAAQ,CAAC,IAAI,SAAS,EAAE;YACnC,OAAO,QAAQ,CAAC,QAAQ,CAAC,CAAC;SAC3B;aAAM,IAAI,gBAAgB,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,EAAE;YAC/C,0BAA0B,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;SAChD;KACF,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;;;AASA,SAAgB,yBAAyB,CAAC,YAAoB,EAAE,QAAa;IAC3E,MAAM,OAAO,GAAQ,EAAE,CAAC;IAExB,OAAO,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;IACpD,0BAA0B,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC;IAElD,OAAO,CAAC,YAAY,CAAC,CAACL,mBAA6B,CAAC,GAAG;QACrD,KAAK,EAAE,qEAAqE;QAC5E,SAAS,EAAE,2CAA2C;KACvD,CAAC;IAEF,OAAO,CAACA,mBAA6B,CAAC,GAAG,EAAE,IAAI,EAAE,iBAAiB,EAAE,CAAC;IACrE,MAAM,cAAc,GAAQ;QAC1B,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;QACjC,OAAO,EAAE,OAAO;KACjB,CAAC;IACF,cAAc,CAACA,mBAA6B,CAAC,GAAG;QAC9C,KAAK,EAAE,6BAA6B;KACrC,CAAC;IACF,OAAO,cAAc,CAAC;AACxB,CAAC;AAED;;;;;;;;;AASA,SAAsB,0BAA0B,CAC9C,cAAwB,EACxB,QAA+B;;;QAG/B,IAAI,QAAQ,CAAC,MAAM,GAAG,GAAG,IAAI,QAAQ,CAAC,MAAM,IAAI,GAAG,EAAE;YACnD,MAAM,UAAU,CAAC,QAAQ,CAAC,CAAC;SAC5B;QAED,eAAe,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC;QAE1C,OAAO,QAAQ,CAAC;KACjB;CAAA;AAED;;;;;;;;;AASA,SAAS,eAAe,CAAC,QAA+B,EAAE,cAAwB;IAChF,MAAM,kBAAkB,GAAG,QAAQ,CAAC,UAAU,CAAC;IAE/C,IAAI,MAAW,CAAC;IAChB,IAAI,CAAC,kBAAkB,EAAE;QACvB,QAAQ,CAAC,UAAU,GAAG,SAAS,CAAC;QAChC,OAAO;KACR;IAED,IAAI,kBAAkB,CAAC,IAAI,EAAE;QAC3B,MAAM,GAAG,eAAe,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;KACnD;SAAM,IAAI,kBAAkB,CAAC,KAAK,EAAE;QACnC,MAAM,GAAG,gBAAgB,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;KACrD;IAED,IAAI,MAAM,EAAE;QACV,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;YACzB,MAAM,CAAC,OAAO,CAAC,CAAC,KAAa;gBAC3B,OAAO,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;aAChC,CAAC,CAAC;SACJ;aAAM;YACL,OAAO,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;SACjC;QACD,QAAQ,CAAC,UAAU,GAAG,MAAM,CAAC;QAC7B,OAAO;KACR;IAEDK,oBAAM,CAAC,OAAO,CACZ,uJAAuJ,EACvJ,kBAAkB,CACnB,CAAC;IACF,MAAM,IAAIE,kBAAS,CACjB,sIAAsI,EACtIA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;AACJ,CAAC;AAED;;;;;;AAMA,SAAS,gBAAgB,CAAC,KAAU;IAClC,IAAI,MAAW,CAAC;IAEhB,IACE,OAAO,KAAK,KAAK,QAAQ;QACzB,KAAK,IAAI,IAAI;QACb,OAAO,KAAK,CAAC,OAAO,KAAK,QAAQ;QACjC,KAAK,CAAC,OAAO,IAAI,IAAI,EACrB;QACA,OAAO,SAAS,CAAC;KAClB;IAED,MAAM,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,UAAS,GAAG;QACxE,OAAO,GAAG,KAAKT,mBAA6B,CAAC;KAC9C,CAAC,CAAC;IAEH,IAAI,mBAAmB,IAAI,mBAAmB,CAAC,CAAC,CAAC,EAAE;QACjD,MAAM,sBAAsB,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAC;QACtD,OAAO,KAAK,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAACA,mBAA6B,CAAC,CAAC;QAC5E,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAAC;QAE/C,IAAI,MAAM,EAAE;YACV,IAAI,KAAK,CAACA,mBAA6B,CAAC,EAAE;gBACxC,MAAM,CAACU,oBAA8B,CAAC,GAAG,KAAK,CAACV,mBAA6B,CAAC,CAAC;aAC/E;iBAAM;gBACL,MAAM,CAACU,oBAA8B,CAAC,GAAG,EAAE,CAAC;aAC7C;YAED,MAAM,CAACA,oBAA8B,CAAC,CAAC,oBAAoB,CAAC,GAAG,sBAAsB,CAAC;YAEtF,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,QAAgB;gBAC1C,IAAI,QAAQ,KAAK,SAAS,IAAI,QAAQ,KAAKV,mBAA6B,EAAE;oBACxE,MAAM,CAACU,oBAA8B,CAAC,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;iBACpE;aACF,CAAC,CAAC;YAEH,OAAO,MAAM,CAAC;SACf;KACF;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;AAED;;;;;;AAMA,SAAS,aAAa,CACpB,QAA8E,EAC9E,YAA6B;IAE7B,IAAI,CAAC,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;QACzC,OAAO,SAAS,CAAC;KAClB;IACD,KAAK,MAAM,QAAQ,IAAI,QAAQ,EAAE;QAC/B,IAAI,QAAQ,CAACV,mBAA6B,CAAC,CAAC,GAAG,KAAK,YAAY,EAAE;YAChE,OAAO,QAAQ,CAACA,mBAA6B,CAAC,CAAC,IAAI,CAAC;SACrD;KACF;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAED;;;;;;AAMA,SAAS,eAAe,CAAC,IAAS;IAChC,MAAM,MAAM,GAAqC,EAAE,CAAC;IACpD,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE;QAC1D,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;YAC7B,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,KAAU;gBAC5B,MAAM,iBAAiB,GAAG,gBAAgB,CAAC,KAAK,CAAC,CAAC;gBAClD,IAAI,iBAAiB,EAAE;oBACrB,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;iBAChC;aACF,CAAC,CAAC;SACJ;aAAM;YACL,MAAM,iBAAiB,GAAG,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACvD,IAAI,iBAAiB,EAAE;gBACrB,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;aAChC;SACF;QACD,MAAM,CAAC,QAAQ,GAAG,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;KACpD;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;;AAMA,SAAS,mBAAmB,CAC1B,UAAkB;IAElB,OAAO,CAAC,CAAEW,iBAAgE,CAAC,UAAU,CAAC,CAAC;AACzF,CAAC;AAED;;;;;;;;;;;;;;;;;;AAkBA,SAAS,OAAO,CAAC,KAAU,EAAE,cAAmB;IAC9C,IAAI,KAAK,CAACD,oBAA8B,CAAC,EAAE;QACzC,IAAI,MAAM,GAAG,KAAK,CAACA,oBAA8B,CAAC,CAAC,EAAE,CAAC;;;;;QAMtD,IAAI,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;YAC9B,MAAM,GAAG,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;SAC3C;QAED,MAAM,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;QACnC,MAAM,QAAQ,GAAW,SAAS,CAAC,QAAQ,CAAC;QAE5C,MAAM,qBAAqB,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAEpD,IAAI,QAAQ,CAAC,KAAK,CAAC,yCAAyC,CAAC,EAAE;YAC7D,MAAM,iCAAiC,GAAG,QAAQ,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC;YAClF,MAAM,0BAA0B,GAAG,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;YAC/D,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,SAAS,CAC3C,qBAAqB,GAAG,CAAC,EACzB,iCAAiC,CAClC,CAAC;YACF,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,SAAS,CAC3C,iCAAiC,GAAG,EAAE,EACtC,0BAA0B,CAC3B,CAAC;YACF,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,SAAS,CAAC,0BAA0B,GAAG,CAAC,CAAC,CAAC;SAC/E;aAAM,IAAI,QAAQ,CAAC,KAAK,CAAC,8BAA8B,CAAC,EAAE;YACzD,MAAM,iCAAiC,GAAG,QAAQ,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC;YAClF,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,SAAS,CAC3C,qBAAqB,GAAG,CAAC,EACzB,iCAAiC,CAClC,CAAC;YACF,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,SAAS,CAAC,iCAAiC,GAAG,EAAE,CAAC,CAAC;SACvF;aAAM,IAAI,QAAQ,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;YACtC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,SAAS,CAAC,qBAAqB,GAAG,CAAC,CAAC,CAAC;SAC1E;KACF;AACH,CAAC;AAED;;;;;;;AAOA,SAAgB,UAAU,CAAC,QAA+B;IACxD,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;QACzC,MAAM,IAAIH,kBAAS,CACjB,8EAA8E,QAAQ,CAAC,MAAM,EAAE,EAC/F,cAAc,EACd,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;KACH;IAED,MAAM,SAAS,GAAG,QAAQ,CAAC,UAAU,CAAC;IACtC,IAAI,YAAY,CAAC;IACjB,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;QACjC,YAAY,GAAG,SAAS,CAAC;KAC1B;SAAM;QACL,IACE,SAAS,IAAI,SAAS;YACtB,SAAS,CAAC,KAAK,IAAI,SAAS;YAC5B,SAAS,CAAC,KAAK,CAAC,MAAM,IAAI,SAAS,EACnC;YACA,YAAY;gBACV,8GAA8G,CAAC;SAClH;aAAM;YACL,YAAY,GAAG,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC;SACvC;KACF;IAED,MAAM,SAAS,GAAG,YAAY,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;IAEvD,MAAM,KAAK,GAAc,IAAIF,kBAAS,CACpC,YAAY,EACZ,SAAS,EACT,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;IACF,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;;;;;;AAQA,SAAS,YAAY,CAAC,QAA+B,EAAE,YAAoB;IACzE,IAAI,QAAQ,CAAC,MAAM,IAAI,GAAG,EAAE;QAC1B,OAAO,0BAA0B,CAAC;KACnC;IACD,IAAI,QAAQ,CAAC,MAAM,IAAI,GAAG,EAAE;QAC1B,OAAO,4BAA4B,CAAC;KACrC;IACD,IAAI,QAAQ,CAAC,MAAM,IAAI,GAAG,EAAE;QAC1B,IAAI,QAAQ,CAAC,OAAO,CAAC,MAAM,IAAI,QAAQ,EAAE;YACvC,OAAO,cAAc,CAAC;SACvB;QAED,IAAI,QAAQ,CAAC,OAAO,CAAC,MAAM,IAAI,KAAK,IAAI,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,GAAG,EAAE;YACvF,OAAO,cAAc,CAAC;SACvB;QAED,IAAI,YAAY,IAAI,YAAY,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,eAAe,CAAC,EAAE;YACxE,OAAO,cAAc,CAAC;SACvB;QAED,OAAO,iCAAiC,CAAC;KAC1C;IAED,IAAI,QAAQ,CAAC,MAAM,IAAI,GAAG,EAAE;QAC1B,IAAI,YAAY,IAAI,YAAY,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,eAAe,CAAC,EAAE;YACxE,OAAO,uBAAuB,CAAC;SAChC;QACD,OAAO,oBAAoB,CAAC;KAC7B;IAED,IAAI,QAAQ,CAAC,MAAM,IAAI,GAAG,EAAE;QAC1B,OAAO,cAAc,CAAC;KACvB;IAED,IAAI,QAAQ,CAAC,MAAM,IAAI,GAAG,EAAE;QAC1B,OAAO,iBAAiB,CAAC;KAC1B;IAED,OAAQE,iBAAgE,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;AAC5F,CAAC;;ACleD;AACA,AA0CA;;;;;;;AAOA,SAAgB,cAAc,CAAC,YAAiB;IAC9C,MAAM,YAAY,IAChB,SAAS,CAAC,YAAY,CAAC,cAAc,CAAC,EAAE,cAAc,CAAC,CACxD,CAAC;IACF,OAAO;QACL,SAAS,EAAE,OAAO,CAAC,YAAY,CAAC,aAAa,CAAC,EAAE,WAAW,CAAC;QAC5D,YAAY,EAAE,YAAY;QAC1B,UAAU,EAAE,OAAO,CAAC,YAAY,CAAC,cAAc,CAAC,EAAE,YAAY,CAAC;QAC/D,IAAI,EAAE,SAAS,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC;QAC7C,cAAc,EACZ,YAAY,KAAK,SAAS;cACtB,UAAU,CAAC,YAAY,CAAC,gBAAgB,CAAC,EAAE,gBAAgB,CAAC;cAC5D,SAAS;KAChB,CAAC;AACJ,CAAC;AAED;;;;;AAKA,MAAa,2BAA2B;IACtC,SAAS;QACP,OAAO,yBAAyB,CAAC,qBAAqB,EAAE,EAAE,CAAC,CAAC;KAC7D;IAEK,WAAW,CAAC,QAA+B;;YAC/C,OAAO,0BAA0B,CAAC,CAAC,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC;SACvD;KAAA;CACF;;AC/ED;AACA,AAwBA;;;;;;;;AAQA,SAAgB,iBAAiB,CAAC,KAAyB;IACzD,OAAO;QACL,YAAY,EAAE,KAAK,CAAC,YAAY;QAChC,kBAAkB,EAAE,oBAAoB,CAAC,KAAK,CAAC,kBAAkB,CAAC;QAClE,0BAA0B,EAAE,oBAAoB,CAAC,KAAK,CAAC,0BAA0B,CAAC;QAClF,eAAe,EAAE,oBAAoB,CAAC,KAAK,CAAC,eAAe,CAAC;QAC5D,wBAAwB,EAAE,KAAK,CAAC,wBAAwB;QACxD,gCAAgC,EAAE,oBAAoB,CAAC,KAAK,CAAC,gCAAgC,CAAC;QAC9F,mCAAmC,EAAE,KAAK,CAAC,mCAAmC;QAC9E,gBAAgB,EAAE,oBAAoB,CAAC,KAAK,CAAC,gBAAgB,CAAC;QAC9D,uBAAuB,EAAE,oBAAoB,CAAC,KAAK,CAAC,uBAAuB,CAAC;QAC5E,kBAAkB,EAAE,wBAAwB,CAAC,KAAK,CAAC,kBAAkB,CAAC;QACtE,MAAM,EAAE,oBAAoB,CAAC,KAAK,CAAC,MAAM,CAAC;QAC1C,gBAAgB,EAAE,oBAAoB,CAAC,KAAK,CAAC,gBAAgB,CAAC;QAC9D,kBAAkB,EAAE,oBAAoB,CAAC,KAAK,CAAC,kBAAkB,CAAC;QAClE,6BAA6B,EAAE,oBAAoB,CAAC,KAAK,CAAC,6BAA6B,CAAC;QACxF,SAAS,EAAE,oBAAoB,CAAC,KAAK,CAAC,SAAS,CAAC;QAChD,YAAY,EAAE,oBAAoB,CAAC,KAAK,CAAC,YAAY,CAAC;QACtD,wBAAwB,EAAE,oBAAoB,CAAC,KAAK,CAAC,kBAAkB,CAAC;QACxE,aAAa,EAAE,oBAAoB,CAAC,KAAK,CAAC,aAAa,CAAC;KACzD,CAAC;AACJ,CAAC;AAED;;;;;;;AAOA,SAAgB,UAAU,CAAC,QAAa;IACtC,OAAO;QACL,IAAI,EAAE,SAAS,CAAC,QAAQ,CAACC,UAAoB,CAAC,EAAE,WAAW,CAAC;QAE5D,SAAS,EAAE,oBAAoB,CAAC,QAAQ,CAACC,UAAoB,CAAC,CAAC;QAC/D,YAAY,EAAE,QAAQ,CAACC,aAAuB,CAAC;QAE/C,YAAY,EAAE,SAAS,CAAC,QAAQ,CAACC,aAAuB,CAAC,EAAE,cAAc,CAAC;QAC1E,kBAAkB,EAAE,UAAU,CAAC,QAAQ,CAACC,qBAA+B,CAAC,EAAE,oBAAoB,CAAC;QAE/F,gBAAgB,EAAE,UAAU,CAAC,QAAQ,CAACC,kBAA4B,CAAC,EAAE,kBAAkB,CAAC;QAExF,kBAAkB,EAAE,UAAU,CAAC,QAAQ,CAACC,mBAA6B,CAAC,EAAE,oBAAoB,CAAC;QAC7F,eAAe,EAAE,UAAU,CAAC,QAAQ,CAACC,gBAA0B,CAAC,EAAE,iBAAiB,CAAC;QACpF,uBAAuB,EAAE,UAAU,CACjC,QAAQ,CAACC,yBAAmC,CAAC,EAC7C,yBAAyB,CAC1B;QAED,wBAAwB,EAAE,SAAS,CACjC,QAAQ,CAACC,4BAAsC,CAAC,EAChD,0BAA0B,CAC3B;QACD,gBAAgB,EAAE,QAAQ,CAACC,mBAA6B,CAAC;QAEzD,0BAA0B,EAAE,UAAU,CACpC,QAAQ,CAACC,4BAAsC,CAAC,EAChD,4BAA4B,CAC7B;QACD,mCAAmC,EAAE,SAAS,CAC5C,QAAQ,CAACC,uCAAiD,CAAC,EAC3D,qCAAqC,CACtC;QACD,gCAAgC,EAAE,UAAU,CAC1C,QAAQ,CAACC,oCAA8C,CAAC,EACxD,kCAAkC,CACnC;QACD,6BAA6B,EAAE,oBAAoB,CACjD,QAAQ,CAACC,gCAA0C,CAAC,CACrD;QAED,kBAAkB,EAAE,gCAAgC,CAAC,QAAQ,CAACC,mBAA6B,CAAC,CAAC;QAE7F,MAAM,EAAE,QAAQ,CAACC,MAAgB,CAAC;QAElC,aAAa,EAAE,UAAU,CAAC,QAAQ,CAACC,cAAwB,CAAC,EAAE,eAAe,CAAC;QAE9E,kBAAkB,EAAE,QAAQ,CAACC,0BAAoC,CAAC;KACnE,CAAC;AACJ,CAAC;AAED;;;;;;;AAOA,SAAgB,2BAA2B,CAAC,QAAa;IACvD,MAAM,mBAAmB,GAAG,sBAAsB,CAAC,QAAQ,CAACC,aAAuB,CAAC,CAAC,CAAC;IACtF,qCACE,IAAI,EAAE,SAAS,CAAC,QAAQ,CAACnB,UAAoB,CAAC,EAAE,WAAW,CAAC,EAC5D,WAAW,EAAE,qBAAqB,CAAC,QAAQ,CAACoB,aAAuB,CAAC,CAAC,EACrE,iBAAiB,EAAE,qBAAqB,CAAC,QAAQ,CAACC,aAAuB,CAAC,CAAC,IACxE,mBAAmB,KACtB,SAAS,EAAE,OAAO,CAAC,QAAQ,CAACC,UAAoB,CAAC,EAAE,WAAW,CAAC,EAC/D,UAAU,EAAE,OAAO,CAAC,QAAQ,CAACC,UAAoB,CAAC,EAAE,YAAY,CAAC,EACjE,UAAU,EAAE,OAAO,CAAC,QAAQ,CAACC,WAAqB,CAAC,EAAE,YAAY,CAAC,IAClE;AACJ,CAAC;AAoeD;;;;;AAKA,MAAa,uBAAuB;IAClC,SAAS,CAAC,QAA8B;QACtC,OAAO,yBAAyB,CAAC,kBAAkB,EAAE,QAAQ,CAAC,CAAC;KAChE;IAEK,WAAW,CAAC,QAA+B;;YAC/C,OAAO,0BAA0B,CAAC,CAAC,WAAW,CAAC,EAAE,QAAQ,CAAC,CAAC;SAC5D;KAAA;CACF;;ACrnBD;AACA,AAYA;;;;;;;AAOA,SAAgB,SAAS,CAAC,OAAY;IACpC,OAAO;QACL,IAAI,EAAE,SAAS,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,UAAU,CAAC;QAChD,MAAM,EAAE,cAAc,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QACzC,MAAM,EAAE,aAAa,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;KACzC,CAAC;AACJ,CAAC;AAED;;;;;;;AAOA,SAAS,cAAc,CAAC,KAAU;IAChC,IAAI,MAA6C,CAAC;IAElD,IAAI,KAAK,CAAC,eAAe,CAAC,IAAI,SAAS,EAAE;QACvC,MAAM,GAAG;YACP,aAAa,EAAE,KAAK,CAAC,eAAe,CAAC;YACrC,aAAa,EAAE,2BAA2B,CAAC,KAAK,CAAC,YAAY,CAAC,EAAE,eAAe,CAAC;SACjF,CAAC;KACH;SAAM;QACL,MAAM,GAAG;YACP,aAAa,EAAE,oBAAoB,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;YAC3D,OAAO,EAAE,oBAAoB,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;YAC7C,EAAE,EAAE,oBAAoB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACrC,OAAO,EAAE,oBAAoB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YAC/C,gBAAgB,EAAE,oBAAoB,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;YACjE,SAAS,EAAE,oBAAoB,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YACnD,SAAS,EAAE,oBAAoB,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YACnD,WAAW,EAAE,oBAAoB,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;YACvD,qBAAqB,EAAE,2BAA2B,CAChD,KAAK,CAAC,YAAY,CAAC,EACnB,uBAAuB,CACxB;SACF,CAAC;KACH;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;;AAMA,SAAS,aAAa,CAAC,KAAU;IAC/B,OAAO;QACL,aAAa,EAAE,KAAK,CAAC,eAAe,CAAC;QACrC,aAAa,EAAE,2BAA2B,CAAC,KAAK,CAAC,YAAY,CAAC,EAAE,eAAe,CAAC;KACjF,CAAC;AACJ,CAAC;AA+FD;;;;;;AAMA,SAAgB,yBAAyB,CAAC,IAAuB;IAC/D,MAAM,QAAQ,GAAwB;QACpC,MAAM,EAAE,EAAE;QACV,MAAM,EAAE,EAAE;QACV,IAAI,EAAE,IAAI,CAAC,IAAI;KAChB,CAAC;IAEF,IAAI,IAAI,CAAC,MAAM,IAAI,SAAS,EAAE;;QAE5B,QAAQ,CAAC,MAAM,GAAG;YAChB,aAAa,EAAE,KAAK;SACrB,CAAC;QACF,QAAQ,CAAC,MAAM,CAACpC,mBAA6B,CAAC,GAAG;YAC/C,SAAS,EAAE,WAAW;YACtB,UAAU,EAAE,2CAA2C;SACxD,CAAC;KACH;SAAM;QACL,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,eAAe,CAAC,EAAE;YAC/C,MAAM,SAAS,GAAkB,IAAI,CAAC,MAAuB,CAAC;YAC9D,QAAQ,CAAC,MAAM,GAAG;gBAChB,aAAa,EAAE,SAAS,CAAC,aAAa;gBACtC,UAAU,EAAE,6BAA6B,CAAC,SAAS,CAAC,aAAa,EAAE,eAAe,CAAC;aACpF,CAAC;YACF,QAAQ,CAAC,MAAM,CAACA,mBAA6B,CAAC,GAAG;gBAC/C,SAAS,EAAE,WAAW;gBACtB,UAAU,EAAE,2CAA2C;aACxD,CAAC;SACH;aAAM;YACL,MAAM,iBAAiB,GAA0B,IAAI,CAAC,MAA+B,CAAC;YAEtF,QAAQ,CAAC,MAAM,GAAG;gBAChB,aAAa,EAAE,iBAAiB,CAAC,aAAa;gBAC9C,KAAK,EAAE,iBAAiB,CAAC,OAAO;gBAChC,EAAE,EAAE,iBAAiB,CAAC,EAAE;gBACxB,OAAO,EAAE,iBAAiB,CAAC,OAAO;gBAClC,gBAAgB,EAAE,iBAAiB,CAAC,gBAAgB;gBACpD,WAAW,EAAE,iBAAiB,CAAC,WAAW;gBAC1C,SAAS,EAAE,iBAAiB,CAAC,SAAS;gBACtC,SAAS,EAAE,iBAAiB,CAAC,SAAS;gBACtC,UAAU,EAAE,6BAA6B,CACvC,iBAAiB,CAAC,qBAAqB,EACvC,uBAAuB,CACxB;aACF,CAAC;YACF,QAAQ,CAAC,MAAM,CAACA,mBAA6B,CAAC,GAAG;gBAC/C,SAAS,EAAE,mBAAmB;gBAC9B,UAAU,EAAE,2CAA2C;aACxD,CAAC;SACH;KACF;IAED,IAAI,IAAI,CAAC,MAAM,IAAI,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC,aAAa,IAAI,SAAS,EAAE;;QAEtE,QAAQ,CAAC,MAAM,GAAG,EAAE,CAAC;QACrB,QAAQ,CAAC,MAAM,CAACA,mBAA6B,CAAC,GAAG;YAC/C,SAAS,EAAE,iBAAiB;YAC5B,UAAU,EAAE,2CAA2C;SACxD,CAAC;KACH;SAAM;QACL,QAAQ,CAAC,MAAM,GAAG;YAChB,aAAa,EAAE,IAAI,CAAC,MAAM,CAAC,aAAa;YACxC,UAAU,EAAE,6BAA6B,CAAC,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE,eAAe,CAAC;SACtF,CAAC;QACF,QAAQ,CAAC,MAAM,CAACA,mBAA6B,CAAC,GAAG;YAC/C,SAAS,EAAE,eAAe;YAC1B,UAAU,EAAE,2CAA2C;SACxD,CAAC;KACH;IAED,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED;;;;;AAKA,MAAa,sBAAsB;IACjC,SAAS,CAAC,IAAoB;QAC5B,OAAO,yBAAyB,CAAC,iBAAiB,EAAE,yBAAyB,CAAC,IAAI,CAAC,CAAC,CAAC;KACtF;IAEK,WAAW,CAAC,QAA+B;;YAC/C,OAAO,0BAA0B,CAAC,CAAC,WAAW,EAAE,kBAAkB,EAAE,UAAU,CAAC,EAAE,QAAQ,CAAC,CAAC;SAC5F;KAAA;CACF;AAED;;;;AAIA,SAAgB,eAAe,CAAC,MAAW;IACzC,OAAO,MAAM,IAAI,IAAI,IAAI,OAAO,MAAM,KAAK,QAAQ,IAAI,eAAe,IAAI,MAAM,CAAC;AACnF,CAAC;AAED;;;;;;;AAOA,IAAK,8BAMJ;AAND,WAAK,8BAA8B;IACjC,uDAAqB,CAAA;IACrB,uDAAqB,CAAA;IACrB,mDAAiB,CAAA;IACjB,uDAAqB,CAAA;IACrB,yDAAuB,CAAA;AACzB,CAAC,EANI,8BAA8B,KAA9B,8BAA8B,QAMlC;AAED;;;;AAIA,IAAK,iCAMJ;AAND,WAAK,iCAAiC;IACpC,gDAAW,CAAA;IACX,sDAAiB,CAAA;IACjB,sDAAiB,CAAA;IACjB,wDAAmB,CAAA;IACnB,sDAAiB,CAAA;AACnB,CAAC,EANI,iCAAiC,KAAjC,iCAAiC,QAMrC;AAoBD;;;;;;AAMA,MAAM,kBAAkB,GAAG,yBAAyB,CAAC;AAErD;;;;;;;AAOA,SAAS,2BAA2B,CAClC,KAAU,EACV,SAAoD;;IAEpD,IAAI,CAAC,KAAK,EAAE;QACV,OAAO,SAAS,CAAC;KAClB;IACD,MAAM,UAAU,GAAQ,EAAE,CAAC;IAC3B,IAAI,aAAa,CAAC;IAClB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC,WAAI,KAAK,CAAC,kBAAkB,CAAC,0CAAE,GAAG,CAAA,EAAE;;;;;;QAM/E,aAAa,GAAG,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC,CAAC;KAC7C;SAAM;QACL,aAAa,GAAG,KAAK,CAAC,kBAAkB,CAAC,CAAC;KAC3C;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;QAChC,KAAK,MAAM,WAAW,IAAI,aAAa,EAAE;YACvC,MAAM,GAAG,GAAG,WAAW,CAAC,GAAG,CAAC;YAC5B,MAAM,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YACrC,MAAM,gBAAgB,GAAG,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC,QAAQ,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YAClF,IACE,gBAAgB,KAAK,iCAAiC,CAAC,GAAG;gBAC1D,gBAAgB,KAAK,iCAAiC,CAAC,MAAM,EAC7D;gBACA,UAAU,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;aACjC;iBAAM,IAAI,gBAAgB,KAAK,iCAAiC,CAAC,MAAM,EAAE;gBACxE,UAAU,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;aACzB;iBAAM,IAAI,gBAAgB,KAAK,iCAAiC,CAAC,OAAO,EAAE;gBACzE,UAAU,CAAC,GAAG,CAAC,GAAG,KAAK,KAAK,MAAM,GAAG,IAAI,GAAG,KAAK,CAAC;aACnD;iBAAM,IAAI,gBAAgB,KAAK,iCAAiC,CAAC,IAAI,EAAE;gBACtE,UAAU,CAAC,GAAG,CAAC,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC;aACnC;iBAAM;gBACL,MAAM,IAAI,SAAS,CACjB,yDAAyD,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE,CACvF,CAAC;aACH;SACF;KACF;SAAM;QACL,MAAM,IAAI,SAAS,CACjB,GAAG,SAAS,oEAAoE,IAAI,CAAC,SAAS,CAC5F,KAAK,CACN,EAAE,CACJ,CAAC;KACH;IACD,OAAO,UAAU,CAAC;AACpB,CAAC;AAED;;;;;;;AAOA,SAAgB,6BAA6B,CAC3C,UAA8C,EAC9C,SAAoD;IAEpD,IAAI,UAAU,IAAI,SAAS,EAAE;QAC3B,OAAO,SAAS,CAAC;KAClB;IACD,IACE,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC;QACzB,OAAO,UAAU,KAAK,QAAQ;QAC9B,OAAO,UAAU,KAAK,QAAQ;QAC9B,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,MAAM,GAAG,CAAC,EACrC;QACA,MAAM,IAAI,SAAS,CACjB,6BAA6B,SAAS,IAAI,IAAI,CAAC,SAAS,CACtD,UAAU,CACX,gDAAgD,CAClD,CAAC;KACH;IACD,MAAM,aAAa,GAAsB,EAAE,CAAC;IAC5C,KAAK,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;QACnD,IAAI,IAA+B,CAAC;QACpC,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC7B,IAAI,GAAG,8BAA8B,CAAC,MAAM,CAAC;SAC9C;aAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YACpC,IAAI,GAAG,8BAA8B,CAAC,MAAM,CAAC;SAC9C;aAAM,IAAI,OAAO,KAAK,KAAK,SAAS,EAAE;YACrC,IAAI,GAAG,8BAA8B,CAAC,OAAO,CAAC;SAC/C;aAAM,IAAI,KAAK,YAAY,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,EAAE;YAC3D,IAAI,GAAG,8BAA8B,CAAC,IAAI,CAAC;YAC3C,KAAK,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC;SACxB;aAAM;YACL,MAAM,IAAI,SAAS,CACjB,yCAAyC,SAAS,iBAAiB,GAAG,GAAG,CAC1E,CAAC;SACH;QAED,MAAM,YAAY,GAAoB;YACpC,GAAG,EAAE,GAAG;YACR,KAAK,EAAE;gBACL,CAACA,mBAA6B,GAAG;oBAC/B,SAAS,EAAE,IAAI;oBACf,WAAW,EAAE,kCAAkC;iBAChD;gBACD,CAACqC,gBAA0B,GAAG,KAAK;aACpC;SACF,CAAC;QACF,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;KAClC;IACD,OAAO;QACL,CAAC,kBAAkB,GAAG,aAAa;KACpC,CAAC;AACJ,CAAC;;ACvbD;AACA,AA2BA;;;;;;;;AAQA,SAAgB,wBAAwB,CACtC,YAAuC;IAEvC,OAAO;QACL,YAAY,EAAE,YAAY,CAAC,YAAY;QACvC,eAAe,EAAE,oBAAoB,CAAC,YAAY,CAAC,eAAe,CAAC;QACnE,wBAAwB,EAAE,oBAAoB,CAAC,YAAY,CAAC,wBAAwB,CAAC;QACrF,gCAAgC,EAAE,oBAAoB,CACpD,YAAY,CAAC,gCAAgC,CAC9C;QACD,yCAAyC,EAAE,oBAAoB,CAC7D,YAAY,CAAC,yCAAyC,CACvD;QACD,sBAAsB,EAAE,YAAY,CAAC,kBAAkB;cACnD,yBAAyB,CAAC,YAAY,CAAC,kBAAkB,CAAC;cAC1D,SAAS;QACb,gBAAgB,EAAE,oBAAoB,CAAC,YAAY,CAAC,gBAAgB,CAAC;QACrE,uBAAuB,EAAE,oBAAoB,CAAC,YAAY,CAAC,uBAAuB,CAAC;QACnF,MAAM,EAAE,oBAAoB,CAAC,YAAY,CAAC,MAAM,CAAC;QACjD,SAAS,EAAE,oBAAoB,CAAC,YAAY,CAAC,SAAS,CAAC;QACvD,YAAY,EAAE,oBAAoB,CAAC,YAAY,CAAC,YAAY,CAAC;QAC7D,6BAA6B,EAAE,oBAAoB,CAAC,YAAY,CAAC,6BAA6B,CAAC;QAC/F,gBAAgB,EAAE,oBAAoB,CAAC,YAAY,CAAC,gBAAgB,CAAC;QACrE,wBAAwB,EAAE,oBAAoB,CAAC,YAAY,CAAC,kBAAkB,CAAC;KAChF,CAAC;AACJ,CAAC;AAED;;;;;;;AAOA,SAAgB,iBAAiB,CAAC,eAAoB;IACpD,OAAO;QACL,gBAAgB,EAAE,SAAS,CAAC,eAAe,CAACC,iBAA2B,CAAC,EAAE,kBAAkB,CAAC;QAC7F,SAAS,EAAE,SAAS,CAAC,eAAe,CAACC,UAAoB,CAAC,EAAE,WAAW,CAAC;QAExE,YAAY,EAAE,SAAS,CAAC,eAAe,CAACxB,aAAuB,CAAC,EAAE,cAAc,CAAC;QACjF,gBAAgB,EAAE,UAAU,CAAC,eAAe,CAACE,kBAA4B,CAAC,EAAE,kBAAkB,CAAC;QAE/F,eAAe,EAAE,UAAU,CAAC,eAAe,CAACE,gBAA0B,CAAC,EAAE,iBAAiB,CAAC;QAC3F,uBAAuB,EAAE,UAAU,CACjC,eAAe,CAACC,yBAAmC,CAAC,EACpD,yBAAyB,CAC1B;QAED,wBAAwB,EAAE,SAAS,CACjC,eAAe,CAACC,4BAAsC,CAAC,EACvD,0BAA0B,CAC3B;QACD,gBAAgB,EAAE,SAAS,CAAC,eAAe,CAACC,mBAA6B,CAAC,EAAE,kBAAkB,CAAC;QAE/F,gCAAgC,EAAE,UAAU,CAC1C,eAAe,CAACG,oCAA8C,CAAC,EAC/D,kCAAkC,CACnC;QACD,yCAAyC,EAAE,UAAU,CACnD,eAAe,CAACe,8CAAwD,CAAC,EACzE,2CAA2C,CAC5C;QACD,6BAA6B,EAAE,oBAAoB,CACjD,eAAe,CAACd,gCAA0C,CAAC,CAC5D;QAED,SAAS,EAAE,oBAAoB,CAAC,eAAe,CAACb,UAAoB,CAAC,CAAC;QACtE,YAAY,EAAE,eAAe,CAACC,aAAuB,CAAC;QAEtD,MAAM,EAAE,SAAS,CAAC,eAAe,CAACc,MAAgB,CAAC,EAAE,QAAQ,CAAiB;QAE9E,kBAAkB,EAAE,SAAS,CAC3B,eAAe,CAACE,0BAAoC,CAAC,EACrD,oBAAoB,CACO;KAC9B,CAAC;AACJ,CAAC;AAED;;;;;;;AAOA,SAAgB,kCAAkC,CAChD,eAAoB;IAEpB,MAAM,mBAAmB,GAAG,sBAAsB,CAAC,eAAe,CAACC,aAAuB,CAAC,CAAC,CAAC;IAC7F,OAAO;QACL,gBAAgB,EAAE,SAAS,CAAC,eAAe,CAACO,iBAA2B,CAAC,EAAE,kBAAkB,CAAC;QAC7F,SAAS,EAAE,SAAS,CAAC,eAAe,CAACC,UAAoB,CAAC,EAAE,WAAW,CAAC;QACxE,iBAAiB,EAAE,UAAU,CAAC,eAAe,CAACN,aAAuB,CAAC,EAAE,cAAc,CAAC;QACvF,kBAAkB,EAAE,mBAAmB,CAAC,kBAAkB;QAC1D,sBAAsB,EAAE,mBAAmB,CAAC,sBAAsB;QAClE,8BAA8B,EAAE,mBAAmB,CAAC,8BAA8B;QAClF,oBAAoB,EAAE,mBAAmB,CAAC,oBAAoB;QAC9D,SAAS,EAAE,OAAO,CAAC,eAAe,CAACC,UAAoB,CAAC,EAAE,WAAW,CAAC;QACtE,UAAU,EAAE,OAAO,CAAC,eAAe,CAACC,UAAoB,CAAC,EAAE,YAAY,CAAC;QACxE,UAAU,EAAE,OAAO,CAAC,eAAe,CAACC,WAAqB,CAAC,EAAE,YAAY,CAAC;KAC1E,CAAC;AACJ,CAAC;AAuaD;;;;;AAKA,MAAa,8BAA8B;IACzC,SAAS,CAAC,QAAqC;QAC7C,OAAO,yBAAyB,CAAC,yBAAyB,EAAE,QAAQ,CAAC,CAAC;KACvE;IAEK,WAAW,CAAC,QAA+B;;YAC/C,OAAO,0BAA0B,CAAC,CAAC,WAAW,EAAE,kBAAkB,CAAC,EAAE,QAAQ,CAAC,CAAC;SAChF;KAAA;CACF;;AC7jBD;AACA,AAwBA;;;;;;;;AAQA,SAAgB,iBAAiB,CAAC,KAAyB;IACzD,OAAO;QACL,wBAAwB,EAAE,KAAK,CAAC,wBAAwB;QACxD,kBAAkB,EAAE,oBAAoB,CAAC,KAAK,CAAC,kBAAkB,CAAC;QAClE,0BAA0B,EAAE,oBAAoB,CAAC,KAAK,CAAC,0BAA0B,CAAC;QAClF,mCAAmC,EAAE,KAAK,CAAC,mCAAmC;QAC9E,uBAAuB,EAAE,oBAAoB,CAAC,KAAK,CAAC,uBAAuB,CAAC;QAC5E,kBAAkB,EAAE,wBAAwB,CAAC,KAAK,CAAC,kBAAkB,CAAC;QACtE,MAAM,EAAE,oBAAoB,CAAC,KAAK,CAAC,MAAM,CAAC;QAC1C,YAAY,EAAE,oBAAoB,CAAC,KAAK,CAAC,YAAY,CAAC;QACtD,eAAe,EAAE,oBAAoB,CAAC,KAAK,CAAC,eAAe,CAAC;QAC5D,gBAAgB,EAAE,oBAAoB,CAAC,KAAK,CAAC,gBAAgB,CAAC;QAC9D,kBAAkB,EAAE,oBAAoB,CAAC,KAAK,CAAC,kBAAkB,CAAC;QAClE,wBAAwB,EAAE,oBAAoB,CAAC,KAAK,CAAC,kBAAkB,CAAC;QACxE,aAAa,EAAE,oBAAoB,CAAC,KAAK,CAAC,aAAa,CAAC;KACzD,CAAC;AACJ,CAAC;AAED;;;;;;;AAOA,SAAgB,UAAU,CAAC,QAAa;IACtC,OAAO;QACL,IAAI,EAAE,SAAS,CAAC,QAAQ,CAACG,UAAoB,CAAC,EAAE,WAAW,CAAC;QAC5D,kBAAkB,EAAE,UAAU,CAAC,QAAQ,CAACvB,qBAA+B,CAAC,EAAE,oBAAoB,CAAC;QAE/F,kBAAkB,EAAE,UAAU,CAAC,QAAQ,CAACE,mBAA6B,CAAC,EAAE,oBAAoB,CAAC;QAC7F,eAAe,EAAE,UAAU,CAAC,QAAQ,CAACuB,gBAA0B,CAAC,EAAE,iBAAiB,CAAC;QACpF,uBAAuB,EAAE,UAAU,CACjC,QAAQ,CAACrB,yBAAmC,CAAC,EAC7C,yBAAyB,CAC1B;QAED,wBAAwB,EAAE,SAAS,CACjC,QAAQ,CAACC,4BAAsC,CAAC,EAChD,0BAA0B,CAC3B;QACD,gBAAgB,EAAE,QAAQ,CAACC,mBAA6B,CAAC;QAEzD,0BAA0B,EAAE,UAAU,CACpC,QAAQ,CAACC,4BAAsC,CAAC,EAChD,4BAA4B,CAC7B;QACD,mCAAmC,EAAE,SAAS,CAC5C,QAAQ,CAACC,uCAAiD,CAAC,EAC3D,qCAAqC,CACtC;QAED,kBAAkB,EAAE,gCAAgC,CAAC,QAAQ,CAACG,mBAA6B,CAAC,CAAC;QAC7F,YAAY,EAAE,QAAQ,CAACb,aAAuB,CAAC;QAE/C,MAAM,EAAE,QAAQ,CAACc,MAAgB,CAAC;QAElC,aAAa,EAAE,UAAU,CAAC,QAAQ,CAACC,cAAwB,CAAC,EAAE,eAAe,CAAC;QAE9E,kBAAkB,EAAE,QAAQ,CAACC,0BAAoC,CAAC;KACnE,CAAC;AACJ,CAAC;AAED;;;;;;;AAOA,SAAgB,2BAA2B,CAAC,QAAa;IACvD,OAAO;QACL,IAAI,EAAE,SAAS,CAAC,QAAQ,CAACS,UAAoB,CAAC,EAAE,WAAW,CAAC;QAC5D,WAAW,EAAE,qBAAqB,CAAC,QAAQ,CAACP,aAAuB,CAAC,CAAC;QACrE,iBAAiB,EAAE,qBAAqB,CAAC,QAAQ,CAACU,kBAA4B,CAAC,CAAC;QAChF,SAAS,EAAE,OAAO,CAAC,QAAQ,CAACR,UAAoB,CAAC,EAAE,WAAW,CAAC;QAC/D,qBAAqB,EAAE,sBAAsB,CAAC,QAAQ,CAACH,aAAuB,CAAC,CAAC;aAC7E,qBAAqB;QACxB,UAAU,EAAE,OAAO,CAAC,QAAQ,CAACI,UAAoB,CAAC,EAAE,YAAY,CAAC;QACjE,UAAU,EAAE,OAAO,CAAC,QAAQ,CAACC,WAAqB,CAAC,EAAE,YAAY,CAAC;KACnE,CAAC;AACJ,CAAC;AAmVD;;;;;AAKA,MAAa,uBAAuB;IAClC,SAAS,CAAC,QAA8B;QACtC,OAAO,yBAAyB,CAAC,kBAAkB,EAAE,QAAQ,CAAC,CAAC;KAChE;IACK,WAAW,CAAC,QAA+B;;YAC/C,OAAO,0BAA0B,CAAC,CAAC,WAAW,CAAC,EAAE,QAAQ,CAAC,CAAC;SAC5D;KAAA;CACF;;ACjdD;AACA,AAQA;;;;;;AAMA,MAAa,mBAAmB;;;;;;;IAiB9B,YAAY,OAAe,EAAE,GAAW;QACtC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;KAChB;;;;;IAMD,QAAQ,CAAC,QAAgB;QACvB,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,GAAG,IAAI,EAAE,QAAQ,CAAC,CAAC;KAC1E;;;;;;;IAQS,YAAY,CACpB,MAAc,EACd,QAAgB,EAChB,SAA2B;QAE3B,QAAQ,GAAG,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QACxC,MAAM,OAAO,GAAG,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACjD,MAAM,YAAY,GAAG,QAAQ,GAAG,IAAI,GAAG,MAAM,CAAC;QAC9C,SAAS,GAAG,SAAS,IAAI,IAAI,CAAC,GAAG,CAAC;QAClC,IAAI,MAAW,CAAC;QAChB,IAAI,QAAQ,CAAC,SAAS,CAAC,EAAE;YACvB,MAAM,GAAG,IAAI,KAAK,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;YAC7C,MAAM,CAAC,UAAU,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;YAC5C,MAAM,CAAC,MAAM,CAACrC,aAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;SAC1C;aAAM;YACL,MAAM,GAAG,IAAI,KAAK,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;YACtC,MAAM,CAAC,UAAU,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;YACrC,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;SAC7B;QACD,MAAM,GAAG,GAAG,kBAAkB,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QACtD,OAAO;YACL,KAAK,EAAE,4BAA4B,QAAQ,QAAQ,GAAG,OAAO,MAAM,QAAQ,OAAO,EAAE;YACpF,kBAAkB,EAAE,MAAM;SAC3B,CAAC;KACH;;;;;IAMD,OAAO,oBAAoB,CAAC,gBAAwB;QAClD,MAAM,MAAM,GAAG4C,8BAAqB,CAIjC,gBAAgB,CAAC,CAAC;QAErB,IAAI,MAAM,CAAC,qBAAqB,IAAI,IAAI,EAAE;YACxC,OAAO,IAAI,mBAAmB,CAAC,MAAM,CAAC,mBAAmB,EAAE,MAAM,CAAC,eAAe,CAAC,CAAC;SACpF;aAAM;YACL,OAAO,IAAI,+BAA+B,CAAC,MAAM,CAAC,qBAAqB,CAAC,CAAC;SAC1E;KACF;CACF;AAED;;;;;;;AAOA,MAAa,+BAAgC,SAAQ,mBAAmB;;;;;IAOtE,YAAY,qBAA6B;QACvC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QAEd,IAAI,CAAC,YAAY,GAAG;YAClB,KAAK,EAAE,qBAAqB;YAC5B,kBAAkB,EAAE,CAAC;SACtB,CAAC;KACH;;;;;;IAOD,QAAQ,CAAC,SAAiB;QACxB,OAAO,IAAI,CAAC,YAAY,CAAC;KAC1B;CACF;;AC/HD;AACA,AAOA;;;;AAIA,SAAsB,WAAW,CAAC,MAAc,EAAE,YAAoB;;QACpE,MAAM,MAAM,GAAG,kBAAkB,CAC/B,MAAM;aACH,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC;aAC5B,MAAM,CAAC,YAAY,CAAC;aACpB,MAAM,CAAC,QAAQ,CAAC,CACpB,CAAC;QACF,OAAO,MAAM,CAAC;KACf;CAAA;;ACpBD;AACA,AAUA;;;;;;AAMA,MAAa,2BAA2B;;;;;;;;IAWtC,YAAY,mBAA2B,EAAE,eAAuB;QAC9D,IAAI,CAAC,OAAO,GAAG,mBAAmB,CAAC;QACnC,IAAI,CAAC,QAAQ,GAAG,eAAe,CAAC;QAChC,IAAI,CAAC,mBAAmB,GAAG,IAAI,mBAAmB,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;KACjF;IAEa,kBAAkB,CAAC,SAAiB,EAAE,cAAsB;;YACxE,MAAM,YAAY,GAAG,GAAG,SAAS,KAAK,cAAc,EAAE,CAAC;YACvD,MAAM,MAAM,GAAG,MAAM,WAAW,CAAC,IAAI,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;YAC9D,OAAO,MAAM,CAAC;SACf;KAAA;;;;;;;IAQK,WAAW,CAAC,WAAwB;;YACxC,IAAI,CAAC,WAAW,CAAC,OAAO;gBAAE,WAAW,CAAC,OAAO,GAAG,IAAIC,oBAAW,EAAE,CAAC;YAElE,MAAM,SAAS,GAAG,kBAAkB,CAAC,WAAW,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;YAElF,MAAM,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;YACxB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,CAAC;YACvC,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,CAAC;YACzD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;YAC3E,WAAW,CAAC,OAAO,CAAC,GAAG,CACrB,eAAe,EACf,6BAA6B,SAAS,OAAO,cAAc,QAAQ,IAAI,CAAC,OAAO,OAAO,SAAS,EAAE,CAClG,CAAC;YACF,WAAW,CAAC,eAAe,GAAG,IAAI,CAAC;YACnC,OAAO,WAAW,CAAC;SACpB;KAAA;IAED,QAAQ,CAAC,QAAgB;QACvB,OAAO,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;KACpD;CACF;;AClED;AACA,AAMA;;;;;;;AAOA,SAAgB,UAAU,CACxB,aAAqB,EACrB,mBAAqC,EAAE;;IAEvC,MAAM,MAAM,GAAGC,qBAAS,EAAE,CAAC;IAC3B,MAAM,WAAW,yCACZ,gBAAgB,CAAC,cAAc,0CAAE,WAAW,KAC/C,IAAI,EAAEC,YAAQ,CAAC,QAAQ,GACxB,CAAC;IAEF,MAAM,IAAI,GAAG,MAAM,CAAC,SAAS,CAAC,oBAAoB,aAAa,EAAE,EAAE,WAAW,CAAC,CAAC;IAChF,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,sBAAsB,CAAC,CAAC;IAE1D,IAAI,cAAc,GAAG,OAAA,gBAAgB,CAAC,cAAc,0CAAE,WAAW,KAAI,EAAE,CAAC;IACxE,IAAI,IAAI,CAAC,WAAW,EAAE,EAAE;QACtB,cAAc,yCACT,gBAAgB,CAAC,cAAc,0CAAE,WAAW,KAC/C,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,EACtB,UAAU,kCACL,WAAW,CAAC,UAAU,KACzB,cAAc,EAAE,sBAAsB,MAEzC,CAAC;KACH;IAED,OAAO;QACL,IAAI;QACJ,uBAAuB,kCAClB,gBAAgB,KACnB,cAAc,kCAAO,gBAAgB,aAAhB,gBAAgB,uBAAhB,gBAAgB,CAAE,cAAc,KAAE,WAAW,EAAE,cAAc,MACnF;KACF,CAAC;AACJ,CAAC;AAED;;;;AAIA,SAAgB,gBAAgB,CAAC,GAAU;IACzC,IAAI,GAAG,YAAYvC,kBAAS,EAAE;QAC5B,QAAQ,GAAG,CAAC,UAAU;YACpB,KAAK,GAAG;gBACN,OAAOwC,iBAAa,CAAC,iBAAiB,CAAC;YACzC,KAAK,GAAG;gBACN,OAAOA,iBAAa,CAAC,SAAS,CAAC;YACjC,KAAK,GAAG;gBACN,OAAOA,iBAAa,CAAC,mBAAmB,CAAC;SAC5C;KACF;IAED,OAAOA,iBAAa,CAAC,OAAO,CAAC;AAC/B,CAAC;;ACjED;AACA,AA8GA;;;;;AAKA,MAAa,8BAA+B,SAAQC,sBAAa;IA8C/D,YACE,0CAAkD,EAClD,oBAAwD,EACxD,QAA0B;;QAE1B,IAAI,OAAwB,CAAC;QAC7B,IAAI,uBAA+B,CAAC;QACpC,IAAI,WAA0D,CAAC;QAC/D,IAAI,UAAgC,CAAC;QACrC,IAAIC,0BAAiB,CAAC,oBAAoB,CAAC,EAAE;YAC3C,uBAAuB,GAAG,0CAA0C,CAAC;YACrE,OAAO,GAAG,QAAQ,IAAI,EAAE,CAAC;YACzB,WAAW,GAAG,oBAAoB,CAAC;YACnC,UAAU,GAAGC,wCAA+B,CAAC,WAAW,EAAEC,kBAAa,CAAC,kBAAkB,CAAC,CAAC;SAC7F;aAAM;YACL,MAAM,gBAAgB,GAAG,0CAA0C,CAAC;YACpE,OAAO,GAAG,oBAAoB,IAAI,EAAE,CAAC;YACrC,MAAM,mBAAmB,GAAQR,8BAAqB,CAAC,gBAAgB,CAAC,CAAC;YACzE,IAAI,mBAAmB,CAAC,QAAQ,IAAI,SAAS,EAAE;gBAC7C,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;aAC3D;YACD,IAAI;gBACF,uBAAuB,GAAG,mBAAmB,CAAC,QAAQ,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;aACjF;YAAC,OAAO,KAAK,EAAE;gBACd,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;aACpE;YACD,WAAW,GAAG,IAAI,2BAA2B,CAC3C,mBAAmB,CAAC,mBAAmB,EACvC,mBAAmB,CAAC,eAAe,CACpC,CAAC;YACF,UAAU,GAAGS,sBAAa,CAAC,WAAW,CAAC,CAAC;SACzC;QACD,MAAM,eAAe,GAAG,qBAAqB,OAAC,OAAO,CAAC,gBAAgB,0CAAE,eAAe,CAAC,CAAC;QACzF,MAAM,oBAAoB,GAAGC,kCAAyB,iCAE/C,OAAO,KACV,gBAAgB,EAAE;gBAChB,eAAe;aAChB,KAEH,UAAU,CACX,CAAC;QACF,KAAK,CAAC,WAAW,EAAE,oBAAoB,CAAC,CAAC;QACzC,IAAI,CAAC,QAAQ,GAAG,uBAAuB,CAAC;QACxC,IAAI,CAAC,oBAAoB,GAAG,uBAAuB,CAAC,QAAQ,CAAC,GAAG,CAAC;cAC7D,OAAO,GAAG,uBAAuB;cACjC,OAAO,GAAG,uBAAuB,GAAG,GAAG,CAAC;QAC5C,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,2BAA2B,GAAG,IAAI,2BAA2B,EAAE,CAAC;QACrE,IAAI,CAAC,uBAAuB,GAAG,IAAI,uBAAuB,EAAE,CAAC;QAC7D,IAAI,CAAC,uBAAuB,GAAG,IAAI,uBAAuB,EAAE,CAAC;QAC7D,IAAI,CAAC,8BAA8B,GAAG,IAAI,8BAA8B,EAAE,CAAC;QAC3E,IAAI,CAAC,sBAAsB,GAAG,IAAI,sBAAsB,EAAE,CAAC;KAC5D;;;;;;;IAQK,sBAAsB,CAC1B,gBAAmC;;YAEnChD,oBAAM,CAAC,OAAO,CAAC,4DAA4D,CAAC,CAAC;YAC7E,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,uDAAuD,EACvD,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,gBAAgB,EAChB,IAAI,CAAC,2BAA2B,EAChC,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,gCAAgC,CAAC,QAAQ,CAAC,CAAC;aACxD;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;;;IAkBK,WAAW,CACf,SAAiB,EACjB,OAA4B;;YAE5B,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,4CAA4C,EAC5C,OAAO,CACR,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,wDAAwD,SAAS,oBAAoB,EACrF,OAAO,CACR,CAAC;gBACF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,SAAS,EACT,iBAAiB,CAAC,OAAO,IAAI,EAAE,CAAC,EAChC,IAAI,CAAC,uBAAuB,EAC5B,KAAK,EACL,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;aAC1C;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;;IAiBK,QAAQ,CACZ,SAAiB,EACjB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,yCAAyC,EACzC,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,qDAAqD,SAAS,GAAG,CAAC,CAAC;gBAClF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;aAC1C;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;IAgBK,yBAAyB,CAC7B,SAAiB,EACjB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,0DAA0D,EAC1D,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,sEAAsE,SAAS,GAAG,CACnF,CAAC;gBACF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,mCAAmC,CAAC,QAAQ,CAAC,CAAC;aAC3D;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;IAea,SAAS,CACrB,OAA+C;;YAE/C,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,0CAA0C,EAC1C,OAAO,CACR,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,gEAAgE,EAAE,OAAO,CAAC,CAAC;gBAC1F,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,aAAa,CAC9D,mBAAmB,EACnB,uBAAuB,EACvB,IAAI,CAAC,uBAAuB,CAC7B,CAAC;gBAEF,OAAO,IAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC;aAC/C;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;IAEc,cAAc,CAC3B,MAAe,EACf,UAAgE,EAAE;;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG;gBACD,YAAY,GAAG,oBAAM,IAAI,CAAC,SAAS,iBACjC,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,0BAAM,YAAY,CAAA,CAAC;aACpB,QAAQ,MAAM,EAAE;SAClB;KAAA;IAEc,aAAa,CAC1B,UAA4B,EAAE;;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,IAAA,KAAAiD,oBAAA,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA;oBAArD,MAAM,OAAO,WAAA,CAAA;oBACtB,oBAAA,OAAOC,uBAAAD,oBAAA,OAAO,CAAA,CAAA,CAAA,CAAC;iBAChB;;;;;;;;;SACF;KAAA;;;;;;;;;;;;;IAcM,UAAU,CACf,OAA0B;QAE1BjD,oBAAM,CAAC,OAAO,CAAC,iEAAiE,EAAE,OAAO,CAAC,CAAC;QAC3F,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QACzC,OAAO;;;;YAIL,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;aACpB;;;;YAID,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;aACb;;;;YAID,MAAM,EAAE,CAAC,WAAyB,EAAE;gBAClC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,iBAAiB,kBACnD,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;aACJ;SACF,CAAC;KACH;;;;;;;;;;;;;IAca,0BAA0B,CACtC,OAA+C;;YAE/C,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,2DAA2D,EAC3D,OAAO,CACR,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,iFAAiF,EACjF,OAAO,CACR,CAAC;gBACF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,aAAa,CAC9D,mBAAmB,EACnB,uBAAuB,EACvB,IAAI,CAAC,uBAAuB,CAC7B,CAAC;gBAEF,OAAO,IAAI,CAAC,wCAAwC,CAAC,QAAQ,CAAC,CAAC;aAChE;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;IAEc,+BAA+B,CAC5C,MAAe,EACf,UAAgE,EAAE;;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG;gBACD,YAAY,GAAG,oBAAM,IAAI,CAAC,0BAA0B,iBAClD,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,0BAAM,YAAY,CAAA,CAAC;aACpB,QAAQ,MAAM,EAAE;SAClB;KAAA;IAEc,8BAA8B,CAC3C,UAA4B,EAAE;;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,IAAA,KAAAiD,oBAAA,IAAI,CAAC,+BAA+B,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA;oBAAtE,MAAM,OAAO,WAAA,CAAA;oBACtB,oBAAA,OAAOC,uBAAAD,oBAAA,OAAO,CAAA,CAAA,CAAA,CAAC;iBAChB;;;;;;;;;SACF;KAAA;;;;;;;;;;;;;;IAeM,2BAA2B,CAChC,OAA0B;QAE1BjD,oBAAM,CAAC,OAAO,CACZ,kFAAkF,EAClF,OAAO,CACR,CAAC;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,8BAA8B,CAAC,OAAO,CAAC,CAAC;QAC1D,OAAO;;;;YAIL,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;aACpB;;;;YAID,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;aACb;;;;YAID,MAAM,EAAE,CAAC,WAAyB,EAAE;gBAClC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,kBACpE,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;aACJ;SACF,CAAC;KACH;;;;;;;;;;;;;;;;;;;;;IAsBK,WAAW,CACf,KAAoC,EACpC,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,4CAA4C,EAC5C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,wDAAwD,KAAK,CAAC,IAAI,oBAAoB,EACtF,KAAK,CACN,CAAC;gBAEF,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,IAAI,EAAE;oBAC7C,MAAM,IAAI,SAAS,CACjB,iGAAiG,CAClG,CAAC;iBACH;gBAED,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;oBACf,MAAM,IAAI,SAAS,CAAC,gEAAgE,CAAC,CAAC;iBACvF;gBAED,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,KAAK,CAAC,IAAI,EACV,iBAAiB,CAAC,KAAK,CAAC,EACxB,IAAI,CAAC,uBAAuB,EAC5B,IAAI,EACJ,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;aAC1C;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;IAgBK,WAAW,CACf,SAAiB,EACjB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,4CAA4C,EAC5C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,wDAAwD,SAAS,GAAG,CAAC,CAAC;gBACrF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,cAAc,CAC/D,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,uBAAuB,CACxB,CAAC;gBAEF,OAAO,EAAE,SAAS,EAAE,mBAAmB,CAAC,QAAQ,CAAC,EAAE,CAAC;aACrD;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;IAOK,WAAW,CAAC,SAAiB,EAAE,gBAAmC;;YACtE,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,4CAA4C,EAC5C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,wDAAwD,SAAS,GAAG,CAAC,CAAC;gBACrF,IAAI;oBACF,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,uBAAuB,CAAC,CAAC;iBACzD;gBAAC,OAAO,KAAK,EAAE;oBACd,IAAI,KAAK,CAAC,IAAI,IAAI,4BAA4B,EAAE;wBAC9C,OAAO,KAAK,CAAC;qBACd;oBACD,MAAM,KAAK,CAAC;iBACb;gBACD,OAAO,IAAI,CAAC;aACb;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;;;IAkBK,WAAW,CACf,SAAiB,EACjB,OAA4B;;YAE5B,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,4CAA4C,EAC5C,OAAO,CACR,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,wDAAwD,SAAS,oBAAoB,EACrF,OAAO,CACR,CAAC;gBACF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,SAAS,EACT,iBAAiB,CAAC,OAAO,IAAI,EAAE,CAAC,EAChC,IAAI,CAAC,uBAAuB,EAC5B,KAAK,EACL,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;aAC1C;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;;IAiBK,QAAQ,CACZ,SAAiB,EACjB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,yCAAyC,EACzC,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,qDAAqD,SAAS,GAAG,CAAC,CAAC;gBAClF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;aAC1C;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;IAgBK,yBAAyB,CAC7B,SAAiB,EACjB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,0DAA0D,EAC1D,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,sEAAsE,SAAS,GAAG,CACnF,CAAC;gBACF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,mCAAmC,CAAC,QAAQ,CAAC,CAAC;aAC3D;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;IAea,SAAS,CACrB,OAA+C;;YAE/C,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,0CAA0C,EAC1C,OAAO,CACR,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,gEAAgE,EAAE,OAAO,CAAC,CAAC;gBAC1F,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,aAAa,CAC9D,mBAAmB,EACnB,uBAAuB,EACvB,IAAI,CAAC,uBAAuB,CAC7B,CAAC;gBAEF,OAAO,IAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC;aAC/C;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;IAEc,cAAc,CAC3B,MAAe,EACf,UAAgE,EAAE;;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG;gBACD,YAAY,GAAG,oBAAM,IAAI,CAAC,SAAS,iBACjC,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,0BAAM,YAAY,CAAA,CAAC;aACpB,QAAQ,MAAM,EAAE;SAClB;KAAA;IAEc,aAAa,CAC1B,UAA4B,EAAE;;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,IAAA,KAAAiD,oBAAA,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA;oBAArD,MAAM,OAAO,WAAA,CAAA;oBACtB,oBAAA,OAAOC,uBAAAD,oBAAA,OAAO,CAAA,CAAA,CAAA,CAAC;iBAChB;;;;;;;;;SACF;KAAA;;;;;;;;;;;;;;IAeM,UAAU,CACf,OAA0B;QAE1BjD,oBAAM,CAAC,OAAO,CAAC,iEAAiE,EAAE,OAAO,CAAC,CAAC;QAC3F,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QACzC,OAAO;;;;YAIL,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;aACpB;;;;YAID,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;aACb;;;;YAID,MAAM,EAAE,CAAC,WAAyB,EAAE;gBAClC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,iBAAiB,kBACnD,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;aACJ;SACF,CAAC;KACH;;;;;;;;;;;;;IAca,0BAA0B,CACtC,OAA+C;;YAE/C,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,2DAA2D,EAC3D,OAAO,CACR,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,iFAAiF,EACjF,OAAO,CACR,CAAC;gBACF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,aAAa,CAC9D,mBAAmB,EACnB,uBAAuB,EACvB,IAAI,CAAC,uBAAuB,CAC7B,CAAC;gBAEF,OAAO,IAAI,CAAC,wCAAwC,CAAC,QAAQ,CAAC,CAAC;aAChE;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;IAEc,+BAA+B,CAC5C,MAAe,EACf,UAAgE,EAAE;;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG;gBACD,YAAY,GAAG,oBAAM,IAAI,CAAC,0BAA0B,iBAClD,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,0BAAM,YAAY,CAAA,CAAC;aACpB,QAAQ,MAAM,EAAE;SAClB;KAAA;IAEc,8BAA8B,CAC3C,UAA4B,EAAE;;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,IAAA,KAAAiD,oBAAA,IAAI,CAAC,+BAA+B,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA;oBAAtE,MAAM,OAAO,WAAA,CAAA;oBACtB,oBAAA,OAAOC,uBAAAD,oBAAA,OAAO,CAAA,CAAA,CAAA,CAAC;iBAChB;;;;;;;;;SACF;KAAA;;;;;;;;;;;;;;;IAgBM,2BAA2B,CAChC,OAA0B;QAE1BjD,oBAAM,CAAC,OAAO,CACZ,kFAAkF,EAClF,OAAO,CACR,CAAC;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,8BAA8B,CAAC,OAAO,CAAC,CAAC;QAC1D,OAAO;;;;YAIL,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;aACpB;;;;YAID,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;aACb;;;;YAID,MAAM,EAAE,CAAC,WAAyB,EAAE;gBAClC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,kBACpE,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;aACJ;SACF,CAAC;KACH;;;;;;;;;;;;;;;;;;;;;IAsBK,WAAW,CACf,KAAoC,EACpC,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,4CAA4C,EAC5C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,wDAAwD,KAAK,CAAC,IAAI,oBAAoB,EACtF,KAAK,CACN,CAAC;gBAEF,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,IAAI,EAAE;oBAC7C,MAAM,IAAI,SAAS,CACjB,iGAAiG,CAClG,CAAC;iBACH;gBAED,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;oBACf,MAAM,IAAI,SAAS,CAAC,gEAAgE,CAAC,CAAC;iBACvF;gBAED,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,KAAK,CAAC,IAAI,EACV,iBAAiB,CAAC,KAAK,CAAC,EACxB,IAAI,CAAC,uBAAuB,EAC5B,IAAI,EACJ,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;aAC1C;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;IAgBK,WAAW,CACf,SAAiB,EACjB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,4CAA4C,EAC5C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,wDAAwD,SAAS,GAAG,CAAC,CAAC;gBACrF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,cAAc,CAC/D,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,uBAAuB,CACxB,CAAC;gBAEF,OAAO,EAAE,SAAS,EAAE,mBAAmB,CAAC,QAAQ,CAAC,EAAE,CAAC;aACrD;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;IAOK,WAAW,CAAC,SAAiB,EAAE,gBAAmC;;YACtE,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,4CAA4C,EAC5C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,wDAAwD,SAAS,GAAG,CAAC,CAAC;gBACrF,IAAI;oBACF,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,uBAAuB,CAAC,CAAC;iBACzD;gBAAC,OAAO,KAAK,EAAE;oBACd,IAAI,KAAK,CAAC,IAAI,IAAI,4BAA4B,EAAE;wBAC9C,OAAO,KAAK,CAAC;qBACd;oBACD,MAAM,KAAK,CAAC;iBACb;gBACD,OAAO,IAAI,CAAC;aACb;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;;;;IAmBK,kBAAkB,CACtB,SAAiB,EACjB,gBAAwB,EACxB,OAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,mDAAmD,EACnD,OAAO,CACR,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,+DAA+D,gBAAgB,oBAAoB,EACnG,OAAO,CACR,CAAC;gBACF,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;gBACvE,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,QAAQ,EACR,wBAAwB,CAAC,OAAO,IAAI,EAAE,CAAC,EACvC,IAAI,CAAC,8BAA8B,EACnC,KAAK,EACL,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC;aACjD;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;;;IAkBK,eAAe,CACnB,SAAiB,EACjB,gBAAwB,EACxB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,gDAAgD,EAChD,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,4DAA4D,gBAAgB,GAAG,CAChF,CAAC;gBACF,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;gBACvE,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,QAAQ,EACR,IAAI,CAAC,8BAA8B,EACnC,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC;aACjD;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;;IAiBK,gCAAgC,CACpC,SAAiB,EACjB,gBAAwB,EACxB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,iEAAiE,EACjE,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,6EAA6E,gBAAgB,GAAG,CACjG,CAAC;gBACF,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;gBACvE,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,QAAQ,EACR,IAAI,CAAC,8BAA8B,EACnC,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,0CAA0C,CAAC,QAAQ,CAAC,CAAC;aAClE;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;IAgBa,gBAAgB,CAC5B,SAAiB,EACjB,OAA+C;;YAE/C,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,iDAAiD,EACjD,OAAO,CACR,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,uEAAuE,EACvE,OAAO,CACR,CAAC;gBACF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,aAAa,CAC9D,SAAS,GAAG,iBAAiB,EAC7B,uBAAuB,EACvB,IAAI,CAAC,8BAA8B,CACpC,CAAC;gBAEF,OAAO,IAAI,CAAC,8BAA8B,CAAC,QAAQ,CAAC,CAAC;aACtD;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;IAEc,qBAAqB,CAClC,SAAiB,EACjB,MAAe,EACf,UAAgE,EAAE;;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG;gBACD,YAAY,GAAG,oBAAM,IAAI,CAAC,gBAAgB,CAAC,SAAS,kBAClD,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,0BAAM,YAAY,CAAA,CAAC;aACpB,QAAQ,MAAM,EAAE;SAClB;KAAA;IAEc,oBAAoB,CACjC,SAAiB,EACjB,UAA4B,EAAE;;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,IAAA,KAAAiD,oBAAA,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA;oBAAvE,MAAM,OAAO,WAAA,CAAA;oBACtB,oBAAA,OAAOC,uBAAAD,oBAAA,OAAO,CAAA,CAAA,CAAA,CAAC;iBAChB;;;;;;;;;SACF;KAAA;;;;;;;;;;;;;;;;;IAkBM,iBAAiB,CACtB,SAAiB,EACjB,OAA0B;QAE1BjD,oBAAM,CAAC,OAAO,CACZ,wEAAwE,EACxE,OAAO,CACR,CAAC;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,oBAAoB,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAC3D,OAAO;;;;YAIL,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;aACpB;;;;YAID,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;aACb;;;;YAID,MAAM,EAAE,CAAC,WAAyB,EAAE;gBAClC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,QAAQ,CAAC,iBAAiB,kBACrE,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;aACJ;SACF,CAAC;KACH;;;;;;;;;;;;;;IAea,iCAAiC,CAC7C,SAAiB,EACjB,OAA+C;;YAE/C,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,kEAAkE,EAClE,OAAO,CACR,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,wFAAwF,EACxF,OAAO,CACR,CAAC;gBACF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,aAAa,CAC9D,SAAS,GAAG,iBAAiB,EAC7B,uBAAuB,EACvB,IAAI,CAAC,8BAA8B,CACpC,CAAC;gBAEF,OAAO,IAAI,CAAC,+CAA+C,CAAC,QAAQ,CAAC,CAAC;aACvE;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;IAEc,sCAAsC,CACnD,SAAiB,EACjB,MAAe,EACf,UAAgE,EAAE;;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG;gBACD,YAAY,GAAG,oBAAM,IAAI,CAAC,iCAAiC,CAAC,SAAS,kBACnE,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,0BAAM,YAAY,CAAA,CAAC;aACpB,QAAQ,MAAM,EAAE;SAClB;KAAA;IAEc,qCAAqC,CAClD,SAAiB,EACjB,UAA4B,EAAE;;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,IAAA,KAAAiD,oBAAA,IAAI,CAAC,sCAAsC,CACrE,SAAS,EACT,MAAM,EACN,OAAO,CACR,CAAA,IAAA;oBAJU,MAAM,OAAO,WAAA,CAAA;oBAKtB,oBAAA,OAAOC,uBAAAD,oBAAA,OAAO,CAAA,CAAA,CAAA,CAAC;iBAChB;;;;;;;;;SACF;KAAA;;;;;;;;;;;;;;;;IAiBM,kCAAkC,CACvC,SAAiB,EACjB,OAA0B;QAK1BjD,oBAAM,CAAC,OAAO,CACZ,yFAAyF,EACzF,OAAO,CACR,CAAC;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,qCAAqC,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAC5E,OAAO;;;;YAIL,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;aACpB;;;;YAID,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;aACb;;;;YAID,MAAM,EAAE,CAAC,WAAyB,EAAE;gBAClC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,sCAAsC,CAAC,SAAS,EAAE,QAAQ,CAAC,iBAAiB,kBACtF,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;aACJ;SACF,CAAC;KACH;;;;;;;;;;;;;;;;;;;IAoBK,kBAAkB,CACtB,YAAkD,EAClD,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,mDAAmD,EACnD,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,+DAA+D,YAAY,CAAC,gBAAgB,oBAAoB,EAChH,YAAY,CACb,CAAC;gBAEF,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,IAAI,YAAY,IAAI,IAAI,EAAE;oBAC3D,MAAM,IAAI,SAAS,CACjB,+GAA+G,CAChH,CAAC;iBACH;gBAED,IAAI,CAAC,YAAY,CAAC,SAAS,IAAI,CAAC,YAAY,CAAC,gBAAgB,EAAE;oBAC7D,MAAM,IAAI,SAAS,CACjB,wGAAwG,CACzG,CAAC;iBACH;gBAED,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CACvC,YAAY,CAAC,SAAS,EACtB,YAAY,CAAC,gBAAgB,CAC9B,CAAC;gBAEF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,QAAQ,EACR,wBAAwB,CAAC,YAAY,CAAC,EACtC,IAAI,CAAC,8BAA8B,EACnC,IAAI,EACJ,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC;aACjD;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;;IAiBK,kBAAkB,CACtB,SAAiB,EACjB,gBAAwB,EACxB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,mDAAmD,EACnD,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,+DAA+D,gBAAgB,GAAG,CACnF,CAAC;gBACF,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;gBACvE,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,cAAc,CAC/D,QAAQ,EACR,IAAI,CAAC,8BAA8B,EACnC,uBAAuB,CACxB,CAAC;gBAEF,OAAO,EAAE,SAAS,EAAE,mBAAmB,CAAC,QAAQ,CAAC,EAAE,CAAC;aACrD;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;IAQK,kBAAkB,CACtB,SAAiB,EACjB,gBAAwB,EACxB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,mDAAmD,EACnD,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,+DAA+D,SAAS,UAAU,gBAAgB,GAAG,CACtG,CAAC;gBACF,IAAI;oBACF,MAAM,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,gBAAgB,EAAE,uBAAuB,CAAC,CAAC;iBAClF;gBAAC,OAAO,KAAK,EAAE;oBACd,IAAI,KAAK,CAAC,IAAI,IAAI,4BAA4B,EAAE;wBAC9C,OAAO,KAAK,CAAC;qBACd;oBACD,MAAM,KAAK,CAAC;iBACb;gBACD,OAAO,IAAI,CAAC;aACb;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;IAsDK,UAAU,CACd,SAAiB,EACjB,gBAAwB,EACxB,QAAgB,EAChB,UAAiD,EACjD,4BAA+D,EAC/D,gBAAmC;;YAEnC,IAAI,UAAU,GAA8B,SAAS,CAAC;YACtD,IAAI,WAAyC,CAAC;YAC9C,IAAI,4BAA4B,EAAE;gBAChC,IAAI,eAAe,CAAC,4BAA4B,CAAC,EAAE;;oBAEjD,UAAU,GAAG,4BAA4B,CAAC;oBAC1C,WAAW,GAAG,gBAAgB,CAAC;iBAChC;qBAAM;;;oBAGL,WAAW,mCAAQ,4BAA4B,GAAK,gBAAgB,CAAE,CAAC;iBACxE;aACF;YACD,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,2CAA2C,EAC3C,WAAW,CACZ,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,uDAAuD,QAAQ,qBAAqB,EACpF,UAAU,CACX,CAAC;gBACF,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,gBAAgB,EAAE,QAAQ,CAAC,CAAC;gBACzE,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,QAAQ,EACR,EAAE,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,EAC1D,IAAI,CAAC,sBAAsB,EAC3B,KAAK,EACL,uBAAuB,CACxB,CAAC;gBACF,OAAO,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;aACzC;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;;;IAkBK,OAAO,CACX,SAAiB,EACjB,gBAAwB,EACxB,QAAgB,EAChB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,wCAAwC,EACxC,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,oDAAoD,QAAQ,GAAG,CAAC,CAAC;gBAChF,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,gBAAgB,EAAE,QAAQ,CAAC,CAAC;gBACzE,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,QAAQ,EACR,IAAI,CAAC,sBAAsB,EAC3B,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;aACzC;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;IAgBa,QAAQ,CACpB,SAAiB,EACjB,gBAAwB,EACxB,OAA+C;;YAE/C,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,yCAAyC,EACzC,OAAO,CACR,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,+DAA+D,EAAE,OAAO,CAAC,CAAC;gBACzF,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,CAAC,GAAG,SAAS,CAAC;gBACnF,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,aAAa,CAC9D,QAAQ,EACR,uBAAuB,EACvB,IAAI,CAAC,sBAAsB,CAC5B,CAAC;gBAEF,OAAO,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;aAC9C;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;IAEc,aAAa,CAC1B,SAAiB,EACjB,gBAAwB,EACxB,MAAe,EACf,UAAgE,EAAE;;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG;gBACD,YAAY,GAAG,oBAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,gBAAgB,kBAC5D,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,0BAAM,YAAY,CAAA,CAAC;aACpB,QAAQ,MAAM,EAAE;SAClB;KAAA;IAEc,YAAY,CACzB,SAAiB,EACjB,gBAAwB,EACxB,UAA4B,EAAE;;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,IAAA,KAAAiD,oBAAA,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,gBAAgB,EAAE,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA;oBAAjF,MAAM,OAAO,WAAA,CAAA;oBACtB,oBAAA,OAAOC,uBAAAD,oBAAA,OAAO,CAAA,CAAA,CAAA,CAAC;iBAChB;;;;;;;;;SACF;KAAA;;;;;;;;;;;;;IAcM,SAAS,CACd,SAAiB,EACjB,gBAAwB,EACxB,OAA0B;QAE1BjD,oBAAM,CAAC,OAAO,CAAC,gEAAgE,EAAE,OAAO,CAAC,CAAC;QAC1F,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,gBAAgB,EAAE,OAAO,CAAC,CAAC;QACrE,OAAO;;;;YAIL,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;aACpB;;;;YAID,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;aACb;;;;YAID,MAAM,EAAE,CAAC,WAAyB,EAAE;gBAClC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,gBAAgB,EAAE,QAAQ,CAAC,iBAAiB,kBAC/E,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;aACJ;SACF,CAAC;KACH;;;;;;;;;;;;;;;;;;;;;IAsBK,UAAU,CACd,SAAiB,EACjB,gBAAwB,EACxB,IAAkC,EAClC,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,2CAA2C,EAC3C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CACZ,uDAAuD,IAAI,CAAC,IAAI,oBAAoB,EACpF,IAAI,CACL,CAAC;gBAEF,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,IAAI,KAAK,IAAI,EAAE;oBAC5C,MAAM,IAAI,SAAS,CACjB,+FAA+F,CAChG,CAAC;iBACH;gBAED,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;oBACd,MAAM,IAAI,SAAS,CAAC,+DAA+D,CAAC,CAAC;iBACtF;gBAED,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,gBAAgB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC1E,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,WAAW,CAC5D,QAAQ,EACR,IAAI,EACJ,IAAI,CAAC,sBAAsB,EAC3B,IAAI,EACJ,uBAAuB,CACxB,CAAC;gBAEF,OAAO,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;aACzC;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;;;;;;;;;IAkBK,UAAU,CACd,SAAiB,EACjB,gBAAwB,EACxB,QAAgB,EAChB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,2CAA2C,EAC3C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,uDAAuD,QAAQ,GAAG,CAAC,CAAC;gBACnF,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,gBAAgB,EAAE,QAAQ,CAAC,CAAC;gBACzE,MAAM,QAAQ,GAA0B,MAAM,IAAI,CAAC,cAAc,CAC/D,QAAQ,EACR,IAAI,CAAC,sBAAsB,EAC3B,uBAAuB,CACxB,CAAC;gBAEF,OAAO,EAAE,SAAS,EAAE,mBAAmB,CAAC,QAAQ,CAAC,EAAE,CAAC;aACrD;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;;IAUK,UAAU,CACd,SAAiB,EACjB,gBAAwB,EACxB,QAAgB,EAChB,gBAAmC;;YAEnC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,2CAA2C,EAC3C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACFA,oBAAM,CAAC,OAAO,CAAC,uDAAuD,QAAQ,GAAG,CAAC,CAAC;gBACnF,IAAI;oBACF,MAAM,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,gBAAgB,EAAE,QAAQ,EAAE,uBAAuB,CAAC,CAAC;iBACpF;gBAAC,OAAO,KAAK,EAAE;oBACd,IAAI,KAAK,CAAC,IAAI,IAAI,4BAA4B,EAAE;wBAC9C,OAAO,KAAK,CAAC;qBACd;oBACD,MAAM,KAAK,CAAC;iBACb;gBACD,OAAO,IAAI,CAAC;aACb;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;;IASa,WAAW,CACvB,IAAY,EACZ,YAIqB,EACrB,UAA6B,EAC7B,WAAoB,KAAK,EACzB,mBAAqC,EAAE;;YAEvC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,4CAA4C,EAC5C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACF,MAAM,WAAW,GAAgB,IAAImD,oBAAW,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC;gBAC3E,WAAW,CAAC,IAAI,GAAG,YAAY,CAAC;gBAChC,IAAI,QAAQ,EAAE;oBACZ,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;iBAC1C;gBAED,MAAM,yBAAyB,GAAG,YAEH,CAAC;gBAChC,IACE,yBAAyB,CAAC,SAAS;oBACnC,yBAAyB,CAAC,6BAA6B,EACvD;oBACA,MAAM,KAAK,GACT,IAAI,CAAC,WAAW,YAAY,2BAA2B;0BACnD,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,KAAK;0BAC9C,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAACL,kBAAa,CAAC,kBAAkB,CAAC,CAAC,EAAG,KAAK,CAAC;oBAEnF,IAAI,yBAAyB,CAAC,SAAS,EAAE;wBACvC,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,sCAAsC,EAAE,KAAK,CAAC,CAAC;wBACvE,IAAI,CAAC,aAAa,CAAC,yBAAyB,CAAC,SAAS,CAAC,EAAE;4BACvD,yBAAyB,CAAC,SAAS,GAAG,IAAI,CAAC,oBAAoB,CAAC,MAAM,CACpE,yBAAyB,CAAC,SAAS,CACpC,CAAC;yBACH;qBACF;oBACD,IAAI,yBAAyB,CAAC,6BAA6B,EAAE;wBAC3D,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,yCAAyC,EAAE,KAAK,CAAC,CAAC;wBAC1E,IAAI,CAAC,aAAa,CAAC,yBAAyB,CAAC,6BAA6B,CAAC,EAAE;4BAC3E,yBAAyB,CAAC,6BAA6B,GAAG,IAAI,CAAC,oBAAoB,CAAC,MAAM,CACxF,yBAAyB,CAAC,6BAA6B,CACxD,CAAC;yBACH;qBACF;iBACF;gBAED,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,+CAA+C,CAAC,CAAC;gBAEzF,OAAO,uBAAuB,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,EAAE,uBAAuB,CAAC,CAAC;aACxF;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;IAOa,WAAW,CACvB,IAAY,EACZ,UAA6B,EAC7B,mBAAqC,EAAE;;YAEvC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,4CAA4C,EAC5C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACF,MAAM,WAAW,GAAgB,IAAIK,oBAAW,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC;gBAE3E,MAAM,QAAQ,GAAG,MAAM,uBAAuB,CAC5C,IAAI,EACJ,WAAW,EACX,UAAU,EACV,uBAAuB,CACxB,CAAC;gBACF,IACE,QAAQ,CAAC,UAAU,IAAI,SAAS;qBAC/B,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,IAAI,CAAC,CAAC,EACvE;oBACA,MAAM,GAAG,GAAG,IAAIjD,kBAAS,CACvB,yBAAyB,IAAI,oCAAoC,EACjE,4BAA4B,EAC5B,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,WAAW,CAAC,EACzBC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;oBACF,MAAM,GAAG,CAAC;iBACX;gBACD,OAAO,QAAQ,CAAC;aACjB;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;;;IAQa,aAAa,CACzB,IAAY,EACZ,UAAiD,EAAE,EACnD,UAA6B;;YAE7B,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,8CAA8C,EAC9C,OAAO,CACR,CAAC;YACF,IAAI;gBACF,MAAM,WAAW,GAA8B,EAAE,CAAC;gBAClD,IAAI,OAAO,EAAE;oBACX,IAAI,OAAO,CAAC,IAAI,EAAE;wBAChB,WAAW,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;qBAChD;oBACD,IAAI,OAAO,CAAC,QAAQ,EAAE;wBACpB,WAAW,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;qBACnD;iBACF;gBAED,MAAM,WAAW,GAAgB,IAAI+C,oBAAW,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,WAAW,CAAC,EAAE,KAAK,CAAC,CAAC;gBAExF,OAAO,uBAAuB,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,EAAE,uBAAuB,CAAC,CAAC;aACxF;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;;;;;IAMa,cAAc,CAC1B,IAAY,EACZ,UAA6B,EAC7B,mBAAqC,EAAE;;YAEvC,MAAM,EAAE,IAAI,EAAE,uBAAuB,EAAE,GAAG,UAAU,CAClD,+CAA+C,EAC/C,gBAAgB,CACjB,CAAC;YACF,IAAI;gBACF,MAAM,WAAW,GAAgB,IAAIA,oBAAW,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,QAAQ,CAAC,CAAC;gBAE9E,OAAO,uBAAuB,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,EAAE,uBAAuB,CAAC,CAAC;aACxF;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC;oBACb,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;oBACzB,OAAO,EAAE,CAAC,CAAC,OAAO;iBACnB,CAAC,CAAC;gBACH,MAAM,CAAC,CAAC;aACT;oBAAS;gBACR,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;KAAA;IAEO,MAAM,CAAC,IAAY,EAAE,WAAuC;QAClE,MAAM,OAAO,GAAG,WAAW,IAAI,CAAC,QAAQ,IAAI,IAAI,EAAE,CAAC;QAEnD,MAAM,UAAU,GAAeC,mBAAU,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QACzD,UAAU,CAAC,iBAAiB,CAACC,qBAA+B,EAAEC,mBAA6B,CAAC,CAAC;QAE7F,IAAI,WAAW,EAAE;YACf,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;gBAC1C,UAAU,CAAC,iBAAiB,CAAC,GAAG,EAAE,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;aACrD;SACF;QAED,OAAO,UAAU,CAAC,QAAQ,EAAE,CAAC;KAC9B;IAEO,mBAAmB,CAAC,SAAiB,EAAE,gBAAwB;QACrE,OAAO,SAAS,GAAG,iBAAiB,GAAG,gBAAgB,CAAC;KACzD;IAEO,WAAW,CAAC,SAAiB,EAAE,gBAAwB,EAAE,QAAgB;QAC/E,OAAO,SAAS,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,SAAS,GAAG,QAAQ,CAAC;KAChF;IAEO,wBAAwB,CAAC,GAAW;QAC1C,IAAI,CAAC,GAAG,EAAE;YACR,OAAO,SAAS,CAAC;SAClB;QACD,IAAI;YACF,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC,YAAY,CAAC,GAAG,CAAC3D,mBAA6B,GAAG,MAAM,CAAC,CAAC;SAC/E;QAAC,OAAO,KAAK,EAAE;YACd,MAAM,IAAI,KAAK,CACb,wBAAwBA,mBAA6B,2CAA2C;gBAC9F,KAAK,CACR,CAAC;SACH;KACF;IAEO,gCAAgC,CACtC,QAA+B;QAE/B,IAAI;YACF,MAAM,SAAS,GAAG,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YACtD,MAAM,iBAAiB,GAAsC,MAAM,CAAC,cAAc,CAChF,SAAS,IAAI,EAAE,EACf,WAAW,EACX,EAAE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC,EAAE,CACzC,CAAC;YACF,OAAO,iBAAiB,CAAC;SAC1B;QAAC,OAAO,GAAG,EAAE;YACZK,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,sHAAsH,EACtHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,uBAAuB,CAC7B,QAA+B;QAE/B,IAAI;YACF,MAAM,MAAM,GAAsB,EAAE,CAAC;YACrC,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;gBACvC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;aAChF;YACD,MAAM,aAAa,GAAQ,QAAQ,CAAC,UAAU,CAAC;YAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC7C,MAAM,KAAK,GAAG,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC3C,IAAI,KAAK,EAAE;oBACT,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACpB;aACF;YACD,MAAM,kBAAkB,GAAsC,MAAM,CAAC,cAAc,CACjF,MAAM,EACN,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,kBAAkB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YAClD,OAAO,kBAAkB,CAAC;SAC3B;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,oHAAoH,EACpHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,wCAAwC,CAC9C,QAA+B;QAE/B,IAAI;YACF,MAAM,MAAM,GAA6B,EAAE,CAAC;YAC5C,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;gBACvC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;aAChF;YACD,MAAM,aAAa,GAAQ,QAAQ,CAAC,UAAU,CAAC;YAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC7C,MAAM,KAAK,GAAG,2BAA2B,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC5D,IAAI,KAAK,EAAE;oBACT,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACpB;aACF;YACD,MAAM,kBAAkB,GAA6C,MAAM,CAAC,cAAc,CACxF,MAAM,EACN,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,kBAAkB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YAClD,OAAO,kBAAkB,CAAC;SAC3B;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,oHAAoH,EACpHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,kBAAkB,CAAC,QAA+B;QACxD,IAAI;YACF,MAAM,KAAK,GAAG,UAAU,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC9C,MAAM,aAAa,GAAkC,MAAM,CAAC,cAAc,CACxE,KAAK,IAAI,EAAE,EACX,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,OAAO,aAAa,CAAC;SACtB;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,kHAAkH,EAClHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,mCAAmC,CACzC,QAA+B;QAE/B,IAAI;YACF,MAAM,KAAK,GAAG,2BAA2B,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC/D,MAAM,aAAa,GAAyC,MAAM,CAAC,cAAc,CAC/E,KAAK,IAAI,EAAE,EACX,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,OAAO,aAAa,CAAC;SACtB;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,kHAAkH,EAClHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,uBAAuB,CAC7B,QAA+B;QAE/B,IAAI;YACF,MAAM,MAAM,GAAsB,EAAE,CAAC;YACrC,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;gBACvC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;aAChF;YACD,MAAM,aAAa,GAAQ,QAAQ,CAAC,UAAU,CAAC;YAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC7C,MAAM,KAAK,GAAG,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC3C,IAAI,KAAK,EAAE;oBACT,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACpB;aACF;YACD,MAAM,kBAAkB,GAAsC,MAAM,CAAC,cAAc,CACjF,MAAM,EACN,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,kBAAkB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YAClD,OAAO,kBAAkB,CAAC;SAC3B;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,oHAAoH,EACpHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,wCAAwC,CAC9C,QAA+B;QAE/B,IAAI;YACF,MAAM,MAAM,GAA6B,EAAE,CAAC;YAC5C,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;gBACvC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;aAChF;YACD,MAAM,aAAa,GAAQ,QAAQ,CAAC,UAAU,CAAC;YAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC7C,MAAM,KAAK,GAAG,2BAA2B,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC5D,IAAI,KAAK,EAAE;oBACT,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACpB;aACF;YACD,MAAM,kBAAkB,GAA6C,MAAM,CAAC,cAAc,CACxF,MAAM,EACN,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,kBAAkB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YAClD,OAAO,kBAAkB,CAAC;SAC3B;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,oHAAoH,EACpHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IACO,kBAAkB,CAAC,QAA+B;QACxD,IAAI;YACF,MAAM,KAAK,GAAG,UAAU,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC9C,MAAM,aAAa,GAAkC,MAAM,CAAC,cAAc,CACxE,KAAK,IAAI,EAAE,EACX,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,OAAO,aAAa,CAAC;SACtB;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,kHAAkH,EAClHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,mCAAmC,CACzC,QAA+B;QAE/B,IAAI;YACF,MAAM,KAAK,GAAG,2BAA2B,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC/D,MAAM,aAAa,GAAyC,MAAM,CAAC,cAAc,CAC/E,KAAK,IAAI,EAAE,EACX,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,OAAO,aAAa,CAAC;SACtB;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,kHAAkH,EAClHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,8BAA8B,CACpC,QAA+B;QAE/B,IAAI;YACF,MAAM,aAAa,GAA6B,EAAE,CAAC;YACnD,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;gBACvC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;aAChF;YACD,MAAM,oBAAoB,GAAQ,QAAQ,CAAC,UAAU,CAAC;YACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACpD,MAAM,YAAY,GAAG,iBAAiB,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC;gBAChE,IAAI,YAAY,EAAE;oBAChB,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;iBAClC;aACF;YACD,MAAM,yBAAyB,GAA6C,MAAM,CAAC,cAAc,CAC/F,aAAa,EACb,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,yBAAyB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YACzD,OAAO,yBAAyB,CAAC;SAClC;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,2HAA2H,EAC3HA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,+CAA+C,CACrD,QAA+B;QAE/B,IAAI;YACF,MAAM,aAAa,GAAoC,EAAE,CAAC;YAC1D,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;gBACvC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;aAChF;YACD,MAAM,oBAAoB,GAAQ,QAAQ,CAAC,UAAU,CAAC;YACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACpD,MAAM,YAAY,GAAG,kCAAkC,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC;gBACjF,IAAI,YAAY,EAAE;oBAChB,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;iBAClC;aACF;YACD,MAAM,yBAAyB,GAAoD,MAAM,CAAC,cAAc,CACtG,aAAa,EACb,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,yBAAyB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YACzD,OAAO,yBAAyB,CAAC;SAClC;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,2HAA2H,EAC3HA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,yBAAyB,CAC/B,QAA+B;QAE/B,IAAI;YACF,MAAM,YAAY,GAAG,iBAAiB,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC5D,MAAM,oBAAoB,GAAyC,MAAM,CAAC,cAAc,CACtF,YAAY,IAAI,EAAE,EAClB,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,OAAO,oBAAoB,CAAC;SAC7B;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,yHAAyH,EACzHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,0CAA0C,CAChD,QAA+B;QAE/B,IAAI;YACF,MAAM,YAAY,GAAG,kCAAkC,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC7E,MAAM,oBAAoB,GAAgD,MAAM,CAAC,cAAc,CAC7F,YAAY,IAAI,EAAE,EAClB,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,OAAO,oBAAoB,CAAC;SAC7B;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,yHAAyH,EACzHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,sBAAsB,CAC5B,QAA+B;QAE/B,IAAI;YACF,MAAM,KAAK,GAAqB,EAAE,CAAC;YACnC,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;gBACvC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;aAChF;YACD,MAAM,YAAY,GAAQ,QAAQ,CAAC,UAAU,CAAC;YAC9C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC5C,MAAM,IAAI,GAAG,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;gBACxC,IAAI,IAAI,EAAE;oBACR,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAClB;aACF;YACD,MAAM,iBAAiB,GAAqC,MAAM,CAAC,cAAc,CAC/E,KAAK,EACL,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,iBAAiB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YACjD,OAAO,iBAAiB,CAAC;SAC1B;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,mHAAmH,EACnHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,iBAAiB,CAAC,QAA+B;QACvD,IAAI;YACF,MAAM,IAAI,GAAG,SAAS,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC5C,MAAM,YAAY,GAAiC,MAAM,CAAC,cAAc,CACtE,IAAI,IAAI,EAAE,EACV,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACF,CAAC;YACF,OAAO,YAAY,CAAC;SACrB;QAAC,OAAO,GAAG,EAAE;YACZJ,oBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAIE,kBAAS,CACjB,iHAAiH,EACjHA,kBAAS,CAAC,WAAW,EACrB,QAAQ,CAAC,MAAM,EACfC,qBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC9BC,sBAAa,CAAC,QAAQ,CAAC,CACxB,CAAC;SACH;KACF;IAEO,+BAA+B,CAAC,KAAyB;QAC/D,IAAI,EAAE,KAAK,KAAK,SAAS,KAAK,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;YAC/E,MAAM,IAAI,KAAK,CAAC,6BAA6B,KAAK,WAAW,CAAC,CAAC;SAChE;KACF;CACF;;ACn1FD;AACA,AAOA;;;;;AAKA,AAAO,MAAM,sBAAsB,GAAG;;;;;;;;;;;;IAYpC,MAAM,CAAC,IAAS;QACd,IAAI,MAAW,CAAC;QAChB,IAAI,QAAQ,CAAC,IAAI,CAAC,EAAE;YAClB,MAAM,GAAGmD,mBAAO,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;SACrC;aAAM;;;;YAIL,IAAI,IAAI,KAAK,SAAS;gBAAE,IAAI,GAAG,IAAI,CAAC;YACpC,IAAI;gBACF,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBACrC,MAAM,GAAGA,mBAAO,CAAC,YAAY,CAAC7D,aAAM,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC;aAC7D;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,GAAG,GACP,uEAAuE;oBACvE,IAAI;oBACJ,GAAG,GAAG,GAAG,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC;gBAC7C,MAAM,CAAC,OAAO,CAAC,WAAW,GAAG,GAAG,CAAC,CAAC;gBAClC,kBAAkB,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;gBAChC,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC;aACtB;SACF;QACD,OAAO,MAAM,CAAC;KACf;;;;;;;;;IAUD,MAAM,CAAC,IAAS;QACd,IAAI,aAAa,GAAQ,IAAI,CAAC;QAC9B,IAAI;YACF,IAAI,IAAI,CAAC,OAAO,IAAI,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;;gBAE1C,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC;aAC9B;YACD,IAAI;;;gBAGF,MAAM,OAAO,GAAW,aAAa,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;gBACvD,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;aACrC;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,CAAC,OAAO,CACZ,6EAA6E;oBAC3E,iBAAiB,EACnB,GAAG,CACJ,CAAC;aACH;SACF;QAAC,OAAO,GAAG,EAAE;YACZ,MAAM,CAAC,OAAO,CACZ,uFAAuF,EACvF,GAAG,CACJ,CAAC;SACH;QACD,OAAO,aAAa,CAAC;KACtB;CACF,CAAC;;ACrFF;AACA,AAiBA;;;;AAIA,AAAA,IAAY,eAKX;AALD,WAAY,eAAe;IACzB,wCAAqB,CAAA;IACrB,4CAAyB,CAAA;IACzB,sCAAmB,CAAA;IACnB,kCAAe,CAAA;AACjB,CAAC,EALW,eAAe,KAAf,eAAe,QAK1B;AA8LD;;;;;AAKA,SAAgB,mCAAmC,CAAC,GAAsB;IACxE,IAAI,GAAG,CAAC,WAAW,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,WAAW,KAAK,QAAQ,EAAE;QAClE,OAAO,IAAI,SAAS,CAAC,oEAAoE,CAAC,CAAC;KAC5F;IAED,IAAI,GAAG,CAAC,OAAO,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,OAAO,KAAK,QAAQ,EAAE;QAC1D,OAAO,IAAI,SAAS,CAAC,8DAA8D,CAAC,CAAC;KACtF;IAED,IAAI,GAAG,CAAC,EAAE,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,QAAQ,EAAE;QAChD,OAAO,IAAI,SAAS,CAAC,2DAA2D,CAAC,CAAC;KACnF;IAED,IAAI,GAAG,CAAC,OAAO,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,OAAO,KAAK,QAAQ,EAAE;QAC1D,OAAO,IAAI,SAAS,CAAC,gEAAgE,CAAC,CAAC;KACxF;IAED,IAAI,GAAG,CAAC,gBAAgB,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,gBAAgB,KAAK,QAAQ,EAAE;QAC5E,OAAO,IAAI,SAAS,CAAC,yEAAyE,CAAC,CAAC;KACjG;IAED,IAAI,GAAG,CAAC,UAAU,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,UAAU,KAAK,QAAQ,EAAE;QAChE,OAAO,IAAI,SAAS,CAAC,mEAAmE,CAAC,CAAC;KAC3F;IAED,IAAI,GAAG,CAAC,SAAS,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,SAAS,KAAK,QAAQ,EAAE;QAC9D,OAAO,IAAI,SAAS,CAAC,kEAAkE,CAAC,CAAC;KAC1F;IAED,IACE,GAAG,CAAC,SAAS,IAAI,IAAI;QACrB,OAAO,GAAG,CAAC,SAAS,KAAK,QAAQ;QACjC,OAAO,GAAG,CAAC,SAAS,KAAK,QAAQ;QACjC,CAACA,aAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,EAC/B;QACA,OAAO,IAAI,SAAS,CAClB,kFAAkF,CACnF,CAAC;KACH;IAED,IACE,GAAG,CAAC,aAAa,IAAI,IAAI;QACzB,OAAO,GAAG,CAAC,aAAa,KAAK,QAAQ;QACrC,OAAO,GAAG,CAAC,aAAa,KAAK,QAAQ;QACrC,CAACA,aAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,aAAa,CAAC,EACnC;QACA,OAAO,IAAI,SAAS,CAClB,sFAAsF,CACvF,CAAC;KACH;IACD,OAAO;AACT,CAAC;AAED;;;;;AAKA,SAAgB,aAAa,CAAC,GAAsB;IAClD,MAAM,OAAO,GAAgB;QAC3B,IAAI,EAAE,GAAG,CAAC,IAAI;QACd,mBAAmB,EAAE,EAAE;KACxB,CAAC;IACF,IAAI,GAAG,CAAC,qBAAqB,IAAI,IAAI,EAAE;QACrC,OAAO,CAAC,sBAAsB,GAAG,GAAG,CAAC,qBAAqB,CAAC;KAC5D;IACD,IAAI,GAAG,CAAC,WAAW,IAAI,IAAI,EAAE;QAC3B,OAAO,CAAC,YAAY,GAAG,GAAG,CAAC,WAAW,CAAC;KACxC;IACD,IAAI,GAAG,CAAC,SAAS,IAAI,IAAI,EAAE;QACzB,IAAI,GAAG,CAAC,SAAS,CAAC,MAAM,GAAG8D,kBAAS,CAAC,kBAAkB,EAAE;YACvD,MAAM,IAAI,KAAK,CACb,sFAAsF,CACvF,CAAC;SACH;QACD,OAAO,CAAC,QAAQ,GAAG,GAAG,CAAC,SAAS,CAAC;KAClC;IACD,IAAI,GAAG,CAAC,OAAO,IAAI,IAAI,EAAE;QACvB,OAAO,CAAC,QAAQ,GAAG,GAAG,CAAC,OAAO,CAAC;KAChC;IACD,IAAI,GAAG,CAAC,EAAE,IAAI,IAAI,EAAE;QAClB,OAAO,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,CAAC;KACrB;IACD,IAAI,GAAG,CAAC,OAAO,IAAI,IAAI,EAAE;QACvB,OAAO,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC;KAC/B;IACD,IAAI,GAAG,CAAC,SAAS,IAAI,IAAI,EAAE;QACzB,IAAI,OAAO,GAAG,CAAC,SAAS,KAAK,QAAQ,IAAI,GAAG,CAAC,SAAS,CAAC,MAAM,GAAGA,kBAAS,CAAC,kBAAkB,EAAE;YAC5F,MAAM,IAAI,KAAK,CACb,sFAAsF,CACvF,CAAC;SACH;QACD,OAAO,CAAC,UAAU,GAAG,GAAG,CAAC,SAAS,CAAC;KACpC;IACD,IAAI,GAAG,CAAC,aAAa,IAAI,IAAI,EAAE;QAC7B,OAAO,CAAC,cAAc,GAAG,GAAG,CAAC,aAAa,CAAC;KAC5C;IACD,IAAI,GAAG,CAAC,gBAAgB,IAAI,IAAI,EAAE;QAChC,OAAO,CAAC,iBAAiB,GAAG,GAAG,CAAC,gBAAgB,CAAC;KAClD;IACD,IAAI,GAAG,CAAC,UAAU,IAAI,IAAI,IAAI,GAAG,CAAC,UAAU,KAAKA,kBAAS,CAAC,gBAAgB,EAAE;QAC3E,OAAO,CAAC,GAAG,GAAG,GAAG,CAAC,UAAU,CAAC;QAC7B,OAAO,CAAC,aAAa,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACnC,IAAIA,kBAAS,CAAC,qBAAqB,GAAG,OAAO,CAAC,aAAa,GAAG,OAAO,CAAC,GAAG,EAAE;YACzE,OAAO,CAAC,oBAAoB,GAAG,OAAO,CAAC,aAAa,GAAG,OAAO,CAAC,GAAG,CAAC;SACpE;aAAM;YACL,OAAO,CAAC,oBAAoB,GAAGA,kBAAS,CAAC,qBAAqB,CAAC;SAChE;KACF;IACD,IAAI,GAAG,CAAC,YAAY,IAAI,IAAI,EAAE;QAC5B,IAAI,GAAG,CAAC,YAAY,CAAC,MAAM,GAAGA,kBAAS,CAAC,qBAAqB,EAAE;YAC7D,MAAM,IAAI,KAAK,CACb,yFAAyF,CAC1F,CAAC;SACH;QACD,OAAO,CAAC,mBAAoB,CAACA,kBAAS,CAAC,YAAY,CAAC,GAAG,GAAG,CAAC,YAAY,CAAC;KACzE;;;;;;;;;;IAYD,IAAI,GAAG,CAAC,uBAAuB,IAAI,IAAI,EAAE;QACvC,OAAO,CAAC,mBAAoB,CAACA,kBAAS,CAAC,oBAAoB,CAAC,GAAG,GAAG,CAAC,uBAAuB,CAAC;KAC5F;IAEDxD,aAAM,CAAC,OAAO,CAAC,8BAA8B,EAAE,OAAO,CAAC,CAAC;IACxD,OAAO,OAAO,CAAC;AACjB,CAAC;AAwFD;;;;;AAKA,SAAgB,eAAe,CAC7B,GAAgB,EAChB,QAAmB,EACnB,sBAAgC;;IAEhC,IAAI,CAAC,GAAG,EAAE;QACR,GAAG,GAAG;YACJ,IAAI,EAAE,SAAS;SAChB,CAAC;KACH;IACD,MAAM,KAAK,GAAsB;QAC/B,IAAI,EAAE,GAAG,CAAC,IAAI;KACf,CAAC;IAEF,IAAI,GAAG,CAAC,sBAAsB,IAAI,IAAI,EAAE;QACtC,KAAK,CAAC,qBAAqB,GAAG,GAAG,CAAC,sBAAsB,CAAC;KAC1D;IACD,IAAI,GAAG,CAAC,YAAY,IAAI,IAAI,EAAE;QAC5B,KAAK,CAAC,WAAW,GAAG,GAAG,CAAC,YAAY,CAAC;KACtC;IACD,IAAI,GAAG,CAAC,QAAQ,IAAI,IAAI,EAAE;QACxB,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,QAAQ,CAAC;KAChC;IACD,IAAI,GAAG,CAAC,QAAQ,IAAI,IAAI,EAAE;QACxB,KAAK,CAAC,OAAO,GAAG,GAAG,CAAC,QAAQ,CAAC;KAC9B;IACD,IAAI,GAAG,CAAC,EAAE,IAAI,IAAI,EAAE;QAClB,KAAK,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,CAAC;KACnB;IACD,IAAI,GAAG,CAAC,GAAG,IAAI,IAAI,EAAE;QACnB,KAAK,CAAC,UAAU,GAAG,GAAG,CAAC,GAAG,CAAC;KAC5B;IACD,IAAI,GAAG,CAAC,OAAO,IAAI,IAAI,EAAE;QACvB,KAAK,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC;KAC7B;IACD,IAAI,GAAG,CAAC,UAAU,IAAI,IAAI,EAAE;QAC1B,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,UAAU,CAAC;KAClC;IACD,IAAI,GAAG,CAAC,cAAc,IAAI,IAAI,EAAE;QAC9B,KAAK,CAAC,aAAa,GAAG,GAAG,CAAC,cAAc,CAAC;KAC1C;IACD,IAAI,GAAG,CAAC,iBAAiB,IAAI,IAAI,EAAE;QACjC,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,iBAAiB,CAAC;KAChD;IAED,IAAI,GAAG,CAAC,mBAAmB,IAAI,IAAI,EAAE;QACnC,IAAI,GAAG,CAAC,mBAAmB,CAACwD,kBAAS,CAAC,YAAY,CAAC,IAAI,IAAI,EAAE;YAC3D,KAAK,CAAC,YAAY,GAAG,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,YAAY,CAAC,CAAC;SACtE;;;;;QAOD,IAAI,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,oBAAoB,CAAC,IAAI,IAAI,EAAE;YACnE,KAAK,CAAC,uBAAuB,GAAG,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,oBAAoB,CAAC,CAAC;SACzF;KACF;IAED,MAAM,KAAK,GAAQ,EAAE,CAAC;IACtB,IAAI,GAAG,CAAC,mBAAmB,IAAI,IAAI,EAAE;QACnC,IAAI,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,gBAAgB,CAAC,IAAI,IAAI,EAAE;YAC/D,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,gBAAgB,CAAC,CAAC;SAC9E;QACD,IAAI,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,qBAAqB,CAAC,IAAI,IAAI,EAAE;YACpE,KAAK,CAAC,sBAAsB,GAAG,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,qBAAqB,CAAC,CAAC;SACzF;QACD,IAAI,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,cAAc,CAAC,IAAI,IAAI,EAAE;YAC7D,IAAI9D,aAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,mBAAmB,CAAC8D,kBAAS,CAAC,cAAc,CAAC,CAAC,EAAE;gBACtE,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,cAAc,CAAC,CAAC,CAAC;aAC5F;iBAAM;gBACL,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,cAAc,CAAC,CAAC,CAAC;aAC3F;SACF;QACD,IAAI,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,YAAY,CAAC,IAAI,IAAI,EAAE;YAC3D,KAAK,CAAC,eAAe,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,YAAY,CAAW,CAAC,CAAC;SAC7F;QACD,IAAI,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,WAAW,CAAC,IAAI,IAAI,EAAE;YAC1D,KAAK,CAAC,cAAc,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,mBAAmB,CAACA,kBAAS,CAAC,WAAW,CAAW,CAAC,CAAC;SAC3F;KACF;IACD,IAAI,GAAG,CAAC,GAAG,IAAI,IAAI,IAAI,GAAG,CAAC,GAAG,IAAIA,kBAAS,CAAC,gBAAgB,GAAG,KAAK,CAAC,eAAe,CAAC,OAAO,EAAE,EAAE;QAC9F,KAAK,CAAC,YAAY,GAAG,IAAI,IAAI,CAACA,kBAAS,CAAC,gBAAgB,CAAC,CAAC;KAC3D;SAAM;QACL,KAAK,CAAC,YAAY,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,OAAO,EAAE,GAAG,GAAG,CAAC,GAAI,CAAC,CAAC;KAC3E;IAED,MAAM,SAAS,+CACb,eAAe,EAAEC,6BAAoB,CAAC,eAAe,CAAC,GAAG,CAAC,EAC1D,SAAS,EAAE,QAAQ,EACnB,aAAa,EAAE,GAAG,CAAC,cAAc,EACjC,SAAS,EACP,QAAQ,IAAI,QAAQ,CAAC,GAAG,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC;cACjDC,0BAAc,CACZ,sBAAsB,KAAK,IAAI;kBAC3B,gBAAgB,CACd,OAAO,QAAQ,CAAC,GAAG,KAAK,QAAQ,GAAGhE,aAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,GAAG,CAC5E;kBACD,OAAO,QAAQ,CAAC,GAAG,KAAK,QAAQ;sBAChCA,aAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC;sBACzB,QAAQ,CAAC,GAAG,CACjB;cACD,SAAS,IACZ,KAAK,GACL,KAAK,KACR,gBAAgB,QAAE,KAAK,CAAC,qBAAqB,0CAAE,gBAAgB,EAC/D,0BAA0B,QAAE,KAAK,CAAC,qBAAqB,0CAAE,0BAA0B,GACpF,CAAC;IAEFM,aAAM,CAAC,OAAO,CAAC,8CAA8C,EAAE,SAAS,CAAC,CAAC;IAC1E,OAAO,SAAS,CAAC;AACnB,CAAC;AAED;;;;AAIA,SAAgB,mBAAmB,CAAC,QAAa;IAC/C,OAAO,QAAQ,IAAI,IAAI,IAAI,OAAO,QAAQ,KAAK,QAAQ,IAAI,MAAM,IAAI,QAAQ,CAAC;AAChF,CAAC;AAED;;;;;;;;AAQA,MAAa,qBAAqB;;;;IA2LhC,YACE,GAAgB,EAChB,QAAkB,EAClB,sBAA+B,EAC/B,WAAwB;QAExB,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,eAAe,CAAC,GAAG,EAAE,QAAQ,EAAE,sBAAsB,CAAC,CAAC,CAAC;;;QAG5E,IAAI,WAAW,KAAK,kBAAkB,EAAE;YACtC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;SAC5B;QACD,IAAI,GAAG,CAAC,IAAI,EAAE;YACZ,IAAI,CAAC,IAAI,GAAG,sBAAsB,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SACrD;;QAED,IAAI,CAAC,eAAe,GAAGyD,6BAAoB,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;QACjE,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;KAC1B;;;;;IAMD,KAAK;;QAEH,MAAM,KAAK,GAAsB;YAC/B,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,WAAW,EAAE,IAAI,CAAC,WAAW;YAC7B,aAAa,EAAE,IAAI,CAAC,aAAa;YACjC,OAAO,EAAE,IAAI,CAAC,OAAO;YACrB,SAAS,EAAE,IAAI,CAAC,SAAS;YACzB,YAAY,EAAE,IAAI,CAAC,YAAY;YAC/B,OAAO,EAAE,IAAI,CAAC,OAAO;YACrB,gBAAgB,EAAE,IAAI,CAAC,gBAAgB;YACvC,uBAAuB,EAAE,IAAI,CAAC,uBAAuB;YACrD,SAAS,EAAE,IAAI,CAAC,SAAS;YACzB,UAAU,EAAE,IAAI,CAAC,UAAU;YAC3B,EAAE,EAAE,IAAI,CAAC,EAAE;YACX,qBAAqB,EAAE,IAAI,CAAC,qBAAqB;;;SAGlD,CAAC;QAEF,OAAO,KAAK,CAAC;KACd;CACF;;AC3uBD;;;;;;AAMA,AAAO,MAAM,sCAAsC,GAAqC,IAAI,GAAG,CAAC;IAC9F,CAAC,8BAA8B,EAAE,yBAAyB,CAAC;IAC3D,CAAC,sBAAsB,EAAE,iBAAiB,CAAC;IAC3C,CAAC,sBAAsB,EAAE,iBAAiB,CAAC;IAC3C,CAAC,sBAAsB,EAAE,qBAAqB,CAAC;IAC/C,CAAC,mCAAmC,EAAE,8BAA8B,CAAC;IACrE,CAAC,8BAA8B,EAAE,yBAAyB,CAAC;IAC3D,CAAC,oBAAoB,EAAE,eAAe,CAAC;IACvC,CAAC,iBAAiB,EAAE,aAAa,CAAC;IAElC,CAAC,uBAAuB,EAAE,gBAAgB,CAAC;IAC3C,CAAC,2BAA2B,EAAE,6BAA6B,CAAC;IAC5D,CAAC,4BAA4B,EAAE,uBAAuB,CAAC;IACvD,CAAC,sBAAsB,EAAE,iBAAiB,CAAC;IAC3C,CAAC,mBAAmB,EAAE,oBAAoB,CAAC;CAC5C,CAAC,CAAC;AAEH;;;AAGA,MAAa,eAAgB,SAAQE,uBAAc;IA+BjD,YAAY,cAAuC,EAAE,IAA0B;QAC7E,MAAM,OAAO,GAAG,OAAO,cAAc,KAAK,QAAQ,GAAG,cAAc,GAAG,cAAc,CAAC,OAAO,CAAC;QAC7F,KAAK,CAAC,OAAO,CAAC,CAAC;QAEf,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;YACtC,IAAI,CAAC,IAAI,GAAG,IAAI,aAAJ,IAAI,cAAJ,IAAI,GAAI,cAAc,CAAC;SACpC;aAAM;YACL,KAAK,MAAM,IAAI,IAAI,cAAc,EAAE;gBAChC,IAAY,CAAC,IAAI,CAAC,GAAI,cAAsB,CAAC,IAAI,CAAC,CAAC;aACrD;YAED,IAAI,CAAC,IAAI,GAAG,eAAe,CAAC,sBAAsB,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;;;YAGxE,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc,IAAI,cAAc,CAAC,IAAI,EAAE;gBACvD,IAAI,CAAC,OAAO,GAAG,GAAG,cAAc,CAAC,IAAI,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC;aAC1D;SACF;QAED,IAAI,CAAC,IAAI,GAAG,iBAAiB,CAAC;KAC/B;IAEO,OAAO,sBAAsB,CAAC,OAAgB;QACpD,IAAI,OAAO,IAAI,IAAI,IAAI,CAAC,sCAAsC,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;YAC3E,OAAO,cAAc,CAAC;SACvB;QAED,OAAO,sCAAsC,CAAC,GAAG,CAAC,OAAO,CAAE,CAAC;KAC7D;CACF;AAED;;;;;;;;;;AAUA,SAAgB,wBAAwB,CAAC,GAAsB;IAC7D,IAAI,iBAAiB,CAAC,GAAG,CAAC,EAAE;QAC1B,OAAO,GAAG,CAAC;KACZ;IAED,MAAM,eAAe,GAAGC,kBAAS,CAAC,GAAG,CAAC,CAAC;IAEvC,IAAIC,yBAAgB,CAAC,eAAe,CAAC,EAAE;QACrC,OAAO,IAAI,eAAe,CAAC,eAAe,CAAC,CAAC;KAC7C;IAED,OAAO,eAAe,CAAC;AACzB,CAAC;AAED;;;;;AAKA,SAAgB,iBAAiB,CAAC,GAAQ;IACxC,OAAO,CAAA,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,IAAI,MAAK,iBAAiB,CAAC;AACzC,CAAC;;ACxLD;AACA,AAqFA;;;;;AAKA,MAAsB,UAAU;;;;;;;;;IAsF9B,YACkB,QAAgB,EAChB,UAAkB,EAClC,OAA0B,EAClB,SAA2B,EAC3B,OAAyB,EACjC,OAA2B;QALX,aAAQ,GAAR,QAAQ,CAAQ;QAChB,eAAU,GAAV,UAAU,CAAQ;QAE1B,cAAS,GAAT,SAAS,CAAkB;QAC3B,YAAO,GAAP,OAAO,CAAkB;;;;;QArB3B,0BAAqB,GAAY,KAAK,CAAC;;;;;QAMvC,cAAS,GAAWpE,yBAAa,EAAE,CAAC;QAkB1C,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,IAAI,EAAE,CAAC;QACrC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,EAAE,CAAC;QACvC,IAAI,CAAC,IAAI,GAAG,aAAa,CAAC,QAAQ,CAAC,CAAC;QACpC,IAAI,CAAC,UAAU,GAAG,IAAI,OAAO,CAAC,YAAY,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,IAAI,GAAG,CAAC;KAC9E;IAtCD,IAAW,SAAS;QAClB,OAAO,IAAI,CAAC,UAAU,CAAC;KACxB;;;;;IA0CD,MAAM;QACJ,MAAM,MAAM,GAAY,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,GAAG,KAAK,CAAC;QACjE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,UAAU,aAAa,MAAM,EAAE,CAAC,CAAC;QAC9D,OAAO,MAAM,CAAC;KACf;;;;;;;;IASK,QAAQ,CAAC,OAA4B,EAAE,WAA6B;;;YAExE,MAAM,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE,CAAC;YAEtC,IAAI,CAAC,OAAO,CAAC,OAAO,CAClB,GAAG,IAAI,CAAC,UAAU,qCAAqC,IAAI,CAAC,SAAS,wBAAwB,CAC9F,CAAC;YACF,OAAOqE,oBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE;gBACzC,IAAI,CAAC,OAAO,CAAC,OAAO,CAClB,GAAG,IAAI,CAAC,UAAU,SAAS,IAAI,CAAC,SAAS,iCAAiC,CAC3E,CAAC;gBACF,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;aACjD,CAAC,CAAC;SACJ;KAAA;IAEa,aAAa,CACzB,OAA4B,EAC5B,WAA6B;;YAE7B,MAAM,YAAY,GAAG;gBACnB,IAAI,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,OAAO,EAAE;oBACxB,MAAM,IAAIlE,0BAAU,CAAC,oBAAoB,CAAC,CAAC;iBAC5C;aACF,CAAC;YAEF,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;YAChD,YAAY,EAAE,CAAC;YAEf,IAAI,OAAO,CAAC,IAAI,EAAE;gBAChB,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;gBACzB,IAAI,CAAC,UAAU,GAAG,IAAI,YAAY,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,IAAI,GAAG,CAAC;aACtE;YAED,IAAI,IAAI,CAAC,qBAAqB,EAAE;gBAC9B,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,UAAU,mDAAmD,CAAC,CAAC;gBAC5F,MAAM,IAAIA,0BAAU,CAAC,kDAAkD,CAAC,CAAC;aAC1E;YAED,IAAI,IAAI,CAAC,MAAM,EAAE,EAAE;gBACjB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,UAAU,mCAAmC,CAAC,CAAC;gBAC5E,OAAO;aACR;YAED,IAAI,CAAC,OAAO,CAAC,OAAO,CAClB,GAAG,IAAI,CAAC,UAAU,wDAAwD,CAC3E,CAAC;YAEF,IAAI;gBACF,MAAM,IAAI,CAAC,eAAe,EAAE,CAAC;gBAE7B,YAAY,EAAE,CAAC;gBACf,IAAI,CAAC,sBAAsB,EAAE,CAAC;gBAE9B,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,UAAU,2BAA2B,EAAE,OAAO,CAAC,CAAC;gBAC7E,IAAI,CAAC,KAAK,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;gBAChD,YAAY,EAAE,CAAC;gBAEf,IAAI,CAAC,mBAAmB,EAAE,CAAC;gBAE3B,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,UAAU,yBAAyB,CAAC,CAAC;aACnE;YAAC,OAAO,GAAG,EAAE;gBACZ,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,UAAU,sCAAsC,CAAC,CAAC;gBACrF,MAAM,IAAI,CAAC,aAAa,EAAE,CAAC;gBAC3B,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;;IAOK,KAAK;;;YAET,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;YAElC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,SAAS,iCAAiC,CAAC,CAAC;;YAGzE,QAAQ,IAAI,CAAC,SAAS;gBACpB,KAAK,GAAG,EAAE;oBACR,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACxC,MAAM;iBACP;gBACD,KAAK,IAAI,CAAC;gBACV,KAAK,IAAI,EAAE;oBACT,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACjD,MAAM;iBACP;gBACD,KAAK,IAAI,EAAE;oBACT,OAAO,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAChD,MAAM;iBACP;aACF;YAED,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC;YACvB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,SAAS,gCAAgC,CAAC,CAAC;SACzE;KAAA;;;;;IAcS,SAAS;QACjB,IAAI,CAAC,OAAO,CAAC,OAAO,CAClB,GAAG,IAAI,CAAC,UAAU,qCAAqC,IAAI,CAAC,SAAS,mBAAmB,CACzF,CAAC;QACF,OAAOkE,oBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE;YACzC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,UAAU,SAAS,IAAI,CAAC,SAAS,4BAA4B,CAAC,CAAC;YAC5F,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC;SAC7B,CAAC,CAAC;KACJ;IAEa,aAAa;;YACzB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,UAAU,yBAAyB,CAAC,CAAC;YAElE,YAAY,CAAC,IAAI,CAAC,kBAAkC,CAAC,CAAC;YACtD,IAAI,CAAC,kBAAkB,GAAG,SAAS,CAAC;YAEpC,IAAI,IAAI,CAAC,KAAK,EAAE;gBACd,IAAI;oBACF,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;oBACxB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;;;oBAIvB,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;oBACnB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,UAAU,UAAU,CAAC,CAAC;iBACpD;gBAAC,OAAO,GAAG,EAAE;oBACZ,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,UAAU,2CAA2C,CAAC,CAAC;iBAC3F;aACF;SACF;KAAA;;;;;IAMD,IAAY,KAAK;QACf,IAAI,MAAM,GAAG,YAAY,CAAC;QAC1B,IAAK,IAAY,CAAC,WAAW,IAAK,IAAY,CAAC,WAAW,CAAC,IAAI,EAAE;YAC/D,MAAM,GAAI,IAAY,CAAC,WAAW,CAAC,IAAI,CAAC;SACzC;QACD,OAAO,MAAM,CAAC;KACf;IAED,IAAc,oBAAoB;QAChC,OAAO,IAAI,CAAC,qBAAqB,CAAC;KACnC;IAED,IAAc,IAAI;QAChB,OAAO,IAAI,CAAC,KAAK,CAAC;KACnB;;;;;;IAOa,eAAe,CAAC,eAAyB;;YACrD,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,UAAU,mCAAmC,CAAC,CAAC;;YAG5E,IAAI,CAAC,sBAAsB,EAAE,CAAC;;;;;YAM9B,IAAI,CAAC,OAAO,CAAC,OAAO,CAClB,kFAAkF;gBAChF,0BAA0B,EAC5B,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,OAAO,EAChC,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;YACF,MAAMA,oBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,OAAO,EAAE;gBAC1D,IAAI,CAAC,sBAAsB,EAAE,CAAC;gBAC9B,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;aACxC,CAAA,CAAC,CAAC;YACH,IAAI,WAAwB,CAAC;YAC7B,IAAI,SAAoB,CAAC;YACzB,IAAI,IAAI,CAAC,QAAQ,CAAC,eAAe,YAAY,mBAAmB,EAAE;gBAChE,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACpE,SAAS,GAAGC,kBAAS,CAAC,eAAe,CAAC;;;gBAItC,IAAI,WAAW,CAAC,kBAAkB,GAAG,CAAC,EAAE;;oBAEtC,IAAI,CAAC,aAAa,GAAG,CAAC,IAAI,GAAG,GAAG,IAAI,IAAI,CAAC;iBAC1C;aACF;iBAAM;gBACL,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,QAAQ,CAACP,kBAAS,CAAC,kBAAkB,CAAC,CAAC;gBAC5F,IAAI,CAAC,QAAQ,EAAE;oBACb,MAAM,IAAI,KAAK,CAAC,gEAAgE,CAAC,CAAC;iBACnF;gBACD,WAAW,GAAG,QAAQ,CAAC;gBACvB,SAAS,GAAGO,kBAAS,CAAC,eAAe,CAAC;gBACtC,IAAI,CAAC,aAAa,GAAG,WAAW,CAAC,kBAAkB,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC;aAClF;YACD,IAAI,CAAC,OAAO,CAAC,OAAO,CAClB,kDAAkD,EAClD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,QAAQ,CACd,CAAC;;YAEF,IAAI,CAAC,OAAO,CAAC,OAAO,CAClB,0EAA0E,EAC1E,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,QAAQ,CAAC,kBAAkB,EAChC,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;YACF,IAAI,CAAC,WAAW,EAAE;gBAChB,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;aACzC;YACD,MAAMD,oBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,kBAAkB,EAAE;gBAC1D,IAAI,CAAC,sBAAsB,EAAE,CAAC;gBAC9B,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;aAC7F,CAAC,CAAC;YACH,IAAI,CAAC,OAAO,CAAC,OAAO,CAClB,uDAAuD,EACvD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;YACF,IAAI,eAAe,EAAE;gBACnB,IAAI,CAAC,mBAAmB,EAAE,CAAC;aAC5B;SACF;KAAA;;;;;;IAOO,sBAAsB;QAC5B,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,mBAAmB,EAAE,EAAE;YACxC,OAAO;SACR;QAED,IAAI,CAAC,OAAO,CAAC,OAAO,CAClB,GAAG,IAAI,CAAC,UAAU,yDAAyD,CAC5E,CAAC;QACF,MAAM,GAAG,GAAG,IAAI,eAAe,CAC7B,wDAAwD,EACxD,cAAc,CACf,CAAC;QACF,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC;QACrB,MAAM,GAAG,CAAC;KACX;;;;;IAMO,mBAAmB;QACzB,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACvB,OAAO;SACR;;;;QAID,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC3B,YAAY,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;SACvC;QACD,IAAI,CAAC,kBAAkB,GAAG,UAAU,CAAC;YACnC,IAAI;gBACF,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;aAClC;YAAC,OAAO,GAAG,EAAE;gBACZ,IAAI,CAAC,OAAO,CAAC,QAAQ,CACnB,GAAG,EACH,wEAAwE,EACxE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;aACH;SACF,CAAA,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QACvB,IAAI,CAAC,OAAO,CAAC,OAAO,CAClB,8EAA8E,EAC9E,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,aAAa,EAClB,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,QAAQ,EAAE,CACrD,CAAC;KACH;CACF;;AClgBD;AACA,AAQA;;;;;;;;AAQA,AAAO,MAAM,uBAAuB,GAClC,qIAAqI,CAAC;AAExI;;;;;;AAMA,AAAO,MAAM,2BAA2B,GAAG,oDAAoD,CAAC;AAEhG;;;;;;AAMA,SAAgB,4BAA4B,CAAC,OAA0B;IACrE,IAAI,OAAO,IAAI,OAAO,CAAC,wBAAwB,EAAE;QAC/C,MAAM,YAAY,GAAG,2CAA2C,CAAC;QACjE,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;QACtC,MAAM,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,YAAY,MAAM,EAAE,KAAK,CAAC,CAAC;QACtD,MAAM,KAAK,CAAC;KACb;AACH,CAAC;AAED;;;;;;AAMA,SAAgB,uBAAuB,CAAC,UAAkB;IACxD,QACE,mBAAmB,UAAU,+CAA+C;QAC5E,qFAAqF,EACrF;AACJ,CAAC;AAED;;;;;;;AAOA,SAAgB,yBAAyB,CAAC,UAAkB,EAAE,SAAkB;IAC9E,IAAI,SAAS,IAAI,SAAS,EAAE;QAC1B,QACE,qBAAqB,UAAU,+CAA+C;YAC9E,yFAAyF,EACzF;KACH;IACD,QACE,6BAA6B,SAAS,SAAS,UAAU,+BAA+B;QACxF,+HAA+H,EAC/H;AACJ,CAAC;AAED;;;;;;AAMA,SAAgB,2BAA2B,CAAC,UAAkB,EAAE,SAAkB;IAChF,IAAI,SAAS,IAAI,SAAS,EAAE;QAC1B,OAAO,qBAAqB,UAAU,kCAAkC,CAAC;KAC1E;IACD,OAAO,6BAA6B,SAAS,UAAU,UAAU,kCAAkC,CAAC;AACtG,CAAC;AAED;;;;;;;;AAQA,SAAgB,gCAAgC,CAC9C,YAAoB,EACpB,aAAqB,EACrB,cAAmB;IAEnB,IAAI,cAAc,KAAK,SAAS,IAAI,cAAc,KAAK,IAAI,EAAE;QAC3D,MAAM,KAAK,GAAG,IAAI,SAAS,CAAC,sBAAsB,aAAa,GAAG,CAAC,CAAC;QACpE,MAAM,CAAC,OAAO,CAAC,IAAI,YAAY,MAAM,EAAE,KAAK,CAAC,CAAC;QAC9C,MAAM,KAAK,CAAC;KACb;AACH,CAAC;AAED;;;;;;;;;AAUA,SAAgB,qCAAqC,CACnD,YAAoB,EACpB,aAAqB,EACrB,cAAmB,EACnB,YAAoB;IAEpB,IAAI,OAAO,cAAc,KAAK,YAAY,EAAE;QAC1C,MAAM,KAAK,GAAG,IAAI,SAAS,CACzB,kBAAkB,aAAa,wBAAwB,YAAY,GAAG,CACvE,CAAC;QACF,MAAM,CAAC,OAAO,CAAC,IAAI,YAAY,MAAM,EAAE,KAAK,CAAC,CAAC;QAC9C,MAAM,KAAK,CAAC;KACb;AACH,CAAC;AAED;;;;;;;;AAQA,SAAgB,gCAAgC,CAC9C,YAAoB,EACpB,aAAqB,EACrB,cAAmB;IAEnB,IAAI,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE;QACjC,OAAO,qCAAqC,CAAC,YAAY,EAAE,aAAa,EAAE,cAAc,CAAC,CAAC;KAC3F;IACD,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE;QAC/B,OAAO;KACR;IACD,MAAM,KAAK,GAAG,IAAI,SAAS,CAAC,kBAAkB,aAAa,4BAA4B,CAAC,CAAC;IACzF,MAAM,CAAC,OAAO,CAAC,IAAI,YAAY,MAAM,EAAE,KAAK,CAAC,CAAC;IAC9C,MAAM,KAAK,CAAC;AACd,CAAC;AAED;;;;;;;;AAQA,SAAgB,qCAAqC,CACnD,YAAoB,EACpB,aAAqB,EACrB,cAAqB;IAErB,IAAI,cAAc,CAAC,KAAK,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE;QACrD,OAAO;KACR;IACD,MAAM,KAAK,GAAG,IAAI,SAAS,CAAC,kBAAkB,aAAa,qCAAqC,CAAC,CAAC;IAClG,MAAM,CAAC,OAAO,CAAC,IAAI,YAAY,MAAM,EAAE,KAAK,CAAC,CAAC;IAC9C,MAAM,KAAK,CAAC;AACd,CAAC;AAED;;;;;;;;AAQA,SAAgB,sCAAsC,CACpD,YAAoB,EACpB,aAAqB,EACrB,cAAsB;IAEtB,IAAI,cAAc,KAAK,EAAE,EAAE;QACzB,OAAO;KACR;IACD,MAAM,KAAK,GAAG,IAAI,SAAS,CAAC,0CAA0C,aAAa,GAAG,CAAC,CAAC;IACxF,MAAM,CAAC,OAAO,CAAC,IAAI,YAAY,MAAM,EAAE,KAAK,CAAC,CAAC;IAC9C,MAAM,KAAK,CAAC;AACd,CAAC;AAED;;;;;AAKA,AAAO,MAAM,sCAAsC,GACjD,oEAAoE,CAAC;AAEvE;;;;;AAKA,AAAO,MAAM,gCAAgC,GAC3C,oNAAoN,CAAC;AAEvN;;;;;AAKA,AAAO,MAAM,qBAAqB,GAAG,wDAAwD,CAAC;AAE9F;;;;;AAKA,SAAgB,qCAAqC,CACnD,OAAkC,EAClC,WAAwB,EACxB,YAAoB;IAEpB,IAAI,KAAwB,CAAC;IAE7B,IAAI,WAAW,KAAK,kBAAkB,EAAE;QACtC,KAAK,GAAG,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;KAC3D;SAAM,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;QAC7B,KAAK,GAAG,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;KACrD;IAED,IAAI,KAAK,EAAE;QACT,cAAc,CAAC,QAAQ,CACrB,KAAK,EACL,iDAAiD,EACjD,YAAY,EACZ,OAAO,CAAC,SAAS,CAClB,CAAC;QACF,MAAM,KAAK,CAAC;KACb;AACH,CAAC;AAED;;;;;;;AAOA,AAAO,MAAM,kCAAkC,GAC7C,yEAAyE,CAAC;AAC5E;;;;;;;AAOA,SAAgB,gCAAgC,CAAC,GAAQ,EAAE,wBAAgC;IACzF,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,EAAE;QAC7B,MAAM,IAAI,SAAS,CAAC,wBAAwB,CAAC,CAAC;KAC/C;IACD,IAAI,GAAG,CAAC,YAAY,IAAI,GAAG,CAAC,SAAS,IAAI,GAAG,CAAC,YAAY,KAAK,GAAG,CAAC,SAAS,EAAE;QAC3E,MAAM,IAAI,SAAS,CAAC,kCAAkC,CAAC,CAAC;KACzD;AACH,CAAC;;ACnRD;AACA,AAkIA;;;;AAIA,MAAM,qBAAqB,GAAG;IAC5B,eAAe;IACf,WAAW;IACX,IAAI;IACJ,SAAS;IACT,SAAS;IACT,WAAW;IACX,kBAAkB;IAClB,aAAa;IACb,uBAAuB;CACxB,CAAC;AAuCF;;;;;;;AAOA,MAAa,gBAAiB,SAAQ,UAA+B;;;;;;;;;;IAmBnE,YAAY,OAA0B,EAAE,UAAkB,EAAE,OAAiC;QAC3F,KAAK,CAAC,GAAG,UAAU,cAAc,EAAE,UAAU,EAAE,OAAO,EAAE,MAAM,EAAE,sBAAsB,EAAE;YACtF,OAAO,EAAE,OAAO,IAAI,OAAO,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,GAAGN,kBAAS,CAAC,UAAU;YAC5E,QAAQ,EACN,OAAO,IAAI,OAAO,CAAC,QAAQ;kBACvB,OAAO,CAAC,QAAQ;kBAChB,GAAG,OAAO,CAAC,MAAM,CAAC,QAAQ,GAAG,UAAU,cAAc;SAC5D,CAAC,CAAC;;;;QAtBL,YAAO,GAAW/D,yBAAa,EAAE,CAAC;;;;QAI1B,8BAAyB,GAAS,IAAI,CAAC,IAAI,CAAC;QAmBlD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;KACzB;IAEa,KAAK,CAAC,WAA6B;;YAC/C,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI;gBACF,MAAM,KAAK,GAAoB;oBAC7B,MAAM,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE;oBACjC,IAAI,EAAE,IAAI,CAAC,OAAO;oBAClB,MAAM,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE;oBACjC,cAAc,EAAE,CAAC,OAAqB;wBACpC,MAAM,OAAO,GAAG,wBAAwB,CAAC,OAAO,CAAC,OAAQ,CAAC,KAAM,CAAC,CAAC;wBAClE,sBAAsB,CAAC,QAAQ,CAC7B,OAAO,EACP,GAAG,IAAI,CAAC,SAAS,8EAA8E,CAChG,CAAC;qBACH;iBACF,CAAC;gBACF,MAAM,KAAK,GAAkB;oBAC3B,MAAM,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE;oBACjC,OAAO,EAAE,CAAC,OAAqB;wBAC7B,MAAM,OAAO,GAAG,wBAAwB,CAAC,OAAO,CAAC,MAAO,CAAC,KAAM,CAAC,CAAC;wBACjE,sBAAsB,CAAC,QAAQ,CAC7B,OAAO,EACP,GAAG,IAAI,CAAC,SAAS,mDAAmD,CACrE,CAAC;qBACH;iBACF,CAAC;;;gBAIF,MAAM,IAAI,CAAC,QAAQ,CACjB;oBACE,aAAa,EAAE,KAAK;oBACpB,eAAe,EAAE,KAAK;iBACvB,EACD,WAAW,CACZ,CAAC;aACH;YAAC,OAAO,GAAG,EAAE;gBACZ,GAAG,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBACpC,sBAAsB,CAAC,QAAQ,CAC7B,GAAG,EACH,GAAG,IAAI,CAAC,SAAS,6DAA6D,CAC/E,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;IAEe,cAAc,CAC5B,OAAmC;;YAEnC,MAAM,QAAQ,GAAG,MAAMuE,4BAAmB,CAAC,MAAM,CAC/C,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,OAAO,CAAC,aAAa,EACrB,OAAO,CAAC,eAAe,CACxB,CAAC;;;;;YAMF,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAACC,0BAAc,CAAC,aAAa,EAAE,CAAC,OAAqB;gBACvE,MAAM,OAAO,GAAG,wBAAwB,CAAC,OAAO,CAAC,QAAS,CAAC,KAAM,CAAC,CAAC;gBACnE,sBAAsB,CAAC,QAAQ,CAC7B,OAAO,EACP,GAAG,IAAI,CAAC,SAAS,qDAAqD,CACvE,CAAC;aACH,CAAC,CAAC;YACH,OAAO,QAAQ,CAAC;SACjB;KAAA;;;;IAKO,6BAA6B,CAAC,IAAa,EAAE,KAAa;QAChE,OAAO,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,GAAG,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC;cAC5D,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK;cACjB,SAAS,CAAC;KACf;IAEa,sBAAsB,CAClC,OAAoB,EACpB,cAAgC,EAChC,qBAAmD,EAAE;;;YAErD,IAAI,OAAO,CAAC,UAAU,IAAI,SAAS,EAAE;gBACnC,OAAO,CAAC,UAAU,GAAGxE,yBAAa,EAAE,CAAC;aACtC;YACD,MAAM,gBAAgB,SACpB,kBAAkB,CAAC,WAAW,mCAAI+D,kBAAS,CAAC,2BAA2B,CAAC;YAC1E,MAAM,sBAAsB,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAC1C,MAAM,kBAAkB,GAAG,CAAC,MAA8B;gBACxD,MAAM,IAAI,GAAW,gCAAgC,OAAO,CAAC,UAAU,sCAAsC,CAAC;gBAC9G,MAAM,CAAC,GAAU;oBACf,IAAI,EAAE,uBAAuB;oBAC7B,OAAO,EAAE,IAAI;iBACd,CAAC;gBAEF,MAAM,CAAC,CAAC,CAAC,CAAC;aACX,CAAC;YAEF,IAAI,SAAwC,CAAC;YAC7C,MAAM,gBAAgB,GAAG,IAAI,OAAO,CAAO,CAAC,CAAC,EAAE,MAAM;gBACnD,SAAS,GAAG,UAAU,CAAC,MAAM,kBAAkB,CAAC,MAAM,CAAC,EAAE,gBAAgB,CAAC,CAAC;aAC5E,CAAC,CAAC;YACH,cAAc,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,SAAS,qDAAqD,CAAC,CAAC;YAE/F,IAAI;gBACF,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE;oBAClB,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,kBAAkB,aAAlB,kBAAkB,uBAAlB,kBAAkB,CAAE,WAAW,CAAC,EAAE,gBAAgB,CAAC,CAAC,CAAC;iBACrF;aACF;oBAAS;gBACR,YAAY,CAAC,SAAU,CAAC,CAAC;aAC1B;;YAGD,MAAM,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,sBAAsB,CAAC;;YAE5D,kBAAkB,CAAC,WAAW,GAAG,gBAAgB,GAAG,eAAe,CAAC;YAEpE,IAAI;gBACF,IAAI,CAAC,OAAO,CAAC,UAAU;oBAAE,OAAO,CAAC,UAAU,GAAG/D,yBAAa,EAAE,CAAC;gBAC9D,OAAO,MAAM,IAAI,CAAC,IAAK,CAAC,WAAW,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;aAClE;YAAC,OAAO,GAAG,EAAE;gBACZ,GAAG,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBACpC,cAAc,CAAC,QAAQ,CACrB,GAAG,EACH,oFAAoF;oBAClF,UAAU,EACZ,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,OAAO,EACZ,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;;KACF;;;;;;IAOK,KAAK;;YACT,IAAI;;;;;;gBAOF,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC;gBACvB,sBAAsB,CAAC,OAAO,CAAC,6CAA6C,CAAC,CAAC;aAC/E;YAAC,OAAO,GAAG,EAAE;gBACZ,sBAAsB,CAAC,QAAQ,CAC7B,GAAG,EACH,GAAG,IAAI,CAAC,SAAS,yDAAyD,CAC3E,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;;;;;;;;;IAcK,IAAI,CACR,YAAoB,EACpB,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,OAAO,IAAI,CAAC,oBAAoB,CAC9B,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,CAAC,CAAC,EACrC,YAAY,EACZ,SAAS,EACT,OAAO,CACR,CAAC;SACH;KAAA;;;;;;;;;;;;;;IAeK,qBAAqB,CACzB,SAAiB,EACjB,YAAoB,EACpB,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,OAAO,IAAI,CAAC,oBAAoB,CAC9B,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,CAAC,CAAC,EACrC,YAAY,EACZ,SAAS,EACT,OAAO,CACR,CAAC;SACH;KAAA;;;;;;;;;IAUK,oBAAoB,CACxB,kBAAwB,EACxB,eAAuB,EACvB,SAAkB,EAClB,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;;YAG1C,gCAAgC,CAAC,MAAM,EAAE,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;YACnF,gCAAgC,CAAC,MAAM,EAAE,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;;YAGnF,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;YACF,qCAAqC,CACnC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,EACf,QAAQ,CACT,CAAC;YAEF,IAAI,KAAK,CAAC,eAAe,CAAC,IAAI,eAAe,GAAG,CAAC,EAAE;gBACjD,MAAM,IAAI,SAAS,CAAC,2BAA2B,CAAC,CAAC;aAClD;YAED,MAAM,WAAW,GAAgC,EAAE,CAAC;YACpD,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,WAAW,CAAC+D,kBAAS,CAAC,kBAAkB,CAAC,GAAGU,iBAAK,CAAC,SAAS,CACzDxE,aAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,SAAS,EAAE,CAAC,CAC5C,CAAC;gBACF,WAAW,CAAC8D,kBAAS,CAAC,YAAY,CAAC,GAAGU,iBAAK,CAAC,QAAQ,CAAC,eAAgB,CAAC,CAAC;gBACvE,IAAI,SAAS,IAAI,SAAS,EAAE;oBAC1B,WAAW,CAACV,kBAAS,CAAC,eAAe,CAAC,GAAG,SAAS,CAAC;iBACpD;gBACD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEA,kBAAS,CAAC,UAAU,CAAC,WAAW;qBAC5C;iBACF,CAAC;gBACF,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,EAAE;oBAC/B,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,kBAAkB,CAAC,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,CAAC;iBAC7F;gBACD,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;;;gBAIxE,cAAc,CAAC,OAAO,CACpB,8CAA8C,EAC9C,IAAI,CAAC,SAAS,EACd,OAAO,CAAC,IAAI,CACb,CAAC;gBAEF,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,cAAc,EAAE,OAAO,CAAC,CAAC;gBACnF,IAAI,MAAM,CAAC,sBAAuB,CAAC,UAAU,KAAK,GAAG,EAAE;oBACrD,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,QAAiC,CAAC;oBAC/D,KAAK,MAAM,GAAG,IAAI,QAAQ,EAAE;wBAC1B,MAAM,cAAc,GAAG0E,mBAAe,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;wBAC3D,MAAM,OAAO,GAAG,eAAe,CAAC,cAAqB,CAAC,CAAC;wBACvD,OAAO,CAAC,IAAI,GAAG,sBAAsB,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;wBAC3D,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;wBAC1B,IAAI,CAAC,yBAAyB,GAAG,OAAO,CAAC,cAAe,CAAC;qBAC1D;iBACF;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAmB,CAAC;gBAC9D,cAAc,CAAC,QAAQ,CACrB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,uFAAuF,CACzG,CAAC;;gBAEF,IAAI,KAAK,CAAC,IAAI,KAAKC,iCAAwB,CAAC,iCAAiC,CAAC,EAAE;oBAC9E,MAAM,KAAK,CAAC;iBACb;aACF;YACD,OAAO,WAAW,CAAC;SACpB;KAAA;;;;;;;;;;;;;;;IAgBK,SAAS,CAAC,SAAiB,EAAE,OAAsC;;YACvE,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI,CAAC,OAAO;gBAAE,OAAO,GAAG,EAAE,CAAC;YAC3B,IAAI,OAAO,CAAC,WAAW,IAAI,IAAI;gBAAE,OAAO,CAAC,WAAW,GAAG,IAAI,CAAC;YAE5D,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAE5B,WAAW,CAACZ,kBAAS,CAAC,UAAU,CAAC,GAAGU,iBAAK,CAAC,UAAU,CAClD,CAACG,0BAAc,CAAC,SAAS,CAAC,CAAC,EAC3B,IAAI,EACJ,SAAS,CACV,CAAC;gBACF,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEb,kBAAS,CAAC,UAAU,CAAC,SAAS;qBAC1C;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBACxE,IAAI,OAAO,CAAC,kBAAkB,EAAE;oBAC9B,OAAO,CAAC,sBAAuB,CAAC+D,kBAAS,CAAC,kBAAkB,CAAC,GAAG,OAAO,CAAC,kBAAkB,CAAC;iBAC5F;gBACD,cAAc,CAAC,OAAO,CACpB,sCAAsC,EACtC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,OAAO,CACR,CAAC;gBACF,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,cAAc,EAAE;oBACxE,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;oBACjC,WAAW,EAAE,WAAW;iBACzB,CAAC,CAAC;gBACH,MAAM,cAAc,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC5D,OAAO,cAAc,CAAC;aACvB;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,cAAc,CAAC,QAAQ,CACrB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,iFAAiF,CACnG,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;;;;IASK,gBAAgB,CACpB,uBAA6B,EAC7B,QAA6B,EAC7B,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;gBACpB,OAAO,EAAE,CAAC;aACX;YACD,MAAM,WAAW,GAAU,EAAE,CAAC;YAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACxC,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACzB,IAAI,CAAC,IAAI,CAAC,SAAS;oBAAE,IAAI,CAAC,SAAS,GAAG/D,yBAAa,EAAE,CAAC;gBACtD,IAAI,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;gBACvD,MAAM,WAAW,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;gBACxC,WAAW,CAAC,IAAI,GAAG,sBAAsB,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBAEnE,IAAI;oBACF,MAAM,KAAK,GAAQ;wBACjB,OAAO,EAAE0E,mBAAe,CAAC,MAAM,CAAC,WAAW,CAAC;wBAC5C,YAAY,EAAE,IAAI,CAAC,SAAS;qBAC7B,CAAC;oBACF,IAAI,IAAI,CAAC,SAAS,EAAE;wBAClB,KAAK,CAACX,kBAAS,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;qBACnD;oBACD,IAAI,IAAI,CAAC,YAAY,EAAE;wBACrB,KAAK,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC;qBAC5C;;;;;oBAOD,MAAM,YAAY,GAAGU,iBAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;oBAC3C,WAAW,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;iBAChC;gBAAC,OAAO,GAAG,EAAE;oBACZ,IAAI,KAAY,CAAC;oBACjB,IAAI,GAAG,YAAY,SAAS,IAAI,GAAG,CAAC,IAAI,KAAK,WAAW,EAAE;;;;;wBAKxD,KAAK,GAAG,wBAAwB,CAAC,mCAAmC,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;qBACpF;yBAAM;wBACL,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;qBACvC;oBACD,YAAY,CAAC,QAAQ,CACnB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,0DAA0D,CAAC,wBAAwB,CACrG,CAAC;oBACF,MAAM,KAAK,CAAC;iBACb;aACF;YACD,IAAI;gBACF,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,EAAE,QAAQ,EAAE,WAAW,EAAE;oBAC/B,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEV,kBAAS,CAAC,UAAU,CAAC,eAAe;qBAChD;iBACF,CAAC;gBACF,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,EAAE;oBAC/B,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,kBAAkB,CAAC,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,CAAC;iBAC7F;gBACD,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBACxE,YAAY,CAAC,OAAO,CAAC,wCAAwC,EAAE,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;gBAC7F,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;gBACjF,MAAM,eAAe,GAAG,MAAM,CAAC,IAAI,CAAC+D,kBAAS,CAAC,eAAe,CAAC,CAAC;gBAC/D,MAAM,qBAAqB,GAAG,EAAE,CAAC;gBACjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC/C,IAAI,OAAO,eAAe,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;wBAC1C,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;qBACjE;yBAAM;wBACL,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;qBAClE;iBACF;gBACD,OAAO,qBAAqB,CAAC;aAC9B;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,YAAY,CAAC,QAAQ,CACnB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,2FAA2F,CAC7G,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;;IAOK,uBAAuB,CAC3B,eAAuB,EACvB,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE;gBAC3B,OAAO;aACR;YACD,MAAM,WAAW,GAAQ,EAAE,CAAC;YAC5B,WAAW,CAACA,kBAAS,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC;YAC5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC/C,MAAM,cAAc,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;gBAC1C,IAAI;oBACF,WAAW,CAACA,kBAAS,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC9D,aAAM,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;iBACtF;gBAAC,OAAO,GAAG,EAAE;oBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;oBAC5C,YAAY,CAAC,QAAQ,CACnB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,0DAA0D,CAAC,+BAA+B,CAC5G,CAAC;oBACF,MAAM,KAAK,CAAC;iBACb;aACF;YAED,IAAI;gBACF,WAAW,CAAC8D,kBAAS,CAAC,eAAe,CAAC,GAAGU,iBAAK,CAAC,UAAU,CACvD,WAAW,CAACV,kBAAS,CAAC,eAAe,CAAC,EACtC,IAAI,EACJ,SAAS,CACV,CAAC;gBACF,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEA,kBAAS,CAAC,UAAU,CAAC,sBAAsB;qBACvD;iBACF,CAAC;gBAEF,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,EAAE;oBAC/B,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,kBAAkB,CAAC,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,CAAC;iBAC7F;gBACD,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBACxE,YAAY,CAAC,OAAO,CAClB,gDAAgD,EAChD,IAAI,CAAC,SAAS,EACd,OAAO,CAAC,IAAI,CACb,CAAC;gBAEF,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;gBAClE,OAAO;aACR;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,YAAY,CAAC,QAAQ,CACnB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,sGAAsG,CACxH,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;;;;;;;IAYK,uBAAuB,CAC3B,eAAuB,EACvB,WAAwB,EACxB,SAAkB,EAClB,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAE5C,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE;gBAC3B,OAAO,EAAE,CAAC;aACX;YAED,MAAM,WAAW,GAA4B,EAAE,CAAC;YAChD,MAAM,WAAW,GAAQ,EAAE,CAAC;YAC5B,WAAW,CAAC+D,kBAAS,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC;YAC5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC/C,MAAM,cAAc,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;gBAC1C,IAAI;oBACF,WAAW,CAACA,kBAAS,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC9D,aAAM,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;iBACtF;gBAAC,OAAO,GAAG,EAAE;oBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;oBAC5C,cAAc,CAAC,QAAQ,CACrB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,0DAA0D,CAAC,+BAA+B,CAC5G,CAAC;oBACF,MAAM,KAAK,CAAC;iBACb;aACF;YAED,IAAI;gBACF,WAAW,CAAC8D,kBAAS,CAAC,eAAe,CAAC,GAAGU,iBAAK,CAAC,UAAU,CACvD,WAAW,CAACV,kBAAS,CAAC,eAAe,CAAC,EACtC,IAAI,EACJ,SAAS,CACV,CAAC;gBACF,MAAM,kBAAkB,GAAW,WAAW,KAAK,kBAAkB,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC9E,WAAW,CAACA,kBAAS,CAAC,kBAAkB,CAAC,GAAGU,iBAAK,CAAC,SAAS,CAAC,kBAAkB,CAAC,CAAC;gBAChF,IAAI,SAAS,IAAI,IAAI,EAAE;oBACrB,WAAW,CAACV,kBAAS,CAAC,eAAe,CAAC,GAAG,SAAS,CAAC;iBACpD;gBACD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEA,kBAAS,CAAC,UAAU,CAAC,uBAAuB;qBACxD;iBACF,CAAC;gBACF,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,EAAE;oBAC/B,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,kBAAkB,CAAC,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,CAAC;iBAC7F;gBACD,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBACxE,cAAc,CAAC,OAAO,CACpB,gDAAgD,EAChD,IAAI,CAAC,SAAS,EACd,OAAO,CAAC,IAAI,CACb,CAAC;gBAEF,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,cAAc,EAAE,OAAO,CAAC,CAAC;gBACnF,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,QAG1B,CAAC;gBACJ,KAAK,MAAM,GAAG,IAAI,QAAQ,EAAE;oBAC1B,MAAM,cAAc,GAAG0E,mBAAe,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;oBAC3D,MAAM,OAAO,GAAG,IAAI,qBAAqB,CACvC,cAAqB,EACrB,EAAE,GAAG,EAAE,GAAG,CAAC,YAAY,CAAC,EAAS,EACjC,KAAK,EACL,WAAW,CACZ,CAAC;oBACF,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBAC3B;gBACD,OAAO,WAAW,CAAC;aACpB;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,cAAc,CAAC,QAAQ,CACrB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,mGAAmG,CACrH,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;;;;;;IAWK,uBAAuB,CAC3B,SAAiB,EACjB,eAAgC,EAChC,OAAiE;;YAEjE,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI,CAAC,OAAO;gBAAE,OAAO,GAAG,EAAE,CAAC;YAC3B,IAAI;gBACF,IAAI,iBAAsE,CAAC;gBAE3E,IAAI,eAAe,KAAK,eAAe,CAAC,OAAO;oBAAE,iBAAiB,GAAG,WAAW,CAAC;qBAC5E,IAAI,eAAe,KAAK,eAAe,CAAC,QAAQ;oBAAE,iBAAiB,GAAG,WAAW,CAAC;qBAClF,IAAI,eAAe,KAAK,eAAe,CAAC,KAAK;oBAAE,iBAAiB,GAAG,SAAS,CAAC;qBAC7E,IAAI,eAAe,KAAK,eAAe,CAAC,UAAU;oBAAE,iBAAiB,GAAG,WAAW,CAAC;;oBACpF,MAAM,IAAI,KAAK,CAAC,gCAAgC,eAAe,aAAa,CAAC,CAAC;gBAEnF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,MAAM,eAAe,GAAa,EAAE,CAAC;gBACrC,eAAe,CAAC,IAAI,CAACE,0BAAc,CAAC,SAAS,CAAC,CAAC,CAAC;gBAChD,WAAW,CAACb,kBAAS,CAAC,UAAU,CAAC,GAAGU,iBAAK,CAAC,UAAU,CAAC,eAAe,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;gBACvF,WAAW,CAACV,kBAAS,CAAC,iBAAiB,CAAC,GAAG,iBAAiB,CAAC;gBAC7D,IAAI,OAAO,CAAC,qBAAqB,IAAI,IAAI,EAAE;oBACzC,WAAW,CAACA,kBAAS,CAAC,qBAAqB,CAAC,GAAG,OAAO,CAAC,qBAAqB,CAAC;iBAC9E;gBACD,IAAI,OAAO,CAAC,gBAAgB,IAAI,IAAI,EAAE;oBACpC,WAAW,CAACA,kBAAS,CAAC,gBAAgB,CAAC,GAAG,OAAO,CAAC,gBAAgB,CAAC;iBACpE;gBACD,IAAI,OAAO,CAAC,kBAAkB,IAAI,IAAI,EAAE;oBACtC,WAAW,CAACA,kBAAS,CAAC,kBAAkB,CAAC,GAAG,OAAO,CAAC,kBAAkB,CAAC;iBACxE;gBACD,IAAI,OAAO,CAAC,SAAS,IAAI,IAAI,EAAE;oBAC7B,WAAW,CAACA,kBAAS,CAAC,eAAe,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC;iBAC5D;gBACD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEA,kBAAS,CAAC,UAAU,CAAC,iBAAiB;qBAClD;iBACF,CAAC;gBACF,IAAI,OAAO,CAAC,kBAAkB,EAAE;oBAC9B,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,kBAAkB,CAAC,GAAG,OAAO,CAAC,kBAAkB,CAAC;iBAC5F;gBACD,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBACxE,cAAc,CAAC,OAAO,CACpB,gDAAgD,EAChD,IAAI,CAAC,SAAS,EACd,OAAO,CAAC,IAAI,CACb,CAAC;gBACF,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,cAAc,EAAE,OAAO,CAAC,CAAC;aACrE;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,cAAc,CAAC,QAAQ,CACrB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,mGAAmG,CACrH,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;;;;IASK,gBAAgB,CACpB,SAAiB,EACjB,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,WAAW,CAAC+D,kBAAS,CAAC,eAAe,CAAC,GAAG,SAAS,CAAC;gBACnD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEA,kBAAS,CAAC,UAAU,CAAC,gBAAgB;qBACjD;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBACxE,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,EAAE;oBAC/B,OAAO,CAAC,sBAAuB,CAAC+D,kBAAS,CAAC,kBAAkB,CAAC,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,CAAC;iBAC7F;gBACD,cAAc,CAAC,OAAO,CACpB,yCAAyC,EACzC,IAAI,CAAC,SAAS,EACd,OAAO,CAAC,IAAI,CACb,CAAC;gBACF,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,cAAc,EAAE,OAAO,CAAC,CAAC;gBACnF,MAAM,cAAc,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBACxD,cAAc,CAAC,OAAO,CACpB,6CAA6C,EAC7C,IAAI,CAAC,SAAS,EACd,SAAS,EACT,cAAc,CAAC,QAAQ,EAAE,CAC1B,CAAC;gBACF,OAAO,cAAc,CAAC;aACvB;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,cAAc,CAAC,QAAQ,CACrB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,iFAAiF,CACnG,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;;;;IASK,eAAe,CACnB,SAAiB,EACjB,KAAU,EACV,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAE5C,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,WAAW,CAACA,kBAAS,CAAC,eAAe,CAAC,GAAG,SAAS,CAAC;gBACnD,WAAW,CAAC,eAAe,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;gBAC/C,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEA,kBAAS,CAAC,UAAU,CAAC,eAAe;qBAChD;iBACF,CAAC;gBACF,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,EAAE;oBAC/B,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,kBAAkB,CAAC,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,CAAC;iBAC7F;gBACD,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBACxE,cAAc,CAAC,OAAO,CACpB,wCAAwC,EACxC,IAAI,CAAC,SAAS,EACd,OAAO,CAAC,IAAI,CACb,CAAC;gBACF,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,cAAc,EAAE,OAAO,CAAC,CAAC;aACrE;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,cAAc,CAAC,QAAQ,CACrB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,iFAAiF,CACnG,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;;;IAQK,eAAe,CACnB,SAAiB,EACjB,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,WAAW,CAAC+D,kBAAS,CAAC,eAAe,CAAC,GAAG,SAAS,CAAC;gBACnD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEA,kBAAS,CAAC,UAAU,CAAC,eAAe;qBAChD;iBACF,CAAC;gBACF,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,EAAE;oBAC/B,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,kBAAkB,CAAC,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,CAAC;iBAC7F;gBACD,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBACxE,cAAc,CAAC,OAAO,CACpB,wCAAwC,EACxC,IAAI,CAAC,SAAS,EACd,OAAO,CAAC,IAAI,CACb,CAAC;gBACF,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,cAAc,EAAE,OAAO,CAAC,CAAC;gBACnF,OAAO,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC;sBAC/B,sBAAsB,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;sBAC3D,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;aAClC;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,cAAc,CAAC,QAAQ,CACrB,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,iFAAiF,CACnG,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;;;;IASK,mBAAmB,CACvB,IAAY,EACZ,GAAW,EACX,eAAsB,EACtB,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,MAAM,wCAAwC,GAAW,SAAS,CAAC;YACnE,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;gBAC5B,MAAM,IAAI,KAAK,CAAC,8DAA8D,CAAC,CAAC;aACjF;YACD,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;gBAC3B,MAAM,IAAI,KAAK,CAAC,6DAA6D,CAAC,CAAC;aAChF;YACD,IAAI,eAAe,IAAI,EAAE,eAAe,YAAY,IAAI,CAAC,EAAE;gBACzD,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;aAC9D;YACD,IAAI,CAAC,eAAe,EAAE;gBACpB,eAAe,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,wCAAwC,CAAC,CAAC;aACnF;YACD,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,WAAW,CAAC,mBAAmB,CAAC,GAAG,eAAe,CAAC;gBACnD,WAAW,CAAC,MAAM,CAAC,GAAGyE,iBAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAC3C,WAAW,CAAC,KAAK,CAAC,GAAGA,iBAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;gBACzC,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEV,kBAAS,CAAC,UAAU,CAAC,iBAAiB;qBAClD;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBACxE,sBAAsB,CAAC,OAAO,CAC5B,oCAAoC,EACpC,IAAI,CAAC,SAAS,EACd,OAAO,CAAC,IAAI,CACb,CAAC;gBACF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,sBAAsB,EAAE,OAAO,CAAC,CAAC;gBAE7F,OAAO,CAAC,QAAQ,IAAI,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;aAC3E;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,sBAAsB,CAAC,QAAQ,CAC7B,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,iFAAiF,CACnG,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;IAMK,QAAQ,CACZ,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI;gBACF,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE;wBACJ,GAAG,EAAEyE,iBAAK,CAAC,QAAQ,CAAC,cAAc,CAAC;wBACnC,IAAI,EAAEA,iBAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;qBACxB;oBACD,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEV,kBAAS,CAAC,UAAU,CAAC,cAAc;qBAC/C;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBAExE,sBAAsB,CAAC,OAAO,CAC5B,gCAAgC,EAChC,IAAI,CAAC,SAAS,EACd,OAAO,CAAC,IAAI,CACb,CAAC;gBACF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,sBAAsB,EAAE,OAAO,CAAC,CAAC;gBAC7F,IACE,QAAQ,CAAC,sBAAuB,CAAC,UAAU,KAAK,GAAG;oBACnD,CAAC,QAAQ,CAAC,IAAI;oBACd,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,EACnC;oBACA,OAAO,EAAE,CAAC;iBACX;;gBAGD,MAAM,MAAM,GAAoC,QAAQ,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;gBAC1E,MAAM,KAAK,GAAsB,EAAE,CAAC;gBACpC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;oBACf,MAAM,cAAc,GAAG,CAAC,CAAC,kBAAkB,CAAC,CAAC;;oBAG7C,IACE,CAAC,cAAc;wBACf,CAAC,cAAc,CAAC,UAAU;wBAC1B,cAAc,CAAC,UAAU,CAAC,KAAK,KAAK+D,kBAAS,CAAC,eAAe,CAAC,mBAAmB;wBACjF,CAAC,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC;wBACpC,cAAc,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAC/B;wBACA,OAAO;qBACR;oBAED,MAAM,cAAc,GAAU,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBACtD,MAAM,cAAc,GAAU,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBACtD,MAAM,IAAI,GAAoB;wBAC5B,IAAI,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK;qBACpC,CAAC;oBAEF,QAAQ,cAAc,CAAC,UAAU,CAAC,KAAK;wBACrC,KAAKA,kBAAS,CAAC,eAAe,CAAC,cAAc;4BAC3C,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;4BACpB,MAAM;wBACR,KAAKA,kBAAS,CAAC,eAAe,CAAC,eAAe;4BAC5C,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;4BACpB,MAAM;wBACR,KAAKA,kBAAS,CAAC,eAAe,CAAC,aAAa;4BAC1C,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;4BAC1E,MAAM;wBACR,KAAKA,kBAAS,CAAC,eAAe,CAAC,qBAAqB;4BAClD,IAAI,CAAC,MAAM,GAAG;gCACZ,aAAa,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCAC1E,SAAS,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCACtE,EAAE,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCAC/D,OAAO,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCACpE,OAAO,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCACpE,SAAS,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCACtE,gBAAgB,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCAC7E,WAAW,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCACxE,qBAAqB,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;6BACnF,CAAC;4BACF,MAAM;wBACR;4BACE,sBAAsB,CAAC,OAAO,CAC5B,GAAG,IAAI,CAAC,SAAS,qDAAqD,cAAc,CAAC,UAAU,CAAC,KAAK,EAAE,CACxG,CAAC;4BACF,MAAM;qBACT;oBAED,IACE,cAAc,CAAC,UAAU,CAAC,KAAK,KAAKA,kBAAS,CAAC,eAAe,CAAC,iBAAiB;wBAC/E,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC;wBACnC,cAAc,CAAC,KAAK,CAAC,MAAM,EAC3B;wBACA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;qBAC3E;oBAED,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAClB,CAAC,CAAC;gBAEH,OAAO,KAAK,CAAC;aACd;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,sBAAsB,CAAC,QAAQ,CAC7B,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,gFAAgF,CAClG,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;IAMK,UAAU,CACd,QAAgB,EAChB,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;YACnF,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC5B,sCAAsC,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;YAEzF,IAAI;gBACF,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE;wBACJ,WAAW,EAAEU,iBAAK,CAAC,WAAW,CAAC,QAAQ,CAAC;qBACzC;oBACD,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEV,kBAAS,CAAC,UAAU,CAAC,UAAU;qBAC3C;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBAExE,sBAAsB,CAAC,OAAO,CAC5B,kCAAkC,EAClC,IAAI,CAAC,SAAS,EACd,OAAO,CAAC,IAAI,CACb,CAAC;gBACF,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,sBAAsB,EAAE,OAAO,CAAC,CAAC;aAC7E;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,sBAAsB,CAAC,QAAQ,CAC7B,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,kFAAkF,CACpG,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;;;IAQK,OAAO,CACX,QAAgB,EAChB,MAAgD,EAChD,uBAAgC,EAChC,OAA6D;;YAE7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAE5C,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;YACnF,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC5B,sCAAsC,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;YAEzF,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;YAC/E,IACE,OAAO,MAAM,KAAK,SAAS;gBAC3B,OAAO,MAAM,KAAK,QAAQ;gBAC1B,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,aAAa,KAAK,MAAM,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC,EACpF;gBACA,MAAM,IAAI,SAAS,CACjB,6GAA6G,CAC9G,CAAC;aACH;YAED,IAAI;gBACF,MAAM,eAAe,GAAQ,EAAE,CAAC;gBAChC,QAAQ,OAAO,MAAM;oBACnB,KAAK,SAAS;wBACZ,eAAe,CAAC,YAAY,CAAC,GAAG;4BAC9B,UAAU,EAAE,MAAM,GAAG,KAAK,GAAG,KAAK;yBACnC,CAAC;wBACF,MAAM;oBACR,KAAK,QAAQ;wBACX,eAAe,CAAC,YAAY,CAAC,GAAG;4BAC9B,UAAU,EAAE,MAAM;yBACnB,CAAC;wBACF,MAAM;oBACR;wBACE,eAAe,CAAC,oBAAoB,CAAC,GAAG;4BACtC,gBAAgB,EAAE,MAAM,CAAC,aAAa;4BACtC,YAAY,EAAE,MAAM,CAAC,SAAS;4BAC9B,EAAE,EAAE,MAAM,CAAC,EAAE;4BACb,UAAU,EAAE,MAAM,CAAC,OAAO;4BAC1B,OAAO,EAAE,MAAM,CAAC,OAAO;4BACvB,YAAY,EAAE,MAAM,CAAC,SAAS;4BAC9B,qBAAqB,EAAE,MAAM,CAAC,gBAAgB;4BAC9C,cAAc,EAAE,MAAM,CAAC,WAAW;4BAClC,qBAAqB,EAAE,MAAM,CAAC,qBAAqB;yBACpD,CAAC;wBACF,MAAM;iBACT;gBAED,IAAI,uBAAuB,KAAK,SAAS,EAAE;oBACzC,eAAe,CAAC,iBAAiB,CAAC,GAAG;wBACnC,UAAU,EAAE,MAAM,CAAC,uBAAuB,CAAC;qBAC5C,CAAC;iBACH;gBACD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE;wBACJ,WAAW,EAAEyE,iBAAK,CAAC,WAAW,CAAC,QAAQ,CAAC;wBACxC,kBAAkB,EAAEA,iBAAK,CAAC,QAAQ,CAAC,eAAe,CAAC;qBACpD;oBACD,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEV,kBAAS,CAAC,UAAU,CAAC,OAAO;qBACxC;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,kBAAS,CAAC,UAAU,CAAC,GAAG/D,yBAAa,EAAE,CAAC;gBAExE,sBAAsB,CAAC,OAAO,CAAC,+BAA+B,EAAE,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;gBAC9F,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,sBAAsB,EAAE,OAAO,CAAC,CAAC;aAC7E;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC5C,sBAAsB,CAAC,QAAQ,CAC7B,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,+EAA+E,CACjG,CAAC;gBACF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;CACF;;AC1zCD;AACA,AAIA;;;;;AAKA,SAAgB,cAAc;IAC5B,MAAM,WAAW,GAAG;QAClB,GAAG,EAAE,MAAM;QACX,KAAK,EAAE,OAAO,CAAC,OAAO;KACvB,CAAC;IAEF,MAAM,MAAM,GAAG;QACb,GAAG,EAAE,IAAI;QACT,KAAK,EAAE,IAAI6E,OAAO,EAAE,IAAIC,OAAO,EAAE,IAAIC,UAAU,EAAE,GAAG;KACrD,CAAC;IAEF,OAAO,GAAG,WAAW,CAAC,GAAG,IAAI,WAAW,CAAC,KAAK,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,KAAK,EAAE,CAAC;AACjF,CAAC;;ACtBD;AACA,AAyIA;;;;;AAKA,SAAe,yBAAyB,CACtC,iBAAoC,EACpC,wBAAyE,EACzE,YAA0B;;QAE1B,MAAM,WAAW,GAAoB,EAAE,CAAC;QAExC,KAAK,MAAM,YAAY,IAAI,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,EAAE;YAC1E,MAAM,QAAQ,GAAG,iBAAiB,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;YAClE,IAAI,QAAQ,IAAI,QAAQ,CAAC,YAAY,KAAK,YAAY,EAAE;gBACtDxE,gBAAM,CAAC,OAAO,CACZ,4CAA4C,EAC5C,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,QAAQ,CAAC,YAAY,EACrB,QAAQ,CAAC,IAAI,CACd,CAAC;gBACF,WAAW,CAAC,IAAI,CACd,QAAQ,CAAC,UAAU,CAAC,wBAAwB,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG;oBACtDA,gBAAM,CAAC,QAAQ,CACb,GAAG,EACH,2EAA2E,EAC3E,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,QAAQ,CAAC,YAAY,EACrB,QAAQ,CAAC,IAAI,CACd,CAAC;iBACH,CAAC,CACH,CAAC;aACH;SACF;QAED,OAAO,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;KACjC;CAAA;AAED;;;;;AAKA,SAAe,oBAAoB,CACjC,iBAAkF,EAClF,YAA0B;;QAE1B,IAAI,YAAY,KAAK,SAAS,EAAE;YAC9B,MAAM,SAAS,GAAG,iBAAiB,CAAC,eAAe,CAAC;YACpD,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC;SACtC;QACD,MAAM,SAAS,GAAG,iBAAiB,CAAC,gBAAgB,CAAC;QACrD,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC7C,MAAM,KAAK,GAAG,aAAa,CAAC,MAAM,CAChC,CAAC,GAAG,EAAE,IAAI,MAAM,SAAS,CAAC,IAAI,CAAC,CAAC,YAAY,KAAK,YAAY,GAAG,EAAE,GAAG,GAAG,GAAG,CAAC,EAC5E,CAAC,CACF,CAAC;QACF,OAAO,KAAK,CAAC;KACd;CAAA;AAED;;;;AAIA,IAAiB,iBAAiB,CAuZjC;AAvZD,WAAiB,iBAAiB;IAChC,SAAgB,MAAM,CACpB,MAAwB,EACxB,eAAsD,EACtD,OAAiC;;QAEjC,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,CAAC;QAC3B,MAAM,SAAS,GAAG,GAAG,qBAAqB,OACxC,OAAO,CAAC,gBAAgB,0CAAE,eAAe,CAC1C,IAAI,cAAc,EAAE,EAAE,CAAC;QACxB,MAAM,UAAU,GAA0C;YACxD,MAAM,EAAE,MAAM;;;YAGd,oBAAoB,EAAE,KAAK;YAC3B,oBAAoB,EAAE;gBACpB,OAAO,EAAE,YAAY;gBACrB,SAAS;gBACT,OAAO,EAAE,eAAe,CAAC,OAAO;aACjC;SACF,CAAC;;QAEF,MAAM,iBAAiB,GAAGyE,8BAAqB,CAAC,MAAM,CAAC,UAAU,CAAsB,CAAC;QACxF,iBAAiB,CAAC,eAAe,GAAG,eAAe,CAAC;QACpD,iBAAiB,CAAC,OAAO,GAAG,EAAE,CAAC;QAC/B,iBAAiB,CAAC,gBAAgB,GAAG,EAAE,CAAC;QACxC,iBAAiB,CAAC,eAAe,GAAG,EAAE,CAAC;QACvC,iBAAiB,CAAC,iBAAiB,GAAG,EAAE,CAAC;QAEzC,IAAI,+BAA2C,CAAC;QAChD,IAAI,+BAA0D,CAAC;QAC/D,MAAM,CAAC,MAAM,CAA8C,iBAAiB,EAAE;YAC5E,mBAAmB;;;gBAGjB,OAAO,OAAO,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,IAAI,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE,CAAC,CAAC;aAC7E;YACK,eAAe;;oBACnBzE,gBAAM,CAAC,OAAO,CACZ,IAAI,IAAI,CAAC,YAAY,uDAAuD,CAC7E,CAAC;;;;oBAIF,IAAI,IAAI,CAAC,mBAAmB,EAAE,EAAE;wBAC9BA,gBAAM,CAAC,OAAO,CACZ,IAAI,IAAI,CAAC,YAAY,yDAAyD,CAC/E,CAAC;;wBAEF,MAAM,IAAI,CAAC,wBAAwB,EAAE,CAAC;qBACvC;;oBAGD,MAAM,IAAI,CAAC,sBAAsB,EAAE,CAAC;oBACpCA,gBAAM,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,YAAY,qCAAqC,CAAC,CAAC;iBAC5E;aAAA;YACD,wBAAwB;gBACtB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO;oBACzBA,gBAAM,CAAC,OAAO,CACZ,IAAI,IAAI,CAAC,YAAY,yCAAyC;wBAC5D,mDAAmD;wBACnD,sDAAsD,CACzD,CAAC;oBACF,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC0E,4BAAgB,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;iBAC9D,CAAC,CAAC;aACJ;YACD,sBAAsB;;gBAEpB,IAAI,+BAA+B,EAAE;oBACnC1E,gBAAM,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,YAAY,gCAAgC,CAAC,CAAC;oBACtE,OAAO,+BAA+B,CAAC;iBACxC;gBAEDA,gBAAM,CAAC,OAAO,CACZ,IAAI,IAAI,CAAC,YAAY,8DAA8D,CACpF,CAAC;gBACF,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;aAC1B;YACD,oBAAoB,CAClB,YAAoB,EACpB,SAAkB;gBAElB,IAAI,SAAS,IAAI,IAAI,IAAI,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,EAAE;oBAC3D,OAAO,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC;iBAC3C;gBAED,IAAI,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,EAAE;oBACvC,OAAO,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;iBAC5C;gBAED,IAAI,iBAAiB,GAAG,EAAE,CAAC;gBAC3B,IAAI,SAAS,IAAI,IAAI,EAAE;oBACrB,KAAK,MAAM,kBAAkB,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;wBAClE,IAAI,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,CAAC,SAAS,KAAK,SAAS,EAAE;4BACpE,iBAAiB,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,CAAC,IAAI,CAAC;4BAClE,MAAM;yBACP;qBACF;iBACF;qBAAM;oBACL,iBAAiB;wBACf,CAAC,iBAAiB,GAAG,IAAI,GAAG,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBAClF;gBAEDA,gBAAM,CAAC,OAAO,CACZ,gEAAgE,EAChE,IAAI,CAAC,YAAY,EACjB,YAAY,EACZ,iBAAiB,CAClB,CAAC;gBACF,OAAO;aACR;YACD,mBAAmB,CAAC,UAAkB;gBACpC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE;oBACvC,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,GAAG,IAAI,gBAAgB,CAAC,IAAI,EAAE,UAAU,EAAE;wBAC1E,OAAO,EAAE,GAAG,UAAU,cAAc;qBACrC,CAAC,CAAC;iBACJ;gBACD,OAAO,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;aAC3C;SACF,CAAC,CAAC;;;QAIH,MAAM,gBAAgB,GAAgB;YACpC,iBAAiB,CAAC,wBAAwB,GAAG,KAAK,CAAC;YACnDA,gBAAM,CAAC,OAAO,CACZ,+EAA+E,EAC/E,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,iBAAiB,CAAC,wBAAwB,CAC3C,CAAC;SACH,CAAC;QAEF,MAAM,YAAY,GAAgB,CAAO,OAAqB;YAC5D,IAAI,+BAA+B,EAAE;gBACnC,OAAO;aACR;YAED,+BAA+B,GAAG,IAAI,OAAO,CAAC,CAAC,OAAO;gBACpD,+BAA+B,GAAG,OAAO,CAAC;aAC3C,CAAC,CAAC;YAEH,MAAM,eAAe,GACnB,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,CAAC,KAAK,GAAG,OAAO,CAAC,UAAU,CAAC,KAAK,GAAG,SAAS,CAAC;YACxF,IAAI,eAAe,EAAE;gBACnBA,gBAAM,CAAC,QAAQ,CACb,eAAe,EACf,uEAAuE,EACvE,iBAAiB,CAAC,UAAU,CAAC,EAAE,CAChC,CAAC;aACH;YACD,MAAM,YAAY,GAAG,OAAO,CAAC,KAAK,CAAC;YACnC,IAAI,YAAY,EAAE;gBAChBA,gBAAM,CAAC,QAAQ,CACb,YAAY,EACZ,4DAA4D,EAC5D,iBAAiB,CAAC,UAAU,CAAC,EAAE,CAChC,CAAC;aACH;YACD,MAAM,KAAK,GAIN;gBACH,wBAAwB,EAAE,iBAAiB,CAAC,wBAAwB;gBACpE,UAAU,EAAE,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,MAAM;gBACzD,YAAY,EACV,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,CAAC,MAAM;oBACtD,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,CAAC,MAAM;aACxD,CAAC;;;YAIF,iBAAiB,CAAC,UAAU,CAAC,iBAAiB,EAAE,CAAC;;YAGjD,MAAM,iBAAiB,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;;YAG3C,KAAK,MAAM,UAAU,IAAI,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,iBAAiB,CAAC,EAAE;gBACzE,MAAM,iBAAiB,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC,KAAK,EAAE,CAAC;aAC/D;;YAGD,IAAI,CAAC,KAAK,CAAC,wBAAwB,IAAI,KAAK,CAAC,UAAU,EAAE;;;;;;;;gBAQvDA,gBAAM,CAAC,OAAO,CACZ,IAAI,iBAAiB,CAAC,UAAU,CAAC,EAAE,mEAAmE,KAAK,CAAC,UAAU,GAAG;oBACvH,mCAAmC,CACtC,CAAC;gBACF,MAAM,WAAW,GAAoB,EAAE,CAAC;gBACxC,KAAK,MAAM,UAAU,IAAI,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAAE;oBAC/D,MAAM,MAAM,GAAG,iBAAiB,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;oBACrD,IAAI,MAAM,EAAE;wBACVA,gBAAM,CAAC,OAAO,CACZ,uCAAuC,EACvC,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,MAAM,CAAC,IAAI,CACZ,CAAC;wBACF,WAAW,CAAC,IAAI,CACd,MAAM,CAAC,UAAU,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG;4BAC5BA,gBAAM,CAAC,QAAQ,CACb,GAAG,EACH,mEAAmE,EACnE,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,MAAM,CAAC,IAAI,CACZ,CAAC;yBACH,CAAC,CACH,CAAC;qBACH;iBACF;gBACD,MAAM,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;aAChC;;YAGD,MAAM,oBAAoB,GAAG,oBAAoB,CAAC,iBAAiB,EAAE,UAAU,CAAC,CAAC;YACjF,IAAI,CAAC,KAAK,CAAC,wBAAwB,IAAI,oBAAoB,EAAE;gBAC3DA,gBAAM,CAAC,OAAO,CACZ,IAAI,iBAAiB,CAAC,UAAU,CAAC,EAAE,mEAAmE,oBAAoB,GAAG;oBAC3H,0CAA0C,CAC7C,CAAC;;gBAGF,MAAM,yBAAyB,CAC7B,iBAAiB,EACjB,eAAe,IAAI,YAAY,EAC/B,UAAU,CACX,CAAC;;;;aAKH;YAED,MAAM,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;YAC3C,+BAA+B,EAAE,CAAC;YAClC,+BAA+B,GAAG,SAAS,CAAC;;;YAG5CA,gBAAM,CAAC,OAAO,CAAC,gBAAgB,EAAE,iBAAiB,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;;YAGxE,MAAM,qBAAqB,GAAG,oBAAoB,CAAC,iBAAiB,EAAE,WAAW,CAAC,CAAC;YACnF,IAAI,CAAC,KAAK,CAAC,wBAAwB,IAAI,qBAAqB,EAAE;gBAC5DA,gBAAM,CAAC,OAAO,CACZ,IAAI,iBAAiB,CAAC,UAAU,CAAC,EAAE,mEAAmE,qBAAqB,GAAG;oBAC5H,2CAA2C,CAC9C,CAAC;;;;;;gBAOF,MAAM,yBAAyB,CAC7B,iBAAiB,EACjB,eAAe,IAAI,YAAY,EAC/B,WAAW,CACZ,CAAC;aACH;SACF,CAAA,CAAC;QAEF,MAAM,aAAa,GAAgB,CAAO,OAAqB;YAC7D,IAAI,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,CAAC,KAAK,EAAE;gBAClDA,gBAAM,CAAC,QAAQ,CACb,OAAO,CAAC,UAAU,CAAC,KAAK,EACxB,uEAAuE,EACvE,iBAAiB,CAAC,UAAU,CAAC,EAAE,CAChC,CAAC;aACH;YACD,IAAI,OAAO,CAAC,KAAK,EAAE;gBACjBA,gBAAM,CAAC,QAAQ,CACb,OAAO,CAAC,KAAK,EACb,4DAA4D,EAC5D,iBAAiB,CAAC,UAAU,CAAC,EAAE,CAChC,CAAC;aACH;SACF,CAAA,CAAC;QAEF,MAAM,KAAK,GAAgB,CAAO,OAAqB;YACrD,IAAI,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,CAAC,KAAK,EAAE;gBAClDA,gBAAM,CAAC,QAAQ,CACb,OAAO,CAAC,UAAU,CAAC,KAAK,EACxB,uEAAuE,EACvE,iBAAiB,CAAC,UAAU,CAAC,EAAE,CAChC,CAAC;aACH;YACD,IAAI,OAAO,CAAC,KAAK,EAAE;gBACjBA,gBAAM,CAAC,QAAQ,CACb,OAAO,CAAC,KAAK,EACb,4DAA4D,EAC5D,iBAAiB,CAAC,UAAU,CAAC,EAAE,CAChC,CAAC;aACH;SACF,CAAA,CAAC;QAEF,SAAe,iBAAiB,CAAC,iBAAoC;;gBACnE,MAAM,oBAAoB,GAAG,iBAAiB,CAAC,YAAY,CAAC;gBAC5D,IAAI;oBACF,MAAM,sBAAsB,CAAC,iBAAiB,CAAC,CAAC;iBACjD;gBAAC,OAAO,GAAG,EAAE;oBACZA,gBAAM,CAAC,QAAQ,CACb,GAAG,EACH,IAAI,iBAAiB,CAAC,YAAY,iEAAiE,CACpG,CAAC;iBACH;;gBAED,iBAAiB,CAAC,iBAAiB,EAAE,CAAC;gBACtC,sBAAsB,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;gBACrDA,gBAAM,CAAC,OAAO,CACZ,mBAAmB,oBAAoB,0BAA0B,iBAAiB,CAAC,YAAY,IAAI,CACpG,CAAC;aACH;SAAA;QAED,SAAS,sBAAsB,CAAC,UAAsB;;YAEpD,UAAU,CAAC,EAAE,CAAC0E,4BAAgB,CAAC,cAAc,EAAE,gBAAgB,CAAC,CAAC;YACjE,UAAU,CAAC,EAAE,CAACA,4BAAgB,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;YAC3D,UAAU,CAAC,EAAE,CAACA,4BAAgB,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;YAC7D,UAAU,CAAC,EAAE,CAACA,4BAAgB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;SAC9C;QAED,SAAe,sBAAsB,CAAC,iBAAoC;;;gBAExE,iBAAiB,CAAC,UAAU,CAAC,cAAc,CACzCA,4BAAgB,CAAC,cAAc,EAC/B,gBAAgB,CACjB,CAAC;gBACF,iBAAiB,CAAC,UAAU,CAAC,cAAc,CAACA,4BAAgB,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;gBACzF,iBAAiB,CAAC,UAAU,CAAC,cAAc,CAACA,4BAAgB,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;gBAC3F,iBAAiB,CAAC,UAAU,CAAC,cAAc,CAACA,4BAAgB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;;gBAE3E,MAAM,iBAAiB,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;aAC5C;SAAA;QAED,sBAAsB,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;QAErD1E,gBAAM,CAAC,OAAO,CAAC,+CAA+C,EAAE,iBAAiB,CAAC,YAAY,CAAC,CAAC;QAEhG,OAAO,iBAAiB,CAAC;KAC1B;IAxVe,wBAAM,SAwVrB,CAAA;;;;;;;;;;IAWD,SAAsB,KAAK,CAAC,OAA0B;;YACpD,MAAM,SAAS,GAAG,IAAI,OAAO,CAAC,YAAY,GAAG,CAAC;YAE9C,IAAI;gBACFA,gBAAM,CAAC,OAAO,CAAC,GAAG,SAAS,yDAAyD,CAAC,CAAC;;gBAGtF,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;gBACjDA,gBAAM,CAAC,OAAO,CAAC,GAAG,SAAS,wBAAwB,WAAW,CAAC,MAAM,WAAW,CAAC,CAAC;gBAClF,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;oBACpC,MAAM,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,KAAK,EAAE,CAAC;iBAC3C;;gBAGD,MAAM,oBAAoB,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;gBACnEA,gBAAM,CAAC,OAAO,CAAC,GAAG,SAAS,wBAAwB,oBAAoB,CAAC,MAAM,aAAa,CAAC,CAAC;gBAC7F,KAAK,MAAM,YAAY,IAAI,oBAAoB,EAAE;oBAC/C,MAAM,OAAO,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC,KAAK,EAAE,CAAC;iBACtD;;gBAGD,MAAM,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;gBACjEA,gBAAM,CAAC,OAAO,CACZ,GAAG,SAAS,wBAAwB,mBAAmB,CAAC,MAAM,qBAAqB,CACpF,CAAC;gBACF,KAAK,MAAM,kBAAkB,IAAI,mBAAmB,EAAE;oBACpD,MAAM,OAAO,CAAC,eAAe,CAAC,kBAAkB,CAAC,CAAC,KAAK,EAAE,CAAC;iBAC3D;;gBAGD,MAAM,4BAA4B,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;gBAC5EA,gBAAM,CAAC,OAAO,CACZ,GAAG,SAAS,wBAAwB,4BAA4B,CAAC,MAAM,qBAAqB,CAC7F,CAAC;gBACF,KAAK,MAAM,UAAU,IAAI,4BAA4B,EAAE;oBACrD,MAAM,OAAO,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC,KAAK,EAAE,CAAC;iBACrD;gBAEDA,gBAAM,CAAC,OAAO,CAAC,GAAG,SAAS,iCAAiC,CAAC,CAAC;gBAC9D,MAAM,OAAO,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;gBAEjCA,gBAAM,CAAC,OAAO,CAAC,GAAG,SAAS,0CAA0C,CAAC,CAAC;gBACvE,MAAM,OAAO,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;gBACjC,OAAO,CAAC,wBAAwB,GAAG,IAAI,CAAC;gBACxCA,gBAAM,CAAC,OAAO,CAAC,IAAI,SAAS,wDAAwD,CAAC,CAAC;aACvF;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,MAAM,GAAG,GAAG,YAAY,KAAK,GAAG,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC3EA,gBAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,SAAS,iDAAiD,CAAC,CAAC;gBACpF,MAAM,MAAM,CAAC;aACd;SACF;KAAA;IAlDqB,uBAAK,QAkD1B,CAAA;AACH,CAAC,EAvZgB,iBAAiB,KAAjB,iBAAiB,QAuZjC;;ACjmBD;AACA,AA2BA;;;;;;;;AAQA,SAAgB,uBAAuB,CACrC,gBAAwB,EACxB,UAAiD,EACjD,OAAgC;;IAEhC,MAAM,MAAM,GAAG2E,yBAAgB,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;IAEzD,MAAM,CAAC,SAAS,SAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,gBAAgB,0CAAE,SAAS,CAAC;IACxD,MAAM,CAAC,qBAAqB,GAAG,uBAAuB,CAAC;IACvD,MAAM,CAAC,2BAA2B,SAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,gBAAgB,0CAAE,2BAA2B,CAAC;IAE5F,OAAO,iBAAiB,CAAC,MAAM,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;AAC/D,CAAC;AAED;;;;;;AAMA,SAAgB,0CAA0C,CACxD,gBAAwB,EACxB,UAAmC,EAAE;IAErC,MAAM,UAAU,GAAG,mBAAmB,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,CAAC;IAC9E,OAAO,uBAAuB,CAAC,gBAAgB,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;AACxE,CAAC;AAED;;;;;;;;AAQA,SAAgB,yCAAyC,CACvD,UAA2B,EAC3B,IAAY,EACZ,UAAmC,EAAE;IAErC,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;QAC5B,MAAM,IAAI,SAAS,CAAC,kCAAkC,CAAC,CAAC;KACzD;;IAGD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;QACvB,IAAI,IAAI,GAAG,CAAC;KACb;IACD,MAAM,gBAAgB,GAAG,iBAAiB,IAAI,sEAAsE,CAAC;IACrH,OAAO,uBAAuB,CAAC,gBAAgB,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;AACxE,CAAC;;ACvFD;AACA,AAeA;;;;AAIA,SAAgB,aAAa,CAC3B,OAAiC;;IAEjC,aAAO,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,0CAAE,MAAM,CAAC;AACtC,CAAC;AAED;;;;;;;;;AASA,SAAgB,cAAc,CAC5B,UAAsC,EACtC,qBAAoC,EAAE,EACtC,UAAmB,EACnB,IAAa;IAEb,MAAM,KAAK,GAAW,kBAAkB,CAAC,GAAG,CAAC,CAAC,OAAO;QACnD,OAAO;YACL,OAAO;SACR,CAAC;KACH,CAAC,CAAC;IACH,MAAM,MAAM,GAAGnC,qBAAS,EAAE,CAAC;IAC3B,MAAM,IAAI,GAAG,MAAM,CAAC,SAAS,CAAC,uBAAuB,EAAE;QACrD,IAAI,EAAEC,YAAQ,CAAC,MAAM;QACrB,MAAM,EAAE,UAAU;QAClB,KAAK;KACN,CAAC,CAAC;IAEH,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,sBAAsB,CAAC,CAAC;IAC1D,IAAI,CAAC,YAAY,CAAC,yBAAyB,EAAE,UAAU,CAAC,CAAC;IACzD,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;IAExC,OAAO,IAAI,CAAC;AACd,CAAC;AAWD;;;;;;;AAOA,SAAsB,KAAK,CAAI,EAAoB,EAAE,IAAU;;QAC7D,IAAI;YACF,MAAM,GAAG,GAAG,MAAM,EAAE,EAAE,CAAC;YACvB,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,EAAEC,iBAAa,CAAC,EAAE,EAAE,CAAC,CAAC;YAC3C,OAAO,GAAG,CAAC;SACZ;QAAC,OAAO,GAAG,EAAE;YACZ,IAAI,CAAC,SAAS,CAAC;gBACb,IAAI,EAAEA,iBAAa,CAAC,OAAO;gBAC3B,OAAO,EAAE,GAAG,CAAC,OAAO;aACrB,CAAC,CAAC;YACH,MAAM,GAAG,CAAC;SACX;gBAAS;YACR,IAAI,CAAC,GAAG,EAAE,CAAC;SACZ;KACF;CAAA;;AC1FD;AACA,AAyBA;;;;;;;;;;;;;AAaA,SAAgB,gBAAgB,CAC9B,SAAiB,EACjB,QAA8B,EAC9B,sBAA4D;IAE5D,IAAI,QAAQ,EAAE;QACZ,MAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC;QACvB,MAAM,KAAK,GAAG,QAAQ,CAAC,YAAY,CAAC;QACpC,MAAM,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC;QACxC,cAAc,CAAC,OAAO,CACpB,wEAAwE,GAAG,WAAW,EACtF,SAAS,EACT,EAAE,EACF,OAAO,EACP,KAAK,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,GAAG,KAAK,CAC3C,CAAC;QACF,IAAI,OAAO,IAAI,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;YAC7C,MAAM,OAAO,GAAG,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAA4B,CAAC;YAC1E,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAC5B,cAAc,CAAC,OAAO,CACpB,oEAAoE,EACpE,SAAS,EACT,EAAE,CACH,CAAC;YACF,MAAM,YAAY,GAAG,sBAAsB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YACvD,cAAc,CAAC,OAAO,CACpB,+DAA+D,EAC/D,SAAS,EACT,EAAE,EACF,YAAY,CACb,CAAC;YACF,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;gBAC9E,MAAM,KAAK,GAAG,wBAAwB,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACpD,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;aAC9B;YAED,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;SAC1B;KACF;AACH,CAAC;AAED;;;;;;;;;;AAUA,SAAgB,qBAAqB,CACnC,IAAY,EACZ,WAAwB,EACxB,MAAc,EACd,QAA0B;IAE1B,MAAM,WAAW,mBACf,IAAI;;;QAGJ,UAAU,EAAE,WAAW,KAAK,kBAAkB,GAAG,IAAI,GAAG,KAAK;;QAE7D,eAAe,EAAE,WAAW,KAAK,kBAAkB,GAAG,CAAC,GAAG,CAAC;;QAE3D,eAAe,EAAE,WAAW,KAAK,kBAAkB,GAAG,CAAC,GAAG,CAAC,EAC3D,MAAM,EACN,aAAa,EAAE,CAAC,IACb,QAAQ,CACZ,CAAC;IAEF,OAAO,WAAW,CAAC;AACrB,CAAC;;AC/GD;AACA,AA+FA;;;;;;AAMA,MAAsB,eAAgB,SAAQ,UAAoB;IA2ChE,YACE,OAA0B,EAC1B,UAAkB,EAClB,YAA0B,EAC1B,OAAmD;QAEnD,KAAK,CAAC,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE1C,cAAM,EAAE;YAC3D,OAAO,EAAE,UAAU;YACnB,QAAQ,EAAE,GAAG,OAAO,CAAC,MAAM,CAAC,QAAQ,GAAG,UAAU,EAAE;SACpD,CAAC,CAAC;;;;;;QA/BK,4BAAuB,GAAyC,IAAI,GAAG,EAG9E,CAAC;QA8BF,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,IAAI,UAAU,CAAC;;QAGrD,IAAI,CAAC,YAAY;YACf,OAAO,CAAC,oBAAoB,KAAK,KAAK,GAAG,OAAO,CAAC,oBAAoB,GAAG,IAAI,CAAC;QAC/E,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,WAAW,CAAC;KACzC;;;;IAKS,sBAAsB,CAC9B,UAAmB,EACnB,QAA0B;QAE1B,MAAM,WAAW,GAAoB,qBAAqB,CACxD,UAAU,GAAG,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,IAAI,EACrD,IAAI,CAAC,WAAW,EAChB;YACE,OAAO,EAAE,IAAI,CAAC,OAAO;SACtB,kBAEC,SAAS,EAAE,CAAC,OAAqB;gBAC/B,OAAO,gBAAgB,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,uBAAuB,CAAC,CAAC;aACzF,IACE,QAAQ,EAEd,CAAC;QAEF,OAAO,WAAW,CAAC;KACpB;;;;;;IAOe,KAAK,CAAC,OAAwB,EAAE,WAA6B;;YAC3E,IAAI;gBACF,MAAM,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;;;gBAI1C,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAW,CAAC;aACzD;YAAC,OAAO,GAAG,EAAE;gBACZ,GAAG,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBACpCA,cAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,iDAAiD,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;;gBAGxF,IAAK,GAAsB,CAAC,IAAI,KAAK,uBAAuB,EAAE;oBAC5D,GAAG,CAAC,OAAO,GAAG,uEAAuE,CAAC;iBACvF;gBAED,MAAM,GAAG,CAAC;aACX;SACF;KAAA;IAES,cAAc,CACtB,OAAwB,EACxB,YAA8B;QAE9B,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;KACzD;;;;;;IAcK,KAAK;;;;;;YACT,MAAA,IAAI,CAAC,YAAY,0CAAE,OAAO,CAAC,IAAI,EAAE;YACjC,MAAM,OAAM,KAAK,WAAE,CAAC;;KACrB;;;;;;;IAQK,aAAa,CACjB,OAA8B,EAC9B,SAA0B,EAC1B,OAAkC;;YAElC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM;;gBACjC,IAAI,CAAC,OAAO;oBAAE,OAAO,GAAG,EAAE,CAAC;gBAC3B,IAAI,SAAS,CAAC,KAAK,CAAC,uCAAuC,CAAC,IAAI,IAAI,EAAE;oBACpE,OAAO,MAAM,CAAC,IAAI,KAAK,CAAC,eAAe,SAAS,6BAA6B,CAAC,CAAC,CAAC;iBACjF;gBACD,MAAA,IAAI,CAAC,YAAY,0CAAE,IAAI,CAAC,IAAI,EAAE,OAAO,EAAE;gBACvC,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;gBAClC,MAAM,KAAK,GAAG,UAAU,CAAC;oBACvB,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;oBAEjDA,cAAM,CAAC,OAAO,CACZ,2EAA2E;wBACzE,iDAAiD,EACnD,IAAI,CAAC,SAAS,EACd,QAAQ,CAAC,EAAE,EACXwD,kBAAS,CAAC,2BAA2B,CACtC,CAAC;oBAEF,MAAM,CAAC,GAAc;wBACnB,SAAS,EAAEoB,iCAAwB,CAAC,uBAAuB;wBAC3D,WAAW,EACT,wEAAwE;4BACxE,sCAAsC;qBACzC,CAAC;oBACF,OAAO,MAAM,CAAC,wBAAwB,CAAC,CAAC,CAAC,CAAC,CAAC;iBAC5C,EAAEpB,kBAAS,CAAC,2BAA2B,CAAC,CAAC;gBAC1C,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,EAAE;oBAC5C,OAAO,EAAE,OAAO;oBAChB,MAAM,EAAE,MAAM;oBACd,KAAK,EAAE,KAAK;iBACb,CAAC,CAAC;gBACH,IAAI,SAAS,KAAK,eAAe,CAAC,QAAQ,EAAE;oBAC1C,QAAQ,CAAC,MAAM,EAAE,CAAC;iBACnB;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,OAAO,EAAE;oBAChD,MAAM,MAAM,GAAQ;wBAClB,kBAAkB,EAAE,KAAK;qBAC1B,CAAC;oBACF,IAAI,OAAO,CAAC,kBAAkB;wBAAE,MAAM,CAAC,mBAAmB,GAAG,OAAO,CAAC,kBAAkB,CAAC;oBACxF,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;iBAC3B;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,KAAK,EAAE;oBAC9C,MAAM,MAAM,GAAQ;wBAClB,kBAAkB,EAAE,IAAI;qBACzB,CAAC;oBACF,IAAI,OAAO,CAAC,kBAAkB;wBAAE,MAAM,CAAC,mBAAmB,GAAG,OAAO,CAAC,kBAAkB,CAAC;oBACxF,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;iBAC3B;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,UAAU,EAAE;oBACnD,MAAM,KAAK,GAAc;wBACvB,SAAS,EAAEA,kBAAS,CAAC,cAAc;wBACnC,IAAI,kCACC,OAAO,CAAC,kBAAkB,KAC7B,gBAAgB,EAAE,OAAO,CAAC,gBAAgB,EAC1C,0BAA0B,EAAE,OAAO,CAAC,qBAAqB,GAC1D;qBACF,CAAC;oBACF,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBACxB;aACF,CAAC,CAAC;SACJ;KAAA;CACF;;ACnTD;AACA,AAKA;;;;;;;AAOA,MAAa,cAAc;IAGzB,YACU,mBAAgF;QAAhF,wBAAmB,GAAnB,mBAAmB,CAA6D;QAHlF,iBAAY,GAAY,KAAK,CAAC;KAIlC;;;;;;;;;;IAWJ,SAAS,CAAC,OAAe;QACvB,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAE3D,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE,EAAE;YAC9BxD,cAAM,CAAC,OAAO,CACZ,GAAG,SAAS,iBAAiB,OAAO,2DAA2D,CAChG,CAAC;YACF,OAAO,KAAK,CAAC;SACd;QAED,IAAI,QAAQ,IAAI,IAAI,EAAE;YACpBA,cAAM,CAAC,OAAO,CAAC,GAAG,SAAS,WAAW,OAAO,UAAU,CAAC,CAAC;YACzD,QAAQ,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;SAC7B;QAED,OAAO,IAAI,CAAC;KACb;;;;;IAMK,OAAO;;YACX,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAE3D,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YAEzB,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAAE;gBACpC,OAAO;aACR;YAEDA,cAAM,CAAC,OAAO,CACZ,GAAG,SAAS,0EAA0E,CACvF,CAAC;YACF,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;SACrB;KAAA;;;;IAKD,MAAM;QACJ,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;KAC3B;;;;;;;;IASD,kBAAkB;QAChB,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAChD,OAAO,CAAC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;KAC9D;;;;;IAMK,KAAK;;YACT,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAE3D,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAAE;gBACpC,OAAO;aACR;YAEDA,cAAM,CAAC,OAAO,CACZ,GAAG,SAAS,mDAAmD,QAAQ,CAAC,MAAM,EAAE,CACjF,CAAC;YAEF,MAAM,YAAY,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO;gBAC7C,QAAQ,CAAC,IAAI,CAACiE,0BAAc,CAAC,eAAe,EAAE;oBAC5CjE,cAAM,CAAC,OAAO,CAAC,GAAG,SAAS,6BAA6B,CAAC,CAAC;oBAC1D,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAC;oBACvB,OAAO,EAAE,CAAC;iBACX,CAAC,CAAC;gBAEH,QAAQ,CAAC,KAAK,GAAG,IAAI,CAAC;;;gBAGtB,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;aACvB,CAAC,CAAC;YAEH,OAAO,YAAY,CAAC;SACrB;KAAA;IAEO,gBAAgB,CAAC,QAA8B;QACrD,OAAO,QAAQ,IAAI,IAAI,IAAI,QAAQ,CAAC,MAAM,EAAE,CAAC;KAC9C;CACF;;ACvHD;AACA,AAkBA;;;;AAIA,SAAgB,0BAA0B,CAAC,QAAa;IACtD,IACE,QAAQ;QACR,QAAQ,CAAC,cAAc,YAAY,QAAQ;QAC3C,QAAQ,CAAC,YAAY,YAAY,QAAQ,EACzC;QACA,OAAO;KACR;IAED,MAAM,IAAI,SAAS,CAAC,qCAAqC,CAAC,CAAC;AAC7D,CAAC;AAED;;;;AAIA,SAAuB,kBAAkB,CACvC,QAAqD,EACrD,OAA8B;;QAE9B,OAAO,IAAI,EAAE;YACX,MAAM,QAAQ,GAAG,oBAAM,QAAQ,CAAC,eAAe,CAAC,CAAC,EAAE,OAAO,CAAC,CAAA,CAAC;YAE5D,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;gBACzB,SAAS;aACV;YAED,0BAAM,QAAQ,CAAC,CAAC,CAAC,CAAA,CAAC;SACnB;KACF;CAAA;AAED;;;;AAIA,SAAgB,uBAAuB,CACrC,QAA+C,EAC/C,SAA2B,cAAc;IAEzC,OAAO,CAAO,IAAsB;QAClC,IAAI;YACF,IAAI,CAAC,KAAK,GAAG,wBAAwB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAClD,MAAM,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;SACnC;QAAC,OAAO,GAAG,EAAE;YACZ,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,0DAA0D,CAAC,CAAC;SAClF;KACF,CAAA,CAAC;AACJ,CAAC;AAED;;;;;;;;AAQA,SAAgB,eAAe,CAC7B,OAA8B,EAC9B,OAA0B,EAC1B,UAAkB;IAElB,cAAc,CAAC,OAAO,CACpB,2CAA2C,EAC3C,OAAO,CAAC,YAAY,EACpB,OAAO,CAAC,SAAS,CAClB,CAAC;IACF,OAAO,aAAa,CAAC,OAAO,EAAE,eAAe,CAAC,QAAQ,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;AAC/E,CAAC;AAED;;;;;;;;;AASA,SAAgB,cAAc,CAC5B,OAA8B,EAC9B,OAA0B,EAC1B,UAAkB,EAClB,kBAA2C;IAE3C,cAAc,CAAC,OAAO,CACpB,2CAA2C,EAC3C,OAAO,CAAC,YAAY,EACpB,OAAO,CAAC,SAAS,CAClB,CAAC;IACF,OAAO,aAAa,CAAC,OAAO,EAAE,eAAe,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE;QAC1E,kBAAkB;KACnB,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;;;AASA,SAAgB,YAAY,CAC1B,OAA8B,EAC9B,OAA0B,EAC1B,UAAkB,EAClB,kBAA2C;IAE3C,cAAc,CAAC,OAAO,CACpB,0CAA0C,EAC1C,OAAO,CAAC,YAAY,EACpB,OAAO,CAAC,SAAS,CAClB,CAAC;IACF,OAAO,aAAa,CAAC,OAAO,EAAE,eAAe,CAAC,KAAK,EAAE,OAAO,EAAE,UAAU,EAAE;QACxE,kBAAkB;KACnB,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;;;AASA,SAAgB,iBAAiB,CAC/B,OAA8B,EAC9B,OAA0B,EAC1B,UAAkB,EAClB,kBAA+D;IAE/D,cAAc,CAAC,OAAO,CACpB,8CAA8C,EAC9C,OAAO,CAAC,YAAY,EACpB,OAAO,CAAC,SAAS,CAClB,CAAC;IAEF,MAAM,wBAAwB,qBACzB,kBAAkB,CACtB,CAAC;;IAGF,OAAO,wBAAwB,CAAC,0BAA0B,CAAC;IAC3D,OAAO,wBAAwB,CAAC,gBAAgB,CAAC;IAEjD,MAAM,wBAAwB,GAA6B;QACzD,kBAAkB,EAAE,wBAAwB;QAC5C,gBAAgB,EAAE,kBAAkB,aAAlB,kBAAkB,uBAAlB,kBAAkB,CAAE,gBAAgB;QACtD,qBAAqB,EAAE,kBAAkB,aAAlB,kBAAkB,uBAAlB,kBAAkB,CAAE,0BAA0B;KACtE,CAAC;IAEF,OAAO,aAAa,CAClB,OAAO,EACP,eAAe,CAAC,UAAU,EAC1B,OAAO,EACP,UAAU,EACV,wBAAwB,CACzB,CAAC;AACJ,CAAC;AAED;;;;;;;;;;AAUA,SAAS,aAAa,CACpB,OAA8B,EAC9B,SAA0B,EAC1B,OAA0B,EAC1B,UAAkB,EAClB,OAAkC;IAElC,MAAM,iBAAiB,GAAG,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC;IACjD,MAAM,QAAQ,GAAG,iBAAiB;UAC9B,SAAS;UACT,OAAO,CAAC,oBAAoB,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;IAChF,MAAM,kBAAkB,GAAG,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,IAAI,CAAC;IAE1C,IAAI,KAAwB,CAAC;IAC7B,IAAI,OAAO,CAAC,QAAQ,CAAC,cAAc,EAAE;QACnC,KAAK,GAAG,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;KAC1C;SAAM,IACL,CAAC,iBAAiB;SACjB,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC;QACjC,OAAO,CAAC,SAAS,IAAI,SAAS,EAC9B;QACA,KAAK,GAAG,wBAAwB,CAAC;YAC/B,WAAW,EACT,aAAa,SAAS,2DAA2D;gBACjF,8BAA8B;YAChC,SAAS,EAAE4E,iCAAwB,CAAC,oBAAoB;SACzD,CAAC,CAAC;KACJ;IAED,IAAI,KAAK,EAAE;QACT,cAAc,CAAC,QAAQ,CACrB,KAAK,EACL,6DAA6D,EAC7D,OAAO,CAAC,YAAY,EACpB,OAAO,CAAC,SAAS,CAClB,CAAC;QACF,MAAM,KAAK,CAAC;KACb;;;;IAKD,IAAI,iBAAiB,KAAK,CAAC,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,OAAO,CAAC,SAAS,IAAI,SAAS,CAAC,EAAE;QAC9F,OAAO,OAAO;aACX,mBAAmB,CAAC,UAAU,CAAC;aAC/B,uBAAuB,CAAC,OAAO,CAAC,SAAU,EAAE,SAAS,kCACjD,OAAO,KACV,kBAAkB,EAClB,SAAS,EAAE,OAAO,CAAC,SAAS,IAC5B;aACD,KAAK,CAAC,CAAC,GAAG;YACT,MAAM,wBAAwB,CAAC,GAAG,CAAC,CAAC;SACrC,CAAC,CAAC;KACN;IAED,OAAO,QAAS,CAAC,aAAa,CAAC,OAAO,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG;QACpE,MAAM,wBAAwB,CAAC,GAAG,CAAC,CAAC;KACrC,CAAC,CAAC;AACL,CAAC;;AC/PD;AACA,AAyCA;;;;;;;;AAQA,MAAa,iBAAkB,SAAQ,eAAe;;;;;;;;IA0EpD,YAAY,OAA0B,EAAE,UAAkB,EAAE,OAAuB;QACjF,KAAK,CAAC,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;;;;;;;QApEnD,uBAAkB,GAAW,CAAC,CAAC;;;;;;;QAQvB,iBAAY,GAAY,KAAK,CAAC;QA8DpC,IAAI,QAAO,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,CAAA,KAAK,QAAQ,IAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,kBAAkB,IAAG,CAAC,EAAE;YACtF,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;SACtD;QAED,IAAI,CAAC,aAAa,GAAG,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,YAAY,KAAI,EAAE,CAAC;QACjD,IAAI,CAAC,MAAM,GAAGC,cAAK,CAAC;QAEpB,IAAI,CAAC,eAAe,GAAG,IAAI,cAAc,CAAC,OAAO;YAC/C,QAAQ,EAAE,IAAI,CAAC,IAAI;YACnB,SAAS,EAAE,IAAI,CAAC,SAAS;SAC1B,CAAC,CAAC,CAAC;QAEJ,IAAI,CAAC,YAAY,GAAG,CAAO,OAAqB;;YAC9C,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC;YACjE,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,IAAI,OAAO,CAAC,QAAS,CAAC;YAEhD7E,cAAM,CAAC,QAAQ,CACb,aAAa,EACb,GAAG,IAAI,CAAC,SAAS,2DAA2D,CAC7E,CAAC;YAEF,MAAA,IAAI,CAAC,YAAY,0CAAE,OAAO,CAAC,IAAI,EAAE;YAEjC,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,EAAE;gBAC1C,MAAM,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;aACtC;iBAAM;gBACLA,cAAM,CAAC,OAAO,CACZ,4EAA4E;oBAC1E,gFAAgF;oBAChF,aAAa,EACf,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;aACH;SACF,CAAA,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAO,OAAqB;;YACjD,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,IAAI,OAAO,CAAC,QAAS,CAAC;YAChD,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAE9DA,cAAM,CAAC,QAAQ,CACb,YAAY,EACZ,GAAG,IAAI,CAAC,SAAS,0DAA0D,CAC5E,CAAC;YAEF,MAAA,IAAI,CAAC,YAAY,0CAAE,OAAO,CAAC,IAAI,EAAE;YAEjC,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,qBAAqB,EAAE,EAAE;gBACjD,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;aACrC;iBAAM;gBACLA,cAAM,CAAC,OAAO,CACZ,iFAAiF;oBAC/E,wFAAwF;oBACxF,aAAa,EACf,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;aACH;SACF,CAAA,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG,CAAC,OAAqB;YACxC,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC;YACjE,IAAI,aAAa,EAAE;gBACjB,MAAM,OAAO,GAAG,wBAAwB,CAAC,aAAa,CAAmB,CAAC;gBAC1EA,cAAM,CAAC,QAAQ,CACb,OAAO,EACP,GAAG,IAAI,CAAC,SAAS,2DAA2D,CAC7E,CAAC;aACH;SACF,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAC,OAAqB;YAC3C,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAC9D,IAAI,YAAY,EAAE;gBAChB,MAAM,OAAO,GAAG,wBAAwB,CAAC,YAAY,CAAmB,CAAC;gBACzEA,cAAM,CAAC,QAAQ,CACb,OAAO,EACP,GAAG,IAAI,CAAC,SAAS,0DAA0D,CAC5E,CAAC;aACH;SACF,CAAC;QAEF,IAAI,CAAC,cAAc,GAAG,CAAO,OAAqB;;;;YAGhD,IAAI,IAAI,CAAC,WAAW,KAAK,UAAU,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE;gBAC1EA,cAAM,CAAC,OAAO,CACZ,oEAAoE;oBAClE,2BAA2B,EAC7B,IAAI,CAAC,SAAS,CACf,CAAC;gBACF,OAAO;aACR;YAED,MAAM,QAAQ,GAA0B,IAAI,qBAAqB,CAC/D,OAAO,CAAC,OAAQ,EAChB,OAAO,CAAC,QAAS,EACjB,IAAI,EACJ,IAAI,CAAC,WAAW,CACjB,CAAC;YAEF,MAAA,IAAI,CAAC,YAAY,0CAAE,KAAK,CAAC,IAAI,EAAE,QAAQ,EAAE,CAAC,GAAG;gBAC3C,IAAI,IAAI,CAAC,QAAQ,EAAE;oBACjB,IAAI,CAAC,QAAQ,CAAC;wBACZ,KAAK,EAAE,GAAG;wBACV,WAAW,EAAE,WAAW;wBACxB,UAAU,EAAE,IAAI,CAAC,UAAU;wBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;qBACnD,CAAC,CAAC;iBACJ;aACF,EAAE;YAEH,IAAI;gBACF,MAAM,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;aACjC;YAAC,OAAO,GAAG,EAAE;gBACZA,cAAM,CAAC,QAAQ,CACb,GAAG,EACH,4EAA4E;oBAC1E,mCAAmC,EACrC,IAAI,CAAC,SAAS,EACd,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,CACV,CAAC;gBACF,IAAI,CAAC,QAAS,CAAC;oBACb,KAAK,EAAE,GAAG;oBACV,WAAW,EAAE,wBAAwB;oBACrC,UAAU,EAAE,IAAI,CAAC,UAAU;oBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;iBACnD,CAAC,CAAC;;;gBAIH,MAAA,IAAI,CAAC,YAAY,0CAAE,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE;gBACxC,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAmB,CAAC;;gBAE9D,IACE,CAAC,QAAQ,CAAC,QAAQ,CAAC,cAAc;oBACjC,KAAK,CAAC,IAAI,KAAKoE,iCAAwB,CAAC,iCAAiC,CAAC;oBAC1E,IAAI,CAAC,WAAW,KAAK,UAAU;oBAC/B,IAAI,CAAC,MAAM,EAAE;kBACb;oBACA,IAAI;wBACFpE,cAAM,CAAC,QAAQ,CACb,KAAK,EACL,oEAAoE;4BAClE,uBAAuB,EACzB,IAAI,CAAC,SAAS,EACd,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,EACT,KAAK,CACN,CAAC;wBACF,MAAM,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;qBAC3D;oBAAC,OAAO,YAAY,EAAE;wBACrB,MAAM,eAAe,GAAG,wBAAwB,CAAC,YAAY,CAAC,CAAC;wBAC/DA,cAAM,CAAC,QAAQ,CACb,eAAe,EACf,wEAAwE;4BACtE,eAAe,EACjB,IAAI,CAAC,SAAS,EACd,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,CACV,CAAC;wBACF,IAAI,CAAC,QAAS,CAAC;4BACb,KAAK,EAAE,eAAe;4BACtB,WAAW,EAAE,SAAS;4BACtB,UAAU,EAAE,IAAI,CAAC,UAAU;4BAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;yBACnD,CAAC,CAAC;qBACJ;iBACF;gBACD,OAAO;aACR;oBAAS;gBACR,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;aACnC;;;YAID,IACE,IAAI,CAAC,YAAY;gBACjB,IAAI,CAAC,WAAW,KAAK,UAAU;gBAC/B,CAAC,QAAQ,CAAC,QAAQ,CAAC,cAAc,EACjC;gBACA,IAAI;oBACFA,cAAM,CAAC,OAAO,CACZ,iDAAiD,GAAG,eAAe,EACnE,IAAI,CAAC,SAAS,EACd,QAAQ,CAAC,SAAS,CACnB,CAAC;oBACF,MAAM,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;iBAC5D;gBAAC,OAAO,aAAa,EAAE;oBACtB,MAAM,eAAe,GAAG,wBAAwB,CAAC,aAAa,CAAC,CAAC;oBAChEA,cAAM,CAAC,QAAQ,CACb,eAAe,EACf,wEAAwE;wBACtE,eAAe,EACjB,IAAI,CAAC,SAAS,EACd,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,IAAI,CAAC,QAAS,CAAC;wBACb,KAAK,EAAE,eAAe;wBACtB,WAAW,EAAE,UAAU;wBACvB,UAAU,EAAE,IAAI,CAAC,UAAU;wBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;qBACnD,CAAC,CAAC;iBACJ;aACF;SACF,CAAA,CAAC;KACH;;;;IAnOD,IAAW,mBAAmB;;;;QAI5B,OAAO,IAAI,CAAC,eAAe,CAAC,kBAAkB,EAAE,CAAC;KAClD;IAgOO,YAAY;QAClB,OAAO;YACL,SAAS,EAAE,CAAC,OAAqB,KAC/B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC;;aAElC,CAAC;YACJ,OAAO,EAAE,CAAC,OAAqB,KAC7B,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC;;aAEhC,CAAC;YACJ,cAAc,EAAE,CAAC,OAAqB,KACpC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC;;aAEnC,CAAC;YACJ,OAAO,EAAE,IAAI,CAAC,YAAY;YAC1B,cAAc,EAAE,IAAI,CAAC,eAAe;SACrC,CAAC;KACH;IAEK,qBAAqB;;YACzB,MAAM,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC;SACtC;KAAA;;;;;;;;;;;;;IAcK,IAAI,CACR,IAGC;;YAED,IAAI,cAAc,GAAG,CAAC,CAAC;YAEvB,OAAO,IAAI,EAAE;gBACX,EAAE,cAAc,CAAC;gBAEjB,MAAM,MAAM,GAAsB;oBAChC,SAAS,EAAE,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;oBACrC,YAAY,EAAE,IAAI,CAAC,YAAY;oBAC/B,aAAa,EAAE8E,2BAAkB,CAAC,YAAY;;;oBAG9C,YAAY,EAAE,IAAI,CAAC,aAAa;oBAChC,WAAW,EAAE,IAAI,CAAC,WAAW;iBAC9B,CAAC;gBAEF,IAAI;oBACF,MAAM,IAAI,CAAC,MAAM,CAAO,MAAM,CAAC,CAAC;oBAChC,MAAM;iBACP;gBAAC,OAAO,GAAG,EAAE;;;oBAGZ,IAAI,CAAC,OAAO,CAAC;wBACX,WAAW,EAAE,SAAS;wBACtB,UAAU,EAAE,IAAI,CAAC,UAAU;wBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;wBAClD,KAAK,EAAE,GAAG;qBACX,CAAC,CAAC;;oBAGH,IAAI,GAAG,CAAC,IAAI,KAAK,YAAY,EAAE;wBAC7B,MAAM,GAAG,CAAC;qBACX;oBAED9E,cAAM,CAAC,QAAQ,CACb,GAAG,EACH,GAAG,IAAI,CAAC,SAAS,gCAAgC,cAAc,6CAA6C,EAC5G,IAAI,CAAC,aAAa,CACnB,CAAC;oBAEF,SAAS;iBACV;aACF;SACF;KAAA;IAEa,SAAS,CAAC,IAGvB;;YACC,MAAM,OAAO,GAAG,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC;YAClF,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;;;;YAK5C,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;SAC/B;KAAA;;;;;;;IAQD,SAAS,CAAC,SAAoB,EAAE,OAAgB;QAC9C,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAE5C,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAExB,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;KACzD;;;;;;IAOK,UAAU,CAAC,aAAiC;;YAChDA,cAAM,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,SAAS,mCAAmC,CAAC,CAAC;;;YAIrE,IAAI,IAAI,CAAC,oBAAoB,EAAE;gBAC7BA,cAAM,CAAC,OAAO,CACZ,GAAG,IAAI,CAAC,SAAS,qEAAqE,CACvF,CAAC;gBACF,OAAO;aACR;;YAGD,IAAI,IAAI,CAAC,YAAY,EAAE;;;;;;;;gBAQrBA,cAAM,CAAC,OAAO,CACZ,GAAG,IAAI,CAAC,SAAS,wDAAwD,IAAI,CAAC,IAAI,2BAA2B,CAC9G,CAAC;gBACF,OAAO;aACR;YAED,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YAEzB,MAAM,eAAe,GAAG,aAAa,GAAG,wBAAwB,CAAC,aAAa,CAAC,GAAG,aAAa,CAAC;YAChGA,cAAM,CAAC,QAAQ,CACb,eAAe,EACf,GAAG,IAAI,CAAC,SAAS,uDAAuD,CACzE,CAAC;YAEF,IAAI;;;gBAGF,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC;aACxB;YAAC,OAAO,GAAG,EAAE;gBACZA,cAAM,CAAC,OAAO,CACZ,GAAG,IAAI,CAAC,SAAS,oEAAoE,EACrF,GAAG,CACJ,CAAC;aACH;YAED,IAAI;gBACF,MAAM,IAAI,CAAC,IAAI,CAAC;;;oBAGd,UAAU,EAAE,IAAI;oBAChB,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;oBACxC,OAAO,EAAE,CAAC,IAAI,KAAK,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC;iBACxD,CAAC,CAAC;gBAEH,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;gBACxDA,cAAM,CAAC,OAAO,CACZ,GAAG,IAAI,CAAC,SAAS,mDAAmD,IAAI,CAAC,kBAAkB,WAAW,CACvG,CAAC;aACH;oBAAS;gBACR,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;aAC3B;SACF;KAAA;CACF;;ACxgBD;AACA,AAaA;;;AAGA,AAAO,MAAM,oBAAoB,GAAG,eAAe,CAAC;AAEpD;;;;;;;;;AASA,SAAgB,2BAA2B,CACzC,OAA0B,EAC1B,IAAU;IAEV,IAAI,OAAO,CAAC,qBAAqB,IAAI,OAAO,CAAC,qBAAqB,CAAC,oBAAoB,CAAC,EAAE;QACxF,OAAO,OAAO,CAAC;KAChB;;IAGD,OAAO,mCAAQ,OAAO,KAAE,qBAAqB,oBAAO,OAAO,CAAC,qBAAqB,IAAI,CAAC;IAEtF,MAAM,WAAW,GAAG+E,gCAAoB,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;IACzD,IAAI,WAAW,EAAE;QACf,OAAO,CAAC,qBAAsB,CAAC,oBAAoB,CAAC,GAAG,WAAW,CAAC;KACpE;IAED,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;;;;AAMA,SAAgB,uCAAuC,CACrD,OAA0B;IAE1B,IAAI,CAAC,OAAO,CAAC,qBAAqB,IAAI,CAAC,OAAO,CAAC,qBAAqB,CAAC,oBAAoB,CAAC,EAAE;QAC1F,OAAO;KACR;IAED,MAAM,YAAY,GAAG,OAAO,CAAC,qBAAqB,CAAC,oBAAoB,CAAW,CAAC;IACnF,OAAOC,mDAAuC,CAAC,YAAY,CAAC,CAAC;AAC/D,CAAC;AAED;;;;;;;;AAQA,UAAU,mBAAmB,CAC3B,gBAAyE;IAEzE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAE;QACpC,MAAM,gBAAgB,CAAC;KACxB;SAAM;QACL,KAAK,MAAM,OAAO,IAAI,gBAAgB,EAAE;YACtC,MAAM,OAAO,CAAC;SACf;KACF;AACH,CAAC;AAED;;;;;;;;;;;;AAYA,SAAgB,oBAAoB,CAClC,gBAAyE;AACzE;AACA;AACA;AACA,QAAgD,EAChD,gBAA2D,EAC3D,OAA8B;;IAE9B,MAAM,KAAK,GAAW,EAAE,CAAC;IAEzB,KAAK,MAAM,eAAe,IAAI,mBAAmB,CAAC,gBAAgB,CAAC,EAAE;QACnE,MAAM,WAAW,GAAG,uCAAuC,CAAC,eAAe,CAAC,CAAC;QAE7E,IAAI,WAAW,IAAI,IAAI,EAAE;YACvB,SAAS;SACV;QAED,KAAK,CAAC,IAAI,CAAC;YACT,OAAO,EAAE,WAAW;YACpB,UAAU,EAAE;gBACV,YAAY,QAAE,eAAe,CAAC,eAAe,0CAAE,OAAO,EAAE;aACzD;SACF,CAAC,CAAC;KACJ;IAED,MAAM,IAAI,GAAGxC,qBAAS,EAAE,CAAC,SAAS,CAAC,0BAA0B,EAAE;QAC7D,IAAI,EAAEC,YAAQ,CAAC,QAAQ;QACvB,KAAK;QACL,MAAM,EAAE,aAAa,CAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,cAAc,CAAC;KAC/C,CAAC,CAAC;IAEH,IAAI,CAAC,aAAa,CAAC;QACjB,cAAc,EAAE,sBAAsB;QACtC,yBAAyB,EAAE,QAAQ,CAAC,UAAU;QAC9C,cAAc,EAAE,gBAAgB,CAAC,IAAI;KACtC,CAAC,CAAC;IAEH,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;;;;AAQA,SAAgB,0BAA0B,CACxC,gBAAyE,EACzE,QAAgD,EAChD,gBAA2D,EAC3D,OAA8B;IAE9B,MAAM,IAAI,GAAG,oBAAoB,CAAC,gBAAgB,EAAE,QAAQ,EAAE,gBAAgB,EAAE,OAAO,CAAC,CAAC;IACzF,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,EAAEC,iBAAa,CAAC,EAAE,EAAE,CAAC,CAAC;IAC3C,IAAI,CAAC,GAAG,EAAE,CAAC;AACb,CAAC;;AC1JD;AACA,AAuBA;;;;;;;;AAQA,MAAa,gBAAiB,SAAQ,eAAe;;;;;;;;IAQnD,YAAY,OAA0B,EAAE,UAAkB,EAAE,OAAuB;QACjF,KAAK,CAAC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;QAEhD,IAAI,CAAC,qBAAqB,GAAG,IAAI,oBAAoB,CACnD,OAAO,EACP,UAAU,EACV,CAAO,WAA6B;YAClC,IAAI,SAAwC,CAAC;YAE7C,MAAM,WAAW,GAAG,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE;gBACrD,OAAO,EAAE,CAAC,OAAO;;oBACf,SAAS,SAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,0CAAE,KAAK,CAAC;iBACtC;gBACD,cAAc,EAAE,CAAC,OAAO;;oBACtB,SAAS,SAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,OAAO,0CAAE,KAAK,CAAC;iBACrC;;gBAED,OAAO,EAAE,4DAAc,CAAA;gBACvB,cAAc,EAAE,4DAAc,CAAA;;gBAE9B,SAAS,EAAE,4DAAc,CAAA;aAC1B,CAAC,CAAC;YAEH,MAAM,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;YAE3C,IAAI,SAAS,IAAI,IAAI,EAAE;gBACrB,MAAM,SAAS,CAAC;aACjB;YAED,OAAO,IAAI,CAAC,IAAI,CAAC;SAClB,CAAA,EACD,IAAI,CAAC,WAAW,CACjB,CAAC;KACH;IAID,IAAI,mBAAmB;QACrB,OAAO,IAAI,CAAC,qBAAqB,CAAC,mBAAmB,CAAC;KACvD;;;;;;IAOK,UAAU,CAAC,eAAmC;;YAClD,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC;YAEvB,IAAI,eAAe,IAAI,IAAI,EAAE;gBAC3B,eAAe,GAAG,IAAI,KAAK,CACzB,yEAAyE,CAC1E,CAAC;aACH;YAED,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;SACnD;KAAA;;;;;;;;;;;IAYK,OAAO,CACX,eAAuB,EACvB,eAAuB,EACvB,4BAAoC,EACpC,OAA6B;;YAE7B,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAE5C,IAAI;gBACF1C,cAAM,CAAC,OAAO,CACZ,wDAAwD,EACxD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,CACV,CAAC;gBAEF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,qBAAqB,CAAC,eAAe,iBAC/D,eAAe;oBACf,eAAe;oBACf,4BAA4B,IACzB,OAAO,EACV,CAAC;gBAEH,IAAI,IAAI,CAAC,YAAY,EAAE;oBACrB,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;wBAC9B,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,MAAM;;;yBAG7C,CAAC,CAAC;qBACJ;iBACF;gBAED,OAAO,QAAQ,CAAC;aACjB;YAAC,OAAO,KAAK,EAAE;gBACdA,cAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,kCAAkC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC3E,MAAM,KAAK,CAAC;aACb;SACF;KAAA;IAED,OAAO,MAAM,CACX,OAA0B,EAC1B,UAAkB,EAClB,OAAuB;QAEvB,4BAA4B,CAAC,OAAO,CAAC,CAAC;QACtC,MAAM,SAAS,GAAG,IAAI,gBAAgB,CAAC,OAAO,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;QACrE,OAAO,CAAC,gBAAgB,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC;QACrD,OAAO,SAAS,CAAC;KAClB;CACF;AAED;;;;;;;;;;;AAWA,SAAgB,0BAA0B,CACxC,eAAuB,EACvB,4BAAoC;IAEpC,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IAE/B,OAAO;QACL,MAAM,eAAe,GAAG,eAAe,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,WAAW,CAAC,CAAC;QAErE,IAAI,eAAe,GAAG,CAAC,EAAE;YACvB,OAAO,CAAC,CAAC;SACV;QAED,OAAO,IAAI,CAAC,GAAG,CAAC,eAAe,EAAE,4BAA4B,CAAC,CAAC;KAChE,CAAC;AACJ,CAAC;AA2CD;;;;;;;;;AASA,MAAa,oBAAoB;IAM/B,YACU,kBAAqC,EACtC,UAAkB,EACjB,mBAEiC,EACjC,YAAyB;QALzB,uBAAkB,GAAlB,kBAAkB,CAAmB;QACtC,eAAU,GAAV,UAAU,CAAQ;QACjB,wBAAmB,GAAnB,mBAAmB,CAEc;QACjC,iBAAY,GAAZ,YAAY,CAAa;QAEjC,IAAI,CAAC,2BAA2B,GAAG,0BAA0B,CAAC;QAE9D,IAAI,CAAC,wBAAwB,GAAG,CAAC,OAA2B;YAC1D,OAAO,IAAI,qBAAqB,CAC9B,OAAO,CAAC,OAAQ,EAChB,OAAO,CAAC,QAAS,EACjB,IAAI,EACJ,IAAI,CAAC,YAAY,CAClB,CAAC;SACH,CAAC;QAEF,IAAI,CAAC,2BAA2B,GAAG,CACjC,eAAuB,EACvB,4BAAoC,KACjC,0BAA0B,CAAC,eAAe,EAAE,4BAA4B,CAAC,CAAC;QAE/E,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;KAClC;;;;;;;IAiBY,eAAe,CAAC,IAAwB;;YACnD,IAAI;gBACF,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;gBAChC,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBAElE,IAAI,QAAQ,IAAI,IAAI,EAAE;;oBAEpB,OAAO,EAAE,CAAC;iBACX;gBAED,MAAM,QAAQ,GAAG,MAAM,IAAI,OAAO,CAA0B,CAAC,OAAO,EAAE,MAAM,KAC1E,IAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,CAAC,CAC3D,CAAC;gBACF,IAAI,CAAC,2BAA2B,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;gBACvF,OAAO,QAAQ,CAAC;aACjB;oBAAS;gBACR,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;gBAC/B,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;aAClC;SACF;KAAA;;;;;;IAOD,KAAK,CAAC,eAAmC;QACvC,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC;YACpC,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;SAChC;KACF;IAEO,oBAAoB,CAC1B,QAAyB,EACzB,IAAwB,EACxB,WAAwD,EACxD,UAA4C;QAE5C,MAAM,wBAAwB,GAAG,IAAI,CAAC,2BAA2B,CAC/D,IAAI,CAAC,eAAe,EACpB,IAAI,CAAC,4BAA4B,CAClC,CAAC;QAEF,MAAM,gBAAgB,GAA4B,EAAE,CAAC;QACrD,MAAM,aAAa,GAAG,IAAI,QAAQ,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ,CAAC,IAAI,GAAG,CAAC;QAEvE,IAAI,cAAwC,CAAC;;QAG7C,IAAI,4BAAwC,CAAC;QAE7C,MAAM,MAAM,GAAG,CAAC,GAAsB;YACpC,4BAA4B,EAAE,CAAC;YAC/B,UAAU,CAAC,GAAG,CAAC,CAAC;SACjB,CAAC;QAEF,MAAM,kBAAkB,GAAG,CAAC,MAA+B;YACzD,4BAA4B,EAAE,CAAC;YAC/B,WAAW,CAAC,MAAM,CAAC,CAAC;SACrB,CAAC;QAEF,MAAM,mCAAmC,GAAG,CAAC,MAA+B;;;;;;;YAO1E,UAAU,CAAC;gBACT,4BAA4B,EAAE,CAAC;gBAC/B,WAAW,CAAC,MAAM,CAAC,CAAC;aACrB,CAAC,CAAC;SACJ,CAAC;QAEF,MAAM,OAAO,GAAgB,CAAC,OAAqB;;YACjD,MAAM,SAAS,GAAG,OAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,KAAI,IAAI,GAAG,eAAe,GAAG,gBAAgB,CAAC;YACtF,IAAI,KAAK,GAAG,OAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,YAAI,OAAO,CAAC,QAAQ,0CAAE,KAAK,CAAA,CAAC;YAE9D,IAAI,KAAK,EAAE;gBACT,KAAK,GAAG,wBAAwB,CAAC,KAAK,CAAC,CAAC;gBACxCA,cAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,aAAa,KAAK,SAAS,qCAAqC,CAAC,CAAC;aAC7F;iBAAM;gBACL,KAAK,GAAG,IAAI,eAAe,CAAC,6CAA6C,EAAE,cAAc,CAAC,CAAC;aAC5F;YACD,MAAM,CAAC,KAAK,CAAC,CAAC;SACf,CAAC;QAEF,IAAI,CAAC,aAAa,GAAG,CAAC,KAAyB;YAC7C;;YAEE,KAAK,IAAI,IAAI;;iBAEZ,IAAI,CAAC,YAAY,KAAK,kBAAkB,IAAI,gBAAgB,CAAC,MAAM,CAAC,EACrE;gBACAA,cAAM,CAAC,OAAO,CACZ,GAAG,aAAa,4BAA4B,gBAAgB,CAAC,MAAM,YAAY,CAChF,CAAC;gBAEF,OAAO,mCAAmC,CAAC,gBAAgB,CAAC,CAAC;aAC9D;YAED,MAAM,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC,CAAC;SACzC,CAAC;QAEF,IAAI,0BAA0B,GAA6B,SAAS,CAAC;;;;;QAMrE,MAAM,WAAW,GAAG;;YAElB,IAAI,QAAQ,CAAC,MAAM,EAAE,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC5CA,cAAM,CAAC,OAAO,CAAC,GAAG,aAAa,8BAA8B,QAAQ,CAAC,MAAM,IAAI,CAAC,CAAC;;;;gBAKlF,QAAQ,CAAC,KAAK,GAAG,IAAI,CAAC;gBACtB,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;aACvB;iBAAM;gBACLA,cAAM,CAAC,OAAO,CACZ,GAAG,aAAa,qCAAqC,gBAAgB,CAAC,MAAM,YAAY,CACzF,CAAC;;;gBAIF,kBAAkB,CAAC,gBAAgB,CAAC,CAAC;aACtC;SACF,CAAC;;QAGF,MAAM,gBAAgB,GAAyB,CAAO,OAAqB;;;;YAIzE,IAAI,IAAI,CAAC,YAAY,KAAK,UAAU,EAAE;gBACpC,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC,EAAE;;;;;;;oBAOjC,IAAI,cAAc;wBAAE,YAAY,CAAC,cAAc,CAAC,CAAC;oBACjD,MAAM,qBAAqB,GAAG,wBAAwB,EAAE,CAAC;oBACzD,cAAc,GAAG,UAAU,CAAC;wBAC1BA,cAAM,CAAC,OAAO,CACZ,GAAG,aAAa,yBAAyB,qBAAqB,kDAAkD,CACjH,CAAC;wBACF,WAAW,EAAE,CAAC;qBACf,EAAE,qBAAqB,CAAC,CAAC;iBAC3B;aACF;YAED,IAAI;gBACF,MAAM,IAAI,GAA0B,IAAI,CAAC,wBAAwB,CAAC,OAAO,CAAC,CAAC;gBAC3E,IAAI,gBAAgB,CAAC,MAAM,GAAG,IAAI,CAAC,eAAe,EAAE;oBAClD,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC7B;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,MAAM,GAAG,GAAG,YAAY,KAAK,GAAG,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC3EA,cAAM,CAAC,QAAQ,CACb,GAAG,EACH,GAAG,aAAa,sEAAsE,CACvF,CAAC;gBACF,MAAM,CAAC,MAAM,CAAC,CAAC;aAChB;YACD,IAAI,gBAAgB,CAAC,MAAM,KAAK,IAAI,CAAC,eAAe,EAAE;gBACpD,WAAW,EAAE,CAAC;aACf;SACF,CAAA,CAAC;QAEF,MAAM,OAAO,GAAyB,CAAO,OAAqB;;YAChE,MAAM,IAAI,GAAG,OAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,KAAI,IAAI,GAAG,gBAAgB,GAAG,iBAAiB,CAAC;YACnF,MAAM,KAAK,GAAG,OAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,YAAI,OAAO,CAAC,QAAQ,0CAAE,KAAK,CAAA,CAAC;YAEhE,IAAI,KAAK,EAAE;gBACTA,cAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,aAAa,KAAK,IAAI,wCAAwC,CAAC,CAAC;aAC3F;SACF,CAAA,CAAC;;QAGF,MAAM,cAAc,GAAgB;YAClC,QAAQ,CAAC,cAAc,CAACiE,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;YACxE,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAC;YAEvBjE,cAAM,CAAC,OAAO,CACZ,GAAG,aAAa,8CAA8C,gBAAgB,CAAC,MAAM,YAAY,CAClG,CAAC;YAEF,mCAAmC,CAAC,gBAAgB,CAAC,CAAC;SACvD,CAAC;QAEF,4BAA4B,GAAG;YAC7B,IAAI,QAAQ,IAAI,IAAI,EAAE;gBACpB,QAAQ,CAAC,cAAc,CAACiE,0BAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;gBAC/D,QAAQ,CAAC,cAAc,CAACA,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;gBAClE,QAAQ,CAAC,OAAO,CAAC,cAAc,CAACgB,yBAAa,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;gBACrE,QAAQ,CAAC,cAAc,CAAChB,0BAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;gBAC/D,QAAQ,CAAC,OAAO,CAAC,cAAc,CAACgB,yBAAa,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;gBACrE,QAAQ,CAAC,cAAc,CAAChB,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;aACzE;YAED,IAAI,cAAc,EAAE;gBAClB,YAAY,CAAC,cAAc,CAAC,CAAC;aAC9B;YAED,IAAI,0BAA0B,EAAE;gBAC9B,0BAA0B,EAAE,CAAC;aAC9B;YACD,0BAA0B,GAAG,SAAS,CAAC;SACxC,CAAC;QAEF,0BAA0B,GAAG,+BAA+B,CAAC,CAAC,GAAG;YAC/D,MAAM,CAAC,GAAG,CAAC,CAAC;SACb,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;QAErBjE,cAAM,CAAC,OAAO,CACZ,GAAG,aAAa,gCAAgC,IAAI,CAAC,eAAe,YAAY,CACjF,CAAC;;;;;QAMF,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAEzCA,cAAM,CAAC,OAAO,CACZ,GAAG,aAAa,+BAA+B,IAAI,CAAC,eAAe,gBAAgB,CACpF,CAAC;QAEF,cAAc,GAAG,UAAU,CAAC;YAC1BA,cAAM,CAAC,OAAO,CACZ,GAAG,aAAa,uCAAuC,IAAI,CAAC,eAAe,gBAAgB,CAC5F,CAAC;YACF,WAAW,EAAE,CAAC;SACf,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;QAEzB,QAAQ,CAAC,EAAE,CAACiE,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;QACtD,QAAQ,CAAC,EAAE,CAACA,0BAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;QACnD,QAAQ,CAAC,EAAE,CAACA,0BAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;QACnD,QAAQ,CAAC,EAAE,CAACA,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;QAE5D,QAAQ,CAAC,OAAO,CAAC,EAAE,CAACgB,yBAAa,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;QACzD,QAAQ,CAAC,OAAO,CAAC,EAAE,CAACA,yBAAa,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;KAC1D;CACF;;ACphBD;AACA,AAyBA;;;;;;AAMA,MAAa,WAAW;IAatB,YACU,QAAwD,EACxD,yBAAiC;QADjC,aAAQ,GAAR,QAAQ,CAAgD;QACxD,8BAAyB,GAAzB,yBAAyB,CAAQ;;;;;QAVnC,4BAAuB,GAAuD,IAAI,GAAG,EAG1F,CAAC;QASF,IAAI,CAAC,4BAA4B,GAAG,2BAA2B,CAAC;KACjE;;;;;;;;;;IAWD,OAAO,MAAM,CACX,OAAuD,EACvD,4BAAoC,EACpC,WAA4C;QAE5C,IAAI,WAAW,KAAK,UAAU,EAAE;YAC9B,OAAO,SAAS,CAAC;SAClB;QAED,IAAI,4BAA4B,IAAI,CAAC,EAAE;YACrC,OAAO,SAAS,CAAC;SAClB;QAED,OAAO,IAAI,WAAW,CAAC,OAAO,EAAE,4BAA4B,CAAC,CAAC;KAC/D;;;;IAKD,OAAO,CAAC,UAAuB;QAC7BjF,cAAM,CAAC,OAAO,CACZ,GAAG,UAAU,CAAC,SAAS,kEAAkE,CAC1F,CAAC;QAEF,MAAM,eAAe,GAAG,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAE1E,IAAI,eAAe,IAAI,IAAI,EAAE;YAC3B,OAAO;SACR;QAED,KAAK,MAAM,SAAS,IAAI,eAAe,CAAC,IAAI,EAAE,EAAE;YAC9C,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,eAAe,EAAE,SAAS,CAAC,CAAC;SACjE;QAED,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;KACtD;;;;;;IAOD,IAAI,CAAC,UAAuB,EAAE,QAAoC;QAChE,MAAM,SAAS,GAAG,QAAQ,CAAC,SAAmB,CAAC;QAE/C,MAAM,eAAe,GAAG,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAE1E,IAAI,eAAe,IAAI,IAAI,EAAE;YAC3B,OAAO;SACR;QAED,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,eAAe,EAAE,SAAS,CAAC,CAAC;KACjE;;;;;;IAOD,KAAK,CAAC,UAAuB,EAAE,QAAoC,EAAE,OAAyB;QAC5F,IAAI;YACF,MAAM,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;YAEvC,IAAI,QAAQ,CAAC,SAAS,IAAI,IAAI,EAAE;gBAC9B,MAAM,IAAI,KAAK,CACb,8DAA8D,QAAQ,CAAC,SAAS,wCAAwC,CACzH,CAAC;aACH;YAED,MAAM,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC;YACrC,MAAM,cAAc,GAAG,IAAI,CAAC,sBAAsB,CAAC,UAAU,CAAC,CAAC;;;;;;;;;YAS/D,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAmB,EAAE,SAAS,CAAC,CAAC;YAE5DA,cAAM,CAAC,OAAO,CACZ,GAAG,SAAS,qBACV,QAAQ,CAAC,SACX,qBAAqB,QAAQ,CAAC,cAAe,CAAC,QAAQ,EAAE,GAAG,CAC5D,CAAC;YACF,MAAM,0BAA0B,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,yBAAyB,CAAC;YAC/EA,cAAM,CAAC,OAAO,CACZ,GAAG,SAAS,sDACV,QAAQ,CAAC,SACX,SAAS,IAAI,IAAI,CAAC,0BAA0B,CAAC,CAAC,QAAQ,EAAE,EAAE,CAC3D,CAAC;YAEF,MAAM,iBAAiB,GAAG;gBACxB,MAAM,2BAA2B;;;gBAG/B,IAAI,IAAI,CAAC,0BAA0B,CAAC,GAAG,QAAQ,CAAC,cAAe,CAAC;;gBAGlE,MAAM,gCAAgC,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,0BAA0B,CAAC;gBAEjF,IAAI,2BAA2B,IAAI,gCAAgC,EAAE;oBACnE,IAAI,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAmB,CAAC,EAAE;;;;;wBAKpD,MAAM,MAAM,GAAG,IAAI,CAAC,4BAA4B,CAAC,QAAQ,CAAC,cAAe,CAAC,CAAC;wBAE3EA,cAAM,CAAC,OAAO,CACZ,GAAG,SAAS,iBAAiB,MAAM,8DAA8D,QAAQ,CAAC,SAAS,GAAG,CACvH,CAAC;;;;wBAIF,MAAM,cAAc,GAAG,UAAU,CAAC;4BAChC,IAAI;gCACFA,cAAM,CAAC,OAAO,CACZ,GAAG,SAAS,sDAAsD,QAAQ,CAAC,SAAS,IAAI,CACzF,CAAC;gCAEF,QAAQ,CAAC,cAAc,GAAG,MAAM,IAAI,CAAC,QAAQ;qCAC1C,mBAAmB,CAAC,UAAU,CAAC,UAAU,CAAC;qCAC1C,SAAS,CAAC,SAAS,EAAE;oCACpB,kBAAkB,EAAE,UAAU,CAAC,IAAI;iCACpC,CAAC,CAAC;gCACLA,cAAM,CAAC,OAAO,CACZ,GAAG,SAAS,uDAAuD,QAAQ,CAAC,SAAS,qDAAqD,CAC3I,CAAC;gCAEF,iBAAiB,EAAE,CAAC;6BACrB;4BAAC,OAAO,GAAG,EAAE;gCACZA,cAAM,CAAC,QAAQ,CACb,GAAG,EACH,GAAG,SAAS,4DAA4D,QAAQ,CAAC,SAAS,0BAA0B,QAAQ,CAAC,SAAS,GAAG,CAC1I,CAAC;gCACF,OAAO,CAAC,GAAG,CAAC,CAAC;6BACd;yBACF,CAAA,EAAE,MAAM,CAAC,CAAC;;wBAGX,IAAI,OAAO,cAAc,CAAC,KAAK,KAAK,UAAU,EAAE;4BAC9C,cAAc,CAAC,KAAK,EAAE,CAAC;yBACxB;wBAED,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAmB,EAAE,cAAc,CAAC,CAAC;qBAClE;yBAAM;wBACLA,cAAM,CAAC,OAAO,CACZ,GAAG,SAAS,0FAA0F,QAAQ,CAAC,SAAS,IAAI,CAC7H,CAAC;qBACH;iBACF;qBAAM;oBACLA,cAAM,CAAC,OAAO,CACZ,GAAG,SAAS,iBAAiB,IAAI,IAAI,EAAE,6CAA6C,IAAI,IAAI,CAC1F,0BAA0B,CAC3B,gCACC,QAAQ,CAAC,SACX,8CAA8C,CAC/C,CAAC;oBAEF,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;iBACjC;aACF,CAAC;;YAGF,iBAAiB,EAAE,CAAC;SACrB;QAAC,OAAO,GAAG,EAAE;YACZ,OAAO,CAAC,GAAG,CAAC,CAAC;SACd;KACF;IAEO,sBAAsB,CAAC,UAAuB;QACpD,IAAI,CAAC,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;YACtD,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAC9B,UAAU,CAAC,IAAI,EACf,IAAI,GAAG,EAAoC,CAC5C,CAAC;SACH;QAED,OAAO,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAE,CAAC;KAC3D;IAEO,kBAAkB,CACxB,UAAuB,EACvB,cAAqD,EACrD,SAA6B;QAE7B,IAAI,SAAS,IAAI,IAAI,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;SACrE;;;QAID,IAAI,cAAc,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;YACjC,YAAY,CAAC,cAAc,CAAC,GAAG,CAAC,SAAS,CAAiB,CAAC,CAAC;YAC5DA,cAAM,CAAC,OAAO,CACZ,GAAG,UAAU,CAAC,SAAS,8DAA8D,SAAS,IAAI,CACnG,CAAC;YACF,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;SAClC;KACF;CACF;;ACvQD;AACA,AA6QA;;;;AAIA,MAAa,sBAAsB;;;;IA2BjC,YACU,QAA2B,EAC5B,UAAkB,EAClB,WAA4C,EACnD,4BAAoC,EACpC,eAA6B,EAAE;QAJvB,aAAQ,GAAR,QAAQ,CAAmB;QAC5B,eAAU,GAAV,UAAU,CAAQ;QAClB,gBAAW,GAAX,WAAW,CAAiC;;;;QAzB7C,cAAS,GAAY,KAAK,CAAC;QA6BjC,4BAA4B,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;QAClC,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC,MAAM,CACpC,IAAI,CAAC,QAAQ,EACb,4BAA4B,EAC5B,WAAW,CACZ,CAAC;QACF,IAAI,CAAC,qBAAqB,GAAG,oBAAoB,CAAC;KACnD;IAtBD,IAAY,SAAS;QACnB,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,aAAa,IAAI,CAAC,UAAU,GAAG,CAAC;KACtE;IAsBO,wBAAwB;QAC9B,IAAI,IAAI,CAAC,oBAAoB,EAAE,EAAE;YAC/B,MAAM,YAAY,GAAG,2BAA2B,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAClE,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtCA,cAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,SAAS,uBAAuB,CAAC,CAAC;YACjE,MAAM,KAAK,CAAC;SACb;KACF;IAEO,kCAAkC;QACxC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC5C,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,YAAY,GAAG,yBAAyB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAChE,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtCA,cAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,SAAS,YAAY,CAAC,CAAC;YACtD,MAAM,KAAK,CAAC;SACb;KACF;IAED,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC;KACjE;;;;;;;;;;;;;;;;;;;;;;IAuBO,uBAAuB,CAC7B,YAAiC,EACjC,SAAoB,EACpB,OAAgB,EAChB,OAAyB;QAEzB,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;QAC1C,gCAAgC,CAAC,MAAM,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;QACjE,gCAAgC,CAAC,MAAM,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;QAC7D,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE;YACnC,MAAM,IAAI,SAAS,CAAC,uDAAuD,CAAC,CAAC;SAC9E;QACD,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;YACjC,MAAM,IAAI,SAAS,CAAC,qDAAqD,CAAC,CAAC;SAC5E;QAED,IAAI,CAAC,wBAAwB,iCACxB,OAAO,KACV,WAAW,EAAE,IAAI,CAAC,WAAW,EAC7B,YAAY,EAAE,IAAI,CAAC,aAAa,EAChC,WAAW,EAAE,IAAI,CAAC,YAAY,EAC9B,OAAO,IACP;aACC,IAAI,CAAC,CAAO,SAAS;YACpB,IAAI,CAAC,SAAS,EAAE;gBACd,OAAO;aACR;YACD,IAAI,CAAC,kBAAkB,GAAG,SAAS,CAAC;YAEpC,IAAI;gBACF,MAAM,YAAY,EAAE,CAAC;aACtB;YAAC,OAAO,GAAG,EAAE;gBACZ,OAAO,CAAC;oBACN,KAAK,EAAE,GAAG;oBACV,WAAW,EAAE,SAAS;oBACtB,UAAU,EAAE,IAAI,CAAC,UAAU;oBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;iBACnD,CAAC,CAAC;aACJ;YAED,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAClB,SAAS,CAAC,SAAS,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;aACzC;iBAAM;gBACL,MAAM,SAAS,CAAC,KAAK,EAAE,CAAC;aACzB;YACD,OAAO;SACR,CAAA,CAAC;aACD,KAAK,CAAC,CAAC,GAAG;;;YAGT,OAAO,CAAC;gBACN,KAAK,EAAE,GAAG;gBACV,WAAW,EAAE,SAAS;gBACtB,UAAU,EAAE,IAAI,CAAC,UAAU;gBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;aACnD,CAAC,CAAC;SACJ,CAAC,CAAC;KACN;IAEa,wBAAwB,CACpC,OAAkC;;;YAElC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI,OAAO,CAAC,oBAAoB,IAAI,IAAI;gBAAE,OAAO,CAAC,oBAAoB,GAAG,IAAI,CAAC;;;;;;;;;;YAW9E,IAAI,CAAC,kBAAkB,SACrB,IAAI,CAAC,kBAAkB,mCAAI,IAAI,iBAAiB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;;;;YAK5F,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,kBAAkB,CAAC;YAEvF,MAAM,IAAI,CAAC,kBAAkB,CAAC,IAAI,iBAChC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,EACxC,UAAU,EAAE,KAAK,IACd,OAAO,EACV,CAAC;YAEH,OAAO,IAAI,CAAC,kBAAkB,CAAC;;KAChC;IAEK,eAAe,CACnB,eAAuB,EACvB,OAAgC;;YAEhC,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAChC,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;YACF,qCAAqC,CACnC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,EACf,QAAQ,CACT,CAAC;YAEF,IAAI,KAAK,CAAC,eAAe,CAAC,IAAI,eAAe,GAAG,CAAC,EAAE;gBACjD,MAAM,IAAI,SAAS,CAAC,2BAA2B,CAAC,CAAC;aAClD;YAED,MAAM,eAAe,GAAG;;gBACtB,IAAI,CAAC,IAAI,CAAC,iBAAiB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE;oBAC3F,MAAM,OAAO,GAAmB;wBAC9B,kBAAkB,EAAE,CAAC;wBACrB,WAAW,EAAE,IAAI,CAAC,WAAW;wBAC7B,WAAW,EAAE,IAAI,CAAC,YAAY;qBAC/B,CAAC;oBACF,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,uBAAuB,CACnD,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,UAAU,EACf,OAAO,CACR,CAAC;iBACH;gBAED,MAAM,gBAAgB,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAC3D,eAAe,QACf,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,mCAAIwD,kBAAS,CAAC,2BAA2B,EACjE,4CAA4C,EAC5C,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,CACd,CAAC;gBAEF,OAAO,gBAAgB,CAAC;aACzB,CAAA,CAAC;YACF,MAAM,MAAM,GAA6C;gBACvD,cAAc,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;gBACzC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,SAAS,EAAE,eAAe;gBAC1B,aAAa,EAAEsB,2BAAkB,CAAC,cAAc;gBAChD,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;gBACjC,YAAY,EAAE,IAAI,CAAC,aAAa;aACjC,CAAC;YACF,OAAOD,cAAK,CAA8B,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG;gBAC1D,MAAM,wBAAwB,CAAC,GAAG,CAAC,CAAC;aACrC,CAAC,CAAC;SACJ;KAAA;IAED,kBAAkB,CAChB,OAAmC;QAEnC,OAAO,kBAAkB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAC1C;IAEK,uBAAuB,CAC3B,eAA8B,EAC9B,UAAgC,EAAE;;YAElC,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;YACF,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;YAEF,MAAM,uBAAuB,GAAG,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC;kBAC1D,eAAe;kBACf,CAAC,eAAe,CAAC,CAAC;YACtB,MAAM,uCAAuC,GAAG;gBAC9C,MAAM,gBAAgB,GAAG,MAAM,IAAI,CAAC,QAAQ;qBACzC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;qBACpC,uBAAuB,CAAC,uBAAuB,EAAE,IAAI,CAAC,WAAW,EAAE,SAAS,kCACxE,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,0BAA0B,EAAE,EACrD,WAAW,EAAE,yBAAyB,EACtC,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;gBACL,OAAO,gBAAgB,CAAC;aACzB,CAAA,CAAC;YACF,MAAM,MAAM,GAA6C;gBACvD,SAAS,EAAE,uCAAuC;gBAClD,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAEC,2BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAOD,cAAK,CAA8B,MAAM,CAAC,CAAC;SACnD;KAAA;;IAIK,YAAY,CAChB,eAAuB,EACvB,UAA+B,EAAE;;;YAEjC,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAE1C,MAAM,wBAAwB,mCACzB,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,0BAA0B,EAAE,EACrD,WAAW,EAAE,cAAc,EAC3B,WAAW,QAAE,IAAI,CAAC,aAAa,0CAAE,WAAW,GAC7C,CAAC;YACF,MAAM,oBAAoB,GAAG;gBAC3B,IAAI,OAAO,CAAC,kBAAkB,EAAE;oBAC9B,OAAO,MAAM,IAAI,CAAC,QAAQ;yBACvB,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;yBACpC,oBAAoB,CACnB,OAAO,CAAC,kBAAkB,EAC1B,eAAe,EACf,SAAS,EACT,wBAAwB,CACzB,CAAC;iBACL;qBAAM;oBACL,OAAO,MAAM,IAAI,CAAC,QAAQ;yBACvB,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;yBACpC,IAAI,CAAC,eAAe,EAAE,wBAAwB,CAAC,CAAC;iBACpD;aACF,CAAA,CAAC;YAEF,MAAM,MAAM,GAA6C;gBACvD,SAAS,EAAE,oBAAoB;gBAC/B,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAEC,2BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAOD,cAAK,CAA8B,MAAM,CAAC,CAAC;;KACnD;IAED,SAAS,CACP,QAAyB,EACzB,OAA0B;QAI1B,0BAA0B,CAAC,QAAQ,CAAC,CAAC;QACrC,OAAO,GAAG,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,CAAC;QAExB,MAAM,YAAY,GAAG,uBAAuB,CAAC,QAAQ,CAAC,CAAC;QAEvD,MAAM,uBAAuB,GAAG,QAAmC,CAAC;QAEpE,IAAI,CAAC,uBAAuB,CAC1B;YACE,IAAI,uBAAuB,aAAvB,uBAAuB,uBAAvB,uBAAuB,CAAE,iBAAiB,EAAE;gBAC9C,MAAM,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;aACnD;SACF,CAAA,EACD,CAAO,OAA8B;YACnC,MAAM,IAAI,GAAG,IAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YACtF,OAAO,KAAK,CAAC,MAAM,QAAQ,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC;SAC5D,CAAA,EACD,YAAY,EACZ,OAAO,CACR,CAAC;QAEF,OAAO;YACL,KAAK,EAAE;;gBACL,aAAO,IAAI,CAAC,kBAAkB,0CAAE,qBAAqB,GAAG;aACzD,CAAA;SACF,CAAC;KACH;IAEK,eAAe,CAAC,OAAkC;;YACtD,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,qCAAqC,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;YACjD,OAAO,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;SACjE;KAAA;IAEK,cAAc,CAClB,OAAkC,EAClC,kBAA2C;;YAE3C,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,qCAAqC,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;YACjD,OAAO,cAAc,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAE,kBAAkB,CAAC,CAAC;SACpF;KAAA;IAEK,YAAY,CAChB,OAAkC,EAClC,kBAA2C;;YAE3C,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,qCAAqC,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;YACjD,OAAO,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAE,kBAAkB,CAAC,CAAC;SAClF;KAAA;IAEK,iBAAiB,CACrB,OAAkC,EAClC,OAAoD;;YAEpD,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,qCAAqC,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;YACjD,OAAO,iBAAiB,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;SAC5E;KAAA;IAEK,gBAAgB,CAAC,OAAkC;;YACvD,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,qCAAqC,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAE7F,MAAM,OAAO,GAAG,OAAgC,CAAC;YAEjD,IAAI,kBAAsC,CAAC;YAC3C,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,EAAE;gBACzB,MAAM,kBAAkB,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC1F,kBAAkB,GAAG,kBAAkB,aAAlB,kBAAkB,uBAAlB,kBAAkB,CAAE,IAAI,CAAC;aAC/C;YACD,OAAO,IAAI,CAAC,QAAQ;iBACjB,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;iBACpC,SAAS,CAAC,OAAO,CAAC,SAAU,EAAE,EAAE,kBAAkB,EAAE,CAAC;iBACrD,IAAI,CAAC,CAAC,WAAW;gBAChB,OAAO,CAAC,cAAc,GAAG,WAAW,CAAC;gBACrC,OAAO,WAAW,CAAC;aACpB,CAAC,CAAC;SACN;KAAA;IAEK,KAAK;;YACT,IAAI;gBACF,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;gBACtB,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE;;oBAEjE,IAAI,IAAI,CAAC,kBAAkB,EAAE;wBAC3B,MAAM,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;qBACvC;;oBAGD,IAAI,IAAI,CAAC,iBAAiB,EAAE;wBAC1B,MAAM,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,CAAC;qBACtC;iBACF;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ7E,cAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,SAAS,+CAA+C,CAAC,CAAC;gBACvF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;IAMO,oBAAoB;QAC1B,IACE,IAAI,CAAC,kBAAkB;YACvB,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE;YAChC,IAAI,CAAC,kBAAkB,CAAC,mBAAmB,EAC3C;YACA,OAAO,IAAI,CAAC;SACb;QACD,IACE,IAAI,CAAC,iBAAiB;YACtB,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE;YAC/B,IAAI,CAAC,iBAAiB,CAAC,mBAAmB,EAC1C;YACA,OAAO,IAAI,CAAC;SACb;QACD,OAAO,KAAK,CAAC;KACd;IAEO,uBAAuB,CAC7B,OAA0B,EAC1B,UAAkB,EAClB,OAAuB;QAEvB,OAAO,gBAAgB,CAAC,MAAM,CAAC,OAAO,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;KAC9D;;;;;IAMO,0BAA0B;QAChC,IAAI,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,EAAE;YAC/D,OAAO,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;SACrC;QACD,IACE,IAAI,CAAC,iBAAiB;YACtB,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE;YAC/B,IAAI,CAAC,iBAAiB,CAAC,mBAAmB,EAC1C;YACA,OAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC;SACpC;QACD,OAAO;KACR;CACF;AAED;;;;;;;;;AASA,AAAO,MAAM,4CAA4C,GAAG,IAAI,CAAC;;ACjwBjE;AACA,AA8GA;;;;AAIA,MAAa,6BAA6B;;;;;;IAmBxC,YACU,eAA+B,EAC/B,QAA2B,EAC5B,UAAkB,EAClB,WAA4C,EAC3C,gBAA8B,EAAE;QAJhC,oBAAe,GAAf,eAAe,CAAgB;QAC/B,aAAQ,GAAR,QAAQ,CAAmB;QAC5B,eAAU,GAAV,UAAU,CAAQ;QAClB,gBAAW,GAAX,WAAW,CAAiC;QAC3C,kBAAa,GAAb,aAAa,CAAmB;;;;QAlBlC,cAAS,GAAY,KAAK,CAAC;QAoBjC,4BAA4B,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC;QAC3C,IAAI,CAAC,qBAAqB,GAAG,oBAAoB,CAAC;KACnD;IAnBD,IAAY,SAAS;QACnB,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,YAAY,IAAI,CAAC,UAAU,GAAG,CAAC;KACrE;IAmBO,kCAAkC;QACxC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC5C,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,IAAI,IAAI,CAAC,SAAS,EAAE;gBAClB,MAAM,YAAY,GAAG,yBAAyB,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBAChF,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;gBACtCA,cAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,SAAS,iBAAiB,CAAC,CAAC;gBAC3D,MAAM,KAAK,CAAC;aACb;YACD,MAAM,SAAS,GAAc;gBAC3B,SAAS,EAAE4E,iCAAwB,CAAC,oBAAoB;gBACxD,WAAW,EAAE,uDAAuD,IAAI,CAAC,SAAS,EAAE;aACrF,CAAC;YACF,MAAM,wBAAwB,CAAC,SAAS,CAAC,CAAC;SAC3C;KACF;IAEO,wBAAwB;QAC9B,IAAI,IAAI,CAAC,oBAAoB,EAAE,EAAE;YAC/B,MAAM,YAAY,GAAG,2BAA2B,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YAClF,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtC5E,cAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,SAAS,wBAAwB,CAAC,CAAC;YAClE,MAAM,KAAK,CAAC;SACb;KACF;IAED,IAAW,QAAQ;QACjB,QACE,IAAI,CAAC,SAAS;YACd,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;YACzD,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,EAC9B;KACH;;;;;;;;;;;;;;IAeD,IAAW,qBAAqB;QAC9B,OAAO,IAAI,CAAC,eAAe,CAAC,qBAAqB,CAAC;KACnD;;;;;;;;;;;;;;;;IAiBK,gBAAgB,CAAC,OAA8B;;YACnD,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,MAAM,gCAAgC,GAAG;gBACvC,IAAI,CAAC,eAAgB,CAAC,qBAAqB,GAAG,MAAM,IAAI,CAAC,QAAQ;qBAC9D,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;qBACpC,gBAAgB,CAAC,IAAI,CAAC,SAAS,kCAC3B,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAC7C,WAAW,EAAE,kBAAkB,EAC/B,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;gBACL,OAAO,IAAI,CAAC,eAAgB,CAAC,qBAAsB,CAAC;aACrD,CAAA,CAAC;YACF,MAAM,MAAM,GAAsB;gBAChC,SAAS,EAAE,gCAAgC;gBAC3C,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAE8E,2BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAOD,cAAK,CAAO,MAAM,CAAC,CAAC;SAC5B;KAAA;;;;;;;;;IAUK,eAAe,CAAC,KAAU,EAAE,UAAgC,EAAE;;YAClE,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAE1C,MAAM,+BAA+B,GAAG;gBACtC,MAAM,IAAI,CAAC,QAAQ;qBAChB,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;qBACpC,eAAe,CAAC,IAAI,CAAC,SAAU,EAAE,KAAK,kCAClC,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAC7C,WAAW,EAAE,UAAU,EACvB,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;gBACL,OAAO;aACR,CAAA,CAAC;YACF,MAAM,MAAM,GAAsB;gBAChC,SAAS,EAAE,+BAA+B;gBAC1C,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAEC,2BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAOD,cAAK,CAAO,MAAM,CAAC,CAAC;SAC5B;KAAA;;;;;;;;;IAUK,eAAe,CAAC,UAAgC,EAAE;;YACtD,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAE1C,MAAM,+BAA+B,GAAG;gBACtC,OAAO,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,SAAS,kCACnF,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAC7C,WAAW,EAAE,UAAU,EACvB,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;aACJ,CAAA,CAAC;YACF,MAAM,MAAM,GAAqB;gBAC/B,SAAS,EAAE,+BAA+B;gBAC1C,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAEC,2BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAOD,cAAK,CAAM,MAAM,CAAC,CAAC;SAC3B;KAAA;IAEK,YAAY,CAChB,eAAuB,EACvB,UAA+B,EAAE;;;YAEjC,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAE1C,MAAM,wBAAwB,mCACzB,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAC7C,WAAW,EAAE,cAAc,EAC3B,WAAW,QAAE,IAAI,CAAC,aAAa,0CAAE,WAAW,GAC7C,CAAC;YACF,MAAM,oBAAoB,GAAG;gBAC3B,IAAI,OAAO,CAAC,kBAAkB,EAAE;oBAC9B,OAAO,MAAM,IAAI,CAAC,QAAQ;yBACvB,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;yBACpC,oBAAoB,CACnB,OAAO,CAAC,kBAAkB,EAC1B,eAAe,EACf,IAAI,CAAC,SAAS,EACd,wBAAwB,CACzB,CAAC;iBACL;qBAAM;oBACL,OAAO,MAAM,IAAI,CAAC,QAAQ;yBACvB,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;yBACpC,qBAAqB,CAAC,IAAI,CAAC,SAAS,EAAE,eAAe,EAAE,wBAAwB,CAAC,CAAC;iBACrF;aACF,CAAA,CAAC;YAEF,MAAM,MAAM,GAA6C;gBACvD,SAAS,EAAE,oBAAoB;gBAC/B,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAEC,2BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAOD,cAAK,CAA8B,MAAM,CAAC,CAAC;;KACnD;IAEK,uBAAuB,CAC3B,eAA8B,EAC9B,UAAgC,EAAE;;YAElC,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;YACF,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;YAEF,MAAM,uBAAuB,GAAG,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC;kBAC1D,eAAe;kBACf,CAAC,eAAe,CAAC,CAAC;YACtB,MAAM,uCAAuC,GAAG;gBAC9C,MAAM,gBAAgB,GAAG,MAAM,IAAI,CAAC,QAAQ;qBACzC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;qBACpC,uBAAuB,CAAC,uBAAuB,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,kCAC7E,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAC7C,WAAW,EAAE,yBAAyB,EACtC,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;gBACL,OAAO,gBAAgB,CAAC;aACzB,CAAA,CAAC;YACF,MAAM,MAAM,GAA6C;gBACvD,SAAS,EAAE,uCAAuC;gBAClD,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAEC,2BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAOD,cAAK,CAA8B,MAAM,CAAC,CAAC;SACnD;KAAA;IAEK,eAAe,CACnB,eAAuB,EACvB,OAAgC;;YAEhC,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAChC,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;YACF,qCAAqC,CACnC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,EACf,QAAQ,CACT,CAAC;YAEF,IAAI,KAAK,CAAC,eAAe,CAAC,IAAI,eAAe,GAAG,CAAC,EAAE;gBACjD,MAAM,IAAI,SAAS,CAAC,2BAA2B,CAAC,CAAC;aAClD;YAED,MAAM,4BAA4B,GAAG;;gBACnC,MAAM,gBAAgB,GAAG,MAAM,IAAI,CAAC,eAAgB,CAAC,eAAe,CAClE,eAAe,QACf,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,mCAAIrB,kBAAS,CAAC,2BAA2B,EACjE,4CAA4C,EAC5C,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,CACd,CAAC;gBAEF,OAAO,gBAAgB,CAAC;aACzB,CAAA,CAAC;YACF,MAAM,MAAM,GAA6C;gBACvD,SAAS,EAAE,4BAA4B;gBACvC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAEsB,2BAAkB,CAAC,cAAc;gBAChD,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAOD,cAAK,CAA8B,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG;gBAC1D,MAAM,wBAAwB,CAAC,GAAG,CAAC,CAAC;aACrC,CAAC,CAAC;SACJ;KAAA;IAED,SAAS,CACP,QAAyB,EACzB,OAA0B;;QAK1B,0BAA0B,CAAC,QAAQ,CAAC,CAAC;QAErC,OAAO,GAAG,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,CAAC;QAExB,MAAM,YAAY,GAAG,uBAAuB,CAAC,QAAQ,CAAC,CAAC;QAEvD,IAAI,CAAC,uBAAuB,CAC1B,CAAO,OAA8B;YACnC,MAAM,IAAI,GAAG,IAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YACtF,OAAO,KAAK,CAAC,MAAM,QAAQ,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC;SAC5D,CAAA,EACD,YAAY,EACZ,OAAO,CACR,CAAC;QAEF,OAAO;YACL,KAAK,EAAE;;gBACL,aAAO,IAAI,CAAC,eAAe,0CAAE,cAAc,CAAC,OAAO,GAAG;aACvD,CAAA;SACF,CAAC;KACH;;;;;;;;;;;;;;;;;;;;;;;IAwBO,uBAAuB,CAC7B,SAAoB,EACpB,OAAgB,EAChB,OAAyB;QAEzB,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;QAC1C,gCAAgC,CAAC,MAAM,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;QACjE,gCAAgC,CAAC,MAAM,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;QAC7D,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE;YACnC,MAAM,IAAI,SAAS,CAAC,uDAAuD,CAAC,CAAC;SAC9E;QACD,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;YACjC,MAAM,IAAI,SAAS,CAAC,qDAAqD,CAAC,CAAC;SAC5E;QAED,IAAI;YACF,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,SAAS,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;SAC7D;QAAC,OAAO,GAAG,EAAE;YACZ,OAAO,CAAC;gBACN,KAAK,EAAE,GAAG;gBACV,WAAW,EAAE,SAAS;gBACtB,UAAU,EAAE,IAAI,CAAC,UAAU;gBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;aACnD,CAAC,CAAC;SACJ;KACF;IAED,kBAAkB,CAChB,OAAmC;QAEnC,OAAO,kBAAkB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAC1C;IAEK,eAAe,CAAC,OAAkC;;YACtD,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,qCAAqC,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;YACjD,OAAO,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;SACjE;KAAA;IAEK,cAAc,CAClB,OAAkC,EAClC,kBAA2C;;YAE3C,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,qCAAqC,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;YACjD,OAAO,cAAc,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAE,kBAAkB,CAAC,CAAC;SACpF;KAAA;IAEK,YAAY,CAChB,OAAkC,EAClC,kBAA2C;;YAE3C,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,qCAAqC,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;YACjD,OAAO,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAE,kBAAkB,CAAC,CAAC;SAClF;KAAA;IAEK,iBAAiB,CACrB,OAAkC,EAClC,OAAoD;;YAEpD,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,qCAAqC,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;YACjD,OAAO,iBAAiB,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;SAC5E;KAAA;IAEK,gBAAgB;;YACpB,MAAM,IAAI,KAAK,CAAC,2EAA2E,CAAC,CAAC;SAC9F;KAAA;IAEK,KAAK;;YACT,IAAI;gBACF,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;aACpC;YAAC,OAAO,GAAG,EAAE;gBACZ7E,cAAM,CAAC,QAAQ,CACb,GAAG,EACH,uEAAuE,EACvE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;oBAAS;gBACR,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;aACvB;SACF;KAAA;;;;;IAMO,oBAAoB;QAC1B,OAAO,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC,mBAAmB,GAAG,KAAK,CAAC;KAChF;CACF;;ACzjBD;AACA,AAMA;;;;AAIA,SAAgB,iBAAiB,CAC/B,UAAsC,EACtC,MAAsD;IAEtD,MAAM,MAAM,GAAGwC,qBAAS,EAAE,CAAC;IAC3B,MAAM,IAAI,GAAG,MAAM,CAAC,SAAS,CAAC,0BAA0B,EAAE;QACxD,IAAI,EAAEC,YAAQ,CAAC,QAAQ;QACvB,MAAM,EAAE,UAAU;KACnB,CAAC,CAAC;IACH,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,sBAAsB,CAAC,CAAC;IAC1D,IAAI,MAAM,EAAE;QACV,IAAI,CAAC,YAAY,CAAC,yBAAyB,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;QAChE,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;KAChD;IACD,OAAO,IAAI,CAAC;AACd,CAAC;;AC1BD;AACA,AAwBA;;;;;AAKA,MAAM,oBAAoB,GAAG,CAAC,CAAC;AAC/B;;;;;AAKA,MAAM,oBAAoB,GAAG,CAAC,CAAC;AAC/B;;;;;AAKA,MAAM,oBAAoB,GAAG,GAAG,CAAC;AA2DjC;;;;;;;AAOA,MAAa,0BAA0B;;;;;;;;IAoBrC,YAAoB,QAA2B,EAAU,eAAuB;QAA5D,aAAQ,GAAR,QAAQ,CAAmB;QAAU,oBAAe,GAAf,eAAe,CAAQ;;;;QAZxE,qBAAgB,GAAa,EAAE,CAAC;;;;QAIhC,kBAAa,GAAkB,EAAE,CAAC;QASxC,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;QACtB,IAAI,CAAC,uBAAuB,GAAG,EAAE,CAAC;KACnC;;;;;IAMD,IAAI,cAAc;QAChB,OAAO,IAAI,CAAC,eAAe,CAAC;KAC7B;;;;;;IAOD,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,YAAY,CAAC;KAC1B;;;;;IAMD,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC;KACrC;;;;;;IAOD,IAAI,oBAAoB;QACtB,OAAO,IAAI,CAAC,aAAa,CAAC;KAC3B;;;;;;;;;;;;IAaO,cAAc,CACpB,eAAyB,EACzB,WAAgC,EAChC,qBAA8C,EAC9C,iBAA6C;QAE7C,MAAM,aAAa,GAAgB;YACjC,IAAI,EAAE0B,mBAAe,CAAC,aAAa,CAAC,eAAe,CAAC;YACpD,mBAAmB,EAAE,WAAW;YAChC,sBAAsB,EAAE,qBAAqB;SAC9C,CAAC;QACF,IAAI,iBAAiB,EAAE;YACrB,KAAK,MAAM,IAAI,IAAIe,6BAAyB,EAAE;gBAC5C,IAAK,iBAAyB,CAAC,IAAI,CAAC,EAAE;oBACnC,aAAqB,CAAC,IAAI,CAAC,GAAI,iBAAyB,CAAC,IAAI,CAAC,CAAC;iBACjE;aACF;SACF;QACD,OAAOf,mBAAe,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;KAC9C;;;;;;;;;;;IAYD,gBAAgB;QACd,OAAO,IAAI,CAAC,cAAc,CACxB,IAAI,CAAC,gBAAgB,EACrB,IAAI,CAAC,iBAAiB,EACtB,IAAI,CAAC,2BAA2B,EAChC,IAAI,CAAC,uBAAuB,CAC7B,CAAC;KACH;;;;;;;;;IA6BM,aAAa,CAAC,OAA0B,EAAE,UAAyB,EAAE;QAC1E,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;QACjF,gCAAgC,CAC9B,OAAO,EACP,iEAAiE,CAClE,CAAC;;QAGF,MAAM,sBAAsB,GAAG,OAAO,CACpC,OAAO,CAAC,qBAAqB,IAAI,OAAO,CAAC,qBAAqB,CAAC,oBAAoB,CAAC,CACrF,CAAC;QACF,IAAI,WAAoC,CAAC;QACzC,IAAI,CAAC,sBAAsB,EAAE;YAC3B,MAAM,WAAW,GAAG,iBAAiB,CAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,UAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YACjF,OAAO,GAAG,2BAA2B,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YAC5D,WAAW,GAAG,WAAW,CAAC,OAAO,EAAE,CAAC;YACpC,WAAW,CAAC,GAAG,EAAE,CAAC;SACnB;;QAGD,MAAM,WAAW,GAAG,aAAa,CAAC,OAAO,CAAC,CAAC;QAC3C,WAAW,CAAC,IAAI,GAAG,sBAAsB,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAE/D,IAAI,cAAsB,CAAC;QAC3B,IAAI;YACF,cAAc,GAAGA,mBAAe,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;SACtD;QAAC,OAAO,KAAK,EAAE;YACd,IAAI,KAAK,YAAY,SAAS,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;gBAC5D,MAAM,mCAAmC,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC;aAC7D;YACD,MAAM,KAAK,CAAC;SACb;QAED,IAAI,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;;;;;QAMpC,IAAI,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YACpB,IAAI,WAAW,CAAC,mBAAmB,EAAE;gBACnC,IAAI,CAAC,iBAAiB,GAAG,WAAW,CAAC,mBAAmB,CAAC;aAC1D;YACD,IAAI,WAAW,CAAC,sBAAsB,EAAE;gBACtC,IAAI,CAAC,2BAA2B,GAAG,WAAW,CAAC,sBAAsB,CAAC;aACvE;YACD,KAAK,MAAM,IAAI,IAAIe,6BAAyB,EAAE;gBAC5C,IAAK,WAAmB,CAAC,IAAI,CAAC,EAAE;oBAC7B,IAAI,CAAC,uBAA+B,CAAC,IAAI,CAAC,GAAI,WAAmB,CAAC,IAAI,CAAC,CAAC;iBAC1E;aACF;;;YAGD,WAAW,IAAI,IAAI,CAAC,cAAc,CAChC,EAAE,EACF,IAAI,CAAC,iBAAiB,EACtB,IAAI,CAAC,2BAA2B,EAChC,IAAI,CAAC,uBAAuB,CAC7B,CAAC,MAAM,CAAC;SACV;QAED,MAAM,WAAW,GAAG,cAAc,CAAC,MAAM,CAAC;QAC1C,MAAM,eAAe,GACnB,WAAW,IAAI,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,CAAC;QACpF,WAAW,IAAI,WAAW,GAAG,eAAe,CAAC;;;QAG7C,IAAI,WAAW,GAAG,IAAI,CAAC,eAAe,EAAE;YACtC,OAAO,KAAK,CAAC;SACd;;QAGD,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC3C,IAAI,WAAW,EAAE;YACf,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SACtC;QAED,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,OAAO,IAAI,CAAC;KACb;CACF;;ACrUD;AACA,AAuCA;;;;;;AAMA,MAAa,aAAc,SAAQ,UAA2B;IAyB5D,YAAY,OAA0B,EAAE,UAAkB,EAAE,YAA0B;QACpF,KAAK,CAAC,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,QAAQ,EAAElF,YAAM,EAAE;YACvD,OAAO,EAAE,UAAU;YACnB,QAAQ,EAAE,GAAG,OAAO,CAAC,MAAM,CAAC,QAAQ,GAAG,UAAU,EAAE;SACpD,CAAC,CAAC;QACH,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;QAClC,IAAI,CAAC,YAAY,GAAG,CAAC,OAAqB;YACxC,MAAM,WAAW,GAAG,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC;YAC3DA,YAAM,CAAC,QAAQ,CACb,WAAW,EACX,yEAAyE;gBACvE,sBAAsB,EACxB,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;;SAEH,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAC,OAAqB;YAC3C,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAC9DA,YAAM,CAAC,QAAQ,CACb,YAAY,EACZ,qFAAqF;gBACnF,sBAAsB,EACxB,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;;SAEH,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG,CAAO,OAAqB;YAC9C,MAAM,WAAW,GAAG,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC;YAE3DA,YAAM,CAAC,QAAQ,CACb,WAAW,EACX,GAAG,IAAI,CAAC,SAAS,yDAAyD,CAC3E,CAAC;YAEF,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG;gBAChCA,YAAM,CAAC,QAAQ,CACb,GAAG,EACH,GAAG,IAAI,CAAC,SAAS,uDAAuD,CACzE,CAAC;aACH,CAAC,CAAC;SACJ,CAAA,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAO,OAAqB;YACjD,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAE9DA,YAAM,CAAC,QAAQ,CACb,YAAY,EACZ,GAAG,IAAI,CAAC,SAAS,0DAA0D,CAC5E,CAAC;YAEF,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG;gBAChCA,YAAM,CAAC,QAAQ,CACb,GAAG,EACH,GAAG,IAAI,CAAC,SAAS,wDAAwD,CAC1E,CAAC;aACH,CAAC,CAAC;SACJ,CAAA,CAAC;KACH;IAEO,oBAAoB,CAAC,WAAmB,EAAE,OAAiB;QACjE,IAAI,OAAO;YAAE,IAAI,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACtD,MAAM,SAAS,GAA2B;YACxC,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,MAAM,EAAE;gBACN,OAAO,EAAE,IAAI,CAAC,OAAO;aACtB;YACD,OAAO,EAAE,IAAI,CAAC,YAAY;YAC1B,OAAO,EAAE,IAAI,CAAC,YAAY;YAC1B,cAAc,EAAE,IAAI,CAAC,eAAe;YACpC,cAAc,EAAE,IAAI,CAAC,eAAe;YACpC,oBAAoB,EAAE,WAAW,GAAG,IAAI;SACzC,CAAC;QACFA,YAAM,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,SAAS,mCAAmC,EAAE,SAAS,CAAC,CAAC;QAChF,OAAO,SAAS,CAAC;KAClB;;;;;;;;;;;;IAaO,QAAQ,CACd,cAAsB,EACtB,SAAkB,EAClB,OAAyC;QAEzC,MAAM,WAAW,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,CAAC;QACzC,MAAM,WAAW,GACf,IAAI,CAAC,aAAa,CAAC,WAAW,IAAI,SAAS;cACvCwD,kBAAS,CAAC,2BAA2B;cACrC,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;QAErC,MAAM,gBAAgB,GAAG,MACvB,IAAI,OAAO,CAAO,CAAO,OAAO,EAAE,MAAM;;YACtC,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACjC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE;gBAClB,IAAI;oBACF,MAAM,8BAA8B,CAAC;wBACnC,QAAQ,EAAE,MAAM,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,CAAC;wBAC1D,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;wBACjC,SAAS,EAAE,WAAW;wBACtB,cAAc,EACZ,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,aAAa,IAAI,CAAC,IAAI,IAAI;4BACxD,iBAAiB,IAAI,CAAC,OAAO,qDAAqD;4BAClF,uBAAuB;qBAC1B,CAAC,CAAC;iBACJ;gBAAC,OAAO,GAAG,EAAE;oBACZ,GAAG,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;oBACpCxD,YAAM,CAAC,QAAQ,CACb,GAAG,EACH,gDAAgD,EAChD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;iBACpB;aACF;YAED,IAAI;gBACF,MAAM,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,aAAa,CAAC;gBAEnDA,YAAM,CAAC,OAAO,CACZ,0CAA0C,EAC1C,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,QACT,IAAI,CAAC,IAAI,0CAAE,MAAM,oBACjB,IAAI,CAAC,IAAI,0CAAE,OAAO,0CAAE,QAAQ,0CAAE,SAAS,GACxC,CAAC;gBAEF,IAAI,QAAC,IAAI,CAAC,IAAI,0CAAE,QAAQ,GAAE,EAAE;oBAC1BA,YAAM,CAAC,OAAO,CACZ,oEAAoE,EACpE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,CACV,CAAC;oBAEF,MAAMmF,cAAK,CAAC,IAAI,CAAC,CAAC;oBAElBnF,YAAM,CAAC,OAAO,CACZ,qEAAqE,EACrE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,QACT,IAAI,CAAC,IAAI,0CAAE,MAAM,oBACjB,IAAI,CAAC,IAAI,0CAAE,OAAO,0CAAE,QAAQ,0CAAE,SAAS,GACxC,CAAC;iBACH;gBACD,UAAI,IAAI,CAAC,IAAI,0CAAE,QAAQ,IAAI;oBACzB,IAAI,WAAW,IAAI,eAAe,EAAE;wBAClC,MAAM,IAAI,GACR,GAAG,IAAI,CAAC,SAAS,YAAY,IAAI,CAAC,IAAI,IAAI;4BAC1C,iBAAiB,IAAI,CAAC,OAAO,qDAAqD;4BAClF,uBAAuB,CAAC;wBAC1BA,YAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;wBACrB,MAAM,CAAC,GAAc;4BACnB,SAAS,EAAE4E,iCAAwB,CAAC,uBAAuB;4BAC3D,WAAW,EAAE,IAAI;yBAClB,CAAC;wBACF,OAAO,MAAM,CAAC,wBAAwB,CAAC,CAAC,CAAC,CAAC,CAAC;qBAC5C;oBACD,IAAI;wBACF,IAAI,CAAC,IAAI,CAAC,oBAAoB,GAAG,CAAC,WAAW,GAAG,eAAe,IAAI,IAAI,CAAC;wBACxE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,IAAK,CAAC,IAAI,CACpC,cAAc,EACd,SAAS,EACT,SAAS,GAAG,UAAU,GAAG,CAAC,CAC3B,CAAC;wBACF5E,YAAM,CAAC,OAAO,CACZ,mDAAmD,EACnD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,QAAQ,CAAC,EAAE,CACZ,CAAC;wBACF,OAAO,OAAO,EAAE,CAAC;qBAClB;oBAAC,OAAO,KAAK,EAAE;wBACd,KAAK,GAAG,wBAAwB,CAAC,KAAK,CAAC,UAAU,IAAI,KAAK,CAAC,CAAC;wBAC5DA,YAAM,CAAC,QAAQ,CACb,KAAK,EACL,GAAG,IAAI,CAAC,SAAS,8CAA8C,CAChE,CAAC;wBACF,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;qBACtB;iBACF;qBAAM;;oBAEL,MAAM,GAAG,GACP,IAAI,IAAI,CAAC,SAAS,aAAa,IAAI,CAAC,IAAI,KAAK;wBAC7C,sDAAsD,CAAC;oBACzDA,YAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;oBACpB,MAAM,SAAS,GAAc;wBAC3B,SAAS,EAAE4E,iCAAwB,CAAC,eAAe;wBACnD,WAAW,EAAE,GAAG;qBACjB,CAAC;oBACF,MAAM,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC,CAAC;iBAC7C;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,CAAC,GAAG,CAAC,CAAC;aACb;SACF,CAAA,CAAC,CAAC;QAEL,MAAM,MAAM,GAAsB;YAChC,SAAS,EAAE,gBAAgB;YAC3B,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAa;YACzC,aAAa,EAAEE,2BAAkB,CAAC,WAAW;YAC7C,YAAY,EAAE,IAAI,CAAC,aAAa;YAChC,WAAW,EAAE,WAAW;SACzB,CAAC;QAEF,OAAOD,cAAK,CAAO,MAAM,CAAC,CAAC;KAC5B;IAEe,cAAc,CAAC,OAA+B;;YAC5D,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC;YAC7E,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;YAC7B,OAAO,MAAM,CAAC;SACf;KAAA;;;;IAKY,IAAI,CACf,OAAgC,EAChC,WAA6B;;YAE7B,IAAI;gBACF,IAAI,CAAC,OAAO,EAAE;oBACZ,OAAO,GAAG,IAAI,CAAC,oBAAoB,CAACrB,kBAAS,CAAC,2BAA2B,CAAC,CAAC;iBAC5E;gBACD,MAAM,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;aAC3C;YAAC,OAAO,GAAG,EAAE;gBACZ,GAAG,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBACpCxD,YAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,SAAS,8CAA8C,CAAC,CAAC;;gBAEtF,IAAK,GAAsB,CAAC,IAAI,KAAK,uBAAuB,EAAE;oBAC5D,GAAG,CAAC,OAAO,GAAG,qEAAqE,CAAC;iBACrF;gBACD,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;;IAOK,UAAU;;;;YAGd,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC;SACxB;KAAA;;;;;IAMD,MAAM;QACJ,MAAM,MAAM,GAAY,IAAI,CAAC,IAAI,IAAI,IAAI,GAAG,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;QACvEA,YAAM,CAAC,OAAO,CACZ,iDAAiD,EACjD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,MAAM,CACP,CAAC;QACF,OAAO,MAAM,CAAC;KACf;;;;;;;IAQK,IAAI,CAAC,IAAuB,EAAE,OAA8B;;YAChE,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI;gBACF,MAAM,WAAW,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;gBACxC,WAAW,CAAC,IAAI,GAAG,sBAAsB,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;gBAG5D,IAAI,cAAc,CAAC;gBACnB,IAAI;oBACF,cAAc,GAAGmE,mBAAe,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;iBACtD;gBAAC,OAAO,KAAK,EAAE;oBACd,IAAI,KAAK,YAAY,SAAS,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;;;;;wBAK5D,MAAM,mCAAmC,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;qBAC1D;oBACD,MAAM,KAAK,CAAC;iBACb;gBACDnE,YAAM,CAAC,OAAO,CAAC,4CAA4C,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC9F,OAAO,MAAM,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAC5D;YAAC,OAAO,GAAG,EAAE;gBACZA,YAAM,CAAC,QAAQ,CACb,GAAG,EACH,2DAA2D,EAC3D,IAAI,CAAC,SAAS,EACd,IAAI,CACL,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;;;;;;IAWK,YAAY,CAChB,aAAkC,EAClC,OAA8B;;YAE9B,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI;gBACF,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;oBACjC,aAAa,GAAG,CAAC,aAAa,CAAC,CAAC;iBACjC;gBACDA,YAAM,CAAC,OAAO,CACZ,8CAA8C,EAC9C,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,aAAa,CACd,CAAC;gBACF,MAAM,YAAY,GAAkB,EAAE,CAAC;gBACvC,MAAM,eAAe,GAAG,EAAE,CAAC;;gBAE3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC7C,MAAM,WAAW,GAAG,aAAa,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpD,WAAW,CAAC,IAAI,GAAG,sBAAsB,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;oBACxE,YAAY,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC;oBAC9B,IAAI;wBACF,eAAe,CAAC,CAAC,CAAC,GAAGmE,mBAAe,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;qBAC1D;oBAAC,OAAO,KAAK,EAAE;wBACd,IAAI,KAAK,YAAY,SAAS,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;4BAC5D,MAAM,mCAAmC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;yBACtE;wBACD,MAAM,KAAK,CAAC;qBACb;iBACF;;gBAGD,MAAM,YAAY,GAAgB;oBAChC,IAAI,EAAEA,mBAAe,CAAC,aAAa,CAAC,eAAe,CAAC;iBACrD,CAAC;;;gBAGF,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,mBAAmB,EAAE;oBACvC,YAAY,CAAC,mBAAmB,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC;iBACxE;gBACD,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,sBAAsB,EAAE;oBAC1C,YAAY,CAAC,sBAAsB,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,sBAAsB,CAAC;iBAC9E;gBACD,KAAK,MAAM,IAAI,IAAIiB,6BAAiB,EAAE;oBACpC,IAAK,YAAY,CAAC,CAAC,CAAS,CAAC,IAAI,CAAC,EAAE;wBACjC,YAAoB,CAAC,IAAI,CAAC,GAAI,YAAY,CAAC,CAAC,CAAS,CAAC,IAAI,CAAC,CAAC;qBAC9D;iBACF;;gBAGD,MAAM,mBAAmB,GAAGjB,mBAAe,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;gBAEjEnE,YAAM,CAAC,OAAO,CACZ,gDAAgD,EAChD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,mBAAmB,CACpB,CAAC;gBACF,OAAO,MAAM,IAAI,CAAC,QAAQ,CAAC,mBAAmB,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;aAChE;YAAC,OAAO,GAAG,EAAE;gBACZA,YAAM,CAAC,QAAQ,CACb,GAAG,EACH,yEAAyE,EACzE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,aAAa,CACd,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;;;;;;;;;;;;IAiBK,iBAAiB,CACrB,UAEgD,EAAE;;YAElD,MAAM,YAAY,GAAG,OAAO,CAAC,YAAY,IAAI,EAAE,CAAC;YAChD,IAAI,IAAI,CAAC,MAAM,EAAE,EAAE;gBACjB,OAAO,IAAI,CAAC,IAAK,CAAC,cAAc,CAAC;aAClC;YACD,OAAO,IAAI,OAAO,CAAS,CAAO,OAAO,EAAE,MAAM;gBAC/C,IAAI;oBACF,MAAM,MAAM,GAAsB;wBAChC,SAAS,EAAE,MAAM,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,CAAC;wBAC3D,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;wBACxC,aAAa,EAAE8E,2BAAkB,CAAC,UAAU;wBAC5C,YAAY,EAAE,YAAY;wBAC1B,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;qBAClC,CAAC;oBAEF,MAAMD,cAAK,CAAO,MAAM,CAAC,CAAC;oBAE1B,OAAO,OAAO,CAAC,IAAI,CAAC,IAAK,CAAC,cAAc,CAAC,CAAC;iBAC3C;gBAAC,OAAO,GAAG,EAAE;oBACZ,MAAM,CAAC,GAAG,CAAC,CAAC;iBACb;aACF,CAAA,CAAC,CAAC;SACJ;KAAA;IAEK,WAAW,CAAC,OAAmC;;YACnD,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI,cAAc,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC;gBAChD,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC,CAAC;YACH,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,cAAc,EAAE;gBAC3B,IAAI,OAAO,CAAC,cAAc,GAAG,cAAe,EAAE;oBAC5C,MAAM,KAAK,GAAG,IAAI,KAAK,CACrB,qBAAqB,OAAO,CAAC,cAAc,iDAAiD,cAAc,kCAAkC,CAC7I,CAAC;oBACF,MAAM,KAAK,CAAC;iBACb;gBACD,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;aACzC;YACD,OAAO,IAAI,0BAA0B,CAAC,IAAI,CAAC,QAAQ,EAAE,cAAe,CAAC,CAAC;SACvE;KAAA;IAEK,SAAS,CACb,YAAoC,EACpC,OAA8B;;YAE9B,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5C,IAAI;gBACF7E,YAAM,CAAC,OAAO,CACZ,gDAAgD,EAChD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,YAAY,CACb,CAAC;gBACF,OAAO,MAAM,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,gBAAgB,EAAE,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;aAC5E;YAAC,OAAO,GAAG,EAAE;gBACZA,YAAM,CAAC,QAAQ,CACb,GAAG,EACH,yEAAyE,EACzE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,YAAY,CACb,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;IAED,OAAO,MAAM,CACX,OAA0B,EAC1B,UAAkB,EAClB,YAA0B;QAE1B,4BAA4B,CAAC,OAAO,CAAC,CAAC;QAEtC,MAAM,QAAQ,GAAG,IAAI,aAAa,CAAC,OAAO,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;QACtE,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC;QAC1C,OAAO,QAAQ,CAAC;KACjB;CACF;;ACrjBD;AACA,AAiIA;;;;;;AAMA,MAAa,oBAAoB;;;;;IAiB/B,YACU,QAA2B,EAC3B,WAAmB,EAC3B,eAA6B,EAAE;QAFvB,aAAQ,GAAR,QAAQ,CAAmB;QAC3B,gBAAW,GAAX,WAAW,CAAQ;;;;QAdrB,cAAS,GAAY,KAAK,CAAC;QAiBjC,4BAA4B,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC;QAC9B,IAAI,CAAC,OAAO,GAAG,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,EAAE,YAAY,CAAC,CAAC;QAC9E,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;KACnC;IAjBD,IAAY,SAAS;QACnB,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,WAAW,IAAI,CAAC,UAAU,GAAG,CAAC;KACpE;IAiBO,gCAAgC;QACtC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC5C,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,YAAY,GAAG,uBAAuB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAC/D,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtCA,YAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,aAAa,CAAC,CAAC;YACpE,MAAM,KAAK,CAAC;SACb;KACF;IAED,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC;KACjE;IAEK,YAAY,CAChB,QAA0E,EAC1E,OAA8B;;YAE9B,IAAI,CAAC,gCAAgC,EAAE,CAAC;YACxC,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;YACnF,MAAM,iBAAiB,GACrB,gIAAgI,CAAC;YAEnI,IAAI,KAA6B,CAAC;YAClC,IAAI,wBAAwB,CAAC,QAAQ,CAAC,EAAE;gBACtC,KAAK,GAAG,QAAQ,CAAC;aAClB;iBAAM;gBACL,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;oBAC5B,QAAQ,GAAG,CAAC,QAAQ,CAAC,CAAC;iBACvB;gBACD,KAAK,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;gBAC/C,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;oBAC9B,gCAAgC,CAAC,OAAO,EAAE,iBAAiB,CAAC,CAAC;oBAC7D,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,OAAO,EAAE,EAAE,UAAU,EAAE,aAAa,CAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,cAAc,CAAC,EAAE,CAAC,EAAE;;wBAEzF,MAAM,IAAI,eAAe,CACvB,yKAAyK,EACzK,qBAAqB,CACtB,CAAC;qBACH;iBACF;aACF;YAED,MAAM,QAAQ,GAAG,cAAc,CAC7B,aAAa,CAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,cAAc,CAAC,EACtC,KAAK,CAAC,oBAAoB,EAC1B,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAC1B,CAAC;YAEF,IAAI;gBACF,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;gBAC5D,QAAQ,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE0C,iBAAa,CAAC,EAAE,EAAE,CAAC,CAAC;gBAC/C,OAAO,MAAM,CAAC;aACf;YAAC,OAAO,KAAK,EAAE;gBACd,QAAQ,CAAC,SAAS,CAAC;oBACjB,IAAI,EAAEA,iBAAa,CAAC,OAAO;oBAC3B,OAAO,EAAE,KAAK,CAAC,OAAO;iBACvB,CAAC,CAAC;gBACH,MAAM,KAAK,CAAC;aACb;oBAAS;gBACR,QAAQ,CAAC,GAAG,EAAE,CAAC;aAChB;SACF;KAAA;IAEK,kBAAkB,CAAC,OAAmC;;YAC1D,IAAI,CAAC,gCAAgC,EAAE,CAAC;YACxC,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;SAC1C;KAAA;IAEK,gBAAgB,CACpB,QAAiD,EACjD,uBAA6B,EAC7B,UAAgC,EAAE;;YAElC,IAAI,CAAC,gCAAgC,EAAE,CAAC;YACxC,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,yBAAyB,EACzB,uBAAuB,CACxB,CAAC;YACF,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;YACnF,MAAM,kBAAkB,GAAG,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,QAAQ,GAAG,CAAC,QAAQ,CAAC,CAAC;YAE3E,KAAK,MAAM,OAAO,IAAI,kBAAkB,EAAE;gBACxC,gCAAgC,CAC9B,OAAO,EACP,wGAAwG,CACzG,CAAC;aACH;YAED,MAAM,+BAA+B,GAAG;gBACtC,OAAO,IAAI,CAAC,QAAQ;qBACjB,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC;qBACrC,gBAAgB,CAAC,uBAAuB,EAAE,kBAAkB,kCACxD,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,EACrC,WAAW,EAAE,kBAAkB,EAC/B,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;aACN,CAAA,CAAC;YACF,MAAM,MAAM,GAAwB;gBAClC,SAAS,EAAE,+BAA+B;gBAC1C,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAEoC,2BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAOD,cAAK,CAAS,MAAM,CAAC,CAAC;SAC9B;KAAA;IAEK,uBAAuB,CAC3B,eAA8B,EAC9B,UAAgC,EAAE;;YAElC,IAAI,CAAC,gCAAgC,EAAE,CAAC;YACxC,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;YACF,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;YAEF,MAAM,uBAAuB,GAAG,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC;kBAC1D,eAAe;kBACf,CAAC,eAAe,CAAC,CAAC;YACtB,MAAM,uCAAuC,GAAG;gBAC9C,OAAO,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,uBAAuB,CAChF,uBAAuB,kCAGlB,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,EACrC,WAAW,EAAE,yBAAyB,EACtC,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAE9C,CAAC;aACH,CAAA,CAAC;YACF,MAAM,MAAM,GAAsB;gBAChC,SAAS,EAAE,uCAAuC;gBAClD,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAEC,2BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAOD,cAAK,CAAO,MAAM,CAAC,CAAC;SAC5B;KAAA;;;;;;;;;;;;;IAiBK,KAAK;;YACT,IAAI;gBACF,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;gBACtB,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;aAC5B;YAAC,OAAO,GAAG,EAAE;gBACZ7E,YAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,SAAS,6CAA6C,CAAC,CAAC;gBACrF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;CACF;AAED;;;;AAIA,SAAgB,wBAAwB,CACtC,sBAA2B;IAE3B,IAAI,sBAAsB,IAAI,IAAI,EAAE;QAClC,OAAO,KAAK,CAAC;KACd;IAED,MAAM,aAAa,GAAG,sBAAgD,CAAC;IAEvE,QACE,OAAO,aAAa,CAAC,aAAa,KAAK,UAAU;QACjD,OAAO,aAAa,CAAC,cAAc,KAAK,QAAQ;QAChD,OAAO,aAAa,CAAC,WAAW,KAAK,QAAQ,EAC7C;AACJ,CAAC;;ACxWD;AACA,AA+DA;;;;;AAKA,MAAa,cAAe,SAAQ,UAAoB;;;;;;;;;IA+RtD,YACE,OAA0B,EAC1B,UAAkB,EACV,kBAAsC,EAC9C,OAA+B;QAE/B,KAAK,CAAC,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,SAAS,EAAEA,cAAM,EAAE;YACxD,OAAO,EAAE,UAAU;YACnB,QAAQ,EAAE,GAAG,OAAO,CAAC,MAAM,CAAC,QAAQ,GAAG,UAAU,EAAE;SACpD,CAAC,CAAC;QANK,uBAAkB,GAAlB,kBAAkB,CAAoB;;;;;;;QA7QhD,uBAAkB,GAAW,CAAC,CAAC;;;;;;QAuCvB,4BAAuB,GAAyC,IAAI,GAAG,EAG5E,CAAC;QA0OF,IAAI,CAAC,eAAe,GAAG,IAAI,cAAc,CAAC,OAAO;YAC/C,QAAQ,EAAE,IAAI,CAAC,IAAI;YACnB,SAAS,EAAE,IAAI,CAAC,SAAS;SAC1B,CAAC,CAAC,CAAC;QACJ,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAC1B,IAAI,IAAI,CAAC,kBAAkB,IAAI,SAAS;YAAE,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,kBAAkB,CAAC;QACnF,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,IAAI,UAAU,CAAC;QACrD,IAAI,CAAC,wBAAwB;YAC3B,OAAO,CAAC,8BAA8B,IAAI,IAAI;kBAC1C,OAAO,CAAC,8BAA8B;kBACtC,GAAG,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,2BAA2B,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,wBAAwB,CAAC;QAC9E,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,wBAAwB,GAAG,CAAC,IAAI,IAAI,CAAC,WAAW,KAAK,UAAU,CAAC;QAE1F,IAAI,CAAC,iCAAiC,GAAG,KAAK,CAAC;QAC/C,IAAI,CAAC,qBAAqB,GAAG,IAAI,oBAAoB,CACnD,OAAO,EACP,UAAU,EACV,CAAO,YAA8B;YACnC,OAAO,IAAI,CAAC,IAAK,CAAC;SACnB,CAAA,EACD,IAAI,CAAC,WAAW,CACjB,CAAC;;QAGF,IAAI,CAAC,UAAU,GAAG,CAAC,OAAqB;YACtC,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;YAElC,gBAAgB,CAAC,IAAI,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,uBAAuB,CAAC,CAAC;SAC1E,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG,CAAC,IAAsB;YACzC,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBACpBA,cAAM,CAAC,OAAO,CACZ,+EAA+E,EAC/E,IAAI,CAAC,SAAS,CACf,CAAC;aACH;SACF,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG,CAAC,OAAqB;YACxC,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC;YACjE,IAAI,aAAa,EAAE;gBACjB,MAAM,OAAO,GAAG,wBAAwB,CAAC,aAAa,CAAmB,CAAC;gBAC1E,IAAI,OAAO,CAAC,IAAI,KAAK,sBAAsB,EAAE;oBAC3C,OAAO,CAAC,OAAO,GAAG,uDAAuD,IAAI,CAAC,SAAS,GAAG,CAAC;iBAC5F;gBACDA,cAAM,CAAC,QAAQ,CAAC,OAAO,EAAE,mCAAmC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC9E,IAAI,CAAC,YAAY,CAAC;oBAChB,KAAK,EAAE,OAAO;oBACd,WAAW,EAAE,SAAS;oBACtB,UAAU,EAAE,IAAI,CAAC,UAAU;oBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;iBACnD,CAAC,CAAC;aACJ;SACF,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAC,OAAqB;YAC3C,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;YAChD,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAC9D,IAAI,YAAY,EAAE;gBAChB,MAAM,OAAO,GAAG,wBAAwB,CAAC,YAAY,CAAC,CAAC;gBACvDA,cAAM,CAAC,QAAQ,CACb,OAAO,EACP,8DAA8D,EAC9D,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,OAAO,CACR,CAAC;gBACF,IAAI,CAAC,YAAY,CAAC;oBAChB,KAAK,EAAE,OAAO;oBACd,WAAW,EAAE,SAAS;oBACtB,UAAU,EAAE,IAAI,CAAC,UAAU;oBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;iBACnD,CAAC,CAAC;aACJ;SACF,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG,CAAO,OAAqB;YAC9C,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;YAChD,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC;YACjE,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,IAAI,OAAO,CAAC,QAAS,CAAC;YAChD,IAAI,aAAa,EAAE;gBACjB,MAAM,OAAO,GAAG,wBAAwB,CAAC,aAAa,CAAmB,CAAC;gBAC1EA,cAAM,CAAC,QAAQ,CACb,OAAO,EACP,6EAA6E;oBAC3E,6BAA6B,EAC/B,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,EACd,OAAO,CACR,CAAC;;;aAGH;YACD,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,EAAE;gBAC1CA,cAAM,CAAC,OAAO,CACZ,wEAAwE;oBACtE,gFAAgF,EAClF,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;gBACF,IAAI;oBACF,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;iBACpB;gBAAC,OAAO,GAAG,EAAE;oBACZA,cAAM,CAAC,QAAQ,CACb,GAAG,EACH,qEAAqE,EACrE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;iBACH;aACF;iBAAM;gBACLA,cAAM,CAAC,OAAO,CACZ,wEAAwE;oBACtE,8EAA8E,EAChF,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;aACH;SACF,CAAA,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAO,OAAqB;YACjD,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,IAAI,OAAO,CAAC,QAAS,CAAC;YAChD,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAC9D,IAAI,YAAY,EAAE;gBAChB,MAAM,OAAO,GAAG,wBAAwB,CAAC,YAAY,CAAC,CAAC;gBACvDA,cAAM,CAAC,QAAQ,CACb,OAAO,EACP,qEAAqE;oBACnE,yBAAyB,EAC3B,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;;;aAGH;YAED,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,qBAAqB,EAAE,EAAE;gBACjDA,cAAM,CAAC,OAAO,CACZ,uEAAuE;oBACrE,gFAAgF,EAClF,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;gBACF,IAAI;oBACF,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;iBACpB;gBAAC,OAAO,GAAG,EAAE;oBACZA,cAAM,CAAC,QAAQ,CACb,GAAG,EACH,oEAAoE,EACpE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;iBACH;aACF;iBAAM;gBACLA,cAAM,CAAC,OAAO,CACZ,sEAAsE;oBACpE,8EAA8E,EAChF,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;aACH;SACF,CAAA,CAAC;KACH;;;;IAhaD,IAAI,mBAAmB;QACrB,OAAO,IAAI,CAAC,qBAAqB,CAAC,mBAAmB,IAAI,IAAI,CAAC,iCAAiC,CAAC;KACjG;IA8DD,IAAW,cAAc;QACvB,OAAO,IAAI,CAAC,eAAe,CAAC;KAC7B;;;;;IAOO,yBAAyB;QAC/B,IACE,IAAI,CAAC,aAAa;YAClB,IAAI,IAAI,CAAC,IAAI,CAAC,2BAA2B,CAAC,GAAG,IAAI,CAAC,qBAAsB;YACxE,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,2BAA2B;YAC7C,IAAI,CAAC,MAAM,EAAE,EACb;YACA,MAAM,kBAAkB,GAAG,2BAA2B,CAAC,IAAI,CAAC,qBAAsB,CAAC,CAAC;YACpF,IAAI,CAAC,wBAAwB,GAAG,UAAU,CAAC;gBACzC,IAAI;oBACFA,cAAM,CAAC,OAAO,CACZ,kEAAkE,GAAG,iBAAiB,EACtF,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,IAAI,CAAC,qBAAqB,GAAG,MAAM,IAAI,CAAC,QAAQ;yBAC7C,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;yBACpC,gBAAgB,CAAC,IAAI,CAAC,SAAS,EAAE;wBAChC,kBAAkB,EAAE,IAAI,CAAC,IAAI;wBAC7B,WAAW,EAAE,KAAK;qBACnB,CAAC,CAAC;oBACLA,cAAM,CAAC,OAAO,CACZ,mEAAmE,GAAG,iBAAiB,EACvF,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,CACV,CAAC;oBACFA,cAAM,CAAC,OAAO,CACZ,uEAAuE,EACvE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;oBACF,IAAI,CAAC,yBAAyB,EAAE,CAAC;iBAClC;gBAAC,OAAO,GAAG,EAAE;oBACZA,cAAM,CAAC,QAAQ,CACb,GAAG,EACH,8EAA8E,EAC9E,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;iBACH;aACF,CAAA,EAAE,kBAAkB,CAAC,CAAC;YACvBA,cAAM,CAAC,OAAO,CACZ,gFAAgF,EAChF,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,EACd,kBAAkB,EAClB,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,kBAAkB,CAAC,CAAC,QAAQ,EAAE,CACrD,CAAC;SACH;KACF;IAES,cAAc,CACtB,OAAwB,EACxB,YAA8B;QAE9B,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;KACzD;;;;IAKa,KAAK,CAAC,WAA6B;;YAC/C,IAAI;gBACF,MAAM,OAAO,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;gBACpD,MAAM,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;gBAE1C,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,EAAE;oBACrB,MAAM,IAAI,KAAK,CAAC,iEAAiE,CAAC,CAAC;iBACpF;gBAED,MAAM,iBAAiB,GACrB,IAAI,CAAC,IAAI,CAAC,MAAM;oBAChB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM;oBACvB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAACwD,kBAAS,CAAC,iBAAiB,CAAC,CAAC;gBAEvD,IAAI,YAAY,GAAW,EAAE,CAAC;gBAE9B,IAAI,IAAI,CAAC,kBAAkB,IAAI,IAAI,IAAI,iBAAiB,IAAI,IAAI,EAAE;;;oBAGhE,YAAY,GAAG,8DAA8D,CAAC;iBAC/E;qBAAM,IAAI,IAAI,CAAC,kBAAkB,IAAI,IAAI,IAAI,iBAAiB,KAAK,IAAI,CAAC,kBAAkB,EAAE;;;oBAG3F,YAAY,GAAG,0DAA0D,IAAI,CAAC,kBAAkB,0CAA0C,CAAC;iBAC5I;gBAED,IAAI,YAAY,EAAE;oBAChB,MAAM,KAAK,GAAG,wBAAwB,CAAC;wBACrC,WAAW,EAAE,YAAY;wBACzB,SAAS,EAAEoB,iCAAwB,CAAC,0BAA0B;qBAC/D,CAAC,CAAC;oBACH5E,cAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;oBACvC,MAAM,KAAK,CAAC;iBACb;gBACD,IAAI,IAAI,CAAC,kBAAkB,IAAI,IAAI;oBAAE,IAAI,CAAC,SAAS,GAAG,iBAAiB,CAAC;gBACxE,IAAI,CAAC,qBAAqB,GAAG,kBAAkB,CAC7C,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,gCAAgC,CAAC,CACvD,CAAC;gBACFA,cAAM,CAAC,OAAO,CACZ,gDAAgD,EAChD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,CACzC,CAAC;gBACFA,cAAM,CAAC,OAAO,CAAC,+CAA+C,EAAE,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;gBACzF,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;oBAC7C,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;iBACjD;gBACD,IAAI,CAAC,2BAA2B,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,wBAAwB,CAAC;gBAC9E,IAAI,CAAC,yBAAyB,EAAE,CAAC;aAClC;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,MAAM,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;gBAC7CA,cAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,iDAAiD,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;;gBAG3F,IAAK,MAAyB,CAAC,IAAI,KAAK,uBAAuB,EAAE;oBAC/D,IAAI,IAAI,CAAC,kBAAkB,EAAE;wBAC3B,MAAM,CAAC,OAAO,GAAG,0DAA0D,IAAI,CAAC,kBAAkB,6CAA6C,CAAC;qBACjJ;yBAAM;wBACL,MAAM,CAAC,OAAO,GAAG,uEAAuE,CAAC;qBAC1F;iBACF;gBACD,MAAM,MAAM,CAAC;aACd;SACF;KAAA;;;;IAKO,4BAA4B;QAClC,MAAM,WAAW,GAAoB,qBAAqB,CACxD,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,WAAW,EAChB;YACE,OAAO,EAAE,IAAI,CAAC,OAAO;YACrB,MAAM,EAAE,EAAE,CAACwD,kBAAS,CAAC,iBAAiB,GAAG,IAAI,CAAC,SAAS,EAAE;SAC1D,EACD;YACE,OAAO,EAAE,CAAC,OAAO,KACf,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC;;aAEhC,CAAC;YACJ,cAAc,EAAE,CAAC,OAAO,KACtB,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC;;aAEnC,CAAC;YACJ,OAAO,EAAE,IAAI,CAAC,YAAY;YAC1B,cAAc,EAAE,IAAI,CAAC,eAAe;YACpC,SAAS,EAAE,IAAI,CAAC,UAAU;SAC3B,CACF,CAAC;QAEF,OAAO,WAAW,CAAC;KACpB;;;;IAgMK,KAAK;;;;;YACT,IAAI;gBACF,IAAI,CAAC,iCAAiC,GAAG,KAAK,CAAC;gBAC/C,IAAI,IAAI,CAAC,wBAAwB;oBAAE,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;gBAC/ExD,cAAM,CAAC,OAAO,CACZ,+DAA+D;oBAC7D,8BAA8B,EAChC,IAAI,CAAC,SAAS,CACf,CAAC;gBAEF,MAAM,OAAM,KAAK,WAAE,CAAC;gBAEpB,MAAM,IAAI,CAAC,qBAAqB,CAAC,KAAK,EAAE,CAAC;aAC1C;YAAC,OAAO,GAAG,EAAE;gBACZA,cAAM,CAAC,QAAQ,CACb,GAAG,EACH,qEAAqE,EACrE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;aACH;SACF;KAAA;;;;IAKD,MAAM;QACJ,MAAM,MAAM,GAAY,IAAI,CAAC,IAAK,IAAI,IAAI,CAAC,IAAK,CAAC,MAAM,EAAE,CAAC;QAC1DA,cAAM,CAAC,OAAO,CACZ,+CAA+C,EAC/C,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,EACd,MAAM,CACP,CAAC;QACF,OAAO,MAAM,CAAC;KACf;;;;;;;;;;;;;;;IAgBD,SAAS,CAAC,SAAoB,EAAE,OAAgB,EAAE,OAAyB;;QACzE,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,CAAC;QAE3B,UAAI,OAAO,CAAC,WAAW,0CAAE,OAAO,EAAE;YAChC,MAAM,IAAIJ,0BAAU,CAAC,oBAAoB,CAAC,CAAC;SAC5C;QAED,IAAI,CAAC,iCAAiC,GAAG,IAAI,CAAC;QAC9C,IAAI,OAAO,OAAO,CAAC,kBAAkB,KAAK,QAAQ,IAAI,OAAO,CAAC,kBAAkB,GAAG,CAAC,EAAE;YACpF,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;SACtD;;QAGD,IAAI,CAAC,YAAY;YACf,OAAO,CAAC,oBAAoB,KAAK,KAAK,GAAG,OAAO,CAAC,oBAAoB,GAAG,IAAI,CAAC;QAC/E,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAExB,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE;YACnC,MAAM,gBAAgB,GAAG,CAAO,OAAqB;;;gBAGnD,IAAI,IAAI,CAAC,WAAW,KAAK,UAAU,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE;oBAC1EI,cAAM,CAAC,OAAO,CACZ,oEAAoE;wBAClE,2BAA2B,EAC7B,IAAI,CAAC,SAAS,CACf,CAAC;oBACF,OAAO;iBACR;gBAED,MAAM,QAAQ,GAAG,IAAI,qBAAqB,CACxC,OAAO,CAAC,OAAQ,EAChB,OAAO,CAAC,QAAS,EACjB,IAAI,EACJ,IAAI,CAAC,WAAW,CACjB,CAAC;gBAEF,IAAI;oBACF,MAAM,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;iBACjC;gBAAC,OAAO,GAAG,EAAE;oBACZA,cAAM,CAAC,QAAQ,CACb,GAAG,EACH,4EAA4E;wBAC1E,8BAA8B,EAChC,IAAI,CAAC,SAAS,EACd,QAAQ,CAAC,SAAS,CACnB,CAAC;oBACF,IAAI,CAAC,QAAS,CAAC;wBACb,KAAK,EAAE,GAAG;wBACV,WAAW,EAAE,wBAAwB;wBACrC,UAAU,EAAE,IAAI,CAAC,UAAU;wBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;qBACnD,CAAC,CAAC;oBAEH,MAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;;oBAE5C,IACE,CAAC,QAAQ,CAAC,QAAQ,CAAC,cAAc;wBACjC,IAAI,CAAC,WAAW,KAAK,UAAU;wBAC/B,IAAI,CAAC,MAAM,EAAE;sBACb;wBACA,IAAI;4BACFA,cAAM,CAAC,QAAQ,CACb,KAAK,EACL,+EAA+E,EAC/E,IAAI,CAAC,SAAS,EACd,QAAQ,CAAC,SAAS,CACnB,CAAC;4BACF,MAAM,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;yBAChE;wBAAC,OAAO,YAAY,EAAE;4BACrB,MAAM,eAAe,GAAG,wBAAwB,CAAC,YAAY,CAAC,CAAC;4BAC/DA,cAAM,CAAC,QAAQ,CACb,eAAe,EACf,wEAAwE;gCACtE,UAAU,EACZ,IAAI,CAAC,SAAS,EACd,QAAQ,CAAC,SAAS,EAClB,eAAe,CAChB,CAAC;4BACF,IAAI,CAAC,YAAY,CAAC;gCAChB,KAAK,EAAE,eAAe;gCACtB,WAAW,EAAE,SAAS;gCACtB,UAAU,EAAE,IAAI,CAAC,UAAU;gCAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;6BACnD,CAAC,CAAC;yBACJ;qBACF;oBACD,OAAO;iBACR;wBAAS;oBACR,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;iBAClC;;;gBAID,IACE,IAAI,CAAC,YAAY;oBACjB,IAAI,CAAC,WAAW,KAAK,UAAU;oBAC/B,CAAC,QAAQ,CAAC,QAAQ,CAAC,cAAc,EACjC;oBACA,IAAI;wBACFA,cAAM,CAAC,OAAO,CACZ,8DAA8D,EAC9D,IAAI,CAAC,SAAS,EACd,QAAQ,CAAC,SAAS,CACnB,CAAC;wBACF,MAAM,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;qBACjE;oBAAC,OAAO,aAAa,EAAE;wBACtB,MAAM,eAAe,GAAG,wBAAwB,CAAC,aAAa,CAAC,CAAC;wBAChEA,cAAM,CAAC,QAAQ,CACb,eAAe,EACf,wEAAwE,GAAG,UAAU,EACrF,IAAI,CAAC,SAAS,EACd,QAAQ,CAAC,SAAS,CACnB,CAAC;wBACF,IAAI,CAAC,YAAY,CAAC;4BAChB,KAAK,EAAE,eAAe;4BACtB,WAAW,EAAE,UAAU;4BACvB,UAAU,EAAE,IAAI,CAAC,UAAU;4BAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;yBACnD,CAAC,CAAC;qBACJ;iBACF;aACF,CAAA,CAAC;;YAEF,IAAI,CAAC,IAAI,CAAC,EAAE,CAACiE,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;;YAEvD,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;SACxD;aAAM;YACL,IAAI,CAAC,iCAAiC,GAAG,KAAK,CAAC;YAC/C,MAAM,GAAG,GACP,kCAAkC,IAAI,CAAC,SAAS,eAAe,IAAI,CAAC,IAAI,IAAI;gBAC5E,6CAA6C,CAAC;YAChDjE,cAAM,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;YAC3D,IAAI,CAAC,YAAY,CAAC;gBAChB,KAAK,EAAE,IAAI,KAAK,CAAC,GAAG,CAAC;;;;;;;;;gBASrB,WAAW,EAAE,SAAS;gBACtB,UAAU,EAAE,IAAI,CAAC,UAAU;gBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;aACnD,CAAC,CAAC;SACJ;KACF;;;;;;;;;;IAWK,eAAe,CACnB,eAAuB,EACvB,eAAuB,EACvB,4BAAoC,EACpC,OAA6B;;YAE7B,IAAI;gBACF,OAAO,MAAM,IAAI,CAAC,qBAAqB,CAAC,eAAe,iBACrD,eAAe;oBACf,eAAe;oBACf,4BAA4B,IACzB,OAAO,EACV,CAAC;aACJ;YAAC,OAAO,KAAK,EAAE;gBACdA,cAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,SAAS,yCAAyC,CAAC,CAAC;gBACnF,MAAM,KAAK,CAAC;aACb;SACF;KAAA;;;;;;;IAQK,aAAa,CACjB,OAA8B,EAC9B,SAA0B,EAC1B,OAAkC;;YAElC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM;gBACjC,IAAI,CAAC,OAAO;oBAAE,OAAO,GAAG,EAAE,CAAC;gBAC3B,IAAI,SAAS,CAAC,KAAK,CAAC,uCAAuC,CAAC,IAAI,IAAI,EAAE;oBACpE,OAAO,MAAM,CAAC,IAAI,KAAK,CAAC,eAAe,SAAS,6BAA6B,CAAC,CAAC,CAAC;iBACjF;gBACD,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;gBAClC,MAAM,KAAK,GAAG,UAAU,CAAC;oBACvB,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;oBACjDA,cAAM,CAAC,OAAO,CACZ,6EAA6E;wBAC3E,gDAAgD,EAClD,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,QAAQ,CAAC,EAAE,EACXwD,kBAAS,CAAC,2BAA2B,CACtC,CAAC;oBAEF,MAAM,CAAC,GAAc;wBACnB,SAAS,EAAEoB,iCAAwB,CAAC,uBAAuB;wBAC3D,WAAW,EACT,wEAAwE;4BACxE,sCAAsC;qBACzC,CAAC;oBACF,OAAO,MAAM,CAAC,wBAAwB,CAAC,CAAC,CAAC,CAAC,CAAC;iBAC5C,EAAEpB,kBAAS,CAAC,2BAA2B,CAAC,CAAC;gBAC1C,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,EAAE;oBAC5C,OAAO,EAAE,OAAO;oBAChB,MAAM,EAAE,MAAM;oBACd,KAAK,EAAE,KAAK;iBACb,CAAC,CAAC;gBACH,IAAI,SAAS,KAAK,eAAe,CAAC,QAAQ,EAAE;oBAC1C,QAAQ,CAAC,MAAM,EAAE,CAAC;iBACnB;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,OAAO,EAAE;oBAChD,MAAM,MAAM,GAAQ;wBAClB,kBAAkB,EAAE,KAAK;qBAC1B,CAAC;oBACF,IAAI,OAAO,CAAC,kBAAkB;wBAAE,MAAM,CAAC,mBAAmB,GAAG,OAAO,CAAC,kBAAkB,CAAC;oBACxF,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;iBAC3B;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,KAAK,EAAE;oBAC9C,MAAM,MAAM,GAAQ;wBAClB,kBAAkB,EAAE,IAAI;qBACzB,CAAC;oBACF,IAAI,OAAO,CAAC,kBAAkB;wBAAE,MAAM,CAAC,mBAAmB,GAAG,OAAO,CAAC,kBAAkB,CAAC;oBACxF,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;iBAC3B;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,UAAU,EAAE;oBACnD,MAAM,KAAK,GAAc;wBACvB,SAAS,EAAEA,kBAAS,CAAC,cAAc;wBACnC,IAAI,kCACC,OAAO,CAAC,kBAAkB,KAC7B,gBAAgB,EAAE,OAAO,CAAC,gBAAgB,EAC1C,0BAA0B,EAAE,OAAO,CAAC,qBAAqB,GAC1D;qBACF,CAAC;oBACF,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBACxB;aACF,CAAC,CAAC;SACJ;KAAA;;;;;;IAOD,OAAa,MAAM,CACjB,OAA0B,EAC1B,UAAkB,EAClB,SAA6B,EAC7B,OAA+B;;YAE/B,4BAA4B,CAAC,OAAO,CAAC,CAAC;YACtC,MAAM,cAAc,GAAG,IAAI,cAAc,CAAC,OAAO,EAAE,UAAU,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;YACnF,MAAM,cAAc,CAAC,KAAK,CAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,CAAC,CAAC;YACjD,OAAO,cAAc,CAAC;SACvB;KAAA;CACF;;ACp1BD;AACA,AAoBA;;;;AAIA,MAAa,gBAAgB;IAqC3B,YACE,0CAAkD,EAClD,oBAAgE,EAChE,QAAkC;QAElC,IAAIZ,0BAAiB,CAAC,oBAAoB,CAAC,EAAE;YAC3C,MAAM,uBAAuB,GAAW,0CAA0C,CAAC;YACnF,MAAM,UAAU,GAAoB,oBAAoB,CAAC;YACzD,IAAI,CAAC,cAAc,GAAG,QAAQ,IAAI,EAAE,CAAC;YAErC,IAAI,CAAC,kBAAkB,GAAG,yCAAyC,CACjE,UAAU,EACV,uBAAuB,EACvB,IAAI,CAAC,cAAc,CACpB,CAAC;SACH;aAAM;YACL,MAAM,gBAAgB,GAAW,0CAA0C,CAAC;YAC5E,IAAI,CAAC,cAAc,GAAG,oBAAoB,IAAI,EAAE,CAAC;YAEjD,IAAI,CAAC,kBAAkB,GAAG,0CAA0C,CAClE,gBAAgB,EAChB,IAAI,CAAC,cAAc,CACpB,CAAC;SACH;QACD,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC;QACnE,IAAI,CAAC,cAAc,CAAC,YAAY,GAAG,IAAI,CAAC,cAAc,CAAC,YAAY,IAAI,EAAE,CAAC;QAE1E,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,WAAW,CAAC;QACjE,IACE,WAAW,IAAI,SAAS;aACvB,OAAO,WAAW,KAAK,QAAQ,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,WAAW,IAAI,CAAC,CAAC,EAC/E;YACA,MAAM,IAAI,KAAK,CAAC,GAAG,WAAW,mDAAmD,CAAC,CAAC;SACpF;KACF;IA+DD,cAAc,CACZ,iBAAyB,EACzB,0BAA+D,EAC/D,QAAoC;QAEpC,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,iBAAiB,CAAC,CAAC;;;QAItE,MAAM,EAAE,UAAU,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,wBAAwB,CACnE,iBAAiB,EACjB,0BAA0B,EAC1B,QAAQ,CACT,CAAC;QAEF,IAAI,sBAAsB,GAAG,UAAU,CAAC;QACxC,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,YAAY,EAAE;YACzB,QAAQ,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,YAAY;gBAC3B,KAAK,YAAY;oBACf,sBAAsB,IAAI,mBAAmB,CAAC;oBAC9C,MAAM;gBACR,KAAK,oBAAoB;oBACvB,sBAAsB,IAAI,6BAA6B,CAAC;oBACxD,MAAM;gBACR;oBACE,MAAM,IAAI,KAAK,CACb,yBAAyB,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,YAAY,oEAAoE,CACnH,CAAC;aACL;SACF;QAED,MAAM,4BAA4B,GAChC,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,8BAA8B,KAAI,IAAI;cAC3C,OAAO,CAAC,8BAA8B;cACtC,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC;QAEpB,OAAO,IAAI,sBAAsB,CAC/B,IAAI,CAAC,kBAAkB,EACvB,sBAAsB,EACtB,WAAW,EACX,4BAA4B,EAC5B,IAAI,CAAC,cAAc,CAAC,YAAY,CACjC,CAAC;KACH;IAoDK,aAAa,CACjB,iBAAyB,EACzB,qCAAiF,EACjF,mBAA+D,EAC/D,QAA2C;;YAE3C,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,iBAAiB,CAAC,CAAC;YAEtE,IAAI,SAAiB,CAAC;YACtB,IAAI,UAAkB,CAAC;YACvB,IAAI,WAA4C,CAAC;YACjD,IAAI,OAAqD,CAAC;YAE1D,IACE,OAAO,iBAAiB,KAAK,QAAQ;gBACrC,OAAO,qCAAqC,KAAK,QAAQ;gBACzD,OAAO,mBAAmB,KAAK,QAAQ,EACvC;;gBAEA,SAAS,GAAG,mBAAmB,CAAC;gBAEhC,CAAC,EAAE,UAAU,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,wBAAwB,CAC9D,iBAAiB,EACjB,qCAAqC;;gBAErC,QAAQ,CACT,EAAE;aACJ;iBAAM,IACL,OAAO,iBAAiB,KAAK,QAAQ;gBACrC,OAAO,qCAAqC,KAAK,QAAQ;gBACzD,OAAO,mBAAmB,KAAK,QAAQ,EACvC;;gBAEA,SAAS,GAAG,qCAAqC,CAAC;gBAElD,CAAC,EAAE,UAAU,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,wBAAwB,CAC9D,iBAAiB;;gBAEjB,mBAAmB,EACnB,SAAS,CACV,EAAE;aACJ;iBAAM;gBACL,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;aAChD;YAED,MAAM,cAAc,GAAG,MAAM,cAAc,CAAC,MAAM,CAChD,IAAI,CAAC,kBAAkB,EACvB,UAAU,EACV,SAAS,EACT;gBACE,8BAA8B,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,8BAA8B;gBACvE,WAAW;gBACX,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CACF,CAAC;YAEF,MAAM,eAAe,GAAG,IAAI,6BAA6B,CACvD,cAAc,EACd,IAAI,CAAC,kBAAkB,EACvB,UAAU,EACV,WAAW,EACX,IAAI,CAAC,cAAc,CAAC,YAAY,CACjC,CAAC;YAEF,OAAO,eAAe,CAAC;SACxB;KAAA;IAgDK,iBAAiB,CACrB,iBAAyB,EACzB,0BAAsE,EACtE,QAA2C;;YAE3C,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,iBAAiB,CAAC,CAAC;YAEtE,MAAM,EAAE,UAAU,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,wBAAwB,CACnE,iBAAiB,EACjB,0BAA0B,EAC1B,QAAQ,CACT,CAAC;YAEF,MAAM,cAAc,GAAG,MAAM,cAAc,CAAC,MAAM,CAChD,IAAI,CAAC,kBAAkB,EACvB,UAAU,EACV,SAAS,EACT;gBACE,8BAA8B,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,8BAA8B;gBACvE,WAAW;gBACX,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CACF,CAAC;YAEF,MAAM,eAAe,GAAG,IAAI,6BAA6B,CACvD,cAAc,EACd,IAAI,CAAC,kBAAkB,EACvB,UAAU,EACV,WAAW,EACX,IAAI,CAAC,cAAc,CAAC,YAAY,CACjC,CAAC;YAEF,OAAO,eAAe,CAAC;SACxB;KAAA;;;;;;;IAQD,YAAY,CAAC,gBAAwB;QACnC,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,gBAAgB,CAAC,CAAC;QAErE,OAAO,IAAI,oBAAoB,CAC7B,IAAI,CAAC,kBAAkB,EACvB,gBAAgB,EAChB,IAAI,CAAC,cAAc,CAAC,YAAY,CACjC,CAAC;KACH;;;;;;IAOD,KAAK;QACH,OAAO,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;KACzD;CACF;AAED;;;;;;;;;;AAUA,SAAgB,wBAAwB,CACtC,iBAAyB,EACzB,0BAAyD,EACzD,kBAA6B;IAM7B,IAAI,UAAkB,CAAC;IACvB,IAAI,OAA6B,CAAC;IAClC,IAAI,OAAO,0BAA0B,KAAK,QAAQ,EAAE;QAClD,MAAM,KAAK,GAAG,iBAAiB,CAAC;QAChC,MAAM,YAAY,GAAG,0BAA0B,CAAC;QAChD,UAAU,GAAG,GAAG,KAAK,kBAAkB,YAAY,EAAE,CAAC;QACtD,OAAO,GAAG,kBAAkB,CAAC;KAC9B;SAAM;QACL,UAAU,GAAG,iBAAiB,CAAC;QAC/B,OAAO,GAAG,0BAA0B,CAAC;KACtC;IACD,IAAI,WAAwB,CAAC;IAC7B,IAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,KAAI,SAAS,IAAI,OAAO,CAAC,WAAW,KAAK,UAAU,EAAE;QAC3E,WAAW,GAAG,UAAU,CAAC;KAC1B;SAAM,IAAI,OAAO,CAAC,WAAW,KAAK,kBAAkB,EAAE;QACrD,WAAW,GAAG,kBAAkB,CAAC;KAClC;SAAM;QACL,MAAM,IAAI,SAAS,CACjB,wBAAwB,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,gEAAgE,CAC7G,CAAC;KACH;IACM,OAAO,aAAP,OAAO,4BAAP,OAAO,CAAE,WAAW,CAAC;IAC5B,OAAO;QACL,UAAU;QACV,WAAW;QACX,OAAO;KACR,CAAC;AACJ,CAAC;AAED;;;;;;;AAOA,SAAS,kBAAkB,CAAC,gBAAkC,EAAE,gBAAwB;IACtF,IAAI,gBAAgB,CAAC,UAAU,IAAI,gBAAgB,CAAC,UAAU,KAAK,gBAAgB,EAAE;QACnF,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;KAC1C;AACH,CAAC;;ACveD;AACA,AA6CA;;;;;;AAMA,SAAgB,+BAA+B,CAC7C,gBAAwB;IAExB,MAAM,YAAY,GAAGN,8BAAqB,CAMvC,gBAAgB,CAAC,CAAC;IACrB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE;QAC1B,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;KACnE;IAED,IAAI,YAAY,CAAC,qBAAqB,EAAE;QACtC,IAAI,YAAY,CAAC,eAAe,IAAI,YAAY,CAAC,mBAAmB,EAAE;YACpE,MAAM,IAAI,KAAK,CACb,oFAAoF,CACrF,CAAC;SACH;KACF;SAAM,IAAI,YAAY,CAAC,eAAe,IAAI,CAAC,YAAY,CAAC,mBAAmB,EAAE;QAC5E,MAAM,IAAI,KAAK,CAAC,yEAAyE,CAAC,CAAC;KAC5F;SAAM,IAAI,CAAC,YAAY,CAAC,eAAe,IAAI,YAAY,CAAC,mBAAmB,EAAE;QAC5E,MAAM,IAAI,KAAK,CACb,iFAAiF,CAClF,CAAC;KACH;IAED,MAAM,MAAM,GAAyC;QACnD,uBAAuB,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QAC/E,QAAQ,EAAE,YAAY,CAAC,QAAQ;KAChC,CAAC;IACF,IAAI,YAAY,CAAC,UAAU,EAAE;QAC3B,MAAM,CAAC,UAAU,GAAG,YAAY,CAAC,UAAU,CAAC;KAC7C;IACD,IAAI,YAAY,CAAC,qBAAqB,EAAE;QACtC,MAAM,CAAC,qBAAqB,GAAG,YAAY,CAAC,qBAAqB,CAAC;KACnE;IACD,IAAI,YAAY,CAAC,eAAe,IAAI,YAAY,CAAC,mBAAmB,EAAE;QACpE,MAAM,CAAC,eAAe,GAAG,YAAY,CAAC,eAAe,CAAC;QACtD,MAAM,CAAC,mBAAmB,GAAG,YAAY,CAAC,mBAAmB,CAAC;KAC/D;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;"}